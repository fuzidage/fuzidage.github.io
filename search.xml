<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux内核-kmalloc与vmalloc及CMA内存</title>
    <url>/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-kmalloc-vmalloc-qu-bie">1 kmalloc&#x2F;vmalloc区别</a><ul>
<li><a href="#1-1-kmalloc-han-shu-yuan-xing">1.1 kmalloc函数原型：</a><ul>
<li><a href="#1-1-1-gpf-flags-han-yi">1.1.1 gpf flags含义</a></li>
</ul>
</li>
<li><a href="#1-2-vmalloc-han-shu-yuan-xing">1.2 vmalloc函数原型：</a></li>
<li><a href="#1-3-nei-cun-shi-fang">1.3 内存释放</a></li>
</ul>
</li>
<li><a href="#2-kmalloc-vmalloc-nei-cun-fen-pei-yuan-li">2 kmalloc&#x2F;vmalloc内存分配原理</a></li>
<li><a href="#3-cma-jie-shao">3 CMA介绍</a><ul>
<li><a href="#3-0-yin-ru-linux-nei-he-buddy-xi-tong">3.0 引入Linux内核Buddy系统</a></li>
<li><a href="#3-1-cma-gai-shu">3.1 CMA概述</a></li>
<li><a href="#3-2-cma-nei-he-shi-neng">3.2 CMA内核使能</a></li>
<li><a href="#3-3-cma-de-ding-yi">3.3 CMA的定义</a></li>
<li><a href="#3-5-cma-nei-cun-yuan-li-he-liu-cheng">3.5 CMA内存原理和流程</a><ul>
<li><a href="#3-5-1-cma-diao-yong-ceng-ci-kuang-jia">3.5.1 CMA调用层次框架</a></li>
<li><a href="#3-5-2-cma-jie-gou-ti">3.5.2 CMA结构体</a></li>
<li><a href="#3-5-3-cma-qu-yu-chu-shi-hua">3.5.3 CMA区域初始化</a><ul>
<li><a href="#3-5-3-0-zheng-ge-memory-chu-shi-hua">3.5.3.0 整个memory初始化</a></li>
<li><a href="#3-5-3-1-dts-miao-shu-zhong-cma-nei-cun-de-chu-shi-hua">3.5.3.1 dts描述中cma内存的初始化</a><ul>
<li><a href="#3-5-3-1-1-quan-ju-cma-nei-cun-chu-shi-hua-rmem-cma-setup">3.5.3.1.1 全局cma内存初始化rmem_cma_setup</a><ul>
<li><a href="#3-5-3-1-1-1-cma-init-reserved-mem">3.5.3.1.1.1 cma_init_reserved_mem</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-5-3-2-dts-mei-you-miao-shu-cma-nei-cun-de-chu-shi-hua">3.5.3.2 dts没有描述cma内存的初始化</a></li>
</ul>
</li>
<li><a href="#3-5-4-cma-qu-yu-nei-cun-ying-she">3.5.4 CMA 区域内存映射</a><ul>
<li><a href="#3-5-4-1-dma-contiguous-remap-jian-li-cma-area-de-ye-biao-ying-she">3.5.4.1 dma_contiguous_remap-建立cma area的页表映射</a></li>
</ul>
</li>
<li><a href="#3-5-5-cma-init-reserved-areas-ji-huo-cma-area-nei-cun">3.5.5 cma_init_reserved_areas-激活cma area内存</a><ul>
<li><a href="#3-5-5-1-cma-activate-area">3.5.5.1 cma_activate_area</a><ul>
<li><a href="#3-5-5-1-1-init-cma-reserved-pageblock">3.5.5.1.1 init_cma_reserved_pageblock</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-cma-nei-cun-shi-yong">4 CMA内存使用</a><ul>
<li><a href="#4-1-dma-alloc-from-contiguous">4.1 dma_alloc_from_contiguous</a></li>
<li><a href="#4-2-dma-release-from-contiguous">4.2 dma_release_from_contiguous</a></li>
<li><a href="#4-3-cma-alloc">4.3 cma_alloc</a></li>
<li><a href="#4-4-cma-release">4.4 cma_release</a></li>
</ul>
</li>
<li><a href="#5-tong-guo-procfs-cha-kan-cma-area">5 通过procfs查看cma area</a><ul>
<li><a href="#5-1-huo-de-ram-di-zhi-fan-wei">5.1 获得ram地址范围</a></li>
<li><a href="#5-2-huo-de-reserved-memory-fan-wei">5.2 获得reserved-memory范围</a></li>
</ul>
</li>
<li><a href="#6-dts-de-reserved-memory-nei-rong-jie-xi">6 dts的reserved-memory内容解析</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-kmalloc-x2f-vmalloc-qu-bie">1 kmalloc&#x2F;vmalloc区别</span><a href="#1-kmalloc-x2f-vmalloc-qu-bie" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>函数</th>
<th>位置</th>
<th>特性</th>
<th>大小限制</th>
</tr>
</thead>
<tbody><tr>
<td>kmalloc</td>
<td>物理内存映射区域</td>
<td>物理地址虚拟地址均连续</td>
<td>不能超过128K</td>
</tr>
<tr>
<td>kzalloc</td>
<td>物理内存映射区域</td>
<td>物理地址虚拟地址均连续</td>
<td>不能超过128K</td>
</tr>
<tr>
<td>vmalloc</td>
<td>虚拟内存映射区域</td>
<td>虚拟地址连续，物理地址不一定连续</td>
<td>无限制</td>
</tr>
<tr>
<td>vzalloc</td>
<td>虚拟内存映射区域</td>
<td>虚拟地址连续，物理地址不一定连续</td>
<td>无限制</td>
</tr>
</tbody></table>
<p>kzalloc只是相当于附加了 <strong>__GFP_ZERO</strong> 标志。所以它除了申请内核内存外，还会对申请到的内存内容清零。<br>同理，vzalloc也是一样，会对申请内存内容清零。<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/1.png" alt="image"></p>
<h2><span id="1-1-kmalloc-han-shu-yuan-xing">1.1 kmalloc函数原型：</span><a href="#1-1-kmalloc-han-shu-yuan-xing" class="header-anchor">#</a></h2><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>；</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-gpf-flags-han-yi">1.1.1 gpf flags含义</span><a href="#1-1-1-gpf-flags-han-yi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|– 在进程上下文，可以睡眠　　　　　GFP_KERNEL</span><br><span class="line"> |– 在进程上下文，不可以睡眠，如： GFP_ATOMIC</span><br><span class="line"> |　　|– 中断处理程序　　　　　　　GFP_ATOMIC</span><br><span class="line"> |　　|– 软中断　　　　　　　　　　GFP_ATOMIC</span><br><span class="line"> |　　|– Tasklet　　　　　　　　　GFP_ATOMIC</span><br><span class="line"> |– 用于DMA的内存，可以睡眠　　　GFP_DMA | GFP_KERNEL</span><br><span class="line"> |– 用于DMA的内存，不可以睡眠　　GFP_DMA |GFP_ATOMIC</span><br></pre></td></tr></table></figure>
<p>如果进程上下文允许睡眠情况下尽量用<code>GFP_KERNEL</code>， 如果进程上下文禁止休眠的话（如中断，taskletd等）必须用<code>GFP_ATOMIC</code></p>
<h2><span id="1-2-vmalloc-han-shu-yuan-xing">1.2 vmalloc函数原型：</span><a href="#1-2-vmalloc-han-shu-yuan-xing" class="header-anchor">#</a></h2><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>注意：vmalloc和vfree可以睡眠，因此中断上下文禁止使用。</p>
<h2><span id="1-3-nei-cun-shi-fang">1.3 内存释放</span><a href="#1-3-nei-cun-shi-fang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>
<h1><span id="2-kmalloc-x2f-vmalloc-nei-cun-fen-pei-yuan-li">2 kmalloc&#x2F;vmalloc内存分配原理</span><a href="#2-kmalloc-x2f-vmalloc-nei-cun-fen-pei-yuan-li" class="header-anchor">#</a></h1><p>slab机制，等后面学习完后介绍。</p>
<h1><span id="3-cma-jie-shao">3 CMA介绍</span><a href="#3-cma-jie-shao" class="header-anchor">#</a></h1><h2><span id="3-0-yin-ru-linux-nei-he-buddy-xi-tong">3.0 引入Linux内核Buddy系统</span><a href="#3-0-yin-ru-linux-nei-he-buddy-xi-tong" class="header-anchor">#</a></h2><p>Linux伙伴系统<code>(Buddy)</code>使用 Page 粒度来管理内存，每个页面大小为4K。伙伴系统按照空闲内存块的长度，把内存挂载到不同长度的 <code>free_list</code>链表中。<code>free_list </code>的单位是以 (<code>2^order个Page</code>) 来递增的，即 <code>1 page、2 page、… 2^n</code>，通常情况下最大 order 为10 对应的空闲内存大小为 4M bytes。我们使用伙伴系统来申请连续的物理页面最大的页面最大小4M bytes。</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/4.png" alt="图片"></p>
<p>当系统内存碎片化严重的时候，也很难分配到高order的页面，这时就引入了CMA概念，接着往下看。</p>
<h2><span id="3-1-cma-gai-shu">3.1 CMA概述</span><a href="#3-1-cma-gai-shu" class="header-anchor">#</a></h2><p>连续内存分配器（<code>Contiguous Memory Allocator</code>），简称CMA。在系统长时间运行后，内存可能碎片化，很难找到连续的物理页，CMA很好的避免了这个问题。<br>举个例子：<br>手机上1300万像素的摄像头，一个像素占用3字节，拍摄一张照片需要大约37MB内存。在系统长时间运行后，内存可能碎片化，很难找到连续的物理页，页分配器（kmalloc）和块分配器(vmalloc)很可能无法分配这么大的连续内存块。</p>
<p>方案1：<br>最开始的一种解决方案是为设备保留一块大的内存区域，比如为摄像头驱动预留一块大内存，通过ioremap来映射后作为私有内存使用，缺点是：当设备驱动不使用的时候（大多数时间手机摄像头是空闲的），内核的其他模块不能使用这块内存。<br>方案2：<br>连续内存分配器CMA很好的解决了这个问题，保留一块大的内存区域，当设备驱动不使用的时候，内核的其他模块可以使用。一般我们把这块区域定义为<code>reserved-memory</code>。<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/5.png" alt="image"></p>
<h2><span id="3-2-cma-nei-he-shi-neng">3.2 CMA内核使能</span><a href="#3-2-cma-nei-he-shi-neng" class="header-anchor">#</a></h2><p>编译内核时需要开启以下配置宏：<br>（1）配置宏CONFIG_CMA，启用连续内存分配器。<br>（2）配置宏CONFIG_CMA_AREAS，指定CMA区域的最大数量，默认值是7。<br>（3）配置宏CONFIG_DMA_CMA，启用允许设备驱动分配内存的连续内存分配器</p>
<h2><span id="3-3-cma-de-ding-yi">3.3 CMA的定义</span><a href="#3-3-cma-de-ding-yi" class="header-anchor">#</a></h2><p>CMA每个区域实际上就是一个<code>reserved memory</code>。CMA分两种:</p>
<ol>
<li>通用的CMA区域，该区域是给整个系统分配使用的;如下面的<code>&quot;linux,cma&quot;</code></li>
<li>专用的CMA区域，这种是专门为单个模块定义的。如下面的<code>&quot;ion”</code></li>
</ol>
<p>dts中CMA属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> reusable:表示当前的内存区域除了被dma使用之外，还可以被内存管理(buddy)子系统reuse。</span><br><span class="line"><span class="number">2.</span> no-<span class="built_in">map</span>:表示是否需要创建页表映射，对于通用的内存，必须要创建映射才可以使用，共享CMA是可以作为通用内存进行分配使用的，因此必须要创建页表映射。</span><br><span class="line"><span class="number">3.</span> 对于共享的CMA区域，需要配置上linux,cma-<span class="keyword">default</span>属性，标志着它是共享的CMA。</span><br><span class="line"><span class="number">4.</span> alignment：对齐参数，保留内存的起始地址需要向该参数对齐</span><br><span class="line"><span class="number">5.</span> alloc-ranges：指定可以用来申请动态保留内存的区间</span><br></pre></td></tr></table></figure>

<p>下面定义了3段区域CMA:<br>1.全局CMA区域，节点名称是<code>“linux,cma”</code>，大小是2GB，8K对齐。配置上<code>linux,cma-default</code>属性,reusable属性。<br>2.私有CMA区域，节点名字<code>“de_mem0” “de_mem1”</code>，128M给GPU 2D engine使用，私有无需建立页表映射。<br>3.私有CMA区域，节点名字<code>“ion”</code>，给video pipeline使用，私有无需建立页表映射。<br>​	2de模块中定义memory-region属性，并且把对应dts定义的cma节点de_reserved0，de_reserved1传递给该模块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reserved-memory &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;0x2&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0x2&gt;</span>;</span></span><br><span class="line">        ranges;</span><br><span class="line">        cma_reserved: linux,cma &#123;</span><br><span class="line">                compatible = <span class="string">&quot;shared-dma-pool&quot;</span>;</span><br><span class="line">                reusable;<span class="comment">//表示 cma 内存可被 buddy 系统使用</span></span><br><span class="line">                size = &lt;<span class="number">0x0</span> <span class="number">0x80000000</span>&gt;; <span class="comment">// 2GB</span></span><br><span class="line">                alignment = &lt;<span class="number">0x0</span> <span class="number">0x2000</span>&gt;; <span class="comment">// 8KB</span></span><br><span class="line">                linux,cma-<span class="keyword">default</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        de_reserved0: de_mem0 &#123;</span><br><span class="line">                        reg = &lt;<span class="number">0x1</span> <span class="number">0x10000000</span> <span class="number">0x0</span> <span class="number">0x8000000</span>&gt;; <span class="comment">// 128M, for 2de</span></span><br><span class="line">                        no-<span class="built_in">map</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        de_reserved1: de_mem1 &#123;</span><br><span class="line">                        reg = &lt;<span class="number">0x1</span> <span class="number">0x18000000</span> <span class="number">0x0</span> <span class="number">0x8000000</span>&gt;; <span class="comment">// 128M, for 2de</span></span><br><span class="line">                        no-<span class="built_in">map</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        ion_reserved: ion &#123;</span><br><span class="line">                compatible = <span class="string">&quot;ion-region&quot;</span>;</span><br><span class="line">                size = &lt;<span class="number">0x0</span> <span class="number">0x04000000</span>&gt;; <span class="comment">// 64MB</span></span><br><span class="line">        &#125;;</span><br><span class="line">        vo_2de0 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;sophgo,vg-lite0&quot;</span>;</span><br><span class="line">                memory-region = &lt;&amp;de_reserved0&gt;;</span><br><span class="line">                interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">27</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                interrupt-names = <span class="string">&quot;vo_2de0&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        vo_2de1 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;sophgo,vg-lite1&quot;</span>;</span><br><span class="line">                memory-region = &lt;&amp;de_reserved1&gt;;</span><br><span class="line">                interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">28</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                interrupt-names = <span class="string">&quot;vo_2de1&quot;</span>;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-5-cma-nei-cun-yuan-li-he-liu-cheng">3.5 CMA内存原理和流程</span><a href="#3-5-cma-nei-cun-yuan-li-he-liu-cheng" class="header-anchor">#</a></h2><p>设备驱动程序不能直接使用连续内存分配器，而是调用DMA映射框架来使用连续内存分配器CMA。</p>
<h3><span id="3-5-1-cma-diao-yong-ceng-ci-kuang-jia">3.5.1 CMA调用层次框架</span><a href="#3-5-1-cma-diao-yong-ceng-ci-kuang-jia" class="header-anchor">#</a></h3><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/6.png" alt="image"></p>
<ol>
<li>最底层为<code>页分配器（以后分析）</code>。</li>
<li>cma_alloc用来从CMA区域分配页，cma_release用来释放从CMA区域分配的页。</li>
<li>第3层为DMA映射框架专用的连续内存分配器，简称DMA专用连续内存分配器，提供的接口<code>dma_alloc_from_contiguous</code>用来从CMA区域分配页，接口<code>dma_release_from_contiguous</code>用来释放从CMA区域分配的页。</li>
<li>第4层就是DMA通用映射框架，供驱动程序调用<code>dma_alloc_coherent</code>和<code>dma_alloc_noncoherent</code>用来分配内存，接口<code>dma_free_coherent</code>和<code>dma_free_noncoherent</code>用来释放内存。</li>
</ol>
<h3><span id="3-5-2-cma-jie-gou-ti">3.5.2 CMA结构体</span><a href="#3-5-2-cma-jie-gou-ti" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mm/cma.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> &#123;</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>    base_pfn; <span class="comment">//该CMA区域的起始页帧号</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>    count; <span class="comment">//该cma区域的页数</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>    *bitmap; <span class="comment">//位图，每个位描述对应的页的分配状态，0表示空闲，1表示已分配</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> order_per_bit;<span class="comment">//位图中的每个位描述的物理页的阶数，目前取值为0，表示每个位描述一页</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>     <span class="title">lock</span>;</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mm/cma.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> <span class="title">cma_areas</span>[<span class="title">MAX_CMA_AREAS</span>];</span><span class="comment">//定义多个CMA区域。</span></span><br><span class="line"><span class="type">unsigned</span> cma_area_count;<span class="comment">//表示实际使用的cma区域数量</span></span><br></pre></td></tr></table></figure>

<p>cma模块使用bitmap来管理其内存的分配，0表示free，1表示已经分配。</p>
<p>重点解释<code>order_per_bit</code>:如果<code>order_per_bit</code>等于0，表示按照一个一个page来分配和释放，如果<code>order_per_bit</code>等于1，表示按照2个page组成的block来分配和释放，以此类推。</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/7.png" alt="image-20240721215512066"></p>
<p>上图<code>cma_area[0]的.order_per_bit = 1</code>,对应2个page，起始页帧号为0x2000, 0x400个页数，对应size为<code>0x400 *2* 2K = 4M</code></p>
<p>刚好对应4M。</p>
<h3><span id="3-5-3-cma-qu-yu-chu-shi-hua">3.5.3 CMA区域初始化</span><a href="#3-5-3-cma-qu-yu-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="3-5-3-0-zheng-ge-memory-chu-shi-hua">3.5.3.0 整个memory初始化</span><a href="#3-5-3-0-zheng-ge-memory-chu-shi-hua" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">    ------&gt;setup_arch</span><br><span class="line">        ------&gt;setup_machine_fdt</span><br><span class="line">            ------&gt;early_init_dt_scan_nodes</span><br><span class="line">                ------&gt;of_scan_flat_dt</span><br><span class="line">                    ------&gt;early_init_dt_scan_memory</span><br><span class="line">                        ------&gt;early_init_dt_add_memory_arch</span><br><span class="line">                            ------&gt;memblock_add</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/8.png" alt="image-20240721223712191"></p>
<h4><span id="3-5-3-1-dts-miao-shu-zhong-cma-nei-cun-de-chu-shi-hua">3.5.3.1 dts描述中cma内存的初始化</span><a href="#3-5-3-1-dts-miao-shu-zhong-cma-nei-cun-de-chu-shi-hua" class="header-anchor">#</a></h4><p>linux内核首先需要解析dtb中节点<code>“memory”</code>，把内存块添加到<code>memblock</code>的memory类型，memory类型保存内存块的物理地址范围，reserved类型保存保留内存块的物理地址范围，CMA区域就属于保留内存块。<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/9.png" alt="image"><br>创建CMA区域的执行流程如下所示：<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/10.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">    ------&gt;setup_arch</span><br><span class="line">        ------&gt;arm_memblock_init</span><br><span class="line">            ------&gt;early_init_fdt_scan_reserved_mem</span><br><span class="line">                ------&gt;of_scan_flat_dt</span><br><span class="line">                     ------&gt; __fdt_scan_reserved_mem</span><br><span class="line">                        ------&gt; fdt_init_reserved_mem</span><br><span class="line">                            ------&gt; memblock_add</span><br></pre></td></tr></table></figure>

<p>linux内核启动时，当调用到<code>__reserved_mem_init_node</code>时会调用所有使用<code>RESERVEDMEM_OF_DECLARE</code>声明的CMA区域。</p>
<p><code>__reserved_mem_init_node</code>会遍历<code>__reservedmem_of_table section</code>中的内容，检查到dts中有compatible匹配（CMA这里为“shared-dma-pool”）就进一步执行对应的<code>initfn</code>。通过<code>RESERVEDMEM_OF_DECLARE</code>定义的都会被链接到<code>__reservedmem_of_table</code>这个section段中，最终会调到使用<code>RESERVEDMEM_OF_DECLAR</code>E定义的函数:</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/11.png" alt="image-20240721190202046"></p>
<p>其中全局CMA区域的初始化函数是<code>rmem_cma_setup</code>：</p>
<h5><span id="3-5-3-1-1-quan-ju-cma-nei-cun-chu-shi-hua-rmem-cma-setup">3.5.3.1.1 全局cma内存初始化rmem_cma_setup</span><a href="#3-5-3-1-1-quan-ju-cma-nei-cun-chu-shi-hua-rmem-cma-setup" class="header-anchor">#</a></h5><p><code>rmem_cma_setup</code>的作用就是将<code>reserved-memory</code>添加到cma子系统：</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/12.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rmem_cma_setup</span><br><span class="line">    |------&gt;cma_init_reserved_mem       <span class="comment">// 将reserved-memory 添加到cma_areas数组中</span></span><br><span class="line">    |------&gt;dma_contiguous_early_fixup<span class="comment">// dma remap</span></span><br><span class="line">    |------&gt;dma_contiguous_set_default<span class="comment">// set_default cma area</span></span><br></pre></td></tr></table></figure>

<h6><span id="3-5-3-1-1-1-cma-init-reserved-mem">3.5.3.1.1.1 cma_init_reserved_mem</span><a href="#3-5-3-1-1-1-cma-init-reserved-mem" class="header-anchor">#</a></h6><p>来看调用的cma_init_reserved_mem：<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/13.png" alt="image"><br>从数组<code>cma_areas</code>分配一个数组项，保存CMA区域的起始页帧号和页数。dts指定了属性<code>“linux,cma-default”</code>，那么这个CMA区域是默认的CMA区域，最后设置全局变量<code>dma_contiguous_default_area</code>指向这个CMA区域(默认全局CMA区域)<br>红色圈出了该cma区域的dts描述和dts是不是完全吻合。</p>
<h4><span id="3-5-3-2-dts-mei-you-miao-shu-cma-nei-cun-de-chu-shi-hua">3.5.3.2 dts没有描述cma内存的初始化</span><a href="#3-5-3-2-dts-mei-you-miao-shu-cma-nei-cun-de-chu-shi-hua" class="header-anchor">#</a></h4><p>如果内核参数或配置宏配置全局CMA区域，cma初始化则流程如下所示：<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/14.png" alt="image"><br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/15.png" alt="image"><br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/16.png" alt="image"></p>
<h3><span id="3-5-4-cma-qu-yu-nei-cun-ying-she">3.5.4 CMA 区域内存映射</span><a href="#3-5-4-cma-qu-yu-nei-cun-ying-she" class="header-anchor">#</a></h3><p>CMA 区域创建初始化完后还不能直接使用，需要单独进行页表映射。前面：</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17995165">linux内核-3.Linux 内核启动流程 - fuzidage - 博客园 (cnblogs.com)</a> <code>2.1.1.1.1 start_kernel</code></p>
<p><a href="https://fuzidage.github.io/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#2-1-1-1-1-start-kernel">Linux内核启动流程 | Hexo (fuzidage.github.io)</a></p>
<p>小结有介绍start_kernel启动流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">    ------&gt;setup_arch</span><br><span class="line">        ------&gt;paging_init<span class="comment">//建立页表映射，包括非保留内存和保留内存。</span></span><br><span class="line">            ------&gt;dma_contiguous_remap</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-4-1-dma-contiguous-remap-jian-li-cma-area-de-ye-biao-ying-she">3.5.4.1 dma_contiguous_remap-建立cma area的页表映射</span><a href="#3-5-4-1-dma-contiguous-remap-jian-li-cma-area-de-ye-biao-ying-she" class="header-anchor">#</a></h4><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/17.png" alt="image-20240721230004292"></p>
<p><code>prepare_page_table</code>负责普通内存的页表映射。<code>dma_contiguous_remap</code>建立<code>cma area</code>的页表映射:</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/18.png" alt="image-20240721231037582"></p>
<h3><span id="3-5-5-cma-init-reserved-areas-ji-huo-cma-area-nei-cun">3.5.5 cma_init_reserved_areas-激活cma area内存</span><a href="#3-5-5-cma-init-reserved-areas-ji-huo-cma-area-nei-cun" class="header-anchor">#</a></h3><p><code>cma_activate_area</code>函数用于将 CMA 区域内的预留页全部释放添加到 Buddy 管理器内，然后激活 CMA 区域供系统使用。</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/19.png" alt="image-20240721174230275"></p>
<h4><span id="3-5-5-1-cma-activate-area">3.5.5.1 cma_activate_area</span><a href="#3-5-5-1-cma-activate-area" class="header-anchor">#</a></h4><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/20.png" alt="image-20240721232741149"></p>
<h5><span id="3-5-5-1-1-init-cma-reserved-pageblock">3.5.5.1.1 init_cma_reserved_pageblock</span><a href="#3-5-5-1-1-init-cma-reserved-pageblock" class="header-anchor">#</a></h5><p>cma默认是从<code>reserved memory</code>中分配的，通常情况这块内存是直接分配并预留不做任何使用，无形之中造成了浪费。所以在不用的时候放入伙伴系统，作为普通内存使用。</p>
<h1><span id="4-cma-nei-cun-shi-yong">4 CMA内存使用</span><a href="#4-cma-nei-cun-shi-yong" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>   *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">page = cma_alloc(dev_get_cma_area(dev)，mem_size, <span class="number">0</span>, GFP_KERNEL);</span><br></pre></td></tr></table></figure>

<p><code>dev_get_cma_area</code>可以获取对应的cma handler，如果获取不到，比如对应模块中并未定义memory-region，那么就会返回共享的<code>cma handler</code>，还记的上面的<code> linux,cma-default</code>属性吗，共享cma区域会被作为缺省cma来使用。</p>
<h2><span id="4-1-dma-alloc-from-contiguous">4.1 dma_alloc_from_contiguous</span><a href="#4-1-dma-alloc-from-contiguous" class="header-anchor">#</a></h2><h2><span id="4-2-dma-release-from-contiguous">4.2 dma_release_from_contiguous</span><a href="#4-2-dma-release-from-contiguous" class="header-anchor">#</a></h2><p>不过一般内核模块要使用CMA内存时，使用的接口依然是dma的接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span> *dma_handle, <span class="type">gfp_t</span> flag)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">dma_free_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">void</span> *cpu_addr, <span class="type">dma_addr_t</span> dma_handle)</span>;</span><br></pre></td></tr></table></figure>

<p>最终也会进入<code>dma_alloc_from_contiguous</code>调用<code>cma_alloc</code>分配内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">dma_alloc_from_contiguous</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> align, <span class="type">bool</span> no_warn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (align &gt; CONFIG_CMA_ALIGNMENT)</span><br><span class="line">		align = CONFIG_CMA_ALIGNMENT;</span><br><span class="line">	<span class="keyword">return</span> cma_alloc(dev_get_cma_area(dev), count, align, no_warn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dma_release_from_contiguous</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> page *pages,</span></span><br><span class="line"><span class="params">	 <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> cma_release(dev_get_cma_area(dev), pages, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cma_alloc() - allocate pages from contiguous area</span></span><br><span class="line"><span class="comment"> * @cma:   Contiguous memory region for which the allocation is performed.</span></span><br><span class="line"><span class="comment"> * @count: Requested number of pages.</span></span><br><span class="line"><span class="comment"> * @align: Requested alignment of pages (in PAGE_SIZE order).</span></span><br><span class="line"><span class="comment"> * @no_warn: Avoid printing message about failed allocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function allocates part of contiguous memory on specific</span></span><br><span class="line"><span class="comment"> * contiguous memory area.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">cma_alloc</span><span class="params">(<span class="keyword">struct</span> cma *cma, <span class="type">size_t</span> count, <span class="type">unsigned</span> <span class="type">int</span> align,</span></span><br><span class="line"><span class="params">			   <span class="type">bool</span> no_warn)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span> *dma_handle, <span class="type">gfp_t</span> flag)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">dma_free_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">void</span> *cpu_addr, <span class="type">dma_addr_t</span> dma_handle)</span>;</span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">dma_alloc_from_contiguous</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> align, <span class="type">bool</span> no_warn)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">dma_release_from_contiguous</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> page *pages,</span></span><br><span class="line"><span class="params">	 <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="4-3-cma-alloc">4.3 cma_alloc</span><a href="#4-3-cma-alloc" class="header-anchor">#</a></h2><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/21.png" alt="图片"></p>
<p>从指定的CMA 区域上分配count个连续的页面，按照align对齐。</p>
<h2><span id="4-4-cma-release">4.4 cma_release</span><a href="#4-4-cma-release" class="header-anchor">#</a></h2><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/22.png" alt="图片"></p>
<p>释放已经分配count个连续的页面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cma_release() - release allocated pages</span></span><br><span class="line"><span class="comment"> * @cma:   Contiguous memory region for which the allocation is performed.</span></span><br><span class="line"><span class="comment"> * @pages: Allocated pages.</span></span><br><span class="line"><span class="comment"> * @count: Number of allocated pages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function releases memory allocated by cma_alloc().</span></span><br><span class="line"><span class="comment"> * It returns false when provided pages do not belong to contiguous area and</span></span><br><span class="line"><span class="comment"> * true otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cma_release</span><span class="params">(<span class="keyword">struct</span> cma *cma, <span class="type">const</span> <span class="keyword">struct</span> page *pages, <span class="type">unsigned</span> <span class="type">int</span> count)</span>；</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/23.png" alt="image-20240721213654864"></p>
<h1><span id="5-tong-guo-procfs-cha-kan-cma-area">5 通过procfs查看cma area</span><a href="#5-tong-guo-procfs-cha-kan-cma-area" class="header-anchor">#</a></h1><h2><span id="5-1-huo-de-ram-di-zhi-fan-wei">5.1 获得ram地址范围</span><a href="#5-1-huo-de-ram-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>第一个比较重要的是获得系统物理内存的范围：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/iomem </span><br><span class="line">10000000-17ffffff : System RAM</span><br><span class="line">  10008000-107fffff : Kernel code</span><br><span class="line">  10900000-10960677 : Kernel data</span><br><span class="line">40002000-4000201f : serial</span><br><span class="line">4000a000-4000a01f : codec@4000a000</span><br><span class="line">40010000-40011fff : i2c0@40010000</span><br><span class="line">40014000-4001401f : serial</span><br><span class="line">40016000-4001601f : serial</span><br><span class="line">40020000-40021fff : i2c2@40020000</span><br><span class="line">4003a000-4003a01f : wdt0@4003a000</span><br><span class="line">40056000-40056fff : video0@40056000</span><br><span class="line">4005a000-4005bfff : dma0@4005a000</span><br><span class="line">40064000-40064fff : video1@40064000</span><br><span class="line">40068000-40069fff : dma1@40068000</span><br><span class="line">4006a000-4006a1ff : lsacc2d@4006a000</span><br><span class="line">40080000-40081fff : clock@40080000</span><br><span class="line">40082000-40082027 : msgunit@40082000</span><br><span class="line">400a0000-400a00ff : mmc0@400a0000</span><br><span class="line">400aa000-400aa1ff : gauss@400aa000</span><br></pre></td></tr></table></figure>

<p>到 <strong>“System RAM”</strong>, 其代表系统物理内存的起始物理地址和终止物理地址。</p>
<h2><span id="5-2-huo-de-reserved-memory-fan-wei">5.2 获得reserved-memory范围</span><a href="#5-2-huo-de-reserved-memory-fan-wei" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/kernel/debug/memblock/reserved </span><br><span class="line">   0: 0x10004000..0x10007fff</span><br><span class="line">   1: 0x10100000..0x10960677</span><br><span class="line">   2: 0x12000000..0x127fffff</span><br><span class="line">   3: 0x1579b000..0x157a1fff</span><br><span class="line">   4: 0x17ea1cc0..0x17eb9fc3</span><br><span class="line">   5: 0x17eba000..0x17ee0fff</span><br><span class="line">   6: 0x17ee3180..0x17ee347f</span><br><span class="line">   7: 0x17ee34b0..0x17ffefff</span><br><span class="line">   8: 0x17fff100..0x17fff177</span><br><span class="line">   9: 0x17fff180..0x17fff1c4</span><br><span class="line">  10: 0x17fff200..0x17fff23b</span><br><span class="line">  11: 0x17fff240..0x17fff3c3</span><br><span class="line">  12: 0x17fff400..0x17fff5c4</span><br><span class="line">  13: 0x17fff600..0x17fff677</span><br><span class="line">  14: 0x17fff680..0x17fff68b</span><br><span class="line">  15: 0x17fff6c0..0x17fff6cb</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>通过这个命令可以知道系统已预留的内存信息，这些已预留的内存信息不可使用。</p>
<h1><span id="6-dts-de-reserved-memory-nei-rong-jie-xi">6 dts的reserved-memory内容解析</span><a href="#6-dts-de-reserved-memory-nei-rong-jie-xi" class="header-anchor">#</a></h1><p>通常使用memory-region将设备和reserved memory 关联起，cvifb 通过 memory-region 关联到 fb_reserved 这块 reserved memory 上面.<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/24.png" alt="image"><br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/25.png" alt="image"><br>通过<code>cvifb</code>节点的<code>memory-region</code>属性找到<code>reserved-memory</code>，<code>of_reserved_mem_lookup</code>根据关联的<code>reserved-momory</code>节点找到预留内存地址.<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/26.png" alt="image"></p>
]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>linux系统构建</tag>
        <tag>linux内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核-内核链表</title>
    <url>/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nei-he-lian-biao">1 内核链表</a><ul>
<li><a href="#1-1-nei-he-lian-biao-jie-gou-ti">1.1 内核链表结构体</a></li>
<li><a href="#1-2-list-chu-shi-hua">1.2 list初始化</a><ul>
<li><a href="#1-2-1-yong-hong-chu-shi-hua-list-head">1.2.1 用宏初始化-LIST_HEAD</a></li>
<li><a href="#1-2-2-yong-jie-kou-chu-shi-hua-init-list-head">1.2.2 用接口初始化-INIT_LIST_HEAD</a></li>
<li><a href="#1-2-3-chu-shi-hua-wan-hou-tou-bu-jie-dian-tu-li">1.2.3 初始化完后头部节点图例</a></li>
</ul>
</li>
<li><a href="#1-3-nei-he-lian-biao-cao-zuo">1.3 内核链表操作</a><ul>
<li><a href="#1-3-1-cha-ru-jie-dian">1.3.1 插入节点</a><ul>
<li><a href="#1-3-1-1-chuang-jian-yi-ge-jie-dian">1.3.1.1 创建一个节点</a></li>
<li><a href="#1-3-1-2-tou-cha-jie-dian-list-add">1.3.1.2 头插节点-list_add</a><ul>
<li><a href="#1-3-1-2-1-tou-cha-ru-de-yao-dian-zong-jie">1.3.1.2.1 头插入的要点总结</a></li>
</ul>
</li>
<li><a href="#1-3-1-3-wei-cha-jie-dian-list-add-tail">1.3.1.3 尾插节点-list_add_tail</a><ul>
<li><a href="#1-3-1-3-1-wei-cha-ru-de-yao-dian-zong-jie">1.3.1.3.1 尾插入的要点总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-2-shan-chu-jie-dian-list-del">1.3.2 删除节点-list_del</a></li>
<li><a href="#1-3-3-lian-biao-shan-chu-yu-fan-chu-shi-hua-list-del-init">1.3.3 链表删除与反初始化-list_del_init</a></li>
<li><a href="#1-3-4-lian-biao-bian-li">1.3.4 链表遍历</a><ul>
<li><a href="#1-3-4-0-list-entry">1.3.4.0 list_entry</a></li>
<li><a href="#1-3-4-1-list-for-each-zheng-xiang-bian-li">1.3.4.1 list_for_each(正向遍历)</a></li>
<li><a href="#1-3-4-1-list-for-each-safe">1.3.4.1 list_for_each_safe</a></li>
<li><a href="#1-3-4-2-list-for-each-entry">1.3.4.2 list_for_each_entry</a></li>
<li><a href="#1-3-4-2-list-for-each-entry-safe">1.3.4.2 list_for_each_entry_safe</a></li>
<li><a href="#1-3-4-3-list-for-each-prev-fan-xiang-bian-li">1.3.4.3 list_for_each_prev(反向遍历)</a></li>
<li><a href="#1-3-4-3-list-for-each-prev-safe">1.3.4.3 list_for_each_prev_safe</a></li>
<li><a href="#1-3-4-4-list-for-each-entry-reverse">1.3.4.4 list_for_each_entry_reverse</a></li>
<li><a href="#1-3-4-4-list-for-each-entry-safe-reverse">1.3.4.4 list_for_each_entry_safe_reverse</a></li>
<li><a href="#1-3-4-5-list-for-each-entry-continue-list-for-each-entry-from-cong-zhong-jian-mou-ge-jie-dian-kai-shi-bian-li">1.3.4.5 list_for_each_entry_continue&#x2F;list_for_each_entry_from(从中间某个节点开始遍历)</a></li>
<li><a href="#1-3-4-5-list-for-each-entry-continue-reverse-cong-zhong-jian-mou-ge-jie-dian-kai-shi-fan-xiang-bian-li">1.3.4.5 list_for_each_entry_continue_reverse(从中间某个节点开始反向遍历)</a></li>
</ul>
</li>
<li><a href="#1-3-5-pan-duan-lian-biao-shi-fou-wei-kong">1.3.5 判段链表是否为空</a><ul>
<li><a href="#1-3-5-1-list-empty">1.3.5.1 list_empty</a></li>
</ul>
</li>
<li><a href="#1-3-6-pan-duan-jie-dian-shi-fou-wei-zui-hou-yi-ge-jie-dian">1.3.6 判段节点是否为最后一个节点</a><ul>
<li><a href="#1-3-6-1-list-is-last">1.3.6.1 list_is_last</a></li>
</ul>
</li>
<li><a href="#1-3-7-huo-qu-di-yi-ge-jie-dian-de-su-zhu-jie-gou">1.3.7 获取第一个节点的宿主结构</a><ul>
<li><a href="#1-3-7-1-list-first-entry-list-first-entry-or-null">1.3.7.1 list_first_entry&#x2F;list_first_entry_or_null</a></li>
</ul>
</li>
<li><a href="#1-3-8-huo-qu-zui-hou-yi-ge-jie-dian-de-su-zhu-jie-gou">1.3.8 获取最后一个节点的宿主结构</a><ul>
<li><a href="#1-3-8-1-list-last-entry-list-first-entry-or-null">1.3.8.1 list_last_entry&#x2F;list_first_entry_or_null</a></li>
</ul>
</li>
<li><a href="#1-3-9-huo-qu-shang-yi-ge-jie-dian-de-su-zhu-jie-gou">1.3.9 获取上一个节点的宿主结构</a><ul>
<li><a href="#1-3-9-1-list-prev-entry">1.3.9.1 list_prev_entry</a></li>
</ul>
</li>
<li><a href="#1-3-10-huo-qu-xia-yi-ge-jie-dian-de-su-zhu-jie-gou">1.3.10 获取下一个节点的宿主结构</a><ul>
<li><a href="#1-3-10-1-list-next-entry">1.3.10.1 list_next_entry</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-4-nei-he-lian-biao-jin-jie-cao-zuo">1.4 内核链表进阶操作</a><ul>
<li><a href="#1-4-1-jie-dian-cong-a-lian-biao-zhuan-yi-dao-b-lian-biao">1.4.1 节点从A链表转移到B链表</a><ul>
<li><a href="#1-4-1-1-ban-yi-dao-xin-lian-biao-tou-list-move">1.4.1.1 搬移到新链表头-list_move</a></li>
<li><a href="#1-4-1-2-ban-yi-dao-xin-lian-biao-wei-list-move-tail">1.4.1.2 搬移到新链表尾-list_move_tail</a></li>
</ul>
</li>
<li><a href="#1-4-2-lian-biao-a-he-lian-biao-b-he-bing-list-splice">1.4.2 链表A和链表B合并-list_splice</a></li>
<li><a href="#1-4-3-jie-dian-de-ti-huan-list-replace">1.4.3 节点的替换-list_replace</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-nei-he-lian-biao-zong-jie">2 内核链表总结</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nei-he-lian-biao">1 内核链表</span><a href="#1-nei-he-lian-biao" class="header-anchor">#</a></h1><p>内核链表本质就是一个双向循环链表：</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/1.png" alt="image-20240802211111723"></p>
<p>链表的实现仅用一个<code>include/linux/list.h</code>实现。</p>
<p>内核链表有别于传统链表就在节点本身不包含数据域，只包含指针域。故而可以很灵活的拓展数据结构。使用时包含在用户数据结构内部。</p>
<h2><span id="1-1-nei-he-lian-biao-jie-gou-ti">1.1 内核链表结构体</span><a href="#1-1-nei-he-lian-biao-jie-gou-ti" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/2.png" alt="image-20240802211751734"></p>
<p>这里把内核经典的<code>container_of</code>和<code>offsetof</code>实现也贴进来了。实际上一般使用<code>container_of</code>都用<code>include\linux\kernel.h</code></p>
<h2><span id="1-2-list-chu-shi-hua">1.2 list初始化</span><a href="#1-2-list-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="1-2-1-yong-hong-chu-shi-hua-list-head">1.2.1 用宏初始化-LIST_HEAD</span><a href="#1-2-1-yong-hong-chu-shi-hua-list-head" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">   struct list_head name = LIST_HEAD_INIT(name)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/3.png" alt="image-20240802212312169"></p>
<p><code>LIST_HEAD</code> 定义一个<code>list_head</code>变量,  让<code>next，和prev</code>，也就是【前驱】和【后继】指针都指向自己，作为链表头指针。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIST_HEAD(<span class="built_in">list</span>); <span class="comment">// struct list_head list = &#123;.next = list, .prev = list&#125;;</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-2-2-yong-jie-kou-chu-shi-hua-init-list-head">1.2.2 用接口初始化-INIT_LIST_HEAD</span><a href="#1-2-2-yong-jie-kou-chu-shi-hua-init-list-head" class="header-anchor">#</a></h3><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/4.png" alt="image-20240802213916603"></p>
<p><code>INIT_LIST_HEAD</code>函数用来对一个list_head指针初始化。<code>WRITE_ONCE</code>是一种内存屏障机制，只写入一次， 防止并发产生竞态，参考<a href="https://fuzidage.github.io/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/#2-1-2-3-read-once">Linux内核-并发与同步 | Hexo (fuzidage.github.io)</a></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/18301805">linux内核下并发时同步机制 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p>因此<code>INIT_LIST_HEAD</code>等效于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">   <span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">INIT_LIST_HEAD(&amp;<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-chu-shi-hua-wan-hou-tou-bu-jie-dian-tu-li">1.2.3 初始化完后头部节点图例</span><a href="#1-2-3-chu-shi-hua-wan-hou-tou-bu-jie-dian-tu-li" class="header-anchor">#</a></h3><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/5.png" alt="image-20240803000855519"></p>
<h2><span id="1-3-nei-he-lian-biao-cao-zuo">1.3 内核链表操作</span><a href="#1-3-nei-he-lian-biao-cao-zuo" class="header-anchor">#</a></h2><h3><span id="1-3-1-cha-ru-jie-dian">1.3.1 插入节点</span><a href="#1-3-1-cha-ru-jie-dian" class="header-anchor">#</a></h3><p><code>list_add</code>总是在链表的头部插入, <code>list_add_tail</code>插在链表尾部。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = new;</span><br><span class="line">	new-&gt;next = next;</span><br><span class="line">	new-&gt;prev = prev;</span><br><span class="line">	WRITE_ONCE(prev-&gt;next, new);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_add(new, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/6.png" alt="image-20240802220834774"></p>
<h4><span id="1-3-1-1-chuang-jian-yi-ge-jie-dian">1.3.1.1 创建一个节点</span><a href="#1-3-1-1-chuang-jian-yi-ge-jie-dian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_data_list</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_data_list</span> <span class="title">first_data</span> =</span> &#123; </span><br><span class="line">    .val = <span class="number">1</span>,</span><br><span class="line">    .<span class="built_in">list</span> = LIST_HEAD_INIT(first_data.node),<span class="comment">//作为节点，其实可以不用初始化next和prev域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/7.png" alt="image-20240803150017826"></p>
<h4><span id="1-3-1-2-tou-cha-jie-dian-list-add">1.3.1.2 头插节点-list_add</span><a href="#1-3-1-2-tou-cha-jie-dian-list-add" class="header-anchor">#</a></h4><p><code>list_add(&amp;frist_data.node, &amp;listHead);</code></p>
<p><code>list_add</code>总是在链表的头部插入,先看<strong>插入第一个节点</strong>:</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/8.png" alt="image-20240803001913257"></p>
<p>插入第一个节点，就是让<code>list_head</code>的<code>next</code>和<code>prev</code>都指向第一个节点，第一个节点的<code>next</code>和<code>prev</code>也都指向了<code>list_head</code>，构成一个单元素的环。</p>
<p><strong>再插入第二个节点</strong>：</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/9.png" alt="image-20240803002115685"></p>
<p>结合代码讲解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = new;</span><br><span class="line">	new-&gt;next = next;</span><br><span class="line">	new-&gt;prev = prev;</span><br><span class="line">	WRITE_ONCE(prev-&gt;next, new);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们把__list_add(new, head, head-&gt;next);带入进去得：</span></span><br><span class="line">&#123;</span><br><span class="line">    head-&gt;next-&gt;prev  = new; <span class="comment">//①</span></span><br><span class="line">    new-&gt;next = head-&gt;next; <span class="comment">//②</span></span><br><span class="line">    new-&gt;prev = head;  <span class="comment">//③</span></span><br><span class="line">    head-&gt;next = new;  <span class="comment">//④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①让节点1的prev指向节点2。</p>
<p>②让节点2的next指向节点1.</p>
<p>③让节点2的prev指向头节点。</p>
<p>④让头节点的next指向节点2。</p>
<h5><span id="1-3-1-2-1-tou-cha-ru-de-yao-dian-zong-jie">1.3.1.2.1 头插入的要点总结</span><a href="#1-3-1-2-1-tou-cha-ru-de-yao-dian-zong-jie" class="header-anchor">#</a></h5><p><strong>总结1</strong>： head的next是指向链表中最新的节点，head的prev指向链表中最旧的节点。</p>
<p><strong>总结2</strong>：<code>list_add</code>函数作为头插本质：</p>
<p>​	①把链表头的next剪掉，next去指向新节点；但是得提前将旧节点的prev剪掉，旧节点prev也去指向新节点。注意为什么要先操作旧节点？因为旧节点就是<code>head-&gt;next</code>啊。</p>
<p>​	②让新节点前驱prev指向head, 后继next指向旧节点。</p>
<p><strong>总结3</strong>：头插遍历总是先访问到最新的元素，类似于<code>”栈stack“, ”先进后出“</code>。</p>
<h4><span id="1-3-1-3-wei-cha-jie-dian-list-add-tail">1.3.1.3 尾插节点-list_add_tail</span><a href="#1-3-1-3-wei-cha-jie-dian-list-add-tail" class="header-anchor">#</a></h4><p><code>list_add_tail(&amp;frist_data.node, &amp;listHead);</code></p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/10.png" alt="image-20240803150107150"></p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/10-1.png" alt="image-20240803150405838"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = new;</span><br><span class="line">	new-&gt;next = next;</span><br><span class="line">	new-&gt;prev = prev;</span><br><span class="line">	WRITE_ONCE(prev-&gt;next, new);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们把__list_add(new, head-&gt;prev, head);带入进去得：</span></span><br><span class="line">&#123;</span><br><span class="line">    head-&gt;prev  = new;       <span class="comment">//①</span></span><br><span class="line">    new-&gt;next = head;        <span class="comment">//②</span></span><br><span class="line">    new-&gt;prev = head-&gt;prev;  <span class="comment">//③</span></span><br><span class="line">    head-&gt;prev-&gt;next = new;  <span class="comment">//④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①头节点的prev指向节点2。</p>
<p>②让节点2的next指向头节点.</p>
<p>③让节点2的prev指向头节点的prev。</p>
<p>④让节点1的next指向节点2。</p>
<h5><span id="1-3-1-3-1-wei-cha-ru-de-yao-dian-zong-jie">1.3.1.3.1 尾插入的要点总结</span><a href="#1-3-1-3-1-wei-cha-ru-de-yao-dian-zong-jie" class="header-anchor">#</a></h5><p><strong>总结1</strong>： head的next是指向链表中最旧的节点，head的prev指向链表中最新的节点。</p>
<p><strong>总结2</strong>：<code>list_add_tail</code>函数作为尾插本质：</p>
<p>​	①先把链表头的prev剪掉，prev去指向新节点；最后把旧节点（尾节点）的next指向新节点。这样插入的就变成了新的尾节点。</p>
<p>​	②同时让新节点的next指向head, prev指向旧节点(尾节点)。</p>
<p><strong>总结3</strong>：尾插遍历总是先访问到旧的元素，类似于<code>”队列FIFO“, ”先进先出“</code>。</p>
<h3><span id="1-3-2-shan-chu-jie-dian-list-del">1.3.2 删除节点-list_del</span><a href="#1-3-2-shan-chu-jie-dian-list-del" class="header-anchor">#</a></h3><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/11.png" alt="image-20240803153026556"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = prev;</span><br><span class="line">	WRITE_ONCE(prev-&gt;next, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del_entry(<span class="keyword">struct</span> list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">	__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">	entry-&gt;next = LIST_POISON1;</span><br><span class="line">	entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>list_del</code>和<code>__list_del_entry</code>没有本质区别，核心都是<code>__list_del</code>。举个例子比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list_del(&amp;frist_data.node);</span><br></pre></td></tr></table></figure>

<p>非常好理解就不画图了，就是将下一个节点的prev指向前一个节点，同时反过来也要将前一个节点的next指向下一个节点。这个节点不就删除掉了。</p>
<p>注意：摘掉的节点prev、next 指针分别被设为 <code>LIST_POSITION2</code>和<code>LIST_POSITION1</code>两个特殊值，这样设置是为了保证不在链表中的节点项不可访问–对<code>LIST_POSITION1</code>和<code>LIST_POSITION2</code>的访问都将引起页故障。一访问就会立马出错，这样保证了数据安全性。来看下<code>LIST_POSITION1</code>和<code>LIST_POSITION2</code>, 在<code>include\linux\poison.h</code>:</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/12.png" alt="image-20240803155146829"></p>
<h3><span id="1-3-3-lian-biao-shan-chu-yu-fan-chu-shi-hua-list-del-init">1.3.3 链表删除与反初始化-list_del_init</span><a href="#1-3-3-lian-biao-shan-chu-yu-fan-chu-shi-hua-list-del-init" class="header-anchor">#</a></h3><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/13.png" alt="image-20240803155651544"></p>
<p>可以看到调用了<code>__list_del_entry</code>摘除自己这个节点，同时<code>INIT_LIST_HEAD</code>用接口初始化自己这个节点。</p>
<h3><span id="1-3-4-lian-biao-bian-li">1.3.4 链表遍历</span><a href="#1-3-4-lian-biao-bian-li" class="header-anchor">#</a></h3><h4><span id="1-3-4-0-list-entry">1.3.4.0 list_entry</span><a href="#1-3-4-0-list-entry" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/14.png" alt="image-20240803162517683"></p>
<p>遍历的关键就是这个<code>list_entry</code> 宏。它等效于<code>container_of</code>, 实现原理参考前面的讲解：</p>
<p> <a href="https://fuzidage.github.io/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">union和bit_field巧妙进行寄存器位操作 | Hexo (fuzidage.github.io)</a></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/14691578.html">union和bit field巧妙进行寄存器位操作 - fuzidage - 博客园 (cnblogs.com)</a></p>
<h4><span id="1-3-4-1-list-for-each-zheng-xiang-bian-li">1.3.4.1 list_for_each(正向遍历)</span><a href="#1-3-4-1-list-for-each-zheng-xiang-bian-li" class="header-anchor">#</a></h4><p>作用：传入头节点，去遍历里面的node</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/15.png" alt="image-20240803162024761"></p>
<p>从<code>head-&gt;next</code>开始，也就是从第一个节点开始往后遍历，直到最后一个节点，这时pos就等于head了，循环结束。</p>
<h4><span id="1-3-4-1-list-for-each-safe">1.3.4.1 list_for_each_safe</span><a href="#1-3-4-1-list-for-each-safe" class="header-anchor">#</a></h4><p>下面这个<code>list_for_each_safe</code>， 多了一个tmp变量而已，提前用n去试探下一节点,安全情况下才赋给pos.</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/16.png" alt="image-20240803205706719"></p>
<h4><span id="1-3-4-2-list-for-each-entry">1.3.4.2 list_for_each_entry</span><a href="#1-3-4-2-list-for-each-entry" class="header-anchor">#</a></h4><p>作用：传入头节点，去遍历里面的node所对应的外层宿主结构体。举个例子比较好理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">job_list</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_job</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> job_state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">//add to xxx_dev job_list</span></span><br><span class="line">	<span class="type">atomic_t</span> job_id;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_job</span> <span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;job-&gt;node, &amp;dev-&gt;job_list);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_job</span> *<span class="title">job_tmp</span>;</span></span><br><span class="line">list_for_each_entry(job_tmp, &amp;dev-&gt;job_list, node) &#123;</span><br><span class="line">    <span class="comment">//从链表中取出job_tmp，do someting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义一个链表<code>job_list</code>藏在<code>xxx_dev</code>里面，然后链表的节点宿主是<code>xxx_job</code>。</p>
<p><code>list_add_tail</code>将<code>xxx_job</code>的<code>node</code>即可加入<code>xxx_dev</code>的<code>job_list</code>。</p>
<p><code>list_for_each_entry</code>即可根据<code>xxx_job</code>的<code>node</code>成员取出宿主结构。</p>
<p>来分析一下<code>list_for_each_entry</code>函数：</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/17.png" alt="image-20240803172745331"></p>
<p><code>list_for_each_entry(job_tmp, &amp;dev-&gt;job_list, node)</code>那么首先进入for循环:</p>
<p>①代入<code>list_first_entry(&amp;dev-&gt;job_list, typeof(*job_tmp), node)</code></p>
<p>继续代入：看到了熟悉的<code>list_entry(&amp;dev-&gt;job_list-&gt;next, typeof(*job_tmp), node)</code>，是不是就是对应第一个节点的宿主结构<code>xxx_job</code>地址。</p>
<p>那么pos(也就是<code>job_tmp</code>)就指向了第一个节点的宿主结构。</p>
<p>②判断node是否达到head（也就是看有没有遍历到最后一个节点）</p>
<p>③此时pos已经是第一个节点的宿主结构，继续代入<code>list_next_entry(第一个节点的宿主结构, node)</code>，看到了熟悉的<code>list_entry(第一个节点的宿主结构-&gt;member-&gt;next, typeof(*job_tmp), node)</code>,这不就是下一个节点的宿主结构嘛，赋值给pos。</p>
<h4><span id="1-3-4-2-list-for-each-entry-safe">1.3.4.2 list_for_each_entry_safe</span><a href="#1-3-4-2-list-for-each-entry-safe" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/18.png" alt="image-20240803174314958"></p>
<p>和前面的<code>list_for_each_entry</code>作用完全一样，可以看到实现也是基本一致。多了一个tmp变量而已，提前用n去试探下一节点,安全情况下才赋给pos.</p>
<h4><span id="1-3-4-3-list-for-each-prev-fan-xiang-bian-li">1.3.4.3 list_for_each_prev(反向遍历)</span><a href="#1-3-4-3-list-for-each-prev-fan-xiang-bian-li" class="header-anchor">#</a></h4><p>作用：传入头节点，反向去遍历里面的node</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/19.png" alt="image-20240803174910449"></p>
<p>没什么好说的，和<code>list_for_each</code>相反方向遍历。</p>
<h4><span id="1-3-4-3-list-for-each-prev-safe">1.3.4.3 list_for_each_prev_safe</span><a href="#1-3-4-3-list-for-each-prev-safe" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/20.png" alt="image-20240803210018006"></p>
<h4><span id="1-3-4-4-list-for-each-entry-reverse">1.3.4.4 list_for_each_entry_reverse</span><a href="#1-3-4-4-list-for-each-entry-reverse" class="header-anchor">#</a></h4><p>作用：传入头节点，反向去遍历里面的node所对应的外层宿主结构体。和<code>list_for_each_entry</code>方向相反。</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/21.png" alt="image-20240803175614268"></p>
<h4><span id="1-3-4-4-list-for-each-entry-safe-reverse">1.3.4.4 list_for_each_entry_safe_reverse</span><a href="#1-3-4-4-list-for-each-entry-safe-reverse" class="header-anchor">#</a></h4><p>和<code>list_for_each_entry_reverse</code>作用完全一样。</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/22.png" alt="image-20240803175551253"></p>
<h4><span id="1-3-4-5-list-for-each-entry-continue-x2f-list-for-each-entry-from-cong-zhong-jian-mou-ge-jie-dian-kai-shi-bian-li">1.3.4.5 list_for_each_entry_continue&#x2F;list_for_each_entry_from(从中间某个节点开始遍历)</span><a href="#1-3-4-5-list-for-each-entry-continue-x2f-list-for-each-entry-from-cong-zhong-jian-mou-ge-jie-dian-kai-shi-bian-li" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/23.png" alt="image-20240803211441312"></p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/23-1.png" alt="image-20240803212127987"></p>
<h4><span id="1-3-4-5-list-for-each-entry-continue-reverse-cong-zhong-jian-mou-ge-jie-dian-kai-shi-fan-xiang-bian-li">1.3.4.5 list_for_each_entry_continue_reverse(从中间某个节点开始反向遍历)</span><a href="#1-3-4-5-list-for-each-entry-continue-reverse-cong-zhong-jian-mou-ge-jie-dian-kai-shi-fan-xiang-bian-li" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/24.png" alt="image-20240803211726153"></p>
<h3><span id="1-3-5-pan-duan-lian-biao-shi-fou-wei-kong">1.3.5 判段链表是否为空</span><a href="#1-3-5-pan-duan-lian-biao-shi-fou-wei-kong" class="header-anchor">#</a></h3><h4><span id="1-3-5-1-list-empty">1.3.5.1 list_empty</span><a href="#1-3-5-1-list-empty" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/25.png" alt="image-20240803201525407"></p>
<p>只要头节点的next还是自己，那就代表链表为空。</p>
<h3><span id="1-3-6-pan-duan-jie-dian-shi-fou-wei-zui-hou-yi-ge-jie-dian">1.3.6 判段节点是否为最后一个节点</span><a href="#1-3-6-pan-duan-jie-dian-shi-fou-wei-zui-hou-yi-ge-jie-dian" class="header-anchor">#</a></h3><h4><span id="1-3-6-1-list-is-last">1.3.6.1 list_is_last</span><a href="#1-3-6-1-list-is-last" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/26.png" alt="image-20240803201702932"></p>
<p>只要传入的节点的next为头节点，那就是最后一个节点。</p>
<h3><span id="1-3-7-huo-qu-di-yi-ge-jie-dian-de-su-zhu-jie-gou">1.3.7 获取第一个节点的宿主结构</span><a href="#1-3-7-huo-qu-di-yi-ge-jie-dian-de-su-zhu-jie-gou" class="header-anchor">#</a></h3><h4><span id="1-3-7-1-list-first-entry-x2f-list-first-entry-or-null">1.3.7.1 list_first_entry&#x2F;list_first_entry_or_null</span><a href="#1-3-7-1-list-first-entry-x2f-list-first-entry-or-null" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/27.png" alt="image-20240803204338002"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_job</span> *<span class="title">job_tmp</span>;</span></span><br><span class="line">job_tmp = list_first_entry(&amp;dev-&gt;job_list, typeof(*job_tmp), node)</span><br></pre></td></tr></table></figure>

<p>前面<code>1.3.4.2 list_for_each_entry</code>小节其实已经分析过了，取出第一个节点的宿主结构指针。</p>
<p>下面这个<code>list_first_entry_or_null</code>多了一个判空，如果空链表，则会返回null。</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/28.png" alt="image-20240803205148821"></p>
<h3><span id="1-3-8-huo-qu-zui-hou-yi-ge-jie-dian-de-su-zhu-jie-gou">1.3.8 获取最后一个节点的宿主结构</span><a href="#1-3-8-huo-qu-zui-hou-yi-ge-jie-dian-de-su-zhu-jie-gou" class="header-anchor">#</a></h3><h4><span id="1-3-8-1-list-last-entry-x2f-list-first-entry-or-null">1.3.8.1 list_last_entry&#x2F;list_first_entry_or_null</span><a href="#1-3-8-1-list-last-entry-x2f-list-first-entry-or-null" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/29.png" alt="image-20240803205532106"></p>
<p>头节点的prev不就对应对应最后一个节点嘛。然后<code>list_entry</code>找到宿主结果。</p>
<h3><span id="1-3-9-huo-qu-shang-yi-ge-jie-dian-de-su-zhu-jie-gou">1.3.9 获取上一个节点的宿主结构</span><a href="#1-3-9-huo-qu-shang-yi-ge-jie-dian-de-su-zhu-jie-gou" class="header-anchor">#</a></h3><h4><span id="1-3-9-1-list-prev-entry">1.3.9.1 list_prev_entry</span><a href="#1-3-9-1-list-prev-entry" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/30.png" alt="image-20240803210650445"></p>
<p>传入某个节点取prev不就是上一个节点嘛，然后<code>list_entry</code>找到宿主结果。</p>
<h3><span id="1-3-10-huo-qu-xia-yi-ge-jie-dian-de-su-zhu-jie-gou">1.3.10 获取下一个节点的宿主结构</span><a href="#1-3-10-huo-qu-xia-yi-ge-jie-dian-de-su-zhu-jie-gou" class="header-anchor">#</a></h3><h4><span id="1-3-10-1-list-next-entry">1.3.10.1 list_next_entry</span><a href="#1-3-10-1-list-next-entry" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/31.png" alt="image-20240803210742319"></p>
<p>传入某个节点取next不就是下一个节点嘛，然后<code>list_entry</code>找到宿主结果。</p>
<h2><span id="1-4-nei-he-lian-biao-jin-jie-cao-zuo">1.4 内核链表进阶操作</span><a href="#1-4-nei-he-lian-biao-jin-jie-cao-zuo" class="header-anchor">#</a></h2><h3><span id="1-4-1-jie-dian-cong-a-lian-biao-zhuan-yi-dao-b-lian-biao">1.4.1 节点从A链表转移到B链表</span><a href="#1-4-1-jie-dian-cong-a-lian-biao-zhuan-yi-dao-b-lian-biao" class="header-anchor">#</a></h3><h4><span id="1-4-1-1-ban-yi-dao-xin-lian-biao-tou-list-move">1.4.1.1 搬移到新链表头-list_move</span><a href="#1-4-1-1-ban-yi-dao-xin-lian-biao-tou-list-move" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/32.png" alt="image-20240803212930512"></p>
<p>可以看到就是从旧链表摘除节点，再头插到新链表。</p>
<h4><span id="1-4-1-2-ban-yi-dao-xin-lian-biao-wei-list-move-tail">1.4.1.2 搬移到新链表尾-list_move_tail</span><a href="#1-4-1-2-ban-yi-dao-xin-lian-biao-wei-list-move-tail" class="header-anchor">#</a></h4><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/33.png" alt="image-20240803213156548"></p>
<p>可以看到就是从旧链表摘除节点，再尾插到新链表。</p>
<h3><span id="1-4-2-lian-biao-a-he-lian-biao-b-he-bing-list-splice">1.4.2 链表A和链表B合并-list_splice</span><a href="#1-4-2-lian-biao-a-he-lian-biao-b-he-bing-list-splice" class="header-anchor">#</a></h3><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/34.png" alt="image-20240803214326416"></p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/35.png" alt="image-20240803215126160"></p>
<p>分析：<code>list_splice(list1, list2);</code> </p>
<p>带入：<code>__list_splice(list1, list2, list2-&gt;next)</code>，那么：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">first = list1-&gt;next;</span><br><span class="line">last = list1-&gt;prev;</span><br><span class="line"></span><br><span class="line">list1-&gt;next = list2;</span><br><span class="line">list2-&gt;next = list1-&gt;next;</span><br><span class="line"></span><br><span class="line">list1-&gt;prev-&gt;next = list2-&gt;next;</span><br><span class="line">list2-&gt;next-&gt;prev = list1-&gt;prev;</span><br></pre></td></tr></table></figure>

<p>最后最好是将还要list1进行反初始化，这样list1才彻底和各个节点断链，比如<code>list_splice_init</code>函数：</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/36.png" alt="image-20240803221224876"></p>
<h3><span id="1-4-3-jie-dian-de-ti-huan-list-replace">1.4.3 节点的替换-list_replace</span><a href="#1-4-3-jie-dian-de-ti-huan-list-replace" class="header-anchor">#</a></h3><p><code>list_replace</code>：将新的节点替换到旧的节点上。</p>
<p><code>list_replace_init</code>：将新的节点替换到旧的节点上。同时将旧的节点的prev和next指向自己，反初始化。</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/37.png" alt="image-20240803213753644"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_replace</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> list_head *new)</span> &#123;</span><br><span class="line">    new-&gt;next = old-&gt;next;<span class="comment">//①</span></span><br><span class="line">    new-&gt;next-&gt;prev = new;<span class="comment">//②</span></span><br><span class="line">    new-&gt;prev = old-&gt;prev;<span class="comment">//③</span></span><br><span class="line">    new-&gt;prev-&gt;next = new;<span class="comment">//④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/38.png" alt="image-20240803223442214"></p>
<p>可以看到虽然替换成功了，但是old还是有指向关系，我们再对old进行<code>INIT_LIST_HEAD(old);</code>断掉old的指向关系，也就是对应<code>list_replace_init</code>函数：</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/38-1.png" alt="image-20240803223615205"></p>
<p>old断链后图像那么最后就会变成：</p>
<p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/39.png" alt="image-20240803223811690"></p>
<h1><span id="2-nei-he-lian-biao-zong-jie">2 内核链表总结</span><a href="#2-nei-he-lian-biao-zong-jie" class="header-anchor">#</a></h1><p><img src="/2024/04/13/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E6%A0%B8%E9%93%BE%E8%A1%A8/40.png" alt="img"></p>
]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核-rootfs构建移植</title>
    <url>/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gen-wen-jian-xi-tong-de-yin-ru">1 根文件系统的引入</a></li>
<li><a href="#2-gen-wen-jian-xi-tong-de-zu-cheng">2 根文件系统的组成</a><ul>
<li><a href="#2-1-bin-mu-lu">2.1 &#x2F;bin 目录</a></li>
<li><a href="#2-2-dev-mu-lu">2.2 &#x2F;dev 目录</a></li>
<li><a href="#2-3-etc-mu-lu">2.3 &#x2F;etc 目录</a></li>
<li><a href="#2-4-lib-mu-lu">2.4 &#x2F;lib 目录</a></li>
<li><a href="#2-5-mnt-mu-lu">2.5 &#x2F;mnt 目录</a></li>
<li><a href="#2-6-proc-mu-lu">2.6 &#x2F;proc 目录</a></li>
<li><a href="#2-7-usr-mu-lu">2.7 &#x2F;usr 目录</a></li>
<li><a href="#2-8-var-mu-lu">2.8 &#x2F;var 目录</a></li>
<li><a href="#2-9-sys-mu-lu">2.9 &#x2F;sys 目录</a></li>
</ul>
</li>
<li><a href="#3-gou-jian-gen-wen-jian-xi-tong">3 构建根文件系统</a><ul>
<li><a href="#3-1-busybox">3.1 busybox</a><ul>
<li><a href="#3-1-1-pei-zhi-bian-yi-busybox">3.1.1 配置编译 BusyBox</a><ul>
<li><a href="#3-1-1-1-busybox-zhi-chi-zhong-wen-shi-bie">3.1.1.1 busybox支持中文识别</a></li>
<li><a href="#3-1-1-2-busybox-pei-zhi">3.1.1.2 busybox配置</a></li>
<li><a href="#3-1-1-3-bian-yi">3.1.1.3 编译</a></li>
</ul>
</li>
<li><a href="#3-1-2-gen-wen-jian-xi-tong-tian-jia-lib-ku">3.1.2 根文件系统添加 lib 库</a><ul>
<li><a href="#3-1-2-1-lib-ku-tian-jia">3.1.2.1 &#x2F;lib库添加</a></li>
<li><a href="#3-1-2-2-usr-lib-ku-tian-jia">3.1.2.2 &#x2F;usr&#x2F;lib库添加</a></li>
</ul>
</li>
<li><a href="#3-1-3-gen-wen-jian-xi-tong-tian-jia-qi-ta-mu-lu">3.1.3 根文件系统添加其他目录</a></li>
<li><a href="#3-1-4-gen-wen-jian-xi-tong-ce-shi">3.1.4 根文件系统测试</a></li>
<li><a href="#3-1-5-gen-wen-jian-xi-tong-tian-jia-etc-pei-zhi-jiao-ben">3.1.5 根文件系统添加 etc配置脚本</a><ul>
<li><a href="#3-1-5-1-chuang-jian-etc-init-d-rcs">3.1.5.1 创建&#x2F;etc&#x2F;init.d&#x2F;rcS</a></li>
<li><a href="#3-1-5-2-chuang-jian-etc-fstab">3.1.5.2 创建&#x2F;etc&#x2F;fstab</a></li>
<li><a href="#3-1-5-3-chuang-jian-etc-inittab-wen-jian">3.1.5.3 创建&#x2F;etc&#x2F;inittab文件</a></li>
<li><a href="#3-1-5-3-chuang-jian-etc-resolv-conf">3.1.5.3 创建&#x2F;etc&#x2F;resolv.conf</a></li>
<li><a href="#3-1-5-4-proc-cmdline">3.1.5.4 <code>/proc/cmdline</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gen-wen-jian-xi-tong-de-yin-ru">1 根文件系统的引入</span><a href="#1-gen-wen-jian-xi-tong-de-yin-ru" class="header-anchor">#</a></h1><p>我们知道文件系统类型有 <code>FATFS、FAT、EXT4、YAFFS 和 NTFS，squashfs</code>等。文件系统可以让我们利用文件IO的形式对文件目录进行访问，而不用去访问flash存储地址，在使用上更为方便轻松。<br>根文件系统rootfs, 首先是内核启动时所 mount(挂载)的第一个文件系统，系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。<br>百度百科上说内核代码镜像文件保存在根文件系统中(对电脑端的Ubuntu来说确实是，放在<code>/boot/vmlinuz-5.4.0-152-generic</code>)。但是我们嵌入式 Linux 并没有将内核代码镜像保存在根文件系统中，而是保存到了其他地方，比如 NAND Flash 的指定存储地址、EMMC 专用分区中。<br>嵌入式根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须要搭配根文件系统。如果不提供根文件系统，Linux 内核在启动的时候就会提示内核崩溃(Kernel panic)：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/1.png" alt="image"></p>
<h1><span id="2-gen-wen-jian-xi-tong-de-zu-cheng">2 根文件系统的组成</span><a href="#2-gen-wen-jian-xi-tong-de-zu-cheng" class="header-anchor">#</a></h1><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/2.png" alt="image"></p>
<h2><span id="2-1-x2f-bin-mu-lu">2.1 &#x2F;bin 目录</span><a href="#2-1-x2f-bin-mu-lu" class="header-anchor">#</a></h2><p>存放着系统需要的可执行文件，一般都是一些命令，比如<code>ls、cp、mv</code>等命令。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/3.png" alt="image"></p>
<h2><span id="2-2-x2f-dev-mu-lu">2.2 &#x2F;dev 目录</span><a href="#2-2-x2f-dev-mu-lu" class="header-anchor">#</a></h2><p>此目录下的文件都是设备节点文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /dev/</span><br><span class="line">crw-rw----    1 root     root       89,   9 Jan  1 08:00 /dev/i2c-9</span><br><span class="line">crw-rw----    1 root     root       10,  62 Jan  1 08:00 /dev/ion</span><br><span class="line">crw-rw----    1 root     root        1,  11 Jan  1 08:00 /dev/kmsg</span><br><span class="line">srw-rw-rw-    1 root     root             0 Jan  1 08:00 /dev/log</span><br><span class="line">crw-rw----    1 root     root       10, 237 Jan  1 08:00 /dev/loop-control</span><br><span class="line">brw-rw----    1 root     root        7,   0 Jan  1 08:00 /dev/loop0</span><br><span class="line">brw-rw----    1 root     root        7,   1 Jan  1 08:00 /dev/loop1</span><br><span class="line">brw-rw----    1 root     root      179,   0 Jan  1 08:00 /dev/mmcblk0</span><br><span class="line">brw-rw----    1 root     root      179,   8 Jan  1 08:00 /dev/mmcblk0boot0</span><br><span class="line">brw-rw----    1 root     root      179,  16 Jan  1 08:00 /dev/mmcblk0boot1</span><br><span class="line">brw-rw----    1 root     root      179,   1 Jan  1 08:00 /dev/mmcblk0p1</span><br><span class="line">brw-rw----    1 root     root      179,   2 Jan  1 08:00 /dev/mmcblk0p2</span><br><span class="line">brw-rw----    1 root     root      179,   3 Jan  1 08:00 /dev/mmcblk0p3</span><br><span class="line">brw-rw----    1 root     root      179,   4 Jan  1 08:00 /dev/mmcblk0p4</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-x2f-etc-mu-lu">2.3 &#x2F;etc 目录</span><a href="#2-3-x2f-etc-mu-lu" class="header-anchor">#</a></h2><p>此目录下存放着各种配置文件。</p>
<h2><span id="2-4-x2f-lib-mu-lu">2.4 &#x2F;lib 目录</span><a href="#2-4-x2f-lib-mu-lu" class="header-anchor">#</a></h2><p>存放着 Linux 所必须的库文件。这些库文件是共享库，命令和用户编写的应用程序要使用这些库文件。</p>
<h2><span id="2-5-x2f-mnt-mu-lu">2.5 &#x2F;mnt 目录</span><a href="#2-5-x2f-mnt-mu-lu" class="header-anchor">#</a></h2><p>临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如&#x2F;mnt&#x2F;sd、&#x2F;mnt&#x2F;usb，这样就可以将 SD 卡或者 U 盘挂载到&#x2F;mnt&#x2F;sd 或者&#x2F;mnt&#x2F;usb 目录中。</p>
<h2><span id="2-6-x2f-proc-mu-lu">2.6 &#x2F;proc 目录</span><a href="#2-6-x2f-proc-mu-lu" class="header-anchor">#</a></h2><p>proc虚拟文件系统，输出硬件驱动模块的相关信息，各种输出打印。（后续专门出一篇博文介绍）<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/4.png" alt="image"></p>
<h2><span id="2-7-x2f-usr-mu-lu">2.7 &#x2F;usr 目录</span><a href="#2-7-x2f-usr-mu-lu" class="header-anchor">#</a></h2><p>这里的usr 不是 user 的缩写，而是 <code>Unix Software Resource </code>的缩写，也就是 Unix 操作系统软件资源目录。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/5.png" alt="image"></p>
<h2><span id="2-8-x2f-var-mu-lu">2.8 &#x2F;var 目录</span><a href="#2-8-x2f-var-mu-lu" class="header-anchor">#</a></h2><p>存放一些可以改变的数据。如&#x2F;var&#x2F;log。</p>
<pre><code>[root@robin]/var/log# ls
messages    messages.0  messages.1  messages.2  messages.3
</code></pre>
<h2><span id="2-9-x2f-sys-mu-lu">2.9 &#x2F;sys 目录</span><a href="#2-9-x2f-sys-mu-lu" class="header-anchor">#</a></h2><p>此目录作为 sysfs 文件系统的挂载点，sysfs 是一个类似于 proc 文件系统的特殊文件系统，sysfs 也是基于 ram 的文件系统，也就是说它也没有实际的存储设备。此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息。</p>
<p>查看硬件模块IP的<code>base addr</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@robin]/sys/devices<span class="comment"># cd platform/</span></span><br><span class="line">[root@robin]/sys/devices/platform<span class="comment"># ls</span></span><br><span class="line">1040000.mon                 29230000.spi3</span><br><span class="line">1900000.rtos_cmdqu          29240000.can</span><br><span class="line">203c0000.bmtpu              29300000.cv-emmc</span><br><span class="line">20400000.pcie               29310000.cv-sd</span><br><span class="line">20bc0000.sata               29320000.cv-sd</span><br><span class="line">20bc0000.sata:sata-port@0   29330000.wifi-sd</span><br><span class="line">20bc0000.sata:sata-port@1   29340000.dma</span><br><span class="line">21020000.vc_drv             29350000.dma</span><br><span class="line">27000000.cv-wd              39000100.usb</span><br><span class="line">27010000.gpio               39000200.usb</span><br><span class="line">27011000.gpio               41d0c00.pdm</span><br><span class="line">27012000.gpio               5021000.gpio</span><br></pre></td></tr></table></figure>


<p>查看debug相关：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@robin]/sys/kernel/debug<span class="comment"># ls</span></span><br><span class="line">27000000.cv-wd      dw_spi2             mtd</span><br><span class="line">asoc                dw_spi3             pinctrl</span><br><span class="line">bdi                 dynamic_debug       pwm</span><br><span class="line">block               extfrag             regmap</span><br><span class="line">bluetooth           fault_around_bytes  sched_debug</span><br><span class="line">clear_warn_once     gpio                sched_features</span><br><span class="line">clk                 hid                 sleep_time</span><br><span class="line">debug_enabled       ieee80211           split_huge_pages</span><br></pre></td></tr></table></figure>
<p>重要的有：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">/sys/kernel/debug/debug_enabled</span><br><span class="line">/sys/kernel/debug/dynamic_debug/control</span><br><span class="line">/sys/kernel/debug/clk/clk_summary</span><br></pre></td></tr></table></figure>

<p>查看和设置驱动模块module param变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/module/soph_stitch/parameters</span><br><span class="line">[root@cvitek]/sys/module/soph_stitch/parameters<span class="comment"># cat stitch_log_lv</span></span><br><span class="line">2</span><br><span class="line">[root@cvitek]/sys/module/soph_stitch/parameters<span class="comment"># echo 2 &gt; stitch_log_lv</span></span><br><span class="line">[root@cvitek]/sys/module/soph_stitch/parameters<span class="comment"># cat stitch_log_lv</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h1><span id="3-gou-jian-gen-wen-jian-xi-tong">3 构建根文件系统</span><a href="#3-gou-jian-gen-wen-jian-xi-tong" class="header-anchor">#</a></h1><h2><span id="3-1-busybox">3.1 busybox</span><a href="#3-1-busybox" class="header-anchor">#</a></h2><p>BusyBox 是一个集成了大量的 Linux 命令和工具的软件，像<code>ls、mv、ifconfig</code>等命令 BusyBox 都会提供。<br>一般下载 BusyBox 的源码，然后配置 BusyBox，选择自己想要的功能，最后编译即可。<br>BusyBox 可以在其官网下载到，官网地址为：<br><a href="https://busybox.net/downloads/">https://busybox.net/downloads/</a></p>
<h3><span id="3-1-1-pei-zhi-bian-yi-busybox">3.1.1 配置编译 BusyBox</span><a href="#3-1-1-pei-zhi-bian-yi-busybox" class="header-anchor">#</a></h3><p>这里我下载的<code>busybox-1.29.0.tar.bz2</code>， 将其进行解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rootfs；<span class="built_in">cd</span> rootfs; tar xfj busybox-1.29.0.tar.bz2</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/6.png" alt="image"><br>修改Makefile添加<code>toolchain</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">164 CROSS_COMPILE ?= /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-</span><br><span class="line">......</span><br><span class="line">190 ARCH ?= arm</span><br></pre></td></tr></table></figure>

<h4><span id="3-1-1-1-busybox-zhi-chi-zhong-wen-shi-bie">3.1.1.1 busybox支持中文识别</span><a href="#3-1-1-1-busybox-zhi-chi-zhong-wen-shi-bie" class="header-anchor">#</a></h4><p>我们知道中文的编码如果采用<code>utf8</code>，那么<code>ascii</code>值肯定是大于<code>0x7f</code>的。因此需要修改busybox源码，让其能识别超过<code>ascii</code>的编码范围<code>0x7f</code>。</p>
<p><strong>utf8 中文编码</strong>：<br>UTF-8是一种广泛使用的<code>Unicode</code>编码方式，它可以用来表示各种语言和符号。对于中文字来说，UTF-8采用了一种特殊的编码方式，即中文字符主要使用三个字节（21比特）来表示。具体来说，当一个汉字的Unicode码位于0x80到0x7FF之间的时，UTF-8会用三个字节来编码这个汉字。例如，汉字“爸”在UTF-8中的编码过程是这样的：</p>
<p>首先，将汉字<code>“爸”</code>的<code>Unicode</code>码<code>（0x5BAD）</code>转换为二进制数<code>（0111 0010 0011 1000）</code>。<br>然后，按照UTF-8的三字节模式进行编码，即每个字节的最高位都设置为1，剩下的7位用于表示该字节所对应的Unicode值。在这个例子中，第一个字节的高位为1，表示这是一个16位的字节；接下来的三位为1011，对应于Unicode码中的第11位，即十进制的5；最后一位为0，代表这是一个字节的最低位。<br>最后，将这三个字节的二进制数转换为十六进制数<code>（0xE788B8）</code>，这就是汉字<code>“爸”</code>在UTF-8中的编码形式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi libbb/unicode.c</span><br></pre></td></tr></table></figure>
<p>打开函数<code>unicode_conv_to_printable2</code>,修改如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/7.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi libbb/printable_string.c</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/8.png" alt="image"></p>
<h4><span id="3-1-1-2-busybox-pei-zhi">3.1.1.2 busybox配置</span><a href="#3-1-1-2-busybox-pei-zhi" class="header-anchor">#</a></h4><p>编译busybox前要先对 busybox 进行默认的配置，有以下几种配置选项：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">①、defconfig，缺省配置，也就是默认配置选项。</span><br><span class="line">②、allyesconfig，全选配置，也就是选中 busybox 的所有功能</span><br><span class="line">③、allnoconfig，最小配置。</span><br><span class="line"></span><br><span class="line">make defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/9.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-&gt; Settings </span><br><span class="line">	-&gt; Build <span class="type">static</span> <span class="title function_">binary</span> <span class="params">(no shared libs)</span></span><br></pre></td></tr></table></figure>
<p>这项请不要勾选，静态编译 busybox会DNS解析有问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-&gt; Settings</span><br><span class="line">	-&gt; vi-style line editing commands</span><br></pre></td></tr></table></figure>
<p>建议勾选这项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-&gt; Linux Module Utilities</span><br><span class="line">	-&gt; Simplified modutils</span><br></pre></td></tr></table></figure>
<p>默认会选中“Simplified modutils”，这里我们要取消勾选。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-&gt; Linux System Utilities</span><br><span class="line">	-&gt; mdev (<span class="number">16</span> kb) <span class="comment">//确保下面的全部选中，默认都是选中的</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/10.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-&gt; Settings</span><br><span class="line">	-&gt; Support Unicode <span class="comment">//选中</span></span><br><span class="line">		-&gt; Check $LC_ALL, $LC_CTYPE and $LANG environment variables <span class="comment">//选中</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/11.png" alt="image"></p>
<h4><span id="3-1-1-3-bian-yi">3.1.1.3 编译</span><a href="#3-1-1-3-bian-yi" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line">make install CONFIG_PREFIX=/media/cvitek/robin.lee/rootfs ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/12.png" alt="image"><br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/13.png" alt="image"></p>
<p>busybox 的所有工具和文件就会被安装到 rootfs 目录中，rootfs 目录内容如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/14.png" alt="image"><br>命令和工具都再对应&#x2F;bin &#x2F;usr&#x2F;bin对应的目录：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/15.png" alt="image"></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17995165" title="3.linux内核启动流程">3.linux内核启动流程</a></p>
<p><a href="https://fuzidage.github.io/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Linux内核启动流程 | Hexo (fuzidage.github.io)</a></p>
<p>说过 Linux 内核 init 进程最后会查找用户空间的 init 程序，找到以后就会运行这个用户空间的 init 程序，从而切换到用户态。如果 <code>bootargs</code> 设置 <code>init=/linuxrc</code>，那么 linuxrc 就是可以作为用户空间的 init 程序，所以用户态空间的 init 程序是 busybox 来生成的。</p>
<p>我们的根文件系统此时就制作好了，但此时还不能使用，还需要一些其他的文件，我们继续来完善 rootfs。</p>
<h3><span id="3-1-2-gen-wen-jian-xi-tong-tian-jia-lib-ku">3.1.2 根文件系统添加 lib 库</span><a href="#3-1-2-gen-wen-jian-xi-tong-tian-jia-lib-ku" class="header-anchor">#</a></h3><h4><span id="3-1-2-1-x2f-lib-ku-tian-jia">3.1.2.1 &#x2F;lib库添加</span><a href="#3-1-2-1-x2f-lib-ku-tian-jia" class="header-anchor">#</a></h4><p>Linux 中的应用程序一般都是需要动态库的，当然你也可以编译成静态的，但是静态的可执行文件会很大。如果编译为动态的话就需要动态库，所以我们需要向根文件系统中添加动态库。lib 库文件从交叉编译器中获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> lib</span><br><span class="line"><span class="built_in">cd</span> gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib</span><br></pre></td></tr></table></figure>
<p>libc库如下：将其拷贝进rootfs。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/16.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> *so* *.a /media/cvitek/robin.lee/rootfs/lib -d <span class="comment">#-d表示将软链接也一同拷贝</span></span><br></pre></td></tr></table></figure>

<p>进入工具链的lib库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib</span><br><span class="line"><span class="built_in">cp</span> *so* *.a /media/cvitek/robin.lee/rootfs/lib -d <span class="comment">#-d表示将软链接也一同拷贝</span></span><br></pre></td></tr></table></figure>
<p>最终根文件系统的&#x2F;lib内容如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/17.png" alt="image"></p>
<h4><span id="3-1-2-2-x2f-usr-x2f-lib-ku-tian-jia">3.1.2.2 &#x2F;usr&#x2F;lib库添加</span><a href="#3-1-2-2-x2f-usr-x2f-lib-ku-tian-jia" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/lib</span><br><span class="line"><span class="built_in">cd</span> gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib</span><br></pre></td></tr></table></figure>
<p>libc&#x2F;usr&#x2F;lib库如下：将其拷贝进rootfs。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/18.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> *so* *.a /media/cvitek/robin.lee/rootfs/usr/lib -d <span class="comment">#-d表示将软链接也一同拷贝</span></span><br></pre></td></tr></table></figure>
<p>至此，根文件系统的库文件就全部添加好了。来看下库占用存储空间多少：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">robin.lee@WORKSTATION5:/media/cvitek/robin.lee/rootfs$ <span class="built_in">du</span> ./lib ./usr/lib/ -sh</span><br><span class="line">57M     ./lib</span><br><span class="line">67M     ./usr/lib/</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-gen-wen-jian-xi-tong-tian-jia-qi-ta-mu-lu">3.1.3 根文件系统添加其他目录</span><a href="#3-1-3-gen-wen-jian-xi-tong-tian-jia-qi-ta-mu-lu" class="header-anchor">#</a></h3><p>dev、proc、mnt、sys、tmp 和 root这些目录需要在rootfs进行创建。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/19.png" alt="image"></p>
<h3><span id="3-1-4-gen-wen-jian-xi-tong-ce-shi">3.1.4 根文件系统测试</span><a href="#3-1-4-gen-wen-jian-xi-tong-ce-shi" class="header-anchor">#</a></h3><p>初步测试我们的rootfs功能，我们最好是利用nfs挂载根文件系统，方便修改。之前<code>bootargs</code>都是设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span></span><br></pre></td></tr></table></figure>
<p>从emmc分区2启动，分区2存放了根文件系统。现在bootargs改成nfs挂载rootfs要如何设置呢？<br>文档为 <code>Documentation/filesystems/nfs/nfsroot.txt</code>，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root=/dev/nfs nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;:&lt;dns0-ip&gt;:&lt;dns1-ip&gt;</span><br><span class="line"></span><br><span class="line">&lt;server-ip&gt;：服务器 IP 地址，比如我的 Ubuntu 主机 IP 地址为 192.168.1.250。</span><br><span class="line">&lt;root-dir&gt;：根文件系统的存放路径，要保证放在nfs共享目录下。比如我的就是/media/cvitek/robin.lee/rootfs</span><br><span class="line">&lt;nfs-options&gt;：NFS 的其他可选选项，一般不设置。</span><br><span class="line">&lt;client-ip&gt;：客户端 IP 地址，也就是我们开发板的 IP 地址</span><br><span class="line">&lt;server-ip&gt;：服务器 IP 地址，前面已经说了。</span><br><span class="line">&lt;gw-ip&gt;：网关地址，我的就是 192.168.1.1。</span><br><span class="line">&lt;netmask&gt;：子网掩码，我的就是 255.255.255.0。</span><br><span class="line">&lt;hostname&gt;：客户机的名字，一般不设置，此值可以空着。</span><br><span class="line">&lt;device&gt;：设备名，也就是网卡名，一般是 eth0，eth1….，正点原子的 I.MX6U-ALPHA 开发板的 ENET2 为 eth0，ENET1 为 eth1。</span><br><span class="line">&lt;autoconf&gt;：自动配置，一般不使用，所以设置为 off。</span><br><span class="line">&lt;dns0-ip&gt;：DNS0 服务器 IP 地址，不使用。</span><br><span class="line">&lt;dns1-ip&gt;：DNS1 服务器 IP 地址，不使用。</span><br></pre></td></tr></table></figure>

<p>最终我们设置 bootargs 环境变量的 root 值如下：<br><code>root=/dev/nfs nfsroot=192.168.1.250:/media/cvitek/robin.lee/rootfs,proto=tcp rw ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off</code></p>
<p><code>“proto=tcp”</code>表示使用 TCP 协议，<code>“rw”</code>表示 nfs 挂载的根文件系统为可读可写。<br>修改保存环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.250:/media/cvitek/robin.lee/rootfs,proto=tcp rw ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off&#x27;</span> <span class="comment">#设置 bootargs</span></span><br><span class="line">saveenv <span class="comment">#保存环境变量</span></span><br></pre></td></tr></table></figure>

<p>设置好以后使用<code>“boot”</code>命令启动 Linux 内核，输出打印如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/20.png" alt="image"><br>可以看到成功挂载rootfs，并且进入Linux控制台。</p>
<h3><span id="3-1-5-gen-wen-jian-xi-tong-tian-jia-etc-pei-zhi-jiao-ben">3.1.5 根文件系统添加 etc配置脚本</span><a href="#3-1-5-gen-wen-jian-xi-tong-tian-jia-etc-pei-zhi-jiao-ben" class="header-anchor">#</a></h3><h4><span id="3-1-5-1-chuang-jian-x2f-etc-x2f-init-d-x2f-rcs">3.1.5.1 创建&#x2F;etc&#x2F;init.d&#x2F;rcS</span><a href="#3-1-5-1-chuang-jian-x2f-etc-x2f-init-d-x2f-rcs" class="header-anchor">#</a></h4><p>前面打印有一行报错，进入根文件系统的时候会有下面这一行错误提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">can<span class="string">&#x27;t run &#x27;</span>/etc/init.d/rcS<span class="string">&#x27;: No such file or directory</span></span><br></pre></td></tr></table></figure>
<p>rcS 是个 shell 脚本，Linux 内核启动以后需要启动一些服务，而 rcS 就是规定启动哪些文件的脚本文件。在 rootfs 中创建<code>/etc/init.d/rcS </code>文件，然后在 rcS 中输入如下所示内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:<span class="variable">$PATH</span></span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/lib:/usr/lib</span><br><span class="line"><span class="built_in">export</span> PATH LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">mount -a</span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>
<p><code>PATH</code> 环境变量保存着可执行文件可能存在的目录;<br><code>LD_LIBRARY_PATH</code> 环境变量保存着库文件所在的目录;<br>mount 命令来挂载所有的文件系统，这些文件系统由文件<code>/etc/fstab</code> 来指定;<br>创建目录<code>/dev/pts</code>，然后将 <code>devpts</code> 挂载到<code>/dev/pts </code>目录中。<br>使用 mdev 来管理热插拔设备，通过这两行，Linux 内核就可以在&#x2F;dev 目录下自动创建设备节点。</p>
<p>我们是简单构造了一个最简单的rcS, 大家如果去看 Ubuntu 或者其他大型 Linux操作系统中的 rcS 文件，就会发现其非常复杂。而且这么复杂的 rcS 文件也是借助其他工具创建的，比如 buildroot 等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 rcS</span><br></pre></td></tr></table></figure>
<p>重新启动 Linux 内核，启动以后如下图：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/21.png" alt="image"></p>
<h4><span id="3-1-5-2-chuang-jian-x2f-etc-x2f-fstab">3.1.5.2 创建&#x2F;etc&#x2F;fstab</span><a href="#3-1-5-2-chuang-jian-x2f-etc-x2f-fstab" class="header-anchor">#</a></h4><p>fstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;file system&gt; &lt;mount point&gt; &lt;<span class="built_in">type</span>&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br><span class="line"></span><br><span class="line">&lt;file system&gt;：要挂载的特殊的设备，也可以是块设备，比如/dev/sda 等等</span><br><span class="line">&lt;mount point&gt;：挂载点。</span><br><span class="line">&lt;<span class="built_in">type</span>&gt;：文件系统类型，比如 ext2、ext3、proc、romfs、tmpfs 等等。</span><br><span class="line">&lt;options&gt;：挂载选项，一般使用 defaults，defaults 包含了 rw、suid、 dev、 <span class="built_in">exec</span>、 auto、 nouser 和 async。</span><br><span class="line">&lt;dump&gt;：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。</span><br><span class="line">&lt;pass&gt;：磁盘检查设置，为 0 表示不检查。根目录‘/’设置为 1，其他的都不能设置为 1，因此这里一般设置为 0</span><br></pre></td></tr></table></figure>
<p>fstab内容设置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&lt;file system&gt;   &lt;mount point&gt;     &lt;type&gt;     &lt;options&gt;   &lt;dump&gt;    &lt;pass&gt;</span></span><br><span class="line">proc             /proc             proc       defaults    0         0</span><br><span class="line">tmpfs            /tmp              tmpfs      defaults    0         0</span><br><span class="line">sysfs            /sys              sysfs      defaults    0         0</span><br></pre></td></tr></table></figure>

<p><code>fstab </code>文件创建完成以后重新启动 Linux打印如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/22.png" alt="image"></p>
<h4><span id="3-1-5-3-chuang-jian-x2f-etc-x2f-inittab-wen-jian">3.1.5.3 创建&#x2F;etc&#x2F;inittab文件</span><a href="#3-1-5-3-chuang-jian-x2f-etc-x2f-inittab-wen-jian" class="header-anchor">#</a></h4><p>inittab 的详细内容可以参考 busybox 下的文件 <code>examples/inittab</code>。init 程序会读取<code>/etc/inittab</code>这个文件，inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">id</span>&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="line">&lt;<span class="built_in">id</span>&gt;：每个指令的标识符，不能重复。但是对于 busybox 的 init 来说，&lt;<span class="built_in">id</span>&gt;有着特殊意义。对于 busybox 而言&lt;<span class="built_in">id</span>&gt;用来指定启动进程的控制 <span class="built_in">tty</span>，一般我们将串口或者 LCD 屏幕设置为控制 <span class="built_in">tty</span>。</span><br><span class="line">&lt;runlevels&gt;：对 busybox 来说此项完全没用，所以空着。</span><br><span class="line">&lt;action&gt;：动作，用于指定&lt;process&gt;可能用到的动作:</span><br><span class="line">	busybox 支持的动作如下：</span><br><span class="line">	sysinit: 在系统初始化的时候 process 才会执行一次。</span><br><span class="line">	respawn: 当 process 终止以后马上启动一个新的。</span><br><span class="line">	askfirst:和 respawn 类似，在运行 process 之前在控制台上显示“Please press Enter to activate this console.”。只要用户按下“Enter”键以后才会执行 process。</span><br><span class="line">	<span class="built_in">wait</span>: 告诉 init，要等待相应的进程执行完以后才能继续执行。</span><br><span class="line">	once: 仅执行一次，而且不会等待 process 执行完成。</span><br><span class="line">	restart: 当 init 重启的时候才会执行 procee。</span><br><span class="line">	ctrlaltdel: 当按下 ctrl+alt+del 组合键才会执行 process。</span><br><span class="line">	shutdown: 关机的时候执行 process。</span><br><span class="line">&lt;process&gt;：具体的动作，比如程序、脚本或命令等</span><br></pre></td></tr></table></figure>

<p>我们的&#x2F;etc&#x2F;inittab内容设置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#etc/inittab</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">console::askfirst:-/bin/sh</span><br><span class="line">::restart:/sbin/init</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br></pre></td></tr></table></figure>

<p>第 2 行，系统启动以后运行<code>/etc/init.d/rcS </code>这个脚本文件。<br>第 3 行，将 console 作为控制台终端，也就是 ttymxc0。<br>第 4 行，重启的话运行&#x2F;sbin&#x2F;init。<br>第 5 行，按下 ctrl+alt+del 组合键的话就运行<code>/sbin/reboot</code>，看来 ctrl+alt+del 组合键用于重启系统。<br>第 6 行，关机的时候执行<code>/bin/umount</code>，也就是卸载各个文件系统。<br>第 7 行，关机的时候执行<code>/sbin/swapoff</code>，也就是关闭交换分区。</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/23.png" alt="image"></p>
<h4><span id="3-1-5-3-chuang-jian-x2f-etc-x2f-resolv-conf">3.1.5.3 创建&#x2F;etc&#x2F;resolv.conf</span><a href="#3-1-5-3-chuang-jian-x2f-etc-x2f-resolv-conf" class="header-anchor">#</a></h4><p><code>/etc/resolv.conf</code>是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，还包含了主机的域名搜索顺序。该文件是由域名解析器（resolver，一个根据主机名解析IP地址的库）使用的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nameserver： 配置DNS服务器地址（顺序来查询，且只有当第一个nameserver没有反应时才查询下面的nameserver）</span><br><span class="line">domain： 声明主机的域名，当查询不完全的域名时主机名将被使用(相当于search的默认值)</span><br><span class="line">search： 它的多个参数指明域名查询顺序。当查询不完全的域名时会使用到（domain和search不能共存）</span><br></pre></td></tr></table></figure>

<p>默认<code>/etc/resolv.conf</code>配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">nameserver 192.168.248.2</span><br></pre></td></tr></table></figure>

<p>一般将<strong>nameserver</strong>设置成网关地址，再加入<code>8.8.8.8</code>和<code>114.114.114.114</code></p>
<p><code>ping blog.csdn.com</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ping blog.csdn.com</span></span><br><span class="line">PING blog.csdn.com.com (45.11.57.36) 56(84) bytes of data.</span><br><span class="line">64 bytes from comcomproxy1.com.com (45.11.57.36): icmp_seq=1 ttl=44 time=291 ms</span><br><span class="line">64 bytes from comcomproxy1.com.com (45.11.57.36): icmp_seq=2 ttl=44 time=270 ms</span><br></pre></td></tr></table></figure>

<p><code>ping blog</code>，发现不通，需要设置<code>domain域</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ping blog</span></span><br><span class="line">ping: blog: 未知的名称或服务</span><br></pre></td></tr></table></figure>
<p>调整<code>/etc/resolv.conf</code>配置文件,添加<strong>domain</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># vi /etc/resolv.conf</span></span><br><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">nameserver 192.168.248.2</span><br><span class="line">domain csdn.net</span><br></pre></td></tr></table></figure>

<p>再次<code>ping blog</code>, ping不完整域名会自动补全</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ping blog</span></span><br><span class="line">PING blog.csdn.net (182.92.187.217) 56(84) bytes of data.</span><br><span class="line">64 bytes from 182.92.187.217 (182.92.187.217): icmp_seq=1 ttl=89 time=20.4 ms</span><br></pre></td></tr></table></figure>

<p>调整<code>/etc/resolv.conf</code>配置文件,添加<strong>search</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># vi /etc/resolv.conf</span></span><br><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">nameserver 192.168.248.2</span><br><span class="line">search abc.com csdn.net</span><br></pre></td></tr></table></figure>

<h4><span id="3-1-5-4-proc-cmdline">3.1.5.4 <code>/proc/cmdline</code></span><a href="#3-1-5-4-proc-cmdline" class="header-anchor">#</a></h4><p><code>cat /proc/cmdline</code> 可以看到内核启动时U-boot传入参数:<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/24.png" alt="image"></p>
]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核-并发与同步</title>
    <url>/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-bing-fa-chang-jing">1 并发场景</a></li>
<li><a href="#2-bing-fa-jie-jue-fang-an">2 并发解决方案</a><ul>
<li><a href="#2-1-nei-cun-ping-zhang">2.1 内存屏障</a><ul>
<li><a href="#2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering">2.1.1 编译器指令重排（Compiler Instruction Reordering)</a></li>
<li><a href="#2-1-2-nei-cun-ping-zhang-api">2.1.2 内存屏障API</a><ul>
<li><a href="#2-1-2-1-barrier">2.1.2.1 barrier</a></li>
<li><a href="#2-1-2-2-cpu-relax">2.1.2.2 cpu_relax</a></li>
<li><a href="#2-1-2-3-read-once">2.1.2.3 READ_ONCE()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-yuan-zi-cao-zuo">2.2 原子操作</a><ul>
<li><a href="#2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru">2.2.0 临界区的原子操作引入</a></li>
<li><a href="#2-2-1-zheng-shu-yuan-zi-cao-zuo-api">2.2.1 整数原子操作API</a></li>
<li><a href="#2-2-2-wei-yuan-zi-cao-zuo-api">2.2.2 位原子操作API</a></li>
</ul>
</li>
<li><a href="#2-3-zi-xuan-suo">2.3 自旋锁</a><ul>
<li><a href="#2-3-1-zi-xuan-suo-api">2.3.1 自旋锁API</a><ul>
<li><a href="#2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan">2.3.1.1 自旋锁和中断相关</a></li>
</ul>
</li>
<li><a href="#2-3-2-du-xie-zi-xuan-suo">2.3.2 读写自旋锁</a></li>
<li><a href="#2-3-3-shun-xu-suo">2.3.3 顺序锁</a></li>
</ul>
</li>
<li><a href="#2-4-xin-hao-liang">2.4 信号量</a><ul>
<li><a href="#2-4-1-xin-hao-liang-api">2.4.1 信号量 API</a></li>
</ul>
</li>
<li><a href="#2-5-hu-chi-suo">2.5 互斥锁</a><ul>
<li><a href="#2-5-1-hu-chi-suo-api">2.5.1 互斥锁API</a></li>
</ul>
</li>
<li><a href="#2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi">2.6 SMP 架构下percpu变量机制</a><ul>
<li><a href="#2-6-0-percpu-bian-liang-de-cun-chu-ge-shi">2.6.0 percpu 变量的存储格式</a></li>
<li><a href="#2-6-1-percpu-bian-liang-shi-yong-chang-jing">2.6.1 percpu变量使用场景</a></li>
<li><a href="#2-6-2-percpu-bian-liang-de-ding-yi">2.6.2 percpu 变量的定义</a></li>
<li><a href="#2-6-3-percpu-bian-liang-de-du-xie">2.6.3 percpu 变量的读写</a></li>
<li><a href="#2-6-4-percpu-bian-liang-shi-xian-yuan-li">2.6.4 percpu 变量实现原理</a><ul>
<li><a href="#2-6-4-1-get-cpu-var-shi-xian">2.6.4.1 get_cpu_var实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing">3 linux内核下不同同步机制的适用场景</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-bing-fa-chang-jing">1 并发场景</span><a href="#1-bing-fa-chang-jing" class="header-anchor">#</a></h1><p>Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原 因：</p>
<ol>
<li>多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。</li>
<li>抢占式并发访问，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以 在任意时刻抢占正在运行的线程，从而运行其他的线程。 </li>
<li>中断程序并发访问，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可 是很大的。</li>
<li>SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并 发访问。</li>
</ol>
<h1><span id="2-bing-fa-jie-jue-fang-an">2 并发解决方案</span><a href="#2-bing-fa-jie-jue-fang-an" class="header-anchor">#</a></h1><h2><span id="2-1-nei-cun-ping-zhang">2.1 内存屏障</span><a href="#2-1-nei-cun-ping-zhang" class="header-anchor">#</a></h2><h3><span id="2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering">2.1.1 编译器指令重排（Compiler Instruction Reordering)</span><a href="#2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w0, [x0]       <span class="comment">//load b to w0</span></span><br><span class="line">    add w1, w0, #<span class="number">0x1</span></span><br><span class="line">    ...</span><br><span class="line">    str w1, [x0]       <span class="comment">//a = b + 1</span></span><br><span class="line">    ...</span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br></pre></td></tr></table></figure>

<p>我们把编译优化打开到-O2，再次反汇编：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w2, [x0]       <span class="comment">//load b to w2</span></span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br><span class="line">    add w0, w2, #<span class="number">0x1</span></span><br><span class="line">    str w0, [x1]       <span class="comment">//a = b + 1</span></span><br></pre></td></tr></table></figure>

<p>可以看到编译器 ”自作聪明“， b被提前赋值了。因此要使用内存屏障。</p>
<h3><span id="2-1-2-nei-cun-ping-zhang-api">2.1.2 内存屏障API</span><a href="#2-1-2-nei-cun-ping-zhang-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">barrier();</span><br><span class="line">cpu_relax();</span><br><span class="line">READ_ONCE(val);</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-1-barrier">2.1.2.1 barrier</span><a href="#2-1-2-1-barrier" class="header-anchor">#</a></h4><p>前面用-O2选项顺序会被错误的排列。加入<code>barrier();//插入内存屏障</code>，再次反汇编可以看到OK符合我们的逻辑了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line"> 	barrier();<span class="comment">//插入内存屏障</span></span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反汇编如下：</span></span><br><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w2, [x0]       <span class="comment">//load b to w2</span></span><br><span class="line">    add w2, w2, #<span class="number">0x1</span></span><br><span class="line">    str w2, [x1]       <span class="comment">//a = a + 1</span></span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-2-cpu-relax">2.1.2.2 cpu_relax</span><a href="#2-1-2-2-cpu-relax" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (run)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run 是个全局变量，foo() 在一个进程中执行，一直循环。我们期望的结果是 foo() 一直等到其他进程修改 run 的值为 0 才退出循环。反汇编看看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000000748</span> &lt;foo&gt;:</span><br><span class="line"><span class="number">748</span>: <span class="number">90000080</span> adrp x0, <span class="number">10000</span></span><br><span class="line"><span class="number">74</span>c: f947e800 ldr x0, [x0, #<span class="number">4048</span>]</span><br><span class="line"><span class="number">750</span>: b9400000 ldr w0, [x0]            <span class="comment">//load run to w0</span></span><br><span class="line"><span class="number">754</span>: d503201f nop</span><br><span class="line"><span class="number">758</span>: <span class="number">35000000</span> cbnz w0, <span class="number">758</span> &lt;foo+<span class="number">0x10</span>&gt; <span class="comment">//if (w0) while (1);</span></span><br><span class="line"><span class="number">75</span>c: d65f03c0 ret</span><br></pre></td></tr></table></figure>

<p>但实际上编译器帮我们优化成了等效下面的样子：这样永远也不会退出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reg = run;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (reg)</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此加上内存屏障如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (run)</span><br><span class="line">        cpu_relax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-3-read-once">2.1.2.3 READ_ONCE()</span><a href="#2-1-2-3-read-once" class="header-anchor">#</a></h4><p>也可用这种方式作为内存屏障。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (READ_ONCE(run)) <span class="comment">/* similar to while (*(volatile int *)&amp;run) */</span></span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-yuan-zi-cao-zuo">2.2 原子操作</span><a href="#2-2-yuan-zi-cao-zuo" class="header-anchor">#</a></h2><h3><span id="2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru">2.2.0 临界区的原子操作引入</span><a href="#2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru" class="header-anchor">#</a></h3><p>所谓的临界区就是共享数据段，如全局变量，对于临界区必须保证一次只有一个线程访问，也就是要保证临 界区是原子访问的。我们都知道，原子是化学反应不可再分的基本微粒，这里的原子访问就表示这一个访问是一个步骤，不能再进行拆分。</p>
<p>示例1：</p>
<p><code>a=3;</code></p>
<p>假设变量 a 的地址为 0X3000000，“a&#x3D;3”这一行 C 语言可能会被编译为如下所示的汇编代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ldr r0, =<span class="number">0X30000000</span> <span class="comment">/* 变量 a 地址 */</span></span><br><span class="line"><span class="number">2</span> ldr r1, = <span class="number">3</span> <span class="comment">/* 要写入的值 */</span></span><br><span class="line"><span class="number">3</span> str r1, [r0] <span class="comment">/* 将 3 写入到 a 变量中 */</span></span><br></pre></td></tr></table></figure>

<p>如果多线程同时执行这条语句。我们期望的执行顺序：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/1.png" alt="image"></p>
<p>实际执行顺序可能是：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/2.png" alt="image"></p>
<p>线程 A 最终将变量 a 设置为了 20，而并不是要求的 10线程 B 没有问题，是期望的a设置成了20，这就是并发竞态。我们希望三条汇编指令一次性执行完，不被打断和拆解，这就是原子操作。</p>
<h2><span id></span><a href="#" class="header-anchor">#</a></h2><h3><span id="2-2-1-zheng-shu-yuan-zi-cao-zuo-api">2.2.1 整数原子操作API</span><a href="#2-2-1-zheng-shu-yuan-zi-cao-zuo-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br><span class="line"><span class="type">atomic_t</span> b = ATOMIC_INIT(<span class="number">0</span>); <span class="comment">//定义原子变量 b 并赋初值为 0</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;b, <span class="number">10</span>); <span class="comment">/* 设置 b=10 */</span></span><br><span class="line"><span class="type">atomic_read</span>(&amp;b); <span class="comment">/* 读取 b 的值，肯定是 10 */</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;b); <span class="comment">/* b 的值加 1，v=11 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="type">long</span> <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br><span class="line"><span class="type">atomic64_t</span> c = ATOMIC64_INIT(<span class="number">0</span>); <span class="comment">//定义64位系统原子变量 c 并赋初值为 0</span></span><br><span class="line"><span class="comment">//注意：如果使用的是64 位的 SOC，那么建议使用 64 位的原子操作函数。Cortex-A7 (armv7)是 32 位的架构，Cortex-A53（armv8）64位架构。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ATOMIC_INIT(int i)</td>
<td>定义原子变量的时候对其初始化。</td>
</tr>
<tr>
<td>int atomic_read(atomic_t *v)</td>
<td>读取 v 的值，并且返回。</td>
</tr>
<tr>
<td>void atomic_set(atomic_t *v, int i)</td>
<td>向 v 写入 i 值。</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t *v)</td>
<td>给 v 加上 i 值。</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t *v)</td>
<td>从 v 减去 i 值。</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t *v)</td>
<td>给 v 加 1，也就是自增。</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t *v)</td>
<td>从 v 减 1，也就是自减</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t *v)</td>
<td>从 v 减 1，并且返回 v 的值。</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t *v)</td>
<td>给 v 加 1，并且返回 v 的值。</td>
</tr>
<tr>
<td>atomic_add_return(int i, atomic_t *v)</td>
<td>给 v 加 i，并且返回 v 的值。</td>
</tr>
<tr>
<td>atomic_sub_return(int i, atomic_t *v)</td>
<td>给 v 减 i，并且返回 v 的值。</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t *v)</td>
<td>从 v 减 i，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t *v)</td>
<td>从 v 减 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t *v)</td>
<td>给 v 加 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_add_negative(int i, atomic_t *v)</td>
<td>给 v 加 i，如果结果为负就返回真，否则返回假</td>
</tr>
<tr>
<td>atomic_cmpxchg(atomic_t *ptr, int old, int new)</td>
<td>比较old和原子变量ptr中的值，如果相等，那么就把new值赋给原子变量。返回旧的原子变量ptr中的值</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!atomic_dec_and_test(&amp;gpioled.lock)) &#123;</span><br><span class="line">		<span class="type">atomic_inc</span>(&amp;gpioled.lock);<span class="comment">/* 小于 0 的话就加 1,使其原子变量等于 0 */</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY; <span class="comment">/* LED 被使用，返回忙 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    filp-&gt;private_data = &amp;gpioled;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关闭驱动文件的时候释放原子变量 */</span></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;dev-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 初始化原子变量 */</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;gpioled.lock, <span class="number">1</span>); <span class="comment">/* 原子变量初始值为 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子用来实现一次只能允许一个应用访问 LED 灯，不能多个进程同时操作LED。第一个用户程序进行open,成功此时原子值counter&#x3D;0，第二个用户程序进行open就会fail, 直到第一个用户程序close, counter会进行加一，此时第二个程序才可以open成功。</p>
<h3><span id="2-2-2-wei-yuan-zi-cao-zuo-api">2.2.2 位原子操作API</span><a href="#2-2-2-wei-yuan-zi-cao-zuo-api" class="header-anchor">#</a></h3><p>原 子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1。</td>
</tr>
<tr>
<td>void clear_bit(int nr,void *p)</td>
<td>将 p 地址的第 nr 位清零。</td>
</tr>
<tr>
<td>void change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位进行翻转。</td>
</tr>
<tr>
<td>int test_bit(int nr, void *p)</td>
<td>获取 p 地址的第 nr 位的值。</td>
</tr>
<tr>
<td>int test_and_set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_clear_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。</td>
</tr>
</tbody></table>
<h2><span id="2-3-zi-xuan-suo">2.3 自旋锁</span><a href="#2-3-zi-xuan-suo" class="header-anchor">#</a></h2><p>原子操作只能对整形变量或者位进行保护，但是，在实际的使用环境中怎么可能只有整形 变量或位这么简单的临界区。</p>
<p>自旋锁的定义：</p>
<p>对于自旋锁而言，如果自旋锁 正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线 程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁 可用。比如现在有个公用电话亭，一次肯定只能进去一个人打电话，现在电话亭里面有人正在 打电话，相当于获得了自旋锁。此时你到了电话亭门口，因为里面有人，所以你不能进去打电 话，相当于没有获取自旋锁，这个时候你肯定是站在原地等待，你可能因为无聊的等待而转圈 圈消遣时光，反正就是哪里也不能去，要一直等到里面的人打完电话出来。终于，里面的人打 完电话出来了，相当于释放了自旋锁，这个时候你就可以使用电话亭打电话了，相当于获取到 了自旋锁。</p>
<p> 自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以 用，可以访问共享资源。把自旋锁比作一个变量 a，变量 a&#x3D;1 的时候表示共享资源可用，当 a&#x3D;0 的时候表示共享资源不可用。现在线程 A 要访问共享资源，发现 a&#x3D;0(自旋锁被其他线程持有)， 那么线程 A 就会不断的查询 a 的值，直到 a&#x3D;1。可</p>
<p><code>缺点：获取自旋锁会原地等待，会浪费处理器时间，降低系统性能，所以自旋锁 的持有时间不能太长。如果临界区比较大，运行时间比较长的话要选择信号量和互斥体。</code></p>
<p><code>适用范围：适用于短时期的轻量级加锁。</code></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/3.png" alt="image"></p>
<h3><span id="2-3-1-zi-xuan-suo-api">2.3.1 自旋锁API</span><a href="#2-3-1-zi-xuan-suo-api" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化一个自选变量。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回 0。</td>
</tr>
</tbody></table>
<p>被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的 API 函数，否则的话会可能会导致死锁现象（不能带锁休眠）。因为自旋锁会禁止抢占，也就说当线程 A 得到锁以后会暂时禁止内核抢占，那既然禁止内核抢占自己又休眠了，粗俗的形容就是“占着茅坑不拉屎”，自己休眠了又没有释放锁就导致死锁。</p>
<h4><span id="2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan">2.3.1.1 自旋锁和中断相关</span><a href="#2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan" class="header-anchor">#</a></h4><p>中断里面访问临界资源，也是可以使用自旋锁的，但是在获取锁之前一定要先禁止本地中断。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t*lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁</td>
</tr>
</tbody></table>
<p>如下图就是没有禁止本地中断导致死锁的例子：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/4.png" alt="image"></p>
<p>线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 <code>functionA </code>函 数的时候中断发生了，中断抢走了 CPU 使用权。右边的中断服务函数也要获取 lock 这个锁， 但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 说“你先放手”，中断说“你先放手”，场面就这么僵持着， 死锁发生！</p>
<p>使用<code> spin_lock_irq/spin_unlock_irq</code> 的时候需要用户能够确定加锁之前的中断状态，但实际上我们是很难确定某个时刻的中断状态，因此不推荐使用<code> spin_lock_irq/spin_unlock_irq</code>。建议使用 <code>spin_lock_irqsave/spin_unlock_irqrestore</code>，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。一般在线程中使用<code> spin_lock_irqsave/ spin_unlock_irqrestore</code>，在中断中使用<code> spin_lock/spin_unlock</code>，例如下面：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SPINLOCK(lock);</span><br><span class="line"><span class="comment">/* 线程 A */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">functionA</span> <span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* 中断状态 */</span></span><br><span class="line">	spin_lock_irqsave(&amp;lock, flags); <span class="comment">/* 获取锁 */</span></span><br><span class="line">	<span class="comment">/* 临界区 */</span></span><br><span class="line">	spin_unlock_irqrestore(&amp;lock, flags); <span class="comment">/* 释放锁 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq</span><span class="params">()</span> &#123;</span><br><span class="line">	spin_lock(&amp;lock); <span class="comment">/* 获取锁 */</span></span><br><span class="line">	<span class="comment">/* 临界区 */</span></span><br><span class="line">	spin_unlock(&amp;lock); <span class="comment">/* 释放锁 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人说为什么中断服务程序不去使用<code>spin_lock_irqsave</code>呢？ 难道不需要去禁止中断吗？</p>
<p>因为GIC中断总入口已经帮我们做了禁止中断。调用了<code>local_irq_disable()</code>,详见<a href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/5.png" alt="image"></p>
<p>如果下半部(BH)也会竞争共享资源，要在下半部里面使用自旋锁:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，并获取自旋锁</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，并释放自旋锁</td>
</tr>
</tbody></table>
<h3><span id="2-3-2-du-xie-zi-xuan-suo">2.3.2 读写自旋锁</span><a href="#2-3-2-du-xie-zi-xuan-suo" class="header-anchor">#</a></h3><p>读写自旋锁为读和写操作提供了不同的锁，一次只能允许一个写操作，也就是只能一个线程持有写锁，而且不能进行读操作。但是当没有写操作的时候允许一个或多个线程持有读锁， 可以进行并发的读操作。Linux 内核使用 rwlock_t 结构体表示读写锁，结构体定义如下(删除了 条件编译)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="type">arch_rwlock_t</span> raw_lock;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>现在有个学生信息表，此表存放着学生的年龄、家庭住址、班级等信息，此表可以随时被 修改和读取，那么必须要对其进行保护，如果我们现在使用自旋锁对其进行 保护。每次只能一个读操作或者写操作，但是，实际上此表是可以并发读取的。只需要保证在 修改此表的时候没人读取，或者在其他人读取此表的时候没有人修改此表就行了。也就是此表 的读和写不能同时进行，但是可以多人并发的读取此表。像这样，当某个数据结构符合读&#x2F;写或 生产者&#x2F;消费者模型的时候就可以使用读写自旋锁。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_RWLOCK(rwlock_t lock)</td>
<td>定义并初始化读写锁</td>
</tr>
<tr>
<td>void rwlock_init(rwlock_t *lock)</td>
<td>初始化读写锁。</td>
</tr>
<tr>
<td>读操作</td>
<td></td>
</tr>
<tr>
<td>void read_lock(rwlock_t *lock)</td>
<td>获取读锁。</td>
</tr>
<tr>
<td>void read_unlock(rwlock_t *lock)</td>
<td>释放读锁。</td>
</tr>
<tr>
<td>void read_lock_irq(rwlock_t *lock)</td>
<td>禁止本地中断，并且获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_irq(rwlock_t *lock)</td>
<td>打开本地中断，并且释放读锁。</td>
</tr>
<tr>
<td>void read_lock_irqsave(rwlock_t *lock, unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_irqrestore(rwlock_t *lock,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放读锁。</td>
</tr>
<tr>
<td>void read_lock_bh(rwlock_t *lock)</td>
<td>关闭下半部，并获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_bh(rwlock_t *lock)</td>
<td>打开下半部，并释放读锁。</td>
</tr>
<tr>
<td>写操作</td>
<td></td>
</tr>
<tr>
<td>void write_lock(rwlock_t *lock)</td>
<td>获取写锁。</td>
</tr>
<tr>
<td>void write_unlock(rwlock_t *lock)</td>
<td>释放写锁。</td>
</tr>
<tr>
<td>void write_lock_irq(rwlock_t *lock)</td>
<td>禁止本地中断，并且获取写锁。</td>
</tr>
<tr>
<td>void write_unlock_irq(rwlock_t *lock)</td>
<td>打开本地中断，并且释放写锁。</td>
</tr>
<tr>
<td>void write_lock_irqsave(rwlock_t *lock,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取写锁</td>
</tr>
<tr>
<td>void write_unlock_irqrestore(rwlock_t *lock,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放读锁。</td>
</tr>
<tr>
<td>void write_lock_bh(rwlock_t *lock)</td>
<td>关闭下半部，并获取读锁。</td>
</tr>
<tr>
<td>void write_unlock_bh(rwlock_t *lock)</td>
<td>打开下半部，并释放读锁。</td>
</tr>
</tbody></table>
<h3><span id="2-3-3-shun-xu-suo">2.3.3 顺序锁</span><a href="#2-3-3-shun-xu-suo" class="header-anchor">#</a></h3><p>顺序锁在读写锁的基础上衍生而来的，使用读写锁的时候读操作和写操作不能同时进行。使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 		<span class="class"><span class="keyword">struct</span> <span class="title">seqcount</span> <span class="title">seqcount</span>;</span></span><br><span class="line"> 		<span class="type">spinlock_t</span> lock;</span><br><span class="line">&#125; <span class="type">seqlock_t</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEQLOCK(seqlock_t sl)</td>
<td>定义并初始化顺序锁</td>
</tr>
<tr>
<td>void seqlock_ini seqlock_t *sl)</td>
<td>初始化顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock(seqlock_t *sl)</td>
<td>获取写顺序锁。</td>
</tr>
<tr>
<td>void write_sequnlock(seqlock_t *sl)</td>
<td>释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_irq(seqlock_t *sl)</td>
<td>禁止本地中断，并且获取写顺序锁</td>
</tr>
<tr>
<td>void write_sequnlock_irq(seqlock_t *sl)</td>
<td>打开本地中断，并且释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_irqsave(seqlock_t *sl,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取写顺序锁。</td>
</tr>
<tr>
<td>void write_sequnlock_irqrestore(seqlock_t *sl,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_bh(seqlock_t *sl)</td>
<td>关闭下半部，并获取写读锁。</td>
</tr>
<tr>
<td>void write_sequnlock_bh(seqlock_t *sl)</td>
<td>打开下半部，并释放写读锁。</td>
</tr>
<tr>
<td>unsigned read_seqbegin(const seqlock_t *sl)</td>
<td>读单元访问共享资源的时候调用此函数，此函数会返回顺序锁的顺序号。</td>
</tr>
<tr>
<td>unsigned read_seqretry(const seqlock_t *sl,unsigned start)</td>
<td>读结束以后调用此函数检查在读的过程中有没有对资源进行写操作，如果有的话就要重读</td>
</tr>
</tbody></table>
<h2><span id="2-4-xin-hao-liang">2.4 信号量</span><a href="#2-4-xin-hao-liang" class="header-anchor">#</a></h2><p>相比于自旋锁，信号量可以使线程进入休眠状态，比如 A 与 B、C 合租了一套房子，这个 房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕 所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着， 等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继 续回房间睡觉，这个时候相当于信号量。可以看出，使用信号量会提高处理器的使用效率，毕 竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使 线程进入休眠状态以后会切换线程，切换线程就会有开销。</p>
<p>信号量的特点： </p>
<p><code>适用于那些占用资源比较久的场合，如线程同步。</code></p>
<p><code>因此信号量等待不能用于中断中，因为中断不能休眠。</code></p>
<h3><span id="2-4-1-xin-hao-liang-api">2.4.1 信号量 API</span><a href="#2-4-1-xin-hao-liang-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	 <span class="type">raw_spinlock_t</span> lock;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td>定义一个信号量，并且设置信号量的值为 1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量 sem，设置信号量值为 val。</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td>获取信号量，因为会导致休眠，因此不能在中断中使用。</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem);</td>
<td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0，并且不会进入休眠。</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td>获取信号量，和 down 类似，只是使用 down 进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的。</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td>释放信号量</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span> <span class="comment">/* 定义信号量 */</span></span><br><span class="line">sema_init(&amp;sem, <span class="number">1</span>); <span class="comment">/* 初始化信号量 */</span></span><br><span class="line">threadA()&#123;</span><br><span class="line">    down(&amp;sem); <span class="comment">/* 申请信号量 */</span></span><br><span class="line">&#125;</span><br><span class="line">theadB()&#123;</span><br><span class="line">    up(&amp;sem); <span class="comment">/* 释放信号量 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-5-hu-chi-suo">2.5 互斥锁</span><a href="#2-5-hu-chi-suo" class="header-anchor">#</a></h2><p>将信号量的值设置为 1 就可以使用信号量进行互斥访问了，虽然可以通过信号量实现互斥，但是 Linux 提供了一个比信号量更专业的机制来进行互斥，它就是互斥体—mutex。互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">	 <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line"> 	<span class="type">atomic_t</span> count;</span><br><span class="line">	 <span class="type">spinlock_t</span> wait_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 mutex 的时候要注意如下几点：</p>
<p><code>1. mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁。</code> </p>
<p><code>2. 和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</code></p>
<p><code> 3. 因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁。</code></p>
<h3><span id="2-5-1-hu-chi-suo-api">2.5.1 互斥锁API</span><a href="#2-5-1-hu-chi-suo-api" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name)</td>
<td>定义并初始化一个 mutex 变量。</td>
</tr>
<tr>
<td>void mutex_init(mutex *lock)</td>
<td>初始化 mutex。</td>
</tr>
<tr>
<td>void mutex_lock(struct mutex *lock)</td>
<td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td>void mutex_unlock(struct mutex *lock)</td>
<td>释放 mutex，也就给 mutex 解锁。</td>
</tr>
<tr>
<td>int mutex_trylock(struct mutex *lock)</td>
<td>尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。</td>
</tr>
<tr>
<td>int mutex_is_locked(struct mutex *lock)</td>
<td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td>
</tr>
<tr>
<td>int mutex_lock_interruptible(struct mutex *lock)</td>
<td>使用此函数获取信号量失败进入休眠以后可以被信号打断</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 定义一个互斥体 */</span></span><br><span class="line">mutex_init(&amp;lock); <span class="comment">/* 初始化互斥体 */</span></span><br><span class="line">mutex_lock(&amp;lock); <span class="comment">/* 上锁 */</span></span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">mutex_unlock(&amp;lock); <span class="comment">/* 解锁 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi">2.6 SMP 架构下percpu变量机制</span><a href="#2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi" class="header-anchor">#</a></h2><p>随着 SMP(对称多处理器架构) 的发展，程序确实是在并发执行，也为数据同步带来了更大的挑战。</p>
<p>在 SMP 架构中，每个 CPU 都拥有自己的高速缓存，通常，L1 cache 是 CPU 独占的，每个 CPU 都有一份，它的速度自然是最快的，而 L2 cache 通常是所有 CPU 共享的高速缓存，当 CPU 载入一个全局数据时，会逐级地查看高速缓存，如果没有在缓存中命中，就从内存中载入，并加入到各级 cache 中，当下次需要读取这个值时，直接读取 cache 。</p>
<p>假如进程在 CPU0 上操作一个共享变量，在某个时刻进程被调度到 CPU1 上执行时，CPU0 和 CPU1 上的 共享变量值就不同。</p>
<p><strong>percpu机制</strong>：为了避免多个 CPU 对全局数据的竞争而导致的性能损失，<strong>percpu 直接为每个 CPU 生成一份独有的数据备份，每个数据备份占用独立的内存</strong>，CPU 不应该修改不属于自己的这部分数据，这样就避免了多 CPU 对全局数据的竞争问题。</p>
<h3><span id="2-6-0-percpu-bian-liang-de-cun-chu-ge-shi">2.6.0 percpu 变量的存储格式</span><a href="#2-6-0-percpu-bian-liang-de-cun-chu-ge-shi" class="header-anchor">#</a></h3><p>对于普通的变量而言，变量的加载地址就是程序中使用的该变量的地址，可以使用取址符获取变量地址。</p>
<p><strong>percpu 变量</strong>：percpu 变量的加载地址是不允许访问的，取而代之的是对于 n 核的 SMP 架构系统，内核将会为每一个 CPU 另行开辟一片内存，将该 percpu 变量复制 n 份分别放在每个 CPU 独有的内存区中。</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/6.png" alt="image"></p>
<p>也就是说，为 percpu 分配内存的时候，原始的变量 var 与 percpu 变量内存偏移值 offset 被保存了下来，每个 CPU 对应的 percpu 变量地址为 <code>(&amp;var + offset)</code>，当然真实情况要比这个复杂，将在后文中讲解。</p>
<h3><span id="2-6-1-percpu-bian-liang-shi-yong-chang-jing">2.6.1 percpu变量使用场景</span><a href="#2-6-1-percpu-bian-liang-shi-yong-chang-jing" class="header-anchor">#</a></h3><ol>
<li>计数器和统计信息：如果你有计数器或者统计信息需要在每个CPU上独立维护，那么<code>percpu</code>变量将会非常有用。</li>
<li>异步任务处理：通过<code>percpu</code>变量来维护异步任务的上下文信息。</li>
</ol>
<h3><span id="2-6-2-percpu-bian-liang-de-ding-yi">2.6.2 percpu 变量的定义</span><a href="#2-6-2-percpu-bian-liang-de-ding-yi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_PER_CPU(type, name);<span class="comment">//静态定义一个 percpu变量，type 是变量类型，name 是变量名</span></span><br><span class="line"></span><br><span class="line">type __percpu *ptr <span class="title function_">alloc_percpu</span><span class="params">(type)</span>;<span class="comment">//动态分配一个percpu变量ptr,这只是一个原始数据，真正被使用的数据被 copy 成 n(n=CPU数量) 份分别保存在每个 CPU 独占的地址空间中，在访问 percpu 变量时就是对每个副本进行访问。</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-6-3-percpu-bian-liang-de-du-xie">2.6.3 percpu 变量的读写</span><a href="#2-6-3-percpu-bian-liang-de-du-xie" class="header-anchor">#</a></h3><p><strong>静态定义的读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_PER_CPU(<span class="type">int</span>, val)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前CPU的percpu变量的值</span></span><br><span class="line"><span class="type">int</span> value = per_cpu(val, smp_processor_id());</span><br><span class="line"><span class="comment">// 遍历所有CPU，并打印percpu变量的值</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line">    value = per_cpu(val, cpu);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_percpu_var on CPU%d is %d\n&quot;</span>, cpu, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*put_cpu_var 和 get_cpu_var 是成对出现的,因为这段期间内静止内核抢占，</span></span><br><span class="line"><span class="comment"> *它们之间的代码不宜执行太长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> *pint = &amp;get_cpu_var(val);<span class="comment">//获取当前 CPU 的 percpu 变量的地址进行操作</span></span><br><span class="line">*pint++;</span><br><span class="line">put_cpu_var(val);</span><br></pre></td></tr></table></figure>

<p>为什么在调用 <code>get_cpu_var </code>时，第一步是禁止内核抢占呢?</p>
<p>想想这样一个场景，进程 A 在 CPU0 上执行，读取了 percpu 变量到寄存器中，这时候进程被高优先级进程抢占，继续执行的时候可能被转移到 CPU1 上执行，这时候在 CPU1 执行的代码操作的仍旧是 CPU0 上的 percpu 变量，这显然是错误的。</p>
<p><strong>动态定义的读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pint = alloc_percpu(<span class="type">int</span>);</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> *p = per_cpu_ptr(pint,raw_smp_processor_id());<span class="comment">//与静态变量的操作接口不一样，这个接口允许指定 CPU ，不再是只能获取当前 CPU 的值</span></span><br><span class="line">(*p)++;</span><br></pre></td></tr></table></figure>

<p><code>raw_smp_processor_id() </code>函数返回<code>当前 CPU num</code>，这个示例也就是操作当前 CPU 的 percpu 变量，这个接口<strong>并不需要禁止内核抢占</strong>，因为不管进程被切换到哪个 CPU 上执行，它所操作的都是第二个参数提供的 CPU。</p>
<h3><span id="2-6-4-percpu-bian-liang-shi-xian-yuan-li">2.6.4 percpu 变量实现原理</span><a href="#2-6-4-percpu-bian-liang-shi-xian-yuan-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU(type, name)                  \</span></span><br><span class="line"><span class="meta">    DEFINE_PER_CPU_SECTION(type, name, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU_SECTION(type, name, sec)             \</span></span><br><span class="line"><span class="meta">    __PCPU_ATTRS(sec) PER_CPU_DEF_ATTRIBUTES            \</span></span><br><span class="line"><span class="meta">    __typeof__(type) name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PCPU_ATTRS(sec)                       \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(PER_CPU_BASE_SECTION sec))) \</span></span><br><span class="line"><span class="meta">    PER_CPU_ATTRIBUTES</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> PER_CPU_BASE_SECTION <span class="string">&quot;.data..percpu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> PER_CPU_BASE_SECTION <span class="string">&quot;.data&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>展开：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU(type, name)                  \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(<span class="string">&quot;.data..percpu&quot;</span>))) type name;  \ </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(<span class="string">&quot;.data&quot;</span>))) type name; \</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>在 SMP 架构下，被定义的 percpu 变量在编译后放在<code> .data..percpu</code> 这个 section 中;</li>
<li>在单核系统中， percpu 变量被放在<code>.data</code>也就是数据段中;</li>
</ol>
<h4><span id="2-6-4-1-get-cpu-var-shi-xian">2.6.4.1 get_cpu_var实现</span><a href="#2-6-4-1-get-cpu-var-shi-xian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_cpu_var(var)                    \</span></span><br><span class="line"><span class="meta">(*(&#123;                                        \</span></span><br><span class="line"><span class="meta">    preempt_disable();                      \</span></span><br><span class="line"><span class="meta">    this_cpu_ptr(&amp;var);                     \</span></span><br><span class="line"><span class="meta">&#125;))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> this_cpu_ptr(ptr) raw_cpu_ptr(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_cpu_ptr(ptr)                        \</span></span><br><span class="line"><span class="meta">(&#123;                                              \</span></span><br><span class="line"><span class="meta">    __verify_pcpu_ptr(ptr);                     \</span></span><br><span class="line"><span class="meta">    arch_raw_cpu_ptr(ptr);                      \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>首先，<code>preempt_disable </code>禁用内核抢占，然后使用 <code>this_cpu_ptr </code>接口获取当前 cpu 上对应的 var 变量地址。</p>
<p>对<code>get_cpu_var</code>展开：可以看到就能准确获取当前cpu的val地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_cpu_var(var)                    \</span></span><br><span class="line"><span class="meta">(*(&#123;                                        \</span></span><br><span class="line"><span class="meta">    preempt_disable();                      \</span></span><br><span class="line"><span class="meta">    &amp;var + __per_cpu_offset[raw_smp_processor_id()]  \</span></span><br><span class="line"><span class="meta">&#125;))</span></span><br></pre></td></tr></table></figure>

<p>使用完变量之后记得调用 <code>put_cpu_var</code> 以使能内核抢占功能，恢复系统状态。</p>
<h1><span id="3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing">3 linux内核下不同同步机制的适用场景</span><a href="#3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing" class="header-anchor">#</a></h1><ol>
<li>原子操作：主要用于进行原子性的读写操作，适用于计数器等场景。</li>
<li>自旋锁：用于短时间内锁定互斥资源，适用于锁持有时间短的场景。</li>
<li>读写锁：用于提供读模式和写模式下的锁操作，适用于读多写少的场景。</li>
<li>MUTEX：类似自旋锁，但是可以导致调用线程睡眠，适用于锁持有时间较长的场景。(允许休眠)</li>
<li>信号量：用于实现互斥和同步，适用于保护临界区和控制访问频率。但是可以导致调用线程睡眠，适用于锁持有时间较长的场景。（允许休眠）</li>
</ol>
]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C-SMBus协议和I2C Tool</title>
    <url>/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-smbus-xie-yi">1 SMBus协议</a><ul>
<li><a href="#1-1-smbus-shi-i2c-xie-yi-de-yi-ge-zi-ji">1.1 SMBus 是 I2C 协议的一个子集</a></li>
<li><a href="#1-2-he-i2c-xie-yi-te-xing-dui-bi">1.2 和I2C协议特性对比</a></li>
<li><a href="#1-3-smbus-shu-ju-ge-shi">1.3 SMBus数据格式</a><ul>
<li><a href="#1-3-1-smbus-quick-command">1.3.1 SMBus Quick Command</a></li>
<li><a href="#1-3-2-smbus-receive-byte">1.3.2 SMBus Receive Byte</a></li>
<li><a href="#1-3-3-smbus-send-byte">1.3.3 SMBus Send Byte</a></li>
<li><a href="#1-3-4-smbus-read-byte">1.3.4 SMBus Read Byte</a></li>
<li><a href="#1-3-5-smbus-read-word">1.3.5 SMBus Read Word</a></li>
<li><a href="#1-3-6-smbus-write-byte">1.3.6 SMBus Write Byte</a></li>
<li><a href="#1-3-7-smbus-write-word">1.3.7 SMBus Write Word</a></li>
<li><a href="#1-3-8-smbus-block-read">1.3.8 SMBus Block Read</a></li>
<li><a href="#1-3-8-smbus-block-write">1.3.8 SMBus Block Write</a></li>
<li><a href="#1-3-9-smbus-block-write-block-read-process-call">1.3.9 SMBus Block Write - Block Read Process Call</a></li>
<li><a href="#1-3-10-packet-error-checking-pec">1.3.10 Packet Error Checking (PEC)</a></li>
</ul>
</li>
<li><a href="#1-4-i2c-shu-ju-ge-shi">1.4 I2C数据格式</a><ul>
<li><a href="#1-4-1-i2c-block-read">1.4.1 I2C Block Read</a></li>
<li><a href="#1-4-2-i2c-block-write">1.4.2 I2C Block Write</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-i2c-tools">2 I2C Tools</a><ul>
<li><a href="#2-1-i2c-kong-zhi-qi-kuang-jia">2.1 I2C控制器框架</a></li>
<li><a href="#2-2-i2c-shu-ju-jie-gou">2.2 i2c数据结构</a><ul>
<li><a href="#2-2-1-i2c-adapter">2.2.1 i2c_adapter</a></li>
<li><a href="#2-2-3-i2c-algorithm">2.2.3 i2c_algorithm</a></li>
<li><a href="#2-3-4-i2c-device-i2c-client">2.3.4 I2c_device&#x2F;I2c_client</a></li>
<li><a href="#2-3-5-i2c-msg">2.3.5 i2c_msg</a></li>
</ul>
</li>
<li><a href="#2-3-i2c-tools-yi-zhi">2.3 I2C-Tools移植</a><ul>
<li><a href="#2-3-1-yuan-ma-xia-zai">2.3.1 源码下载</a></li>
<li><a href="#2-3-2-gong-ju-lian-pei-zhi">2.3.2 工具链配置</a></li>
<li><a href="#2-3-3-bian-yi">2.3.3 编译</a></li>
</ul>
</li>
<li><a href="#2-4-i2c-tools-shi-yong">2.4 I2C Tools使用</a><ul>
<li><a href="#2-4-1-i2cdetect-i2c-jian-ce">2.4.1 i2cdetect: I2C 检测</a></li>
<li><a href="#2-4-2-i2cget-i2c-du-smbus-xie-yi">2.4.2 i2cget:  I2C 读（SMBus协议）</a></li>
<li><a href="#2-4-3-i2cset-i2c-xie-smbus-xie-yi">2.4.3 i2cset: I2C 写（SMBus协议）</a></li>
<li><a href="#2-4-4-i2ctransfer-i2c-chuan-shu-i2c-xie-yi">2.4.4 i2ctransfer：I2C传输（I2C协议）</a></li>
</ul>
</li>
<li><a href="#2-5-i2c-tools-fang-wen-i2c-she-bei-de-fang-shi">2.5 I2C-Tools 访问 I2C 设备的方式</a><ul>
<li><a href="#2-5-1-shu-ju-chuan-shu-fang-shi">2.5.1 数据传输方式</a><ul>
<li><a href="#2-5-1-1-shi-yong-i2c-fang-shi">2.5.1.1 使用I2C方式</a></li>
<li><a href="#2-5-1-2-shi-yong-smbus-fang-shi">2.5.1.2 使用SMBus方式</a></li>
<li><a href="#2-5-1-3-zhi-jie-shi-yong-read-write-fang-shi">2.5.1.3 直接使用read()&#x2F;write()方式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-smbus-xie-yi">1 SMBus协议</span><a href="#1-smbus-xie-yi" class="header-anchor">#</a></h1><h2><span id="1-1-smbus-shi-i2c-xie-yi-de-yi-ge-zi-ji">1.1 SMBus 是 I2C 协议的一个子集</span><a href="#1-1-smbus-shi-i2c-xie-yi-de-yi-ge-zi-ji" class="header-anchor">#</a></h2><p>SMBus: System Management Bus，系统管理总线。SMBus 最初的目的是为智能电池、充电电池、其他微控制器之间的通信链路而定义的。SMBus 也被用来连接各种设备，包括电源相关设备，系统传感器，EEPROM 通讯设备等等。SMBus 为系统和电源管理这样的任务提供了一条控制总线，使用 SMBus 的系 统，设备之间发送和接收消息都是通过 SMBus，而不是使用单独的控制线，这样可以节省设备的管脚数。</p>
<p>SMBus 是基于 I2C 协议的，SMBus 要求更严格，SMBus 是 I2C 协议的子集。</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/1.png" alt="img"></p>
<h2><span id="1-2-he-i2c-xie-yi-te-xing-dui-bi">1.2 和I2C协议特性对比</span><a href="#1-2-he-i2c-xie-yi-te-xing-dui-bi" class="header-anchor">#</a></h2><p>SMBus 有哪些更严格的要求？跟一般的 I2C 协议有哪些差别？</p>
<ol>
<li>VDD 的极限值不一样<br>　　1.1 I2C 协议：范围很广，甚至讨论了高达 12V 的情况<br>　　　　　　　　　　　　　　　　1.2 SMBus：1.8V~5V</li>
<li>速率更高<br>　　I2C 协议：时钟频率最小值无限制，Clock Stretching 时长也没有限制<br>　　　　　　　　　　　　　　　　SMBus：时钟频率最小值是 10KHz，Clock Stretching 的最大时间值也有限制</li>
<li>地址回应(Address Acknowledge)：一个 I2C 设备接收到它的设备地址后， 是否必须发出回应信号？<br>　　I2C 协议：没有强制要求必须发出回应信号<br>　　　　　　　　　　　　　　　　SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态： busy，failed，或是被移除了</li>
<li>SMBus 协议明确了数据的传输格式<br>　　I2C 协议：它只定义了怎么传输数据，但是并没有定义数据的格式，这完全由设备来定义<br>　　　　　　　　　　　　　　　　SMBus：定义了几种数据格式</li>
<li><code>REPEATED START Condition(重复发出 S 信号)</code><br>　　比如读 EEPROM 时，涉及 2 个操作：<br>　　　　　　　　　　　　　　​	 把存储地址发给设备<br>　　　　　　　　　　　　　　​	 读数据<br>　　　　　　　　　　　　　　在写、读之间，可以不发出 P 信号，而是直接发出 S 信号：这个 S 信号就是<br>　　　　　　　　　　　　　　<code>REPEATED START</code></li>
</ol>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/2.png" alt="img"></p>
<h2><span id="1-3-smbus-shu-ju-ge-shi">1.3 SMBus数据格式</span><a href="#1-3-smbus-shu-ju-ge-shi" class="header-anchor">#</a></h2><p>下面文档中的 Functionality flag 是 Linux 的某个 I2C 控制器驱动所支持的功能。比如 Functionality flag: I2C_FUNC_SMBUS_QUICK，表示需要I2C 控制器支持 SMBus Quick Command。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">symbols(符号)：</span><br><span class="line">S (<span class="number">1</span> bit) : Start <span class="title function_">bit</span><span class="params">(开始位)</span></span><br><span class="line">　<span class="title function_">Sr</span> <span class="params">(<span class="number">1</span> bit)</span> : 重复的开始位</span><br><span class="line">　<span class="title function_">P</span> <span class="params">(<span class="number">1</span> bit)</span> : Stop <span class="title function_">bit</span><span class="params">(停止位)</span></span><br><span class="line">　R/W# <span class="params">(<span class="number">1</span> bit)</span> : Read/Write bit. Rd equals 1, Wr equals 0.<span class="params">(读写位)</span></span><br><span class="line">　A, <span class="title function_">N</span> <span class="params">(<span class="number">1</span> bit)</span> : Accept and reverse accept bit.<span class="params">(回应位)</span></span><br><span class="line">　<span class="title function_">Address</span><span class="params">(<span class="number">7</span> bits)</span>: I2C 7 bit address. Note that this can be expanded as usual to get a 10 bit I2C address.<span class="params">(地址位，<span class="number">7</span> 位地址)</span></span><br><span class="line">　Command <span class="title function_">Code</span> <span class="params">(<span class="number">8</span> bits)</span>: Command byte, a data byte which often selects a <span class="keyword">register</span> on the device.<span class="params">(命令字节，一般用来选择芯片内部的寄存器)</span></span><br><span class="line">  Data <span class="title function_">Byte</span> <span class="params">(<span class="number">8</span> bits)</span>: A plain data byte. Sometimes, I write DataLow, DataHigh <span class="keyword">for</span> 16 bit data.<span class="params">(数据字节，<span class="number">8</span> 位；如果是 <span class="number">16</span> 位数据的话，用 <span class="number">2</span> 个字节来表示：DataLow、DataHigh)</span></span><br><span class="line">　<span class="title function_">Count</span> <span class="params">(<span class="number">8</span> bits)</span>: A data byte containing the length of a block operation.<span class="params">(在 block 操作总，表示数据长度)</span></span><br><span class="line">　[..]: Data sent by I2C device, as opposed to data sent by the host adapter.<span class="params">(中括号表示 I2C 设备发送的数据，没有中括号表示 host adapter 发送的数据)</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-3-1-smbus-quick-command">1.3.1 SMBus Quick Command</span><a href="#1-3-1-smbus-quick-command" class="header-anchor">#</a></h3><p>只是用来发送一位数据：R&#x2F;W#本意是用来表示读或写，但是在 SMBus 里可以用来表示其他含义。比如某些开关设备，可以根据这一位来决定是打开还是关闭.</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/3.png" alt="img"></p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_QUICK</strong></p>
<h3><span id="1-3-2-smbus-receive-byte">1.3.2 SMBus Receive Byte</span><a href="#1-3-2-smbus-receive-byte" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/4.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_byte()</code>。读取一个字节，Host adapter 接收到一个字节后不需要发出回应信号(上图中 N 表示不回应)。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_BYTE</strong></p>
<h3><span id="1-3-3-smbus-send-byte">1.3.3 SMBus Send Byte</span><a href="#1-3-3-smbus-send-byte" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/5.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_byte()</code>。发送一个字节。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_BYTE</strong></p>
<h3><span id="1-3-4-smbus-read-byte">1.3.4 SMBus Read Byte</span><a href="#1-3-4-smbus-read-byte" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/6.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_byte_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再读取一个字节的数据。上面介绍的 SMBus Receive Byte 是不发送 Comand，直接读取数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_READ_BYTE_DATA</strong></p>
<h3><span id="1-3-5-smbus-read-word">1.3.5 SMBus Read Word</span><a href="#1-3-5-smbus-read-word" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/7.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_word_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再读取 2 个字节的数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_READ_WORD_DATA</strong></p>
<h3><span id="1-3-6-smbus-write-byte">1.3.6 SMBus Write Byte</span><a href="#1-3-6-smbus-write-byte" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/8.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_byte_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_BYTE_DATA</strong></p>
<h3><span id="1-3-7-smbus-write-word">1.3.7 SMBus Write Word</span><a href="#1-3-7-smbus-write-word" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/9.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_word_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_WORD_DATA</strong></p>
<h3><span id="1-3-8-smbus-block-read">1.3.8 SMBus Block Read</span><a href="#1-3-8-smbus-block-read" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/10.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_block_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发起度操作：</p>
<p>　　1. 先读到一个字节(Block Count)，表示后续要读的字节数<br>　　1.  然后读取全部数据</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_READ_BLOCK_DATA</strong></p>
<h3><span id="1-3-8-smbus-block-write">1.3.8 SMBus Block Write</span><a href="#1-3-8-smbus-block-write" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/11.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_block_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的 Byte Conut(表示后续要发出的数据字节数)，最后发出全部数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_BLOCK_DATA</strong></p>
<h3><span id="1-3-9-smbus-block-write-block-read-process-call">1.3.9 SMBus Block Write - Block Read Process Call</span><a href="#1-3-9-smbus-block-write-block-read-process-call" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/12.png" alt="img"></p>
<p>先写一块数据，再读一块数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_BLOCK_PROC_CALL</strong></p>
<h3><span id="1-3-10-packet-error-checking-pec">1.3.10 Packet Error Checking (PEC)</span><a href="#1-3-10-packet-error-checking-pec" class="header-anchor">#</a></h3><p>PEC 是一种错误校验码，如果使用 PEC，那么在 P 信号之前，数据发送方要发送一个字节的 PEC 码(它是 CRC-8 码)。以 SMBus Send Byte 为例，下图中，一个未使用 PEC，另一个使用 PEC：(一般很少使用)</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/13.png" alt="img"></p>
<h2><span id="1-4-i2c-shu-ju-ge-shi">1.4 I2C数据格式</span><a href="#1-4-i2c-shu-ju-ge-shi" class="header-anchor">#</a></h2><h3><span id="1-4-1-i2c-block-read">1.4.1 I2C Block Read</span><a href="#1-4-1-i2c-block-read" class="header-anchor">#</a></h3><p>在一般的 I2C 协议中，也可以连续读出多个字节。它跟 SMBus Block Read 的差别在于设备发出的第 1 个数据不是长度 N，如下图所示：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/14.png" alt="img"></p>
<p>I2C-tools 中的函数：&#96;i2c_smbus_read_i2c_block_data()。先发出 Command Code(它一般表示芯片内部的寄存器地址)，直接读出全部数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_READ_I2C_BLOCK</strong></p>
<h3><span id="1-4-2-i2c-block-write">1.4.2 I2C Block Write</span><a href="#1-4-2-i2c-block-write" class="header-anchor">#</a></h3><p>在一般的 I2C 协议中，也可以连续发出多个字节。它跟 SMBus Block Write 的差别在于发出的第 1 个数据不是长度 N，如下图所示：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/15.png" alt="img"></p>
<p>I2C-tools 中的函数：i2c_smbus_write_i2c_block_data()。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的 data，最后发出全部数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_I2C_BLOCK</strong></p>
<h1><span id="2-i2c-tools">2 I2C Tools</span><a href="#2-i2c-tools" class="header-anchor">#</a></h1><h2><span id="2-1-i2c-kong-zhi-qi-kuang-jia">2.1 I2C控制器框架</span><a href="#2-1-i2c-kong-zhi-qi-kuang-jia" class="header-anchor">#</a></h2><p>APP 访问硬件肯定是需要驱动程序的，对于 I2C 设备，linux内核提供了默认的驱动程序 drivers&#x2F;i2c&#x2F;i2c-dev.c，通过它可以直接使用下面的 I2C 控制器驱动程序来 访问 I2C 设备。</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/16.png" alt="img"></p>
<h2><span id="2-2-i2c-shu-ju-jie-gou">2.2 i2c数据结构</span><a href="#2-2-i2c-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="2-2-1-i2c-adapter">2.2.1 i2c_adapter</span><a href="#2-2-1-i2c-adapter" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/17.png" alt="img"></p>
<p>i2c_adapter 表示一个 I2C BUS，或称为 I2C Controller，里面有 2 个重要的成员：</p>
<ol>
<li>nr：第几个 I2C BUS(I2C Controller)</li>
<li>i2c_algorithm，里面有该 I2C BUS 的传输函数，用来收发 I2C 数据</li>
</ol>
<p>怎么表示 I2C Controller , 一个芯片里可能有多个 I2C Controller，比如第 0 个、第 1 个、……</p>
<h3><span id="2-2-3-i2c-algorithm">2.2.3 i2c_algorithm</span><a href="#2-2-3-i2c-algorithm" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/18.png" alt="img"></p>
<h3><span id="2-3-4-i2c-device-x2f-i2c-client">2.3.4 I2c_device&#x2F;I2c_client</span><a href="#2-3-4-i2c-device-x2f-i2c-client" class="header-anchor">#</a></h3><p>一个 I2C Device，一定有设备地址， 那它连接在哪个 I2C Controller 上，即对应的 i2c_adapter 是什么。</p>
<p>使用 i2c_client 来表示一个 I2C Device。</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/19.png" alt="img"></p>
<h3><span id="2-3-5-i2c-msg">2.3.5 i2c_msg</span><a href="#2-3-5-i2c-msg" class="header-anchor">#</a></h3><p>在上面的i2c_algorithm结构体中可以看到要传输的数据被称为：i2c_msg</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/20.png" alt="img"></p>
<p>flags： 用来表示传输方向：bit 0 等于 I2C_M_RD 表示 读，bit 0 等于 0 表示写。一个 i2c_msg 要么是读，要么是写<br>举例：设备地址为 0x50 的 EEPROM，要读取它里面存储地址为 0x10 的一个字节， 应该构造几个 i2c_msg？<br>要构造 2 个 i2c_msg :</p>
<ol>
<li><p>第一个 i2c_msg 表示写操作，把要访问的存储地址 0x10 发给设备</p>
</li>
<li><p>第二个 i2c_msg 表示读操作,并且返回读出的数据</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　　<span class="comment">//例如：</span></span><br><span class="line">　　u8 data_addr = <span class="number">0x10</span>;</span><br><span class="line">　　i8 data;</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[2];</span></span><br><span class="line">　　</span><br><span class="line">　　msgs[<span class="number">0</span>].addr = <span class="number">0x50</span>;</span><br><span class="line">　　msgs[<span class="number">0</span>].flags = <span class="number">0</span>;</span><br><span class="line">　　msgs[<span class="number">0</span>].len = <span class="number">1</span>;</span><br><span class="line">　　msgs[<span class="number">0</span>].buf = &amp;data_addr;</span><br><span class="line">　　msgs[<span class="number">1</span>].addr = <span class="number">0x50</span>;</span><br><span class="line">　　msgs[<span class="number">1</span>].flags = I2C_M_RD;</span><br><span class="line">　　msgs[<span class="number">1</span>].len = <span class="number">1</span>;</span><br><span class="line">　　msgs[<span class="number">1</span>].buf = &amp;data;</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-i2c-tools-yi-zhi">2.3 I2C-Tools移植</span><a href="#2-3-i2c-tools-yi-zhi" class="header-anchor">#</a></h2><h3><span id="2-3-1-yuan-ma-xia-zai">2.3.1 源码下载</span><a href="#2-3-1-yuan-ma-xia-zai" class="header-anchor">#</a></h3><p><a href="https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/">https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/</a></p>
<h3><span id="2-3-2-gong-ju-lian-pei-zhi">2.3.2 工具链配置</span><a href="#2-3-2-gong-ju-lian-pei-zhi" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueab ihf_sdk-buildroot/bin</span><br></pre></td></tr></table></figure>

<h3><span id="2-3-3-bian-yi">2.3.3 编译</span><a href="#2-3-3-bian-yi" class="header-anchor">#</a></h3><p>修改 I2C-Tools 的 Makefile 指定交叉编译工具链</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC ?= gcc</span><br><span class="line">AR ?= ar</span><br><span class="line">STRIP ?= strip</span><br></pre></td></tr></table></figure>

<p>改为(指定交叉编译工具链前缀, 去掉问号)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC = $(CROSS_COMPILE)gcc</span><br><span class="line">AR = $(CROSS_COMPILE)ar</span><br><span class="line">STRIP = $(CROSS_COMPILE)strip</span><br></pre></td></tr></table></figure>

<p>在 Makefile 中，“?&#x3D;”在第一次设置变量时才会起效果，如果之前设置过该变量，则不会起效果。</p>
<p>执行 make 时，是动态链接，需要把 libi2c.so 也放到单板上。 想静态链接的话，执行：make USE_STATIC_LIB&#x3D;1</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/21.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/22.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/23.png" alt="img"></p>
<h2><span id="2-4-i2c-tools-shi-yong">2.4 I2C Tools使用</span><a href="#2-4-i2c-tools-shi-yong" class="header-anchor">#</a></h2><h3><span id="2-4-1-i2cdetect-i2c-jian-ce">2.4.1 i2cdetect: I2C 检测</span><a href="#2-4-1-i2cdetect-i2c-jian-ce" class="header-anchor">#</a></h3><p>&#x2F;&#x2F; 列出当前的 I2C Adapter(或称为 I2C Bus、I2C Controller)</p>
<p><code>i2cdetect -l</code></p>
<p>&#x2F;&#x2F; 打印某个 I2C Adapter 的 Functionalities, I2CBUS 为 0、1、2 等整数 i2cdetect -F I2CBUS</p>
<p>&#x2F;&#x2F; 看看有哪些 I2C 设备, I2CBUS 为 0、1、2 等整数</p>
<p><code>i2cdetect -y -a I2CBUS</code></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/24.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/25.png" alt="img"></p>
<h3><span id="2-4-2-i2cget-i2c-du-smbus-xie-yi">2.4.2 i2cget:  I2C 读（SMBus协议）</span><a href="#2-4-2-i2cget-i2c-du-smbus-xie-yi" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/26.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/27.png" alt="img"></p>
<p>使用示例：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/28.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/29.png" alt="img"></p>
<h3><span id="2-4-3-i2cset-i2c-xie-smbus-xie-yi">2.4.3 i2cset: I2C 写（SMBus协议）</span><a href="#2-4-3-i2cset-i2c-xie-smbus-xie-yi" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/30.png" alt="img"></p>
<p>使用示例：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/31.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/32.png" alt="img"></p>
<h3><span id="2-4-4-i2ctransfer-i2c-chuan-shu-i2c-xie-yi">2.4.4 i2ctransfer：I2C传输（I2C协议）</span><a href="#2-4-4-i2ctransfer-i2c-chuan-shu-i2c-xie-yi" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/33.png" alt="img"></p>
<p>使用示例：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/34.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/35.png" alt="img"></p>
<p>从i2c总线0，往0x1e设备地址，写2个字节，第一个字节写入寄存器地址0，第二个字节表示往寄存器0地址写入0x4。<br>从i2c总线0，往0x1e设备地址，写2个字节，第一个字节写入寄存器地址0，第二个字节表示往寄存器0地址写入0x3。<br>从i2c总线0，往0x1e设备地址，写1个字节，写入寄存器地址0xc表示要读0xc里面的值，再从0xc读2个字节。</p>
<h2><span id="2-5-i2c-tools-fang-wen-i2c-she-bei-de-fang-shi">2.5 I2C-Tools 访问 I2C 设备的方式</span><a href="#2-5-i2c-tools-fang-wen-i2c-she-bei-de-fang-shi" class="header-anchor">#</a></h2><p>I2C-Tools 可以通过 <strong>SMBus</strong> 来访问 I2C 设备，也可以使用一般的 <strong>I2C 协议</strong> 来访问 I2C 设备。 使用一句话概括 I2C 传输：APP 通过 I2C Controller 与 I2C Device 传 输数据.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Open(<span class="string">&quot;dev/i2c-0&quot;</span>);</span><br><span class="line">ioctl(file, I2C_SLAVE, address);</span><br></pre></td></tr></table></figure>

<p>如果该设备已经有了对应的设备驱动程序，则返回失败。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ioctl(file, I2C_SLAVE_FORCE, address);</span><br></pre></td></tr></table></figure>

<p> 如果该设备已经有了对应的设备驱动程序但是还是想通过 i2c-dev 驱 动来访问它，则使用这个 ioctl 来指定 I2C 设备地址。</p>
<h3><span id="2-5-1-shu-ju-chuan-shu-fang-shi">2.5.1 数据传输方式</span><a href="#2-5-1-shu-ju-chuan-shu-fang-shi" class="header-anchor">#</a></h3><h4><span id="2-5-1-1-shi-yong-i2c-fang-shi">2.5.1.1 使用I2C方式</span><a href="#2-5-1-1-shi-yong-i2c-fang-shi" class="header-anchor">#</a></h4><p><code>ioctl(file, I2C_RDWR, &amp;rdwr)；(使用I2C方式)</code></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/36.png" alt="img"></p>
<p>该结构体表示一个或者多个i2c_msg。</p>
<p>示例代码：i2ctransfer.c</p>
<p>以<code>i2ctransfer -f -y 0 w1@0x1e 0xe r2</code>为例：</p>
<p>流程如下：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/37.png" alt="img"></p>
<p>构造i2c_rdwr_ioctl_data结构，要用2个i2c_msg结构，第一个表示写入0xe寄存器地址给设备，第二个表示要从0xe寄存器读出2个字节。</p>
<h4><span id="2-5-1-2-shi-yong-smbus-fang-shi">2.5.1.2 使用SMBus方式</span><a href="#2-5-1-2-shi-yong-smbus-fang-shi" class="header-anchor">#</a></h4><p><code>ioctl(file, I2C_SMBUS, &amp;args) ；（使用SMBus方式）</code></p>
<p>示例代码：i2cget.c i2cset.c</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/38.png" alt="img"></p>
<h4><span id="2-5-1-3-zhi-jie-shi-yong-read-x2f-write-fang-shi">2.5.1.3 直接使用read()&#x2F;write()方式</span><a href="#2-5-1-3-zhi-jie-shi-yong-read-x2f-write-fang-shi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gc2053_read_register</span><span class="params">(VI_PIPE ViPipe, <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ret, data;</span><br><span class="line">        CVI_U8 buf[<span class="number">8</span>];</span><br><span class="line">        CVI_U8 idx = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (g_fd[ViPipe] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> CVI_FAILURE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gc2053_addr_byte == <span class="number">2</span>)</span><br><span class="line">                buf[idx++] = (addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add address byte 0</span></span><br><span class="line">        buf[idx++] = addr &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        ret = write(g_fd[ViPipe], buf, gc2053_addr_byte);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                CVI_TRACE_SNS(CVI_DBG_ERR, <span class="string">&quot;I2C_WRITE error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        ret = read(g_fd[ViPipe], buf, gc2053_data_byte);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                CVI_TRACE_SNS(CVI_DBG_ERR, <span class="string">&quot;I2C_READ error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// pack read back data</span></span><br><span class="line">        data = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (gc2053_data_byte == <span class="number">2</span>) &#123;</span><br><span class="line">                data = buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">                data += buf[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = buf[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        syslog(LOG_DEBUG, <span class="string">&quot;i2c r 0x%x = 0x%x\n&quot;</span>, addr, data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gc2053_write_register</span><span class="params">(VI_PIPE ViPipe, <span class="type">int</span> addr, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">        CVI_U8 idx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        CVI_U8 buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_fd[ViPipe] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> CVI_SUCCESS;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (gc2053_addr_byte == <span class="number">1</span>) &#123;</span><br><span class="line">                buf[idx] = addr &amp; <span class="number">0xff</span>;</span><br><span class="line">                idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gc2053_data_byte == <span class="number">1</span>) &#123;</span><br><span class="line">                buf[idx] = data &amp; <span class="number">0xff</span>;</span><br><span class="line">                idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = write(g_fd[ViPipe], buf, gc2053_addr_byte + gc2053_data_byte);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                CVI_TRACE_SNS(CVI_DBG_ERR, <span class="string">&quot;I2C_WRITE error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> CVI_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = read(g_fd[ViPipe], buf, gc2053_addr_byte + gc2053_data_byte);</span><br><span class="line">        <span class="comment">//syslog(LOG_DEBUG, &quot;i2c w 0x%x 0x%x\n&quot;, addr, data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CVI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>开源插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核-异常输出函数调用栈calltrace分析</title>
    <url>/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dump-stack-han-shu">1 dump_stack函数</a></li>
<li><a href="#2-nei-he-tai-yi-chang-call-trace-deng-ji">2 内核态异常call trace等级</a><ul>
<li><a href="#2-1-warn-on-han-shu">2.1 WARN_ON函数</a></li>
<li><a href="#2-2-bug-on-han-shu">2.2 BUG_ON函数</a></li>
<li><a href="#2-3-panic-han-shu">2.3 panic函数</a></li>
</ul>
</li>
<li><a href="#3-ftrace-gong-ju-ji">3 Ftrace工具集</a><ul>
<li><a href="#3-1-ftrace-shi-ru-he-ji-lu-xin-xi-de">3.1 Ftrace是如何记录信息的</a><ul>
<li><a href="#3-1-1-jing-tai-cha-zhuang">3.1.1 静态插桩</a></li>
<li><a href="#3-1-2-dong-tai-cha-zhuang">3.1.2 动态插桩</a></li>
</ul>
</li>
<li><a href="#3-2-shi-neng-ftrace">3.2 使能Ftrace</a><ul>
<li><a href="#3-2-1-gua-zai-debugfs">3.2.1 挂载debugfs</a></li>
</ul>
</li>
<li><a href="#3-3-ftrace-shi-yong">3.3 Ftrace 使用</a><ul>
<li><a href="#3-3-1-sys-kernel-tracing-jie-shao">3.3.1 &#x2F;sys&#x2F;kernel&#x2F;tracing介绍</a></li>
<li><a href="#3-3-2-trace-he-trace-pipe-shi-yong">3.3.2 trace和trace_pipe使用</a><ul>
<li><a href="#3-3-2-1-xuan-yong-han-shu-zhui-zong">3.3.2.1 选用函数追踪</a></li>
<li><a href="#3-3-2-2-xuan-yong-tu-xiang-hua-han-shu-zhui-zong">3.3.2.2 选用图像化函数追踪</a></li>
<li><a href="#3-3-2-3-xuan-yong-dong-tai-guo-lu-zhui-zong">3.3.2.3 选用动态过滤追踪</a></li>
<li><a href="#3-3-2-4-zhui-zong-te-ding-jin-cheng">3.3.2.4 追踪特定进程</a></li>
<li><a href="#3-3-2-5-zhui-zong-te-ding-han-shu">3.3.2.5 追踪特定函数</a></li>
<li><a href="#3-3-2-6-zhui-zong-te-ding-ko-mo-kuai">3.3.2.6 追踪特定ko模块</a></li>
<li><a href="#3-3-2-7-chong-zhi-zhui-zong">3.3.2.7 重置追踪</a></li>
<li><a href="#3-3-2-8-shi-jian-zhui-zong">3.3.2.8 事件追踪</a></li>
<li><a href="#3-3-2-n-trace-printk-han-shu-shi-yong">3.3.2.n trace_printk函数使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-yin-ru-yong-hu-tai-ltrace-he-strace">3.4 引入用户态ltrace和strace</a><ul>
<li><a href="#3-4-1-ltrace">3.4.1 ltrace</a></li>
<li><a href="#3-4-2-strace">3.4.2 strace</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-dump-stack-han-shu">1 dump_stack函数</span><a href="#1-dump-stack-han-shu" class="header-anchor">#</a></h1><p>打印内核调用堆栈。举个例子：</p>
<p>我们定义四个函数<code>aaa</code>、<code>bbb</code>、<code>ccc</code>、<code>ddd</code>，然后<code>bbb</code>中调用<code>aaa</code>，<code>ccc</code>中调用<code>bbb</code>，<code>ddd</code>函数谁都不调用。在入口函数中，我们调用<code>ccc</code>与<code>ddd</code>函数，看看堆栈打印效果如何：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">aaa</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;aaa\n&quot;</span>);</span><br><span class="line">    dump_stack();</span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bbb</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;bbb\n&quot;</span>);</span><br><span class="line">    aaa();</span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ccc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;ccc\n&quot;</span>);</span><br><span class="line">    bbb();</span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ddd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;ddd\n&quot;</span>);</span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevTest_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;INIT func\r\n&quot;</span>);</span><br><span class="line">    ccc();</span><br><span class="line">    ddd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevTest_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;EXIT func\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(chrdevTest_init);</span><br><span class="line">module_exit(chrdevTest_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到当打印完<code>aaa</code>后开始<code>dump_stack</code>, 打印出函数调用栈。</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/1.png" alt="image-20240727224310304"></p>
<h1><span id="2-nei-he-tai-yi-chang-call-trace-deng-ji">2 内核态异常call trace等级</span><a href="#2-nei-he-tai-yi-chang-call-trace-deng-ji" class="header-anchor">#</a></h1><p>内核态call trace 有三种出错情况，分别是<code>bug</code>, <code>oops</code>和<code>panic</code>。</p>
<p>1、 <code>bug</code>- <strong>bug只是提示警告</strong>。<br><code>BUG: sleeping function called from invalid context at …</code>, 比如在原子上下文中休眠，总断服务函数休眠，spin_lock中进行might_sleep等。</p>
<p>我在某个设备驱动的中断处理函数 <code>XXX_ISR()</code> 里加了 <code>msleep(10) </code>之后：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/2.png" alt="image-20240727230940026"></p>
<p>可以看到跑出了BUG打印，为什么是<code>BUG: scheduling while atomic</code>呢？而不是<code>BUG: sleeping function called from invalid context at …</code></p>
<p>那是因为在原子上文中发生了调度，我们调用might_sleep是会时间片到了啊，让出CPU自然就进行了schedule。</p>
<p><code>BUG: spinlock bad magic on CPU</code>错误表示自旋锁使用时没有初始化。</p>
<p>2、 <code>Oops</code>- <strong>oops会终止进程，但是不会系统崩溃</strong>。<br>程序在内核态进入一种异常情况，比如引用非法指针导致的数据异常，数组越界导致的取指异常，此时异常处理机制能够捕获此异常，并将系统关键信息打印到串口上，正常情况下Oops消息会被记录到系统日志中去。</p>
<p>3、<code> Panic</code> -<strong>panic系统崩溃</strong>。<br>当Oops发生在中断上下文中或者在进程0和1中，系统将彻底挂起，因为中断服务程序异常后，将无法恢复，这种情况即称为内核panic。</p>
<h2><span id="2-1-warn-on-han-shu">2.1  WARN_ON函数</span><a href="#2-1-warn-on-han-shu" class="header-anchor">#</a></h2><p>我们把上面的实验<code>aaa</code>函数中<code>dump_stack</code>改成<code>WARN_ON(1)</code>函数。可以看到<code>WARN_ON(1)</code>就是调用了<code>dump_stack</code>，多了绿色打印部分而已:</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/3.png" alt="image-20240727232452233"></p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/4.png" alt="image-20240727232843642"></p>
<p>注意只有当<code>condition=1</code>时才会真正调用<code>__warn</code>:</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/5.png" alt=":"></p>
<h2><span id="2-2-bug-on-han-shu">2.2 BUG_ON函数</span><a href="#2-2-bug-on-han-shu" class="header-anchor">#</a></h2><p><code>BUG_ON</code>这句，一旦执行就会抛出<code>oops</code>，导致栈的回溯和错误信息的打印，大部分体系结构把<code>BUG()</code>和<code>BUG_ON()</code>定义成某种非法操作，这样自然会产生需要的oops。类似一种断言，让进程终止。我们把上面的实验<code>aaa</code>函数中<code>dump_stack</code>改成<code>BUG_ON(1)</code>函数:</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/6.png" alt="image-20240727233540771"></p>
<h2><span id="2-3-panic-han-shu">2.3 panic函数</span><a href="#2-3-panic-han-shu" class="header-anchor">#</a></h2><p>当Oops发生在中断上下文中或者在进程0和1中，系统将彻底挂起，因为中断服务程序异常后，将无法恢复，这种情况即称为内核panic</p>
<h1><span id="3-ftrace-gong-ju-ji">3 Ftrace工具集</span><a href="#3-ftrace-gong-ju-ji" class="header-anchor">#</a></h1><p><code>Ftrace</code>是<code>Function Trace</code>的简写。它是一个内核函数追踪工具，旨在帮助内核设计和开发人员去追踪系统内部的函数调用流程。</p>
<p>还可以用来调试和分析系统的延迟和性能问题，并发展成为一个追踪类调试工具的框架：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/7.png" alt="image-20240728145336807"></p>
<p>可以看到还包括了用户态的<code>ltrace</code>和<code>ftrace</code>。</p>
<h2><span id="3-1-ftrace-shi-ru-he-ji-lu-xin-xi-de">3.1 Ftrace是如何记录信息的</span><a href="#3-1-ftrace-shi-ru-he-ji-lu-xin-xi-de" class="header-anchor">#</a></h2><p><code>Ftrace</code>采用了静态插桩和动态插桩两种方式来实现。</p>
<h3><span id="3-1-1-jing-tai-cha-zhuang">3.1.1 静态插桩</span><a href="#3-1-1-jing-tai-cha-zhuang" class="header-anchor">#</a></h3><p><code>Kernel</code>中打开了<code>CONFIG_FUNCTION_TRACER</code>功能后，会增加一个<code>-pg</code>的一个编译选项，这样每个函数入口处，都会插入<code>bl mcount</code>跳转指令，使得每个函数运行时都会进入<code>mcount</code>函数。</p>
<p>既然每个函数都静态插桩，这带来的性能开销是惊人的，有可能导致人们弃用<code>Ftrace</code>功能。为了解决这个问题，开发者推出了<code>Dynamic ftrace</code>，以此来优化整体的性能。</p>
<h3><span id="3-1-2-dong-tai-cha-zhuang">3.1.2 动态插桩</span><a href="#3-1-2-dong-tai-cha-zhuang" class="header-anchor">#</a></h3><p>既然静态插桩记录这些可追踪的函数，为了减少性能消耗，将跳转函数替换为<code>nop</code>指令，动态将被调试函数的<code>nop</code>指令，替换为跳转指令，以实现追踪。</p>
<h2><span id="3-2-shi-neng-ftrace">3.2 使能Ftrace</span><a href="#3-2-shi-neng-ftrace" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG_FTRACE=y                             <span class="comment"># 启用了 Ftrace</span></span><br><span class="line">CONFIG_FUNCTION_TRACER=y                    <span class="comment"># 启用函数级别的追踪器</span></span><br><span class="line">CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y         <span class="comment"># 表示内核支持图形显示</span></span><br><span class="line">CONFIG_FUNCTION_GRAPH_TRACER=y              <span class="comment"># 以图形的方式显示函数追踪过程</span></span><br><span class="line">CONFIG_STACK_TRACER=y                       <span class="comment"># 启用堆栈追踪器，用于跟踪内核函数调用的堆栈信息。</span></span><br><span class="line">CONFIG_DYNAMIC_FTRACE=y                     <span class="comment"># 启用动态 Ftrace，允许在运行时启用和禁用 Ftrace 功能。</span></span><br><span class="line">CONFIG_HAVE_FTRACE_NMI_ENTER=y              <span class="comment"># 表示内核支持非屏蔽中断（NMI）时进入 Ftrace 的功能</span></span><br><span class="line">CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y          <span class="comment"># 表示内核支持通过 mcount 记录函数调用关系。</span></span><br><span class="line">CONFIG_FTRACE_NMI_ENTER=y                   <span class="comment"># 表示内核支持通过 mcount 记录函数调用关系。   </span></span><br><span class="line">CONFIG_FTRACE_SYSCALLS=y                    <span class="comment"># 系统调用的追踪</span></span><br><span class="line">CONFIG_FTRACE_MCOUNT_RECORD=y               <span class="comment"># 启用 mcount 记录函数调用关系。</span></span><br><span class="line">CONFIG_SCHED_TRACER=y                       <span class="comment"># 支持调度追踪</span></span><br><span class="line">CONFIG_CONTEXT_SWITCH_TRACER                <span class="comment">#使能上下文切换追踪功能，可以用来跟踪进程之间的切换。</span></span><br><span class="line">CONFIG_NOP_TRACER                           <span class="comment">#使能空操作追踪功能，可以用来在不需要追踪的情况下占位。</span></span><br><span class="line">CONFIG_FUNCTION_PROFILER=y                  <span class="comment"># 启用函数分析器，主要用于记录函数的执行时间和调用次数</span></span><br><span class="line">CONFIG_DEBUG_FS=y                           <span class="comment"># 启用 Debug 文件系统支持</span></span><br></pre></td></tr></table></figure>

<p>上述配置不一定全部打开，勾选自己需要的即可，通常我们选择<code>CONFIG_FUNCTION_TRACER</code>和<code>CONFIG_HAVE_FUNCTION_GRAPH_TRACER</code>即可，然后编译烧录到开发板。</p>
<p>通过<code>make menuconfig</code>的方式写入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">       Tracers ─&gt;</span><br><span class="line">           [*]   Kernel Function Tracer</span><br><span class="line">           [*]     Kernel Function Graph <span class="title function_">Tracer</span> <span class="params">(NEW)</span></span><br><span class="line">           <span class="comment">// (下面还有几个追踪器的选项，可以根据自己的需要选择)</span></span><br></pre></td></tr></table></figure>

<p><code>Ftrace </code>通过 <code>debugfs </code>向用户态提供了访问接口，所以还需要将<code> debugfs</code> 编译进内核:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">        -*- Debug Filesystem</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-1-gua-zai-debugfs">3.2.1 挂载debugfs</span><a href="#3-2-1-gua-zai-debugfs" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户态需要挂载debugfs,or通过配置修改etc/fstab文件</span></span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">或者 mount -t tracefs nodev /sys/kernel/tracing</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/8.png" alt="img"></p>
<p>我们能够在<code>/sys/kernel/debug</code>下看到内核支持的所有的调试信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /sys/kernel/debug/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line"> asoc                gpio                regmap</span><br><span class="line"> bdi                 ieee80211           sched_debug</span><br><span class="line"> block               memblock            sched_features</span><br><span class="line"> clk                 mmc0                sleep_time</span><br><span class="line"> device_component    mmc1                suspend_stats</span><br><span class="line"> devices_deferred    mtd                 tracing</span><br><span class="line"> dma_buf             opp                 ubi</span><br><span class="line"> extfrag             pinctrl             ubifs</span><br><span class="line"> fault_around_bytes  pm_qos              wakeup_sources</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-ftrace-shi-yong">3.3 Ftrace 使用</span><a href="#3-3-ftrace-shi-yong" class="header-anchor">#</a></h2><h3><span id="3-3-1-x2f-sys-x2f-kernel-x2f-tracing-jie-shao">3.3.1 &#x2F;sys&#x2F;kernel&#x2F;tracing介绍</span><a href="#3-3-1-x2f-sys-x2f-kernel-x2f-tracing-jie-shao" class="header-anchor">#</a></h3><p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/9.png" alt="image-20240728163630564"></p>
<h3><span id="3-3-2-trace-he-trace-pipe-shi-yong">3.3.2 trace和trace_pipe使用</span><a href="#3-3-2-trace-he-trace-pipe-shi-yong" class="header-anchor">#</a></h3><p><code>cat trace_pipe</code>是堵塞读取，有数据就读，没数据就等待。</p>
<p>打开关闭追踪：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; tracing_on             <span class="comment">// 打开跟踪</span></span><br><span class="line">do_someting</span><br><span class="line">echo <span class="number">0</span> &gt; tracing_on             <span class="comment">// 关闭跟踪</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cat trace  &gt; /tmp/<span class="built_in">log</span> <span class="comment">//一次性导出log</span></span><br><span class="line">cat trace_pipe &gt; /tmp/<span class="built_in">log</span> &amp;<span class="comment">//后台导出log</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cat current_tracer                    <span class="comment">// 查看当前追踪器</span></span><br><span class="line">cat available_tracers                 <span class="comment">// 查看当前内核中可用跟踪器</span></span><br><span class="line">cat available_events                  <span class="comment">// 查看当前内核中可用事件</span></span><br><span class="line">cat available_filter_functions        </span><br><span class="line"><span class="comment">// 查看当前内核中可用函数,可以被追踪的函数列表，</span></span><br><span class="line"><span class="comment">// 即可以写到 set_ftrace_filter，set_ftrace_notrace，set_graph_function，</span></span><br><span class="line"><span class="comment">// set_graph_notrace 文件的函数列表</span></span><br><span class="line"></span><br><span class="line">echo function &gt; current_tracer        <span class="comment">// 选用 function 追踪器，</span></span><br><span class="line">echo function_graph &gt; current_tracer  <span class="comment">// 选用 function_graph 追踪器，</span></span><br><span class="line">echo [func] &gt; set_ftrace_filter       <span class="comment">// 选择追踪指定 [func] 函数的调用栈</span></span><br><span class="line">echo [pid] &gt; set_ftrace_pid           <span class="comment">// 选择追踪指定 [pid] 进程的调用栈</span></span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-1-xuan-yong-han-shu-zhui-zong">3.3.2.1 选用函数追踪</span><a href="#3-3-2-1-xuan-yong-han-shu-zhui-zong" class="header-anchor">#</a></h4><p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/10.png" alt="image-20240728153553129"></p>
<h4><span id="3-3-2-2-xuan-yong-tu-xiang-hua-han-shu-zhui-zong">3.3.2.2 选用图像化函数追踪</span><a href="#3-3-2-2-xuan-yong-tu-xiang-hua-han-shu-zhui-zong" class="header-anchor">#</a></h4><p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/11.png" alt="image-20240728153651223"></p>
<h4><span id="3-3-2-3-xuan-yong-dong-tai-guo-lu-zhui-zong">3.3.2.3 选用动态过滤追踪</span><a href="#3-3-2-3-xuan-yong-dong-tai-guo-lu-zhui-zong" class="header-anchor">#</a></h4><p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/12.png" alt="image-20240728155333300"></p>
<h4><span id="3-3-2-4-zhui-zong-te-ding-jin-cheng">3.3.2.4 追踪特定进程</span><a href="#3-3-2-4-zhui-zong-te-ding-jin-cheng" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">echo</span> 0 &gt; tracing_on                                 <span class="comment"># 关闭追踪器</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="keyword">function</span> &gt; current_tracer                      <span class="comment"># 设置当前追踪类别</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> &gt; trace; <span class="built_in">echo</span> $$ &gt; set_ftrace_pid; <span class="built_in">echo</span> 1 &gt; tracing_on; your_command; <span class="built_in">echo</span> 0 &gt; tracing_on</span><br></pre></td></tr></table></figure>

<p><code>$$</code>表示当前bash的pid,这样可以追踪任意命令。</p>
<p>如果我们要抓执行<code>a.out</code>的trace信息，那么先要获取到<code>a.out</code>程序的pid。</p>
<p>为什么要写成一条语句？</p>
<p>因为<code>ftrace</code>当打开时，在没有过滤的情况下，瞬间会抓取到内核所有的函数调用，为了更准确的抓取我们执行的命令，所以需要打开<code>trace</code>，执行完命令后，马上关闭。</p>
<h4><span id="3-3-2-5-zhui-zong-te-ding-han-shu">3.3.2.5 追踪特定函数</span><a href="#3-3-2-5-zhui-zong-te-ding-han-shu" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; options/func_stack_trace</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; tracing_on									<span class="comment"># 关闭追踪器</span></span><br><span class="line"><span class="built_in">cat</span> available_filter_functions | grep <span class="string">&quot;xxxxxx&quot;</span>		<span class="comment"># 搜索函数是否存在</span></span><br><span class="line"><span class="built_in">echo</span> xxxxxx &gt; set_ftrace_filter						<span class="comment"># 设定追踪的函数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="keyword">function</span> &gt; current_tracer						<span class="comment"># 设置当前追踪类别</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; options/func_stack_trace					<span class="comment"># 记录堆栈信息</span></span><br><span class="line"><span class="built_in">echo</span> &gt; trace										<span class="comment"># 清空缓存</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; tracing_on</span><br></pre></td></tr></table></figure>

<p>查看结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: function</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># entries-in-buffer/entries-written: 2/2   #P:3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                              _-----=&gt; irqs-off</span></span><br><span class="line"><span class="comment">#                             / _----=&gt; need-resched</span></span><br><span class="line"><span class="comment">#                            | / _---=&gt; hardirq/softirq</span></span><br><span class="line"><span class="comment">#                            || / _--=&gt; preempt-depth</span></span><br><span class="line"><span class="comment">#                            ||| /     delay</span></span><br><span class="line"><span class="comment">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |   ||||       |         |</span></span><br><span class="line">     kworker/1:1-59    [001] ....   168.954199: mmc_rescan &lt;-process_one_work</span><br><span class="line">     kworker/1:1-59    [001] ....   168.954248: &lt;stack trace&gt;</span><br><span class="line"> =&gt; mmc_rescan</span><br><span class="line"> =&gt; process_one_work</span><br><span class="line"> =&gt; worker_thread</span><br><span class="line"> =&gt; kthread</span><br><span class="line"> =&gt; ret_from_fork</span><br><span class="line"> =&gt; 0</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-6-zhui-zong-te-ding-ko-mo-kuai">3.3.2.6 追踪特定ko模块</span><a href="#3-3-2-6-zhui-zong-te-ding-ko-mo-kuai" class="header-anchor">#</a></h4><p>编译ko需要加上编译参数<code>-pg</code>。否则你在<code>available_filter_functions</code>列表中，查找不到你想要的函数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">Format: :mod:&lt;module-name&gt;</span><br><span class="line">example: <span class="built_in">echo</span> :mod:ext3 &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>

<p>追踪<code>ext3</code>模块内的所有函数。</p>
<h4><span id="3-3-2-7-chong-zhi-zhui-zong">3.3.2.7 重置追踪</span><a href="#3-3-2-7-chong-zhi-zhui-zong" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; tracing_on         <span class="comment"># 关闭trace</span></span><br><span class="line"><span class="built_in">echo</span> &gt; trace                <span class="comment"># 清空当前trace记录</span></span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-8-shi-jian-zhui-zong">3.3.2.8 事件追踪</span><a href="#3-3-2-8-shi-jian-zhui-zong" class="header-anchor">#</a></h4><p><strong>查看事件</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@100ask:/sys/kernel/debug/tracing/events<span class="comment"># ls</span></span><br><span class="line">alarmtimer    exceptions    i2c          migrate         power         signal </span><br><span class="line">block         ext4          initcall     mmc             printk        skb                    </span><br><span class="line"><span class="built_in">enable</span>        hyperv        mdio         percpu</span><br><span class="line">    </span><br><span class="line">root@100ask:/sys/kernel/debug/tracing/events/sched<span class="comment"># ls</span></span><br><span class="line"><span class="built_in">enable</span>                  sched_move_numa     sched_process_free  sched_stat_runtime  sched_switch          </span><br><span class="line">filter                  sched_pi_setprio    sched_process_hang  sched_stat_sleep</span><br><span class="line">sched_kthread_stop      sched_process_exec  sched_process_wait  sched_stat_wait</span><br></pre></td></tr></table></figure>

<p><strong>追踪一个&#x2F;若干事件</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># echo 1 &gt; events/sched/sched_wakeup/enable</span></span><br><span class="line"> ...（省略追踪过程）</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat trace | head -10</span></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#TASK-PID  CPU#  TIMESTAMP    FUNCTION</span></span><br><span class="line"><span class="comment"># || | |</span></span><br><span class="line">bash-2613 [001] 425.078164: sched_wakeup: task bash:2613 [120] success=0 [001]</span><br><span class="line">bash-2613 [001] 425.078184: sched_wakeup: task bash:2613 [120] success=0 [001]</span><br></pre></td></tr></table></figure>

<p><strong>追踪所有事件</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 1 &gt; events/enable</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat trace | head -10</span></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#TASK-PID     CPU#     TIMESTAMP    FUNCTION</span></span><br><span class="line"><span class="comment">#   |                    |                    |                   | </span></span><br><span class="line">cpid-1470       [001]   794.947181:         kfree: call_site=ffffffff810c996d ptr=(null)</span><br><span class="line">acpid-1470     [001] 794.947182:      sys_read -&gt; 0x1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-n-trace-printk-han-shu-shi-yong">3.3.2.n trace_printk函数使用</span><a href="#3-3-2-n-trace-printk-han-shu-shi-yong" class="header-anchor">#</a></h4><p>内核头文件<code> include/linux/kernel.h</code> 中描述了 <code>ftrace </code>提供的工具函数的原型，这些函数包括 <code>trace_printk</code>、<code>tracing_on</code>&#x2F;<code>tracing_off</code> 等。</p>
<h2><span id="3-4-yin-ru-yong-hu-tai-ltrace-he-strace">3.4 引入用户态ltrace和strace</span><a href="#3-4-yin-ru-yong-hu-tai-ltrace-he-strace" class="header-anchor">#</a></h2><h3><span id="3-4-1-ltrace">3.4.1 ltrace</span><a href="#3-4-1-ltrace" class="header-anchor">#</a></h3><p>跟踪进程调用<code>C库函数</code>的情况。</p>
<p>常用的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a : 对齐具体某个列的返回值。</span><br><span class="line">-c : 计算时间和调用，并在程序退出时打印摘要。</span><br><span class="line">-d : 打印调试信息。</span><br><span class="line">-h : 打印帮助信息。</span><br><span class="line">-i : 打印指令指针，当库调用时。</span><br><span class="line">-l : 只打印某个库中的调用。</span><br><span class="line">-o, --output=file : 把输出定向到文件。</span><br><span class="line">-p : PID 附着在值为PID的进程号上进行ltrace。</span><br><span class="line">-r : 打印相对时间戳。</span><br><span class="line">-S : 显示系统调用。</span><br><span class="line">-t, -tt, -ttt : 打印绝对时间戳。</span><br><span class="line">-T : 输出每个调用过程的时间开销。</span><br><span class="line">-V, --version : 打印版本信息，然后退出。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(arr, <span class="number">2</span>, n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.查看c库调用：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/13.png" alt="image-20240728165618548"></p>
<p>2.查看c库调用次数：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/14.png" alt="image-20240728165742636"></p>
<p>3.查看c库执行时间：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/15.png" alt="image-20240728165842926"></p>
<p>4.查看系统调用情况：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/16.png" alt="image-20240728170027545"></p>
<h3><span id="3-4-2-strace">3.4.2 strace</span><a href="#3-4-2-strace" class="header-anchor">#</a></h3><p>跟踪进程系统调用<code>System Call</code>使用情况。</p>
<p>常用的参数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</span><br><span class="line">-d 输出strace关于标准错误的调试信息.</span><br><span class="line">-f 跟踪由fork调用所产生的子进程.</span><br><span class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</span><br><span class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</span><br><span class="line">-h 输出简要的帮助信息.</span><br><span class="line">-i 输出系统调用的入口指针.</span><br><span class="line">-q 禁止输出关于脱离的消息.</span><br><span class="line">-r 打印出相对时间关于,,每一个系统调用.</span><br><span class="line">-t 在输出中的每一行前加上时间信息.</span><br><span class="line">-tt 在输出中的每一行前加上时间信息,微秒级.</span><br><span class="line">-ttt 微秒级输出,以秒了表示时间.</span><br><span class="line">-T 显示每一调用所耗的时间.</span><br><span class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</span><br><span class="line">-V 输出strace的版本信息.</span><br><span class="line">-x 以十六进制形式输出非标准字符串</span><br><span class="line">-xx 所有字符串以十六进制形式输出.</span><br><span class="line">-a column 设置返回值的输出位置.默认 为40.</span><br><span class="line">-e expr 指定一个表达式,用来控制如何跟踪.格式：[qualifier=][!]value1[,value2]...</span><br><span class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open 表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</span><br><span class="line">-e trace=set 只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</span><br><span class="line">-e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</span><br><span class="line">-e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5</span><br><span class="line">-e write=set 输出写入到指定文件中的数据.</span><br><span class="line">-o filename 将strace的输出写入文件filename</span><br><span class="line">-p pid 跟踪指定的进程pid.</span><br></pre></td></tr></table></figure>

<p>查看系统调用的时间：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/17.png" alt="image-20240728170644866"></p>
]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核Makefile编译过程</title>
    <url>/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zimage-bian-yi">1 zImage编译</a><ul>
<li><a href="#1-1-vmlinux-bian-yi">1.1 vmlinux编译</a><ul>
<li><a href="#1-1-1-head-y">1.1.1 head-y</a></li>
<li><a href="#1-1-2-init-y-drivers-y-he-net-y">1.1.2 init-y&#x2F;drivers-y和net-y</a></li>
<li><a href="#1-1-3-libs-y">1.1.3 libs-y</a></li>
<li><a href="#1-1-4-core-y">1.1.4 core-y</a></li>
<li><a href="#1-1-5-built-in-o-chan-sheng-guo-cheng">1.1.5 built-in.o产生过程</a><ul>
<li><a href="#1-1-5-1-vmlinux-deps-zhan-kai">1.1.5.1 vmlinux-deps展开</a></li>
<li><a href="#1-1-5-2-prepare-zhun-bei-gong-zuo">1.1.5.2 prepare准备工作</a><ul>
<li><a href="#1-1-5-2-1-prepare-de-kuang-jia">1.1.5.2.1 prepare 的框架</a></li>
</ul>
</li>
<li><a href="#1-1-5-3-vmlinux-dirs-zhan-kai">1.1.5.3 <code>vmlinux-dirs</code>展开</a></li>
</ul>
</li>
<li><a href="#1-1-6-link-vmlinux">1.1.6 link-vmlinux</a></li>
<li><a href="#1-1-7-xin-ban-de-link-vmlinux">1.1.7 新版的link-vmlinux</a><ul>
<li><a href="#1-1-7-1-autoksyms-recursive">1.1.7.1 autoksyms_recursive</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-2-make-zimage-guo-cheng">1.2 make zImage过程</a><ul>
<li><a href="#1-2-1-vmlinux-image-zimage-uimage-de-qu-bie">1.2.1 vmlinux、Image，zImage、uImage 的区别</a></li>
<li><a href="#1-2-2-image-de-bian-yi-guo-cheng">1.2.2 Image的编译过程</a></li>
<li><a href="#1-2-3-zimage-de-bian-yi-guo-cheng">1.2.3 zImage的编译过程</a></li>
<li><a href="#1-2-4-objcopyflags">1.2.4 OBJCOPYFLAGS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-sheng-cheng-de-wen-jian">2 生成的文件</a></li>
<li><a href="#3-she-bei-shu-de-bian-yi-guo-cheng">3 设备树的编译过程</a><ul>
<li><a href="#3-1-sheng-cheng-dtc-gong-ju">3.1 生成dtc工具</a></li>
<li><a href="#3-2-sheng-cheng-dtb">3.2 生成dtb</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zimage-bian-yi">1 zImage编译</span><a href="#1-zimage-bian-yi" class="header-anchor">#</a></h1><p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/1.png" alt="image"><br><code>_all </code>是默认目标，如果使用命令make或者make all编译 Linux 的话此目标就会被匹配。<br><code>KBUILD_EXTMOD </code>为空的，因此194 行的代码成立, 因此<code>_all</code>依赖all。all又依赖vmlinux，开始编译vmlinux。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_v7_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j16</span><br></pre></td></tr></table></figure>
<h2><span id="1-1-vmlinux-bian-yi">1.1 vmlinux编译</span><a href="#1-1-vmlinux-bian-yi" class="header-anchor">#</a></h2><p>找到vmlinux目标开始分析：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/2.png" alt="image"><br>目标 vmlinux 依赖 <code>scripts/link-vmlinux.sh</code> <code>$(vmlinux-deps)</code> <code>FORCE</code>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">vmlinux-deps= <span class="variable">$(KBUILD_LDS)</span> <span class="variable">$(KBUILD_VMLINUX_INIT)</span> <span class="variable">$(KBUILD_VMLINUX_MAIN)</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KBUILD_VMLINUX_INIT= $(head-y) $(init-y)</span><br><span class="line">KBUILD_VMLINUX_MAIN = $(core-y) $(libs-y) $(drivers-y) $(net-y)</span><br><span class="line">KBUILD_LDS= arch/<span class="variable">$(SRCARCH)</span>/kernel/vmlinux.lds  //链接脚本</span><br></pre></td></tr></table></figure>

<p>综上所述，vmlinux 的依赖为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">scripts/link-vmlinux.sh</span><br><span class="line">$(head-y) 、$(init-y)、$(core-y) 、</span><br><span class="line">$(libs-y) 、$(drivers-y) 、$(net-y)、arch/arm/kernel/vmlinux.lds 和 FORCE</span><br></pre></td></tr></table></figure>
<h3><span id="1-1-1-head-y">1.1.1 head-y</span><a href="#1-1-1-head-y" class="header-anchor">#</a></h3><p>head-y 定义在文件 arch&#x2F;arm&#x2F;Makefile 中:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">135 head-y := arch/arm/kernel/head<span class="variable">$(MMUEXT)</span>.o</span><br></pre></td></tr></table></figure>
<p>当不使能 MMU 的话 <code>MMUEXT=-nommu</code>，如果使能 MMU 的话为空，因此 head-y为：<br><code>head-y = arch/arm/kernel/head.o</code></p>
<h3><span id="1-1-2-init-y-x2f-drivers-y-he-net-y">1.1.2 init-y&#x2F;drivers-y和net-y</span><a href="#1-1-2-init-y-x2f-drivers-y-he-net-y" class="header-anchor">#</a></h3><p>顶层Makefile内容如下：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/3.png" alt="image"><br>展开后：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">init-y = init/built-in.o</span><br><span class="line">drivers-y = drivers/built-in.o sound/built-in.o firmware/built-in.o</span><br><span class="line">net-y = net/built-in.o</span><br></pre></td></tr></table></figure>
<h3><span id="1-1-3-libs-y">1.1.3 libs-y</span><a href="#1-1-3-libs-y" class="header-anchor">#</a></h3><p>顶层Makefile中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">561 libs-y := lib/</span><br></pre></td></tr></table></figure>

<p>在arch&#x2F;arm&#x2F;Makefile中，对libs-y又追加了：<br><code>libs-y := arch/arm/lib/ $(libs-y)</code><br>展开后：<br><code>libs-y = arch/arm/lib lib/</code><br>回到顶层Makefile:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">900 libs-y1 := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/lib.a, $(libs-y)</span>)</span><br><span class="line">901 libs-y2 := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(libs-y)</span>)</span><br><span class="line">902 libs-y := $(libs-y1) $(libs-y2)</span><br></pre></td></tr></table></figure>
<p>展开后：<br><code>libs-y = arch/arm/lib/lib.a lib/lib.a arch/arm/lib/built-in.o lib/built-in.o</code></p>
<h3><span id="1-1-4-core-y">1.1.4 core-y</span><a href="#1-1-4-core-y" class="header-anchor">#</a></h3><p>顶层Makefile中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">532 core-y := usr/</span><br><span class="line">......</span><br><span class="line">887 core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/</span><br></pre></td></tr></table></figure>
<p>在 arch&#x2F;arm&#x2F;Makefile 中会对 core-y 进行追加，代码如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">269 core-<span class="variable">$(CONFIG_FPE_NWFPE)</span> += arch/arm/nwfpe/</span><br><span class="line">270 core-<span class="variable">$(CONFIG_FPE_FASTFPE)</span> += <span class="variable">$(FASTFPE_OBJ)</span></span><br><span class="line">271 core-<span class="variable">$(CONFIG_VFP)</span> += arch/arm/vfp/</span><br><span class="line">272 core-<span class="variable">$(CONFIG_XEN)</span> += arch/arm/xen/</span><br><span class="line">273 core-<span class="variable">$(CONFIG_KVM_ARM_HOST)</span> += arch/arm/kvm/</span><br><span class="line">274 core-<span class="variable">$(CONFIG_VDSO)</span> += arch/arm/vdso/</span><br><span class="line">275</span><br><span class="line">276 <span class="comment"># If we have a machine-specific directory, then include it in the build.</span></span><br><span class="line">277 core-y += arch/arm/kernel/ arch/arm/mm/ arch/arm/common/</span><br><span class="line">278 core-y += arch/arm/probes/</span><br><span class="line">279 core-y += arch/arm/net/</span><br><span class="line">280 core-y += arch/arm/crypto/</span><br><span class="line">281 core-y += arch/arm/firmware/</span><br><span class="line">282 core-y += <span class="variable">$(machdirs)</span> <span class="variable">$(platdirs)</span></span><br></pre></td></tr></table></figure>

<p>比如使能 <code>VFP </code>的话就会在<code>.config</code>中有 CONFIG_VFP&#x3D;y 这一行，那么 core-y 就会追加<code>“arch/arm/vfp/”</code>。<br>顶层 Makefile 中还有：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">897 core-y := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(core-y)</span>)</span><br></pre></td></tr></table></figure>
<p>最终 core-y 的值为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">core-y = usr/built-in.o		arch/arm/vfp/built-in.o \</span><br><span class="line">arch/arm/vdso/built-in.o	arch/arm/kernel/built-in.o \</span><br><span class="line">arch/arm/mm/built-in.o 		arch/arm/common/built-in.o \</span><br><span class="line">arch/arm/probes/built-in.o 	arch/arm/net/built-in.o \</span><br><span class="line">arch/arm/crypto/built-in.o 	arch/arm/firmware/built-in.o \</span><br><span class="line">arch/arm/mach-imx/built-in.o 	kernel/built-in.o\</span><br><span class="line">mm/built-in.o 			fs/built-in.o \</span><br><span class="line">ipc/built-in.o 			security/built-in.o \</span><br><span class="line">crypto/built-in.o 		block/built-in.o</span><br></pre></td></tr></table></figure>

<p>可以看到和 uboot 一样这些变量都是一些 built-in.o 或.a 等文件，都是将相应目录中的源码文件进行编译，然后在各自目录下生成 built-in.o 文件，有些生成了.a 库文件。最终将这些 built-in.o 和.a 文件进行链接即可形成 ELF 格式的可执行文件，也就是 vmlinux。但是链接是需要链接脚本的，vmlinux 的依赖 arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds 就是整个 Linux 的链接脚本。</p>
<h3><span id="1-1-5-built-in-o-chan-sheng-guo-cheng">1.1.5 built-in.o产生过程</span><a href="#1-1-5-built-in-o-chan-sheng-guo-cheng" class="header-anchor">#</a></h3><h4><span id="1-1-5-1-vmlinux-deps-zhan-kai">1.1.5.1 vmlinux-deps展开</span><a href="#1-1-5-1-vmlinux-deps-zhan-kai" class="header-anchor">#</a></h4><p>vmliux 依赖 vmlinux-deps:<br><code>vmlinux-deps= $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)</code><br>这些变量进行展开：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$(head-y) 、$(init-y)、$(core-y) 、</span><br><span class="line">$(libs-y) 、$(drivers-y) 、$(net-y)、arch/arm/kernel/vmlinux.lds</span><br></pre></td></tr></table></figure>

<p>展开：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">init-y      := init/</span><br><span class="line">drivers-y   := drivers/ sound/</span><br><span class="line">drivers-<span class="variable">$(CONFIG_SAMPLES)</span> += samples/</span><br><span class="line">net-y       := net/</span><br><span class="line">libs-y      := lib/</span><br><span class="line">core-y      := usr/</span><br><span class="line">virt-y      := virt/</span><br><span class="line"><span class="comment"># 每个变量的值原本是目录，将目录名后加上 built-in.a 后缀</span></span><br><span class="line">init-y      := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.a, $(init-y)</span>)</span><br><span class="line">core-y      := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.a, $(core-y)</span>)</span><br><span class="line">drivers-y   := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.a, $(drivers-y)</span>)</span><br><span class="line">net-y       := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.a, $(net-y)</span>)</span><br><span class="line">libs-y1     := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/lib.a, $(libs-y)</span>)</span><br><span class="line">libs-y2     := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.a, $(<span class="built_in">filter</span>-out %.a, $(libs-y)</span>))</span><br><span class="line">virt-y      := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.a, $(virt-y)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vmlinux 相关的目标文件</span></span><br><span class="line">KBUILD_VMLINUX_OBJS := $(head-y) $(init-y) $(core-y) $(libs-y2) \</span><br><span class="line">                  $(drivers-y) $(net-y) $(virt-y)</span><br><span class="line"><span class="comment"># vmlinux 的链接脚本</span></span><br><span class="line">KBUILD_LDS          := arch/<span class="variable">$(SRCARCH)</span>/kernel/vmlinux.lds</span><br><span class="line"><span class="comment"># vmlinux 相关的库</span></span><br><span class="line">KBUILD_VMLINUX_LIBS := $(libs-y1)</span><br><span class="line"></span><br><span class="line">vmlinux-deps := <span class="variable">$(KBUILD_LDS)</span> <span class="variable">$(KBUILD_VMLINUX_OBJS)</span> <span class="variable">$(KBUILD_VMLINUX_LIBS)</span></span><br></pre></td></tr></table></figure>

<p>最后：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">vmlinux-deps = arch/arm/kernel/vmlinux.lds</span><br><span class="line">		arch/arm/kernel/head.o \</span><br><span class="line">		init/built-in.o              usr/built-in.o \</span><br><span class="line">		arch/arm/vfp/built-in.o      arch/arm/vdso/built-in.o \</span><br><span class="line">		arch/arm/kernel/built-in.o   arch/arm/mm/built-in.o \</span><br><span class="line">		arch/arm/common/built-in.o   arch/arm/probes/built-in.o \</span><br><span class="line">		arch/arm/net/built-in.o      arch/arm/crypto/built-in.o \</span><br><span class="line">		arch/arm/firmware/built-in.o arch/arm/mach-imx/built-in.o \</span><br><span class="line">		kernel/built-in.o            mm/built-in.o \</span><br><span class="line">		fs/built-in.o                ipc/built-in.o \</span><br><span class="line">		security/built-in.o          crypto/built-in.o\</span><br><span class="line">		block/built-in.o             arch/arm/lib/lib.a\</span><br><span class="line">		lib/lib.a                    arch/arm/lib/built-in.o\</span><br><span class="line">		lib/built-in.o               drivers/built-in.o \</span><br><span class="line">		sound/built-in.o             firmware/built-in.o \</span><br><span class="line">		net/built-in.o</span><br></pre></td></tr></table></figure>
<p>除了 arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds 以外，其他都是要编译链接生成的。顶层 Makefile 中有如下代码：<br><code>937 $(sort $(vmlinux-deps)): $(vmlinux-dirs) ;</code><br>sort 是排序函数，用于对 vmlinux-deps 的字符串列表进行排序，并且去掉重复的单词。可以看出 <code>vmlinux-deps </code>依赖 <code>vmlinux-dirs</code>，&#96;&#96;vmlinux-dirs&#96; 也定义在顶层 Makefile 中，定义如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">889 vmlinux-dirs := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(init-y)</span> $(init-m) \</span><br><span class="line">890 		$(core-y) $(core-m) $(drivers-y) $(drivers-m) \</span><br><span class="line">891 		$(net-y) $(net-m) $(libs-y) $(libs-m)))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/4.png" alt="image"></p>
<p>因此展开vmlinux-dirs为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">vmlinux-dirs = init        usr             arch/arm/vfp \</span><br><span class="line">		arch/arm/vdso arch/arm/kernel      arch/arm/mm \</span><br><span class="line">		arch/arm/common arch/arm/probes    arch/arm/net \</span><br><span class="line">		arch/arm/crypto arch/arm/firmware  arch/arm/mach-imx\</span><br><span class="line">		kernel                             mm        fs \</span><br><span class="line">		ipc                                security  crypto \</span><br><span class="line">		block                              drivers   sound \</span><br><span class="line">		firmware                           net       arch/arm/lib \</span><br><span class="line">		lib</span><br></pre></td></tr></table></figure>

<p>在顶层 Makefile 中有如下代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">946 $(vmlinux-dirs): prepare scripts</span><br><span class="line">947 	<span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=<span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<h4><span id="1-1-5-2-prepare-zhun-bei-gong-zuo">1.1.5.2 prepare准备工作</span><a href="#1-1-5-2-prepare-zhun-bei-gong-zuo" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">vmlinux-deps -&gt; vmlinux-dirs -&gt; prepare</span><br></pre></td></tr></table></figure>

<h5><span id="1-1-5-2-1-prepare-de-kuang-jia">1.1.5.2.1 prepare 的框架</span><a href="#1-1-5-2-1-prepare-de-kuang-jia" class="header-anchor">#</a></h5><p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/5.png" alt="image"></p>
<p><code>prepare0</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1 prepare0: archprepare</span><br><span class="line">2   <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/mod</span><br><span class="line">3   <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=.</span><br></pre></td></tr></table></figure>

<p>第2行，等于<code>make -f ./scripts/Makefile.build obj=scripts/mod</code></p>
<p>首先进入到<code> scripts/Makefile.build</code> ,然后包含<code> scripts/mod/Makefile</code> 文件，执行<code>scripts/mod/Makefile</code>下的默认目标:</p>
<p><code>scripts/mod/Makefile</code>内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">hostprogs-y := modpost mk_elfconfig</span><br><span class="line">always      := $(hostprogs-y) empty.o</span><br><span class="line"></span><br><span class="line">devicetable-offsets-file := devicetable-offsets.h</span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span>/$(devicetable-offsets-file): <span class="variable">$(obj)</span>/devicetable-offsets.s FORCE</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> filechk,offsets,__DEVICETABLE_OFFSETS_H__)</span></span><br></pre></td></tr></table></figure>

<p>这部分命令将生成 <code>scripts/mod/devicetable-offsets.h </code>这个全局偏移文件。</p>
<p>同时，<code>modpost</code> 和 <code>mk_elfconfig </code>这两个目标(这是两个主机程序)被赋值给<code>always</code>变量，根据 <code>scripts/Makefile.build </code>中的规则，将在<code>Makefile.host</code>中被生成。<code>modpost</code> 和 <code>mk_elfconfig </code>是两个主机程序，负责处理模块与编译符号相关的内容。</p>
<p><code>archprepare</code>：</p>
<p>看到 arch 前缀就知道这是架构相关的，这部分的定义与 <code>arch/$(ARCH)/Makefile</code> 有非常大的关系.<code>archprepare </code>并没有命令部分，仅仅是四个依赖:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">archprepare: archheaders archscripts prepare1 scripts</span><br></pre></td></tr></table></figure>

<ol>
<li><code>archheaders</code></li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">archheaders:</span></span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=arch/arm/tools uapi <span class="comment">#定义再arch/$(ARCH)/Makfile</span></span><br></pre></td></tr></table></figure>

<p>进入<code>scripts/Makefile.build</code> 中，并包含 <code>arch/arm/tools/Makefile</code>,编译目标为<code> uapi</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">uapi-hdrs-y := <span class="variable">$(uapi)</span>/unistd-common.h</span><br><span class="line">uapi-hdrs-y += <span class="variable">$(uapi)</span>/unistd-oabi.h</span><br><span class="line">uapi-hdrs-y += <span class="variable">$(uapi)</span>/unistd-eabi.h</span><br><span class="line"><span class="section">uapi:   $(uapi-hdrs-y)</span></span><br></pre></td></tr></table></figure>

<p>uapi 为用户 API 的头文件，包含<code>unistd-common.h、unistd-oabi.h、unistd-eabi.h</code>等通用头文件。</p>
<ol start="2">
<li><p><code>archscripts</code></p>
<p>archscripts 产生平台相关的支持脚本。</p>
</li>
<li><p><code>scripts</code></p>
</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">scripts: scripts_basic scripts_dtc</span></span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=$(@)</span><br></pre></td></tr></table></figure>

<p>等于<code>make -f ./scripts/Makefile.build obj=scripts</code>, 找到找到<code> scripts</code>下的 Makefile，Makefile 下的内容是这样的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">hostprogs-<span class="variable">$(CONFIG_BUILD_BIN2C)</span>  += bin2c</span><br><span class="line">hostprogs-<span class="variable">$(CONFIG_KALLSYMS)</span>     += kallsyms</span><br><span class="line">hostprogs-<span class="variable">$(CONFIG_LOGO)</span>         += pnmtologo</span><br><span class="line">hostprogs-<span class="variable">$(CONFIG_VT)</span>           += conmakehash</span><br><span class="line">hostprogs-<span class="variable">$(BUILD_C_RECORDMCOUNT)</span> += recordmcount</span><br><span class="line">hostprogs-<span class="variable">$(CONFIG_BUILDTIME_EXTABLE_SORT)</span> += sortextable</span><br><span class="line">hostprogs-<span class="variable">$(CONFIG_ASN1)</span>     += asn1_compiler</span><br><span class="line">...</span><br><span class="line">hostprogs-y += unifdef</span><br><span class="line"><span class="section">build_unifdef: <span class="variable">$(obj)</span>/unifdef</span></span><br><span class="line">    @:</span><br></pre></td></tr></table></figure>

<p>编译了一系列的主机程序，包括<code> bin2c</code>、<code>kallsyms</code>、<code>pnmtologo</code>等。</p>
<p><code>scripts_basic</code>前面讲过了，编译出<code>fixdep</code>。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html">Uboot顶层Makefile解析-1. defconfig过程分析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<p><code>scripts_dtc</code>定义如下:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">scripts_dtc: scripts_basic</span></span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/dtc</span><br></pre></td></tr></table></figure>

<p>同样的，进入 <code>scripts/dtc/Makefile</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">hostprogs-<span class="variable">$(CONFIG_DTC)</span> := dtc</span><br><span class="line">always      := $(hostprogs-y)</span><br><span class="line">dtc-objs    := dtc.o flattree.o fstree.o data.o livetree.o treesource.o \</span><br><span class="line">           srcpos.o checks.o util.o</span><br><span class="line">dtc-objs    += dtc-lexer.lex.o dtc-parser.tab.o</span><br></pre></td></tr></table></figure>

<p>可以看到，该目标的作用就是生成 dtc。</p>
<ol start="4">
<li><code>prepare1</code></li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">prepare1: prepare3 outputMakefile asm-generic <span class="variable">$(version_h)</span> <span class="variable">$(autoksyms_h)</span> \</span></span><br><span class="line">                        <span class="keyword">include</span>/generated/utsrelease.h</span><br><span class="line">    <span class="variable">$(cmd_crmodverdir)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">md_crmodverdir = <span class="variable">$(Q)</span>mkdir -p <span class="variable">$(MODVERDIR)</span> \</span><br><span class="line">                  <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(KBUILD_MODULES)</span>,; rm -f <span class="variable">$(MODVERDIR)</span>/*)</span></span><br></pre></td></tr></table></figure>

<p><code>$(MODVERDIR) </code>仅与编译外部模块相关，这里针对外部模块的处理，如果指定编译外部模块，则不做任何事，如果没有指定编译外部模块，清除<code>$(MODVERDIR)/</code>目录下所有内容。</p>
<p>4.1 <code>prepare3</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">prepare3: include/config/kernel.release</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(srctree)</span>,.)</span><br><span class="line">    @<span class="variable">$(kecho)</span> &#x27;  Using <span class="variable">$(srctree)</span> as source for kernel&#x27;</span><br><span class="line">    <span class="variable">$(Q)</span>if [ -f <span class="variable">$(srctree)</span>/.config -o \</span><br><span class="line">         -d <span class="variable">$(srctree)</span>/<span class="keyword">include</span>/config -o \</span><br><span class="line">         -d <span class="variable">$(srctree)</span>/arch/<span class="variable">$(SRCARCH)</span>/<span class="keyword">include</span>/generated ]; then \</span><br><span class="line">        echo &gt;&amp;2 <span class="string">&quot;  <span class="variable">$(srctree)</span> is not clean, please run &#x27;make mrproper&#x27;&quot;</span>; \</span><br><span class="line">        echo &gt;&amp;2 <span class="string">&quot;  in the &#x27;<span class="variable">$(srctree)</span>&#x27; directory.&quot;</span>;\</span><br><span class="line">        /bin/false; \</span><br><span class="line">    fi;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>当我们指定了<code> O=DIR</code> 参数时，发现如果源代码中在之前的编译中有残留的之前编译过的中间文件，编译过程就会报错，系统会提示我们使用<code>make mrprope</code>将之前的所有编译中间文件清除，再重新编译。<code>prepare3</code>的作用就是起到检查内核源码是否干净。</p>
<p>从源码中可以看出，<code>prepare3 </code>将会检查的文件有:</p>
<p> <code>$(srctree)/include/config、$(srctree)/arch/$(SRCARCH)/include/generated、$(srctree)/.config</code>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make help</span><br><span class="line">Cleaning targets:</span><br><span class="line">  clean           - Remove most generated files but keep the config and</span><br><span class="line">                    enough build support to build external modules</span><br><span class="line">  mrproper        - Remove all generated files + config + various backup files</span><br><span class="line">  distclean       - mrproper + remove editor backup and patch files</span><br></pre></td></tr></table></figure>

<p>输入<code>make help</code>可以看到clean目标的程度。</p>
<p>4.2 <code>outputMakefile</code></p>
<p>前面讲过了。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html">Uboot顶层Makefile解析-1. defconfig过程分析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<p>4.3 <code>asm-generic、version_h、autoksyms_h、 include/generated/utsrelease.h</code></p>
<p>产生相关头文件。</p>
<h4><span id="1-1-5-3-vmlinux-dirs-zhan-kai">1.1.5.3 <code>vmlinux-dirs</code>展开</span><a href="#1-1-5-3-vmlinux-dirs-zhan-kai" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">946 $(vmlinux-dirs): prepare scripts</span><br><span class="line">947 	<span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=<span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>第947行内容进行展开:<br><code>@ make -f ./scripts/Makefile.build obj=$@</code><br>$@在makefile中表示target，因此就是为vmlinux-dirs 的值，将 vmlinux-dirs 中的这些目录全部带入到命令中：</p>
<pre><code>@ make -f ./scripts/Makefile.build obj=init
@ make -f ./scripts/Makefile.build obj=usr
@ make -f ./scripts/Makefile.build obj=arch/arm/vfp
@ make -f ./scripts/Makefile.build obj=arch/arm/vdso
@ make -f ./scripts/Makefile.build obj=arch/arm/kernel
@ make -f ./scripts/Makefile.build obj=arch/arm/mm
@ make -f ./scripts/Makefile.build obj=arch/arm/common
@ make -f ./scripts/Makefile.build obj=arch/arm/probes
@ make -f ./scripts/Makefile.build obj=arch/arm/net
@ make -f ./scripts/Makefile.build obj=arch/arm/crypto
@ make -f ./scripts/Makefile.build obj=arch/arm/firmware
@ make -f ./scripts/Makefile.build obj=arch/arm/mach-imx
@ make -f ./scripts/Makefile.build obj=kernel
@ make -f ./scripts/Makefile.build obj=mm
@ make -f ./scripts/Makefile.build obj=fs
@ make -f ./scripts/Makefile.build obj=ipc
@ make -f ./scripts/Makefile.build obj=security
@ make -f ./scripts/Makefile.build obj=crypto
@ make -f ./scripts/Makefile.build obj=block
@ make -f ./scripts/Makefile.build obj=drivers
@ make -f ./scripts/Makefile.build obj=sound
@ make -f ./scripts/Makefile.build obj=firmware
@ make -f ./scripts/Makefile.build obj=net
@ make -f ./scripts/Makefile.build obj=arch/arm/lib
@ make -f ./scripts/Makefile.build obj=lib
</code></pre>
<p>以<code>@ make -f ./scripts/Makefile.build obj=init</code>这个命令为例，讲解一下详细的运行过程。可以看到这些命令运行过程其实都是一样的。再次打开scripts&#x2F;Makefile.build，这个在做xxx_defconfig时已经分析过了：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/6.png" alt="image"><br>当 只 编 译 Linux 内 核 镜 像 文 件 ， 也 就 是 使 用 <code>“ make zImage ” </code>编 译 的 时 候 ，<code>KBUILD_BUILTIN=1，KBUILD_MODULES</code> 为空。<code>“make”</code>命令是会编译所有的东西，包括 Linux内核镜像文件和一些模块文件。如果只编译 Linux 内核镜像的话，<code>__build </code>目标简化为：<br><code>__build: $(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always)</code><br> <code>@:</code><br>重点看下<code>builtin-target</code>这个依赖，同样定义在scripts&#x2F;Makefile.build如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">86 <span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> $(obj-y)</span> $(obj-m) $(obj-) $(subdir-m) $(lib-target)),)</span><br><span class="line">87 builtin-target := <span class="variable">$(obj)</span>/built-in.o</span><br><span class="line">88 <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>可以看到只要<code>obj-y、obj-m、obj-、subdir-m 和 lib-target </code>这些变量不能全部为空，<code>builtin-target </code>变量的值为：<code>“$(obj)/built-in.o”</code>， 这就是这些 built-in.o 的来源了。我们以<code>@ make -f ./scripts/Makefile.build obj=init</code>这个命令为例:<br>那么现在开始编译：<br><code>builtin-target := init/built-in.o</code></p>
<p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/7.png" alt="image"></p>
<p>目标<code>builtin-target</code>依赖为 obj-y，命令为<code>$(call if_changed,link_o_target)</code>，也就是调用函数<code> if_changed</code>，参数为<code> link_o_target</code>，其返回值就是具体的命令。前面讲过了<code>if_changed</code> <a href="https://www.cnblogs.com/fuzidage/p/17901135.html" title="uboot顶层makefile-2编译过程">uboot顶层makefile-2编译过程</a>，<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/8.png" alt="image"></p>
<p>它会调用 <code>cmd_$(1)</code>所对应的命令<code>($(1)就是函数的第 1 个参数)</code>，因此这里就是调用：<br><code>cmd_link_o_target</code>，也就是:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">331 cmd_link_o_target = <span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">strip</span> $(obj-y)</span>),\</span><br><span class="line">	332 <span class="variable">$(LD)</span> <span class="variable">$(ld_flags)</span> -r -o <span class="variable">$@</span> <span class="variable">$(<span class="built_in">filter</span> $(obj-y)</span>, <span class="variable">$^</span>) \</span><br><span class="line">	333 <span class="variable">$(cmd_secanalysis)</span>,\</span><br><span class="line">	334 rm -f <span class="variable">$@</span>; <span class="variable">$(AR)</span> rcs<span class="variable">$(KBUILD_ARFLAGS)</span> <span class="variable">$@</span>)</span><br></pre></td></tr></table></figure>
<p><code>cmd_link_o_target </code>就是使用 LD将某个目录下的所有.o 文件链接在一起，最终形成 built-in.o。<br>命令会记录到<code>.built-in.o.cmd</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmd_init/built-in.o :=  arm-linux-gnueabihf-ld -EL    -r -o init/built-in.o init/main.o init/version.o init/mounts.o init/initramfs.o init/calibrate.o init/init_task.o</span><br></pre></td></tr></table></figure>

<p>同理，其他的依赖项<code>built-in.o</code>也是同样的方式编译。</p>
<h3><span id="1-1-6-link-vmlinux">1.1.6 link-vmlinux</span><a href="#1-1-6-link-vmlinux" class="header-anchor">#</a></h3><p>vmlinux的依赖产生完后，调用<code>+$(call if_changed,link-vmlinux)</code>链接生成 vmlinux。<br>命令<code>“+$(call if_changed,link-vmlinux)”</code>表示将<code>$(call if_changed,link-vmlinux)</code>的结果作为最终生成 vmlinux 的命令，前面的“+”表示该命令结果不可忽略。<code>$(call if_changed,link-vmlinux)</code>是调用函数<code> if_changed</code>，<code>link-vmlinux</code> 是函数<code>if_changed</code>的参数，函数<code> if_changed</code> 定义在文件 scripts&#x2F;Kbuild.include 中：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/9.png" alt="image"></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17901135.html" title="uboot顶层makefile-2编译过程">uboot顶层makefile-2编译过程</a>有具体分析<code> if_changed</code>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">总结：当依赖比目标新的时候，或者命令有改变的时候，if_changed 就会执行一些命令</span><br><span class="line">“@set -e”告诉 bash，如果任何语句的执行结果不为 true(也就是执行出错)的话就直接退出。</span><br><span class="line">$(echo-cmd)用于打印命令执行过程，比如在链接 vmlinux 的时候就会输出“LINK vmlinux”。$(cmd_$(1))中的$(1)表示参数，也就是 link-vmlinux，因此$(cmd_$(1))表示执行 cmd_link-vmlinux 的内容。</span><br></pre></td></tr></table></figure>

<p>打开<code>.vmlinux.cmd</code>文件内容如下：<br><code>cmd_vmlinux := /bin/bash scripts/link-vmlinux.sh arm-linux-gnueabihf-ld -EL  -p --no-undefined -X --pic-veneer --build-id</code><br><code>cmd_link-vmlinux </code>在顶层 Makefile 中定义如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">914 <span class="comment"># Final link of vmlinux</span></span><br><span class="line">915 cmd_link-vmlinux = <span class="variable">$(CONFIG_SHELL)</span> <span class="variable">$&lt;</span> <span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(LDFLAGS_vmlinux)</span></span><br><span class="line">916 quiet_cmd_link-vmlinux = LINK <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>第 915 行就是 <code>cmd_link-vmlinux</code> 的值，其中 <code>CONFIG_SHELL=/bin/bash</code>，<code>$&lt;</code>表示目标 vmlinux的第一个依赖文件，也就是 <code>scripts/link-vmlinux.sh</code>。<br><code>LD= arm-linux-gnueabihf-ld -EL</code>，<code>LDFLAGS </code>为空。<code>LDFLAGS_vmlinux </code>的值由顶层 Makefile 和arch&#x2F;arm&#x2F;Makefile 这两个文件共同决定，最终:<br><code>LDFLAGS_vmlinux=-p --no-undefined -X --pic-veneer --build-id</code><br>因此 <code>cmd_link-vmlinux </code>最终的值:<br><code>cmd_link-vmlinux = /bin/bash scripts/link-vmlinux.sh arm-linux-gnueabihf-ld -EL -p --no-undefined -X --pic-veneer --build-id</code><br><code>cmd_link-vmlinux </code>会调用<code>scripts/link-vmlinux.sh</code>这个脚本来链接出 vmlinux。脚本内容如下：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/10.png" alt="image"><br><strong>vmliux_link</strong> 就是最终链接出 vmlinux 的函数，判断 <code>SRCARCH </code>是否不等于<code>“um”</code>，因为<code> SRCARCH=arm</code>，因此条件成立。执行：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;LD&#125; $&#123;LDFLAGS&#125; $&#123;LDFLAGS_vmlinux&#125; -o $&#123;2&#125; \</span><br><span class="line">	-T $&#123;lds&#125; $&#123;KBUILD_VMLINUX_INIT&#125; \</span><br><span class="line">	--start-group $&#123;KBUILD_VMLINUX_MAIN&#125; --end-group $&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>这三行代码应该很熟悉了！ 就是普通的链接操作，连接脚本为<code>lds= ./arch/arm/kernel/vmlinux.lds</code> ，需要链接的文件由变量<code>KBUILD_VMLINUX_INIT</code>和<code>KBUILD_VMLINUX_MAIN </code>来决定，这两个变量在前面讲过了：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KBUILD_VMLINUX_INIT= $(head-y) $(init-y)</span><br><span class="line">KBUILD_VMLINUX_MAIN = $(core-y) $(libs-y) $(drivers-y) $(net-y)</span><br><span class="line">KBUILD_LDS= arch/<span class="variable">$(SRCARCH)</span>/kernel/vmlinux.lds  <span class="comment">#链接脚本</span></span><br></pre></td></tr></table></figure>

<p>第 217 行调用 vmlinux_link 函数来链接出 vmlinux。<br>编译时V&#x3D;1即可看到详细LD链接过程如下：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/11.png" alt="image"><br>总结：将各个子目录下的 built-in.o、.a 等文件链接在一起，最终生成 vmlinux 这个 ELF 格式的可执行文件。链接脚本为arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds，链接过程是由shell脚本scripts&#x2F;link-vmlinux.s来完成的。</p>
<h3><span id="1-1-7-xin-ban-de-link-vmlinux">1.1.7 新版的link-vmlinux</span><a href="#1-1-7-xin-ban-de-link-vmlinux" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmd_link-vmlinux =                                                 \</span><br><span class="line">    <span class="variable">$(CONFIG_SHELL)</span> <span class="variable">$&lt;</span> <span class="variable">$(LD)</span> <span class="variable">$(KBUILD_LDFLAGS)</span> <span class="variable">$(LDFLAGS_vmlinux)</span> ;    \</span><br><span class="line">    <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(ARCH_POSTLINK)</span>, <span class="variable">$(MAKE)</span> -f <span class="variable">$(ARCH_POSTLINK)</span> <span class="variable">$@</span>, true)</span></span><br><span class="line">    </span><br><span class="line"><span class="section">vmlinux: scripts/link-vmlinux.sh autoksyms_recursive $(vmlinux-deps) FORCE</span></span><br><span class="line">    +<span class="variable">$(<span class="built_in">call</span> if_changed,link-vmlinux)</span></span><br></pre></td></tr></table></figure>

<h4><span id="1-1-7-1-autoksyms-recursive">1.1.7.1 autoksyms_recursive</span><a href="#1-1-7-1-autoksyms-recursive" class="header-anchor">#</a></h4><p>内核的符号优化。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">autoksyms_recursive: $(vmlinux-deps)</span></span><br><span class="line"><span class="keyword">ifdef</span> CONFIG_TRIM_UNUSED_KSYMS</span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(CONFIG_SHELL)</span> <span class="variable">$(srctree)</span>/scripts/adjust_autoksyms.sh \</span><br><span class="line">      <span class="string">&quot;<span class="variable">$(MAKE)</span> -f <span class="variable">$(srctree)</span>/Makefile vmlinux&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>如果在源码的配置阶段定义了<code>CONFIG_TRIM_UNUSED_KSYMS</code>这个变量，就执行：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(Q)</span><span class="variable">$(CONFIG_SHELL)</span> <span class="variable">$(srctree)</span>/scripts/adjust_autoksyms.sh \</span><br><span class="line">      <span class="string">&quot;<span class="variable">$(MAKE)</span> -f <span class="variable">$(srctree)</span>/Makefile vmlinux&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，这里的脚本并不会执行。</p>
<p><code> if_changed</code>,执行<code>link-vmlinux</code>,也就是<code>cmd_link-vmlinux</code>.</p>
<h2><span id="1-2-make-zimage-guo-cheng">1.2 make zImage过程</span><a href="#1-2-make-zimage-guo-cheng" class="header-anchor">#</a></h2><p>当我们输入：<br><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all</code>会编译vmlinux, zImage,然后再编译dtb,编译ko。</p>
<h3><span id="1-2-1-vmlinux-image-zimage-uimage-de-qu-bie">1.2.1 vmlinux、Image，zImage、uImage 的区别</span><a href="#1-2-1-vmlinux-image-zimage-uimage-de-qu-bie" class="header-anchor">#</a></h3><p>①、vmlinux 是编译出来的最原始的内核文件，是未压缩的，比如正点原子提供的 Linux 源码编译出来的 vmlinux 差不多有 16MB。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lh vmlinux</span><br><span class="line">-rwxrwxr-x 1 robin.lee robin.lee 17M 1月  29 16:26 vmlinux</span><br></pre></td></tr></table></figure>
<p>②、Image 是 Linux 内核镜像文件，但是 Image 仅包含可执行的二进制数据。Image 就是使用 objcopy 取消掉 vmlinux 中的一些其他信息，比如符号表什么的。但是 Image 是没有压缩过的，Image 保存在 arch&#x2F;arm&#x2F;boot 目录下，其大小大概在 12MB 左右。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lh <span class="built_in">arch</span>/arm/boot/Image</span><br><span class="line">-rwxrwxr-x 1 robin.lee robin.lee 13M 1月  29 16:26 <span class="built_in">arch</span>/arm/boot/Image</span><br></pre></td></tr></table></figure>

<p>③、zImage 是经过 gzip 压缩后的 Image，经过压缩以后其大小大概在 6MB 左右。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lh <span class="built_in">arch</span>/arm/boot/zImage</span><br><span class="line">-rwxrwxr-x 1 robin.lee robin.lee 6.5M 1月  29 16:26 <span class="built_in">arch</span>/arm/boot/zImage</span><br></pre></td></tr></table></figure>
<p>④、uImage 是老版本 uboot 专用的镜像文件，uImag 是在 zImage 前面加了一个长度为 64字节的“头”，这个头信息描述了该镜像文件的类型、加载位置、生成时间、大小等信息。但是新的 uboot 已经支持了 zImage 启动！所以已经很少用到 uImage 了，除非你用的很古老的 uboot。</p>
<h3><span id="1-2-2-image-de-bian-yi-guo-cheng">1.2.2 Image的编译过程</span><a href="#1-2-2-image-de-bian-yi-guo-cheng" class="header-anchor">#</a></h3><p>使用<code>“make”、“make all”、“make zImage”</code>都可以编译出zImage, arch&#x2F;arm&#x2F;Makefile 中有如下代码:<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/12.png" alt="image"><br>all依赖<code>$(KBUILD_IMAGE) $(KBUILD_DTBS)</code>, <code>KBUILD_IMAGE</code>为zImage， <code>KBUILD_DTBS</code>为dtbs。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#boot 对应目录</span></span><br><span class="line">boot := arch/arm/boot</span><br><span class="line"><span class="comment">#实际镜像</span></span><br><span class="line">BOOT_TARGETS    = zImage Image xipImage bootpImage uImage</span><br><span class="line"><span class="comment">#镜像生成规则</span></span><br><span class="line"><span class="variable">$(BOOT_TARGETS)</span>: vmlinux</span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=<span class="variable">$(boot)</span> MACHINE=<span class="variable">$(MACHINE)</span> <span class="variable">$(boot)</span>/<span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>可以看到当vmlinux产生后，就会去继续产生zImage, 展开：<br><code>@ make -f ./scripts/Makefile.build obj=arch/arm/boot MACHINE=arch/arm/boot/zImage</code><br>可以看到又是通过scripts&#x2F;Makefile.build来完成的编译。进入<code>arch/arm/boot</code>的makefile:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">rm Image zImage</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- Image V=1</span><br></pre></td></tr></table></figure>

<p>Image生成过程:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Image 生成的规则</span></span><br><span class="line"><span class="variable">$(obj)</span>/Image: vmlinux FORCE</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed,objcopy)</span></span><br></pre></td></tr></table></figure>

<p>执行<code>cmd_objcopy</code>,该命令定义在<code>scripts/Makefile.lib </code>中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在arch/$(ARCH)/boot/Makefile 下定义</span></span><br><span class="line">OBJCOPYFLAGS    :=-O binary -R .comment -S</span><br><span class="line"><span class="comment">#scripts/Makefile.lib</span></span><br><span class="line">cmd_objcopy = <span class="variable">$(OBJCOPY)</span> <span class="variable">$(OBJCOPYFLAGS)</span> $(OBJCOPYFLAGS_$(@F)) <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>打印如下:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f ./scripts/Makefile.build obj=arch/arm/boot MACHINE= arch/arm/boot/Image</span><br><span class="line">  arm-linux-gnueabihf-objcopy -O binary -R .comment -S  vmlinux arch/arm/boot/Image</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-zimage-de-bian-yi-guo-cheng">1.2.3 zImage的编译过程</span><a href="#1-2-3-zimage-de-bian-yi-guo-cheng" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage V=1</span><br></pre></td></tr></table></figure>

<p>zImage生成过程:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>/zImage:  <span class="variable">$(obj)</span>/compressed/vmlinux FORCE</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed,objcopy)</span></span><br></pre></td></tr></table></figure>

<p>打印如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f ./scripts/Makefile.build obj=arch/arm/boot MACHINE= arch/arm/boot/zImage</span><br><span class="line">make -f ./scripts/Makefile.build obj=arch/arm/boot/compressed arch/arm/boot/compressed/vmlinux</span><br><span class="line">  (cat arch/arm/boot/compressed/../Image | lzop -9 &amp;&amp; printf \000\100\303\000) &gt; arch/arm/boot/compressed/piggy.lzo || (rm -f arch/arm/boot/compressed/piggy.lzo ; false)</span><br><span class="line">  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/boot/compressed/.piggy.lzo.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/<span class="keyword">include</span> -I./arch/arm/<span class="keyword">include</span> -Iarch/arm/<span class="keyword">include</span>/generated/uapi -Iarch/arm/<span class="keyword">include</span>/generated  -Iinclude -I./arch/arm/<span class="keyword">include</span>/uapi -Iarch/arm/<span class="keyword">include</span>/generated/uapi -I./<span class="keyword">include</span>/uapi -Iinclude/generated/uapi <span class="keyword">-include</span> ./<span class="keyword">include</span>/linux/kconfig.h -D__KERNEL__ -mlittle-endian   -D__ASSEMBLY__ -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -funwind-tables -marm -D__LINUX_ARM_ARCH__=7 -march=armv7-a  <span class="keyword">-include</span> asm/unified.h -msoft-float -DCC_HAVE_ASM_GOTO        -DZIMAGE     -c -o arch/arm/boot/compressed/piggy.lzo.o arch/arm/boot/compressed/piggy.lzo.S</span><br><span class="line">  arm-linux-gnueabihf-ld -EL    --defsym _kernel_bss_size=463520 -p --no-undefined -X -T arch/arm/boot/compressed/vmlinux.lds arch/arm/boot/compressed/head.o arch/arm/boot/compressed/piggy.lzo.o arch/arm/boot/compressed/misc.o arch/arm/boot/compressed/decompress.o arch/arm/boot/compressed/string.o arch/arm/boot/compressed/hyp-stub.o arch/arm/boot/compressed/lib1funcs.o arch/arm/boot/compressed/ashldi3.o arch/arm/boot/compressed/bswapsdi2.o -o arch/arm/boot/compressed/vmlinux</span><br><span class="line">  arm-linux-gnueabihf-objcopy -O binary -R .comment -S  arch/arm/boot/compressed/vmlinux arch/arm/boot/zImage</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-4-objcopyflags">1.2.4 OBJCOPYFLAGS</span><a href="#1-2-4-objcopyflags" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">-O binary：表示输出格式为 binary，也就是二进制</span><br><span class="line">-R .comment：表示移除二进制文件中的 .comment 段，这个段主要用于 debug</span><br><span class="line">-S ： 表示移除所有的符号以及重定位信息</span><br></pre></td></tr></table></figure>

<h1><span id="2-sheng-cheng-de-wen-jian">2 生成的文件</span><a href="#2-sheng-cheng-de-wen-jian" class="header-anchor">#</a></h1><p><code>System.map</code>： 内核镜像中所有的符号，符号表<br><code>.*.o.d 和 .*.o.cmd: </code>记录编译指令的内容，如：<code>.vmlinux.cmd</code><br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/13.png" alt="image"></p>
<p><code>modules.order</code> 、 <code>modules.build</code> 和 <code>modules.builtin.modinfo :</code> 这两个文件主要负责记录编译的模块，<code>modules.builtin.modinfo</code>记录模块信息，以供 modprobe 使用<br><code>arch/$(ARCH)/boot</code> : 编译出的文件，一般包含这几部分：镜像、内核符号表、系统dtb。<br><code>include/generate/*</code> : 内核编译过程将会生成一些头文件，其中比较重要的是 autoconf.h，这是 .config 的头文件版本，以及uapi&#x2F;目录下的文件，这个目录下的保存着用户头文件。<br><code>include/config/* </code>： 为了解决 autoconf.h 牵一发而动全身的问题(即修改一个配置导致所有依赖 autoconf.h 的文件需要重新编译)，将 autoconf.h 分散为多个头文件放在 include&#x2F;config&#x2F; 下，以解决 autoconf.h 的依赖问题。</p>
<h1><span id="3-she-bei-shu-de-bian-yi-guo-cheng">3 设备树的编译过程</span><a href="#3-she-bei-shu-de-bian-yi-guo-cheng" class="header-anchor">#</a></h1><p>Linux内核目录下<code>make all</code>会把dtb也编译出来。详见<a href="https://www.cnblogs.com/fuzidage/p/17363949.html">字符设备驱动-4.设备树</a> 第2.3 DTB文件的编译。</p>
<p><code>make dtbs V=1</code>可查看详细编译过程。</p>
<h2><span id="3-1-sheng-cheng-dtc-gong-ju">3.1 生成dtc工具</span><a href="#3-1-sheng-cheng-dtc-gong-ju" class="header-anchor">#</a></h2><p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/14.png" alt="image-20240719001049071"></p>
<h2><span id="3-2-sheng-cheng-dtb">3.2 生成dtb</span><a href="#3-2-sheng-cheng-dtb" class="header-anchor">#</a></h2><p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/15.png" alt="image-20240719001248018"></p>
<p>vmlinux和zImage产生后会继续编译设备树，用dtc编译dts得到dtb。</p>
]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核启动流程</title>
    <url>/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-lian-jie-jiao-ben-vmlinux-lds">1 链接脚本vmlinux.lds</a></li>
<li><a href="#2-linux-nei-he-qi-dong-liu-cheng">2 Linux 内核启动流程</a><ul>
<li><a href="#2-0-linux-kernel-qi-dong-liu-cheng-gai-shu">2.0 Linux kernel启动流程概述</a></li>
<li><a href="#2-1pre-linux-nei-he-jing-xiang-jie-ya">2.1pre linux内核镜像解压</a></li>
<li><a href="#2-1-linux-nei-he-ru-kou-stext">2.1 Linux 内核入口 stext</a><ul>
<li><a href="#2-1-0-create-page-tables">2.1.0 <code>__create_page_tables</code></a></li>
<li><a href="#2-1-1-enable-mmu">2.1.1 <code>__enable_mmu</code></a><ul>
<li><a href="#2-1-1-1-mmap-switched">2.1.1.1 <code>__mmap_switched</code></a><ul>
<li><a href="#2-1-1-1-1-start-kernel">2.1.1.1.1 start_kernel</a><ul>
<li><a href="#2-1-1-1-1-1-setup-arch">2.1.1.1.1.1 setup_arch</a></li>
<li><a href="#2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args">2.1.1.1.1.2 setup_command_line、parse_early_param以及parse_args</a></li>
<li><a href="#2-1-1-1-1-n-reset-init">2.1.1.1.1.n reset_init</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-kernel-init-init-jin-cheng-xiang-jie">2.2 kernel_init(init进程详解)</a><ul>
<li><a href="#2-2-1-kernel-init-freeable">2.2.1 kernel_init_freeable</a><ul>
<li><a href="#2-2-1-1-driver-init">2.2.1.1 driver_init</a></li>
<li><a href="#2-2-1-2-she-zhi-kong-zhi-tai">2.2.1.2 设置控制台</a></li>
<li><a href="#2-2-1-3-gua-zai-gen-wen-jian-xi-tong">2.2.1.3 挂载根文件系统</a><ul>
<li><a href="#2-2-1-3-1-init-fu-wu">2.2.1.3.1 init 服务</a><ul>
<li><a href="#2-2-1-3-1-1-rc-sysinit">2.2.1.3.1.1 rc.sysinit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-linux-nei-he-initcall-ji-zhi">3 Linux内核initcall机制</a><ul>
<li><a href="#3-1-xxx-initcall-de-yuan-ma">3.1 xxx_initcall的源码</a></li>
<li><a href="#3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong">3.2 xxx_initcall修饰的函数怎么被调用</a><ul>
<li><a href="#3-2-1-do-initcalls">3.2.1 do_initcalls</a><ul>
<li><a href="#3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian">3.2.1.1 <code>__initcall##level##_start</code>与<code>.initcall##level##.init</code>段的关联</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-lian-jie-jiao-ben-vmlinux-lds">1 链接脚本vmlinux.lds</span><a href="#1-lian-jie-jiao-ben-vmlinux-lds" class="header-anchor">#</a></h1><p>先编译一下 Linux 源码，因为有很多文件是需要编译才会生成的。首先分析 Linux 内核的连接脚本文件 <code>arch/arm/kernel/vmlinux.lds</code>，通过链接脚本可以找到 Linux 内核的第一行程序是从哪里执行的。vmlinux.lds 中有如下代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">492</span> OUTPUT_ARCH(arm)</span><br><span class="line"><span class="number">493</span> ENTRY(stext)</span><br><span class="line"><span class="number">494</span> jiffies = jiffies_64;</span><br><span class="line"><span class="number">495</span> SECTIONS</span><br><span class="line"><span class="number">496</span> &#123;</span><br><span class="line"><span class="number">497</span> 	<span class="comment">/*</span></span><br><span class="line"><span class="comment">498 	* <span class="doctag">XXX:</span> The linker does not define how output sections are</span></span><br><span class="line"><span class="comment">499 	* assigned to input sections when there are multiple statements</span></span><br><span class="line"><span class="comment">500 	* matching the same input section name. There is no documented</span></span><br><span class="line"><span class="comment">501 	* order of matching.</span></span><br><span class="line"><span class="comment">502 	*</span></span><br><span class="line"><span class="comment">503 	* unwind exit sections must be discarded before the rest of the</span></span><br><span class="line"><span class="comment">504 	* unwind sections get included.</span></span><br><span class="line"><span class="comment">505 	*/</span></span><br><span class="line"><span class="number">506</span> 	/DISCARD/ : &#123;</span><br><span class="line"><span class="number">507</span> 	*(.ARM.exidx.<span class="built_in">exit</span>.text)</span><br><span class="line"><span class="number">508</span> 	*(.ARM.extab.<span class="built_in">exit</span>.text)</span><br><span class="line"><span class="number">509</span> 	</span><br><span class="line">......</span><br><span class="line"><span class="number">645</span> &#125;</span><br></pre></td></tr></table></figure>

<p>ENTRY 指明了了 Linux 内核入口，入口为 stext，stext 定义在文件arch&#x2F;arm&#x2F;kernel&#x2F;head.S 中 ， 因 此 要 分 析 Linux 内 核 的 启 动 流 程 ， 就 得 先 从 文 件arch&#x2F;arm&#x2F;kernel&#x2F;head.S 的 stext 处开始分析。</p>
<h1><span id="2-linux-nei-he-qi-dong-liu-cheng">2 Linux 内核启动流程</span><a href="#2-linux-nei-he-qi-dong-liu-cheng" class="header-anchor">#</a></h1><h2><span id="2-0-linux-kernel-qi-dong-liu-cheng-gai-shu">2.0 Linux kernel启动流程概述</span><a href="#2-0-linux-kernel-qi-dong-liu-cheng-gai-shu" class="header-anchor">#</a></h2><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/0.png" alt="image-20240720160759323"></p>
<h2><span id="2-1pre-linux-nei-he-jing-xiang-jie-ya">2.1pre linux内核镜像解压</span><a href="#2-1pre-linux-nei-he-jing-xiang-jie-ya" class="header-anchor">#</a></h2><p><code>kernel/lib/inflate.c</code>的<code>decompress_kernel</code>，<code> inflate.c</code>是从gzip 插件源代码移过来的。解压完后会看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UncompressingLinux...done, booting the kernel.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">call_kernel: bl    cache_clean_flush</span><br><span class="line">  bl    cache_off</span><br><span class="line">  mov       r0, #<span class="number">0</span>          @ must be zero</span><br><span class="line">  mov       r1, r7          @ restore architecture number</span><br><span class="line">  mov       r2, r8          @ restore atags pointer</span><br><span class="line">  mov       pc, r4          @ call kernel</span><br></pre></td></tr></table></figure>

<p> r4 中已经在head.S处预置为内核镜像的地址,因此会跳转到r4去执行，就是Linux 内核入口 stext。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUTO_ZRELADDR</span></span><br><span class="line">  @determine final kernel image address</span><br><span class="line">  mov       r4, pc</span><br><span class="line">  and r4, r4, #<span class="number">0xf8000000</span></span><br><span class="line">  add r4, r4, #TEXT_OFFSET</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  ldr   r4, =zreladdr</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2><span id="2-1-linux-nei-he-ru-kou-stext">2.1 Linux 内核入口 stext</span><a href="#2-1-linux-nei-he-ru-kou-stext" class="header-anchor">#</a></h2><p>打开arch&#x2F;arm&#x2F;kernel&#x2F;head.S可以看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Kernel startup entry point.</span></span><br><span class="line"><span class="comment">* ---------------------------</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This is normally called from the decompressor code. The requirements</span></span><br><span class="line"><span class="comment">* are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,</span></span><br><span class="line"><span class="comment">* r1 = machine nr, r2 = atags or dtb pointer.</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Linux 内核的入口点 stext 其实相当于内核的入口函数，stext 函数内容如下：</p>
<p>依据上面的注释内容，Linux 内核启动之前要求如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">①、关闭 MMU。</span><br><span class="line">②、关闭 D-cache。</span><br><span class="line">③、I-Cache 无所谓。</span><br><span class="line">④、r0=<span class="number">0</span>。</span><br><span class="line">⑤、r1=machine nr(也就是机器 ID)。</span><br><span class="line">⑥、r2=atags 或者设备树(dtb)首地址。</span><br></pre></td></tr></table></figure>

<p>stext代码如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image"></p>
<p>第 92 行，调用函数 <code>safe_svcmode_maskall</code> 确保 CPU 处于 SVC 模式，并且关闭了所有的中断。<code>safe_svcmode_maskall </code>定义在文件 <code>arch/arm/include/asm/assembler.h </code>中。<br>第 94 行，读处理器 ID，ID 值保存在 r9 寄存器中。<br>第 95 行，调用函数<code>__lookup_processor_type </code>检查当前系统是否支持此 CPU，如果支持就获取 procinfo 信 息 。 procinfo 是 <code>proc_info_list </code>类 型 的 结 构 体，<code>proc_info_list </code>在 文 件<code>arch/arm/include/asm/procinfo.h </code>中的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> &#123;</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> cpu_val;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> cpu_mask;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_mm_mmu_flags; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_io_mmu_flags; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_flush; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *arch_name;</span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *elf_name;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> elf_hwcap;</span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *cpu_name;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">processor</span> *<span class="title">proc</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_tlb_fns</span> *<span class="title">tlb</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_user_fns</span> *<span class="title">user</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_cache_fns</span> *<span class="title">cache</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每种处理器都抽象为一个 proc_info_list 结构体，每种处理器都对应一个procinfo。因此可以通过处理器 ID 来找到对应的 procinfo 结构，<code>__lookup_processor_type </code>函数找到对应处理器的 procinfo 以后会将其保存到 r5 寄存器中。</p>
<p>第121行，函数<code>__vet_atags </code>验证 atags 或设备树(dtb)的合法性。函数<code>__vet_atags </code>定义在文件 <code>arch/arm/kernel/head-common.S </code>中。<br>第128行，调用函数<code>__create_page_tables </code>创建页表。<br>第 137 行，将函数<code>__mmap_switched</code> 的地址保存到 r13 寄存器中。<code>__mmap_switched </code>定义在文件 <code>arch/arm/kernel/head-common.S</code>，<code>__mmap_switched</code> 最终会调用 start_kernel 函数。<br>第 144 行 ， 调 用 <code>__enable_mmu </code>函 数 使 能 MMU ，<code>__enable_mmu</code>定 义 在 文 件<code>arch/arm/kernel/head.S </code>中。<code>__enable_mmu</code> 最终会通过调用<code>__turn_mmu_on </code>来打开 MMU，<code>__turn_mmu_on </code>最后会执行 r13 里面保存的<code>__mmap_switched </code>函数。</p>
<h3><span id="2-1-0-create-page-tables">2.1.0 <code>__create_page_tables</code></span><a href="#2-1-0-create-page-tables" class="header-anchor">#</a></h3><ul>
<li>内核所在物理内存块的初始地址，保存在寄存器 r8 中。</li>
<li>内核代码相对于初始地址的偏移值，是在程序编译前就确定的一个宏：<code>TEXT_OFFSET</code>，arm32 中通常是 0x8000，也就是偏移地址为 32 K，前面保留的 32K 内存就是用来存放页表。</li>
</ul>
<p>在建立页表之前，目前所处的相关寄存器环境为：<code>r8 = phys_offset, r9 = cpuid, r10 = procinfo.</code></p>
<h3><span id="2-1-1-enable-mmu">2.1.1  <code>__enable_mmu</code></span><a href="#2-1-1-enable-mmu" class="header-anchor">#</a></h3><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image"></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image"></p>
<h4><span id="2-1-1-1-mmap-switched">2.1.1.1 <code>__mmap_switched</code></span><a href="#2-1-1-1-mmap-switched" class="header-anchor">#</a></h4><p>前面讲到<code>__enable_mmu</code>会调用<code>__mmap_switched </code>函数（通过调用<code>__turn_mmu_on</code> 再调用r13）。现在具体分析它：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image"><br>可以看到<code>__mmap_switched</code>主要就是做clear bss,然后保存处理器ID, 序列号，最终跳转start_kernel函数。</p>
<h5><span id="2-1-1-1-1-start-kernel">2.1.1.1.1  start_kernel</span><a href="#2-1-1-1-1-start-kernel" class="header-anchor">#</a></h5><p>start_kernel会调用大量的子函数完成linux启动前的一些初始化工作，start_kernel 函数里面调用的子函数太多，而这些子函数又很复杂。我们简单的来看一下一些重要的子函数。精简并添加注释后的 start_kernel 函数内容如下：</p>
<details>
<summary>init/main/start_kenel函数</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *command_line;</span><br><span class="line">	<span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Need to run as early as possible, to initialize the</span></span><br><span class="line"><span class="comment">	 * lockdep hash:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_init();</span><br><span class="line">	set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">	smp_setup_processor_id();</span><br><span class="line">	debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up the the initial canary ASAP:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">	cgroup_init_early();</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are still disabled. Do necessary setups, then</span></span><br><span class="line"><span class="comment"> * enable them</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	boot_cpu_init();</span><br><span class="line">	page_address_init();</span><br><span class="line">	pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);</span><br><span class="line">	setup_arch(&amp;command_line);</span><br><span class="line">	mm_init_cpumask(&amp;init_mm);</span><br><span class="line">	setup_command_line(command_line);</span><br><span class="line">	setup_nr_cpu_ids();</span><br><span class="line">	setup_per_cpu_areas();</span><br><span class="line">	smp_prepare_boot_cpu();	<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line"></span><br><span class="line">	build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	page_alloc_init();</span><br><span class="line"></span><br><span class="line">	pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line);</span><br><span class="line">	parse_early_param();</span><br><span class="line">	after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">				  static_command_line, __start___param,</span><br><span class="line">				  __stop___param - __start___param,</span><br><span class="line">				  <span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">		parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">			   set_init_arg);</span><br><span class="line"></span><br><span class="line">	jump_label_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment">	 * kmem_cache_init()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	setup_log_buf(<span class="number">0</span>);</span><br><span class="line">	pidhash_init();</span><br><span class="line">	vfs_caches_init_early();</span><br><span class="line">	sort_main_extable();</span><br><span class="line">	trap_init();</span><br><span class="line">	mm_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment">	 * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment">	 * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sched_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Disable preemption - early bootup scheduling is extremely</span></span><br><span class="line"><span class="comment">	 * fragile until we cpu_idle() for the first time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line">		 <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">		local_irq_disable();</span><br><span class="line">	idr_init_cache();</span><br><span class="line">	rcu_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* trace_printk() and trace points may be used after this */</span></span><br><span class="line">	trace_init();</span><br><span class="line"></span><br><span class="line">	context_tracking_init();</span><br><span class="line">	radix_tree_init();</span><br><span class="line">	<span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">	early_irq_init();</span><br><span class="line">	init_IRQ();</span><br><span class="line">	tick_init();</span><br><span class="line">	rcu_init_nohz();</span><br><span class="line">	init_timers();</span><br><span class="line">	hrtimers_init();</span><br><span class="line">	softirq_init();</span><br><span class="line">	timekeeping_init();</span><br><span class="line">	time_init();</span><br><span class="line">	sched_clock_postinit();</span><br><span class="line">	perf_event_init();</span><br><span class="line">	profile_init();</span><br><span class="line">	call_function_init();</span><br><span class="line">	WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">	early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment">	 * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment">	 * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (panic_later)</span><br><span class="line">		panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">		      panic_param);</span><br><span class="line"></span><br><span class="line">	lockdep_info();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Need to run this when irqs are enabled, because it wants</span></span><br><span class="line"><span class="comment">	 * to self-test [hard/soft]-irqs on/off lock inversion bugs</span></span><br><span class="line"><span class="comment">	 * too:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line">	<span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">	    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">		pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">		    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)),</span><br><span class="line">		    min_low_pfn);</span><br><span class="line">		initrd_start = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	page_ext_init();</span><br><span class="line">	debug_objects_mem_init();</span><br><span class="line">	kmemleak_init();</span><br><span class="line">	setup_per_cpu_pageset();</span><br><span class="line">	numa_policy_init();</span><br><span class="line">	<span class="keyword">if</span> (late_time_init)</span><br><span class="line">		late_time_init();</span><br><span class="line">	sched_clock_init();</span><br><span class="line">	calibrate_delay();</span><br><span class="line">	pidmap_init();</span><br><span class="line">	anon_vma_init();</span><br><span class="line">	acpi_early_init();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">	<span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">		efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_ESPFIX64</span></span><br><span class="line">	<span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">	init_espfix_bsp();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	thread_info_cache_init();</span><br><span class="line">	cred_init();</span><br><span class="line">	fork_init();</span><br><span class="line">	proc_caches_init();</span><br><span class="line">	buffer_init();</span><br><span class="line">	key_init();</span><br><span class="line">	security_init();</span><br><span class="line">	dbg_late_init();</span><br><span class="line">	vfs_caches_init(totalram_pages);</span><br><span class="line">	signals_init();</span><br><span class="line">	<span class="comment">/* rootfs populating might need page-writeback */</span></span><br><span class="line">	page_writeback_init();</span><br><span class="line">	proc_root_init();</span><br><span class="line">	nsfs_init();</span><br><span class="line">	cpuset_init();</span><br><span class="line">	cgroup_init();</span><br><span class="line">	taskstats_init_early();</span><br><span class="line">	delayacct_init();</span><br><span class="line"></span><br><span class="line">	check_bugs();</span><br><span class="line"></span><br><span class="line">	acpi_subsystem_init();</span><br><span class="line">	sfi_init_late();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES)) &#123;</span><br><span class="line">		efi_late_init();</span><br><span class="line">		efi_free_boot_services();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ftrace_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">	rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>如下，打上注释方便清楚每个子调用的含义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lockdep_init() <span class="comment">//lockdep 是死锁检测模块，此函数会初始化两个 hash 表</span></span><br><span class="line">set_task_stack_end_magic() <span class="comment">//设置任务栈结束魔术数，用于栈溢出检测</span></span><br><span class="line">smp_setup_processor_id() <span class="comment">//跟 SMP 有关(多核处理器)，设置处理器 ID</span></span><br><span class="line">debug_objects_early_init() <span class="comment">//做一些和 debug 有关的初始化</span></span><br><span class="line">boot_init_stack_canary() <span class="comment">//栈溢出检测初始化</span></span><br><span class="line">cgroup_init_early() <span class="comment">//cgroup 初始化，cgroup 用于控制 Linux 系统资源</span></span><br><span class="line">local_irq_disable() <span class="comment">//关闭当前 CPU 中断, 中断关闭期间做一些重要的操作，然后打开中断</span></span><br><span class="line">boot_cpu_init() <span class="comment">//跟 CPU 有关的初始化</span></span><br><span class="line">page_address_init() <span class="comment">//页地址相关的初始化</span></span><br><span class="line">pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);<span class="comment">/* 打印 Linux 版本号、编译时间等信息 */</span></span><br><span class="line">setup_arch(&amp;command_line); <span class="comment">//架构相关的初始化，此函数会解析传递进来的ATAGS 或者设备树(DTB)文件。会根据设备树里面的 model 和 compatible 这两个属性值来查找Linux 是否支持这个单板。此函数也会获取设备树中 chosen 节点下的 bootargs 属性值来得到命令行参数，也就是 uboot 中的 bootargs 环境变量的值，获取到的命令行参数会保存到command_line 中</span></span><br><span class="line">mm_init_cpumask(&amp;init_mm) <span class="comment">//内存有关的初始化</span></span><br><span class="line">setup_command_line(command_line) <span class="comment">//存储命令行参数</span></span><br><span class="line">setup_nr_cpu_ids() <span class="comment">//如果只是 SMP(多核 CPU)的话，此函数用于获取CPU 核心数量，CPU 数量保存在变量nr_cpu_ids 中</span></span><br><span class="line">setup_per_cpu_areas() <span class="comment">//在 SMP 系统中有用，设置每个 CPU 的 per-cpu 数据</span></span><br><span class="line">smp_prepare_boot_cpu()</span><br><span class="line">build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">/* 建立系统内存页区(zone)链表 */</span></span><br><span class="line">page_alloc_init(); <span class="comment">/* 处理用于热插拔 CPU 的页 */</span></span><br><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line); <span class="comment">//打印命令行信息</span></span><br><span class="line">parse_early_param(); <span class="comment">/* 解析命令行中的 console 参数 */</span></span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">		static_command_line, __start___param,</span><br><span class="line">		__stop___param - __start___param,</span><br><span class="line">		<span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line">setup_log_buf(<span class="number">0</span>); <span class="comment">/* 设置 log 使用的缓冲区*/</span></span><br><span class="line">pidhash_init(); <span class="comment">// 构建 PID 哈希表，Linux 中每个进程都有一个 ID,这个 ID 叫做 PID。通过构建哈希表可以快速搜索进程信息结构体</span></span><br><span class="line">idr_init_cache(); <span class="comment">// IDR 初始化，IDR 是 Linux 内核的整数管理机制，也就是将一个整数 ID 与一个指针关联起来</span></span><br><span class="line">rcu_init(); <span class="comment">// 初始化 RCU，RCU 全称为 Read Copy Update(读-拷贝修改)</span></span><br><span class="line">trace_init(); <span class="comment">// 跟踪调试相关初始化 </span></span><br><span class="line">radix_tree_init(); <span class="comment">//基数树相关数据结构初始化</span></span><br><span class="line">early_irq_init(); <span class="comment">//初始中断相关初始化,主要是注册 irq_desc 结构体变量，因为 Linux 内核使用 irq_desc 来描述一个中断</span></span><br><span class="line">init_IRQ(); <span class="comment">/* 中断初始化 */</span></span><br><span class="line">tick_init(); <span class="comment">/* tick 初始化 */</span></span><br><span class="line">init_timers(); <span class="comment">/* 初始化定时器 */</span></span><br><span class="line">hrtimers_init(); <span class="comment">/* 初始化高精度定时器 */</span></span><br><span class="line">softirq_init(); <span class="comment">/* 软中断初始化 */</span></span><br><span class="line">timekeeping_init(); </span><br><span class="line">time_init(); <span class="comment">/* 初始化系统时间 */</span></span><br><span class="line">WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">local_irq_enable(); <span class="comment">/* 使能中断 */</span></span><br><span class="line">kmem_cache_init_late(); <span class="comment">/* slab 初始化，slab 是 Linux 内存分配器 */</span></span><br><span class="line">console_init(); <span class="comment">//初始化控制台，之前 printk 打印的信息都存放缓冲区中，并没有打印出来。只有调用此函数初始化控制台以后才能在控制台上打印信息</span></span><br><span class="line">locking_selftest() <span class="comment">/* 锁自测 */</span></span><br><span class="line">kmemleak_init(); <span class="comment">/* kmemleak 初始化，kmemleak 用于检查内存泄漏 */</span></span><br><span class="line">calibrate_delay(); <span class="comment">/* 测定 BogoMIPS 值，可以通过 BogoMIPS 来判断 CPU 的性能BogoMIPS 设置越大，说明 CPU 性能越好*/</span></span><br><span class="line">pidmap_init(); <span class="comment">/* PID 位图初始化 */</span></span><br><span class="line">anon_vma_init(); <span class="comment">/* 生成 anon_vma slab 缓存 */</span></span><br><span class="line">cred_init(); <span class="comment">/* 为对象的每个用于赋予资格(凭证) */</span></span><br><span class="line">fork_init(); <span class="comment">/* 初始化一些结构体以使用 fork 函数 */</span></span><br><span class="line">proc_caches_init(); <span class="comment">/* 给各种资源管理结构分配缓存 */</span></span><br><span class="line">buffer_init(); <span class="comment">/* 初始化缓冲缓存 */</span></span><br><span class="line">key_init(); <span class="comment">/* 初始化密钥 */</span></span><br><span class="line">security_init(); <span class="comment">/* 安全相关初始化 */</span></span><br><span class="line">vfs_caches_init(totalram_pages); <span class="comment">/* 为 VFS 创建缓存 */</span></span><br><span class="line">signals_init(); <span class="comment">/* 初始化信号 */</span></span><br><span class="line">page_writeback_init(); <span class="comment">/* 页回写初始化 */</span></span><br><span class="line">proc_root_init(); <span class="comment">/* 注册并挂载 proc 文件系统 */</span></span><br><span class="line">cpuset_init(); <span class="comment">/* 初始化 cpuset，cpuset 是将 CPU 和内存资源以逻辑性和层次性集成的一种机制，是 cgroup 使用的子系统之一*/</span></span><br><span class="line">cgroup_init(); <span class="comment">/* 初始化 cgroup */</span></span><br><span class="line">taskstats_init_early(); <span class="comment">/* 进程状态初始化 */</span></span><br><span class="line">check_bugs(); <span class="comment">/* 检查写缓冲一致性 */</span></span><br><span class="line">rest_init(); <span class="comment">/* rest_init 函数 */</span></span><br></pre></td></tr></table></figure>

<p>start_kernel完成内核初始化工作。具体包括以下部分：</p>
<p>（1）内核架构 、通用配置相关初始化</p>
<p>（2） 内存管理相关初始化</p>
<p>（3）进程管理相关初始化</p>
<p>（4）进程调度相关初始化</p>
<p>（5）网络子系统管理</p>
<p>（6）虚拟文件系统</p>
<p>（7）文件系统</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.1.png" alt="image-20240720151715291"></p>
<h6><span id="2-1-1-1-1-1-setup-arch">2.1.1.1.1.1 setup_arch</span><a href="#2-1-1-1-1-1-setup-arch" class="header-anchor">#</a></h6><p>内核架构相关的初始化函数, 包含了处理器相关参数的初始化、内核启动参数（tagged list）的获取和前期处理、内存子系统的早期初始化。</p>
<p><code>setup_arch(&amp;command_line);</code></p>
<p>若uboot中bootargs的值为空，<code>command_line = default_command_line</code>，即为内核中的默认命令行参数，其值在<code>.config</code>文件中配置，对应<code>CONFIG_CMDLINE</code>配置项。</p>
<h6><span id="2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args">2.1.1.1.1.2 setup_command_line、parse_early_param以及parse_args</span><a href="#2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args" class="header-anchor">#</a></h6><p>完成命令行参数的解析、保存。譬如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmdline = console=ttySAC2,115200 root=/dev/mmcblk0p2 rw</span><br><span class="line">init=/linuxrc rootfstype=ext3 <span class="comment">#解析为一下四个参数：</span></span><br><span class="line">console=ttySAC2,115200 <span class="comment">#指定控制台的串口设备号，及其波特率</span></span><br><span class="line">root=/dev/mmcblk0p2 rw <span class="comment">#指定根文件系统rootfs的路径</span></span><br><span class="line">init=/linuxrc <span class="comment">#指定第一个用户进程init的路径rootf stype=ext3</span></span><br></pre></td></tr></table></figure>

<h6><span id="2-1-1-1-1-n-reset-init">2.1.1.1.1.n reset_init</span><a href="#2-1-1-1-1-n-reset-init" class="header-anchor">#</a></h6><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.2.png" alt="image-20240720161109653"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd。</span><br><span class="line">    kernel_init线程中调用prepare_namespace函数挂载根文件系统rootfs；</span><br><span class="line">    然后调用init_post函数，执行根文件系统rootfs下的第一个用户进程init。</span><br><span class="line">    用户进程有4个备选方案，若command_line中init的路径错误，则会执行备用方案。</span><br><span class="line">    第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。</span><br><span class="line"></span><br><span class="line">2）调用schedule函数开启内核调度系统；</span><br><span class="line">3）调用cpu_idle函数，启动空闲进程idle，完成内核启动。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __init_refok <span class="title function_">rest_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">	rcu_scheduler_starting();</span><br><span class="line">	smpboot_thread_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to spawn init first so that it obtains pid 1, however</span></span><br><span class="line"><span class="comment">	 * the init task will end up wanting to create kthreads, which, if</span></span><br><span class="line"><span class="comment">	 * we schedule it before we create kthreadd, will OOPS.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">	numa_default_policy();</span><br><span class="line">	pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The boot idle thread must execute schedule()</span></span><br><span class="line"><span class="comment">	 * at least once to get things moving:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	init_idle_bootup_task(current);</span><br><span class="line">	schedule_preempt_disabled();</span><br><span class="line">	<span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">	cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数 rcu_scheduler_starting，启动 RCU 锁调度器。<br>调用函数 kernel_thread 创建 kernel_init 进程，也就是大名鼎鼎的 init 内核进程。init 进程的 PID 为 1。init 进程一开始是内核进程(也就是运行在内核态)，后面 init 进程会在根文件系统中查找名为“init”这个程序，这个“init”程序处于用户态，通过运行这个“init”程序，init 进程就会实现从内核态到用户态的转变。<br>调用函数 kernel_thread 创建 kthreadd 内核进程，此内核进程的 PID 为 2。kthreadd进程负责所有内核进程的调度和管理。<br>最后调用函数 cpu_startup_entry 来进入 idle 进程，cpu_startup_entry 会调用cpu_idle_loop，cpu_idle_loop 是个 while 循环，也就是 idle 进程代码。idle 进程的 PID 为 0，idle进程叫做空闲进程，如果学过 FreeRTOS 或者 UCOS 的话应该听说过空闲任务。idle 空闲进程就和空闲任务一样，当 CPU 没有事情做的时候就在 idle 空闲进程里面“瞎逛游”，反正就是给CPU 找点事做。当其他进程要工作的时候就会抢占 idle 进程，从而夺取 CPU 使用权。其实大家应该可以看到 idle 进程并没有使用 kernel_thread 或者 fork 函数来创建，因为它是有主进程演变而来的。<br>在 Linux 终端中输入<code>“ps -A”</code>就可以打印出当前系统中的所有进程，其中就能看到 init 进程和 kthreadd 进程：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.png" alt="image"><br>init 进程的 PID 为 1，kthreadd 进程的 PID 为 2。没有显示 PID 为 0 的 idle 进程，那是因为 idle 进程是内核进程。kernel_init 就是 init 进程的进程函数。</p>
<h2><span id="2-2-kernel-init-init-jin-cheng-xiang-jie">2.2 kernel_init(init进程详解)</span><a href="#2-2-kernel-init-init-jin-cheng-xiang-jie" class="header-anchor">#</a></h2><p>把reset_init中的<code>kernel_init</code> 拆出来，函数<code>kernel_init</code> 就是 init 进程具体做的工作，函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __ref <span class="title function_">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	kernel_init_freeable(); <span class="comment">/* init 进程的一些其他初始化工作 */</span></span><br><span class="line">	<span class="comment">/* need to finish all async __init code before freeing the memory */</span></span><br><span class="line">	async_synchronize_full(); <span class="comment">/* 等待所有的异步调用执行完成 */</span></span><br><span class="line">	free_initmem(); <span class="comment">/* 释放 init 段内存 */</span></span><br><span class="line">	mark_rodata_ro();</span><br><span class="line">	system_state = SYSTEM_RUNNING; <span class="comment">/* 标记系统正在运行 */</span></span><br><span class="line">	numa_default_policy();</span><br><span class="line"></span><br><span class="line">	flush_delayed_fput();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">		ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">		ramdisk_execute_command, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* We try each of these until one succeeds.</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* The Bourne shell can be used instead of init if we are</span></span><br><span class="line"><span class="comment">	* trying to recover a really broken machine.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">		ret = run_init_process(execute_command);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		panic(<span class="string">&quot;Requested init %s failed (error %d).&quot;</span>,</span><br><span class="line">		execute_command, ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">&quot;No working init found. Try passing init= option to kernel. &quot;</span></span><br><span class="line">	<span class="string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kernel_init_freeable </code>函数用于完成 init 进程的一些其他初始化工作，稍后再来具体看一下此函数。<br><code>ramdisk_execute_command </code>是一个全局的 char 指针变量，此变量值为<code>“/init”</code>，也就是根目录下的 init 程序。<code>ramdisk_execute_command </code>也可以通过 uboot 传递，在 bootargs 中使用<code>“rdinit=xxx”</code>即可，xxx 为具体的 init 程序名字。<br>如果存在<code>“/init”</code>程序的话就通过函数 <code>run_init_process </code>来运行此程序。<br>如果 <code>ramdisk_execute_command </code>为空的话就看 <code>execute_command </code>是否为空，反正不管如何一定要在根文件系统中找到一个可运行的 init 程序。<code>execute_command</code> 的值是通过uboot 传递，在 bootargs 中使用<code>“init=xxxx”</code>就可以了，比如<code>“init=/linuxrc”</code>表示根文件系统中的 linuxrc 就是要执行的用户空间 init 程序。<br>如果<code>ramdisk_execute_command</code>和 <code>execute_command </code>都为空，那么就依次查找<code>“/sbin/init”</code>、<code>“/etc/init”</code>、<code>“/bin/init”</code>和<code>“/bin/sh”</code>，这四个相当于备用 init 程序，如果这四个也不存在，那么 Linux 启动失败！<br>如果以上步骤都没有找到用户空间的 init 程序，那么就提示错误发生！</p>
<h3><span id="2-2-1-kernel-init-freeable">2.2.1 kernel_init_freeable</span><a href="#2-2-1-kernel-init-freeable" class="header-anchor">#</a></h3><p><code>kernel_init_freeable </code>定义在文件 init&#x2F;main.c 中，缩减后的函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __init <span class="title function_">kernel_init_freeable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Wait until kthreadd is all set-up.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	wait_for_completion(&amp;kthreadd_done);<span class="comment">/* 等待 kthreadd 进程准备就绪 */</span></span><br><span class="line">	smp_init(); <span class="comment">/* SMP 初始化 */</span></span><br><span class="line">	sched_init_smp(); <span class="comment">/* 多核(SMP)调度初始化 */</span></span><br><span class="line">	do_basic_setup(); <span class="comment">/* 设备初始化都在此函数中完成 */</span></span><br><span class="line">	<span class="comment">/* Open the /dev/console on the rootfs, this should never fail */</span></span><br><span class="line">	<span class="keyword">if</span> (sys_open((<span class="type">const</span> <span class="type">char</span> __user *) <span class="string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="number">0</span>) &lt; <span class="number">0</span>)	</span><br><span class="line">		pr_err(<span class="string">&quot;Warning: unable to open an initial console.\n&quot;</span>);</span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* check if there is an early userspace init. If yes, let it do </span></span><br><span class="line"><span class="comment">	* all the work</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">	<span class="keyword">if</span> (!ramdisk_execute_command)</span><br><span class="line">		ramdisk_execute_command = <span class="string">&quot;/init&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (sys_access((<span class="type">const</span> <span class="type">char</span> __user *) ramdisk_execute_command, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		ramdisk_execute_command = <span class="literal">NULL</span>;</span><br><span class="line">		prepare_namespace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Ok, we have completed the initial bootup, and</span></span><br><span class="line"><span class="comment">	* we&#x27;re essentially up and running. Get rid of the</span></span><br><span class="line"><span class="comment">	* initmem segments and start the user-mode stuff..</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* rootfs is available now, try loading the public keys</span></span><br><span class="line"><span class="comment">	* and default modules</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	integrity_load_keys();</span><br><span class="line">	load_default_modules();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-1-1-driver-init">2.2.1.1 driver_init</span><a href="#2-2-1-1-driver-init" class="header-anchor">#</a></h4><p><code>do_basic_setup</code> 函数用于完成 Linux 下设备驱动初始化工作！非常重要。do_basic_setup 会调用 <code>driver_init </code>函数完成 Linux 下驱动模型子系统的初始化。</p>
<h4><span id="2-2-1-2-she-zhi-kong-zhi-tai">2.2.1.2 设置控制台</span><a href="#2-2-1-2-she-zhi-kong-zhi-tai" class="header-anchor">#</a></h4><p>打开设备<code>“/dev/console”</code>，在 Linux 中一切皆为文件！因此<code>“/dev/console”</code>也是一个文件，此文件为控制台设备。每个文件都有一个文件描述符，此处打开的<code>“/dev/console”</code>文件描述符为 0，作为标准输入(0)。<br><code>sys_dup </code>函数将标准输入(0)的文件描述符复制了 2 次，一个作为标准输出(1)，一个作为标准错误(2)。这样标准输入、输出、错误都是&#x2F;dev&#x2F;console 了。console 通过uboot 的 bootargs 环境变量设置，<code>“console=ttymxc0,115200”</code>表示将<code>/dev/ttymxc0 </code>设置为 console，也就是 I.MX6U 的串口 1。当然，也可以设置其他的设备为 console，比如虚拟控制台 tty1，设置 tty1 为 console 就可以在 LCD 屏幕上看到系统的提示信息。</p>
<h4><span id="2-2-1-3-gua-zai-gen-wen-jian-xi-tong">2.2.1.3 挂载根文件系统</span><a href="#2-2-1-3-gua-zai-gen-wen-jian-xi-tong" class="header-anchor">#</a></h4><p>调用函数 <code>prepare_namespace</code> 来挂载根文件系统。根文件系统也是由命令行参数指定的，就是 uboot 的 bootargs 环境变量。比如<code>“root=/dev/mmcblk1p2 rootwait rw”</code>就表示根文件系统在&#x2F;dev&#x2F;mmcblk1p2 中，也就是 EMMC 的分区 2 中。</p>
<p>下面2张图都是emmc存储，分别挂载ext3格式和squashfs格式根文件系统：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image"><br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image"></p>
<p>如果根文件系统缺失错误，这里我们故意将:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200&#x27;</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>这时候挂载根文件系统时，由于没有指定<code>root=/dev/mmcblk1p2 rootwait rw</code>，因此报错如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image"><br>还能看到call trace如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image"></p>
<h5><span id="2-2-1-3-1-init-fu-wu">2.2.1.3.1 init 服务</span><a href="#2-2-1-3-1-init-fu-wu" class="header-anchor">#</a></h5><p>启动init服务时，init服务会读取<code>/etc/inittab</code>文件，<code>/etc/inittab</code>中设置了初始化系统环境的工作。 <code>/etc/inittab</code>定义 init 服务在 linux启动过程中必须依序执行以下几个Script ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/etc/rc.d/rc.sysinit</span><br><span class="line">/etc/rc.d/rc</span><br><span class="line">/etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<h6><span id="2-2-1-3-1-1-rc-sysinit">2.2.1.3.1.1 rc.sysinit</span><a href="#2-2-1-3-1-1-rc-sysinit" class="header-anchor">#</a></h6><p><code>/etc/rc.d/rc.sysinit</code>主要的功能是设置系统的基本环境:</p>
<p>(1)启动<code>udev</code></p>
<p>(2)设置内核参数：执行<code>sysctl –p</code> ,以便从 <code>/etc/sysctl.conf </code>设置内核参数</p>
<p>(3)设置系统时间：将硬件时间设置为系统时间</p>
<p>(4)启用交换内存空间：执行<code> swpaon –a –e</code>，以便根据<code>/etc/fstab</code>的设置启用所有的交换内存空间。</p>
<p>(5)检查并挂载所有文件系统：检查所有需要挂载的文件系统，以确保这些文件系统的完整性。检查完毕后以可读可写的方式挂载文件系统。</p>
<p>(6)初始化硬件设备：Linux除了在启动内核时以静态驱动程序驱动部分的硬件外，在执行<code>rc.sysinit </code>时，也会试着驱动剩余的硬件设备</p>
<h1><span id="3-linux-nei-he-initcall-ji-zhi">3 Linux内核initcall机制</span><a href="#3-linux-nei-he-initcall-ji-zhi" class="header-anchor">#</a></h1><p>linux内核提供<code>xxx_init(init_func)</code>宏定义接口,驱动开发者只需要将驱动程序的<code>init_func</code>使用<code>xxx_init()</code>来修饰，这个函数就被自动添加到了上述的段中，开发者完全不需要关心实现细节。</p>
<h2><span id="3-1-xxx-initcall-de-yuan-ma">3.1 xxx_initcall的源码</span><a href="#3-1-xxx-initcall-de-yuan-ma" class="header-anchor">#</a></h2><p>在平台对应的<code>init.h</code>文件中，可以找到<code>xxx_initcall</code>的定义：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image"></p>
<p>n是一个数字或者是数字+s，这个数字代表这个fn执行的优先级，数字越小，优先级越高，带s的fn优先级低于不带s的fn优先级。可以看到上面的从<code>pure_initcall</code>到<code>late_initcall</code>优先级依次变低。</p>
<p>这里<code>__attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;)))</code>表示编译时将目标符号放置在括号指定的段中。</p>
<p>举个例子，对<code>pure_initcall(test_init);</code>展开：</p>
<ul>
<li>首先宏展开成：<code>__define_initcall(test_init, 0)</code></li>
<li>然后接着展开：<code>static initcall_t __initcall_test_init0 = test_init;</code>这就是一个简单的变量定义。</li>
<li>同时声明<code>__initcall_test_init0这个变量</code>即使没被引用也保留符号，且将其放置在内核镜像的<code>.initcall0.init</code>段处。</li>
</ul>
<p>在开发者添加 <code>xxx_initcall(fn)</code> 时，事实上是将<code>fn</code>放置到了 <code>&quot;.initcall##level##.init&quot; </code>的段中。</p>
<h2><span id="3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong">3.2 xxx_initcall修饰的函数怎么被调用</span><a href="#3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong" class="header-anchor">#</a></h2><p>见<code>Linux-4.9.88\init\main.c</code></p>
<h3><span id="3-2-1-do-initcalls">3.2.1 do_initcalls</span><a href="#3-2-1-do-initcalls" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">-&gt; rest_init();</span><br><span class="line">    -&gt; kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">        -&gt; kernel_init()</span><br><span class="line">            -&gt; kernel_init_freeable();</span><br><span class="line">                -&gt; do_basic_setup();</span><br><span class="line">                    -&gt; do_initcalls();</span><br></pre></td></tr></table></figure>

<p>这个<code>do_initcalls()</code>就是我们需要寻找的函数了，在这个函数中执行所有使用<code>xxx_initcall()</code>声明的函数。</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/11.png" alt="image"></p>
<p><code>do_initcalls() </code>循环调用 <code>do_initcall_level(level)</code>，level就是 <code>initcall </code>的优先级数字，由 for 循环的终止条件<code>ARRAY_SIZE(initcall_levels) - 1</code>可知，总共会调用8次。</p>
<p>而 <code>do_initcall_level(level)</code> 中则会遍历 <code>initcall_levels[level] </code>中的每个函数指针，<code>initcall_levels[level] </code>实际上是对应的<code>__initcall##level##_start </code>指针变量，然后依次取出<code>__initcall##level##_start </code>指向地址存储的每个函数指针，并调用 <code>do_one_initcall(*fn)</code>，实际上就是执行当前函数。</p>
<p>这个<code>__initcall##level##_start </code>所存储的函数指针就是开发者用 <code>xxx_initcall() </code>宏添加的函数，对应<code>&quot;.initcall_##level##.init&quot;</code>段。</p>
<p>听起来很绕，举个例子：</p>
<p>比如有一个<code>core_initcall(beagle_init);</code>展开为<code>__define_initcall(beagle_init, 1)</code>，所以 <code>beagle_init() </code>这个函数被放置在<code> &quot;.initcall1.init&quot;</code>段处。</p>
<p>再比如有一个<code>core_initcall(beagle2_init);</code>, 在<code> &quot;.initcall1.init&quot;</code>段就会增加一组函数。</p>
<p>那么<code>do_one_initcall(*fn)</code> 的执行：判断<code>initcall_debug</code>的值，如果为真，则调用 <code>do_one_initcall_debug(fn); </code>如果为假，则直接调用<code>fn</code>。</p>
<p>事实上，调用<code>do_one_initcall_debug(fn)</code>只是在调用<code>fn</code>的基础上添加一些额外的打印信息，可以直接看成是调用<code>fn</code>。</p>
<p>可能有些C语言基础不太好的朋友不太理解 <code>do_initcall_level() </code>函数中依次取出地址并执行的函数执行逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)</span><br><span class="line">    do_one_initcall(*fn);</span><br></pre></td></tr></table></figure>

<p><code>fn</code>为函数指针，<code>fn++</code>相当于函数指针+1，相当于：<code>内存地址+sizeof(fn)</code>，<code>sizeof(fn)</code>根据平台不同而不同，一般来说，32位机上是4字节，64位机则是8字节.</p>
<p>也就是在同等level下，会从同一个<code>&quot;.initcall_##level##.init&quot;</code>段中依次取出对应的函数指针。<br>也就是从<code>&quot;.initcall##level##.init&quot;</code>段开始，每次取一个函数出来执行，并累加指针，直到取完（即到了下一个段的起始地址就表示取完了）。</p>
<h4><span id="3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian">3.2.1.1 <code>__initcall##level##_start</code>与<code>.initcall##level##.init</code>段的关联</span><a href="#3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian" class="header-anchor">#</a></h4><p>前面说了在开发者添加 <code>xxx_initcall(fn)</code> 时，事实上是将<code>fn</code>放置到了 <code>&quot;.initcall##level##.init&quot; </code>的段中。</p>
<p>在<code>do_initcall()</code>的时候，却是从<code>initcall_levels[level]</code>(即<code>__initcall##level##_start</code>指针)取出，那么</p>
<p><code>initcall_levels[level] </code>是怎么关联到<code>&quot;.initcall##level##.init&quot;</code>段的呢？</p>
<p>在vmlinux.lds.h中：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/12.png" alt="image"></p>
<p>关联到<code>&quot;.initcallearly.init&quot;</code>段。</p>
<p>然后对每个 level 定义了<code>INIT_CALLS_LEVEL(level)</code>，将<code>INIT_CALLS_LEVEL(level)</code>展开之后的结果是定义<code> __initcall##level##_start</code>,并将<code>__initcall##level##_start</code>关联到 <code>&quot;.initcall##level##.init&quot; </code>段和<code>&quot;.initcall##level##s.init&quot;</code>段。</p>
<p>到这里，<code>__initcall##level##_start </code>和<code>&quot;.initcall##level##.init&quot;</code>段的对应就比较清晰了，所以，从 <code>initcall_levels[level] </code>部分一个个取出函数指针并执行函数就是执行<code>xxx_init_call()</code>定义的函数。</p>
]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志管理-dynamic_debug</title>
    <url>/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dynamic-debug-jie-shao">1 dynamic_debug介绍</a><ul>
<li><a href="#1-1-kai-qi-dynamic-debug">1.1 开启dynamic debug</a></li>
<li><a href="#1-2-dynamic-debug-shi-yong">1.2 dynamic debug使用</a><ul>
<li><a href="#1-2-1-kai-qi-dynamic-debug">1.2.1 开启dynamic debug</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-dev-err-dev-info-dev-warn">2 dev_err&#x2F;dev_info&#x2F;dev_warn</a></li>
<li><a href="#3-ke-bian-can-shu-hong">3 可变参数宏</a></li>
<li><a href="#4-mo-kuai-da-yin-deng-ji-kong-zhi">4 模块打印等级控制</a><ul>
<li><a href="#4-1-an-zhao-da-yin-deng-ji-kong-zhi">4.1 按照打印等级控制</a></li>
<li><a href="#4-2-jing-que-kong-zhi-da-yin-deng-ji">4.2 精确控制打印等级</a></li>
</ul>
</li>
<li><a href="#5-yong-hu-tai-mo-kuai-da-yin-deng-ji-kong-zhi">5 用户态模块打印等级控制</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-dynamic-debug-jie-shao">1 dynamic_debug介绍</span><a href="#1-dynamic-debug-jie-shao" class="header-anchor">#</a></h1><p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/1.png" alt="img"></p>
<p>这里强烈推荐驱动开发者用这种方式输出log。linux kernel space中有<code>pr_debug</code>及<code>dev_dbg</code>来使用dynamic debug。可以看到当用户<code>define DEBUG</code>后，<code>pr_debug</code>和<code>dev_dbg</code>就等于printk的KERN_DEBUG级别输出了；否则什么也不打印。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/2.png" alt="img"></p>
<h2><span id="1-1-kai-qi-dynamic-debug">1.1 开启dynamic debug</span><a href="#1-1-kai-qi-dynamic-debug" class="header-anchor">#</a></h2><p>要使用dynamic_debug需要在kernel的defconfig中开启。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_DEBUG_FS=y</span><br><span class="line">CONFIG_DYNAMIC_DEBUG=y</span><br></pre></td></tr></table></figure>

<p>用menuconfig去配置的话如下图：</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/3.png" alt="img"></p>
<h2><span id="1-2-dynamic-debug-shi-yong">1.2 dynamic debug使用</span><a href="#1-2-dynamic-debug-shi-yong" class="header-anchor">#</a></h2><p>编译好image后，需要挂载debugfs（不挂载的话将不会创建debugfs,那么<code>/sys/kernel/debug/</code>下是空的）。</p>
<p>修改etc&#x2F;fstab文件，追加下面这段字符:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nodev      /sys/kernel/debug debugfs   defaults    0   0</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/4.png" alt="img"></p>
<p>可以用<code>cat /sys/kernel/debug/dynamic_debug/control | grep xxx.c</code>来查看自己想要查看的log所在文件有没有包含进去。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/5.png" alt="img"></p>
<p>这里可以看到该文件所有用<code>dev_dbg()</code>打印出的讯息。</p>
<p>那如果不开启<code>CONFIG_DYNAMIC_DEBUG</code>，将不会产生<code>/sys/kernel/debug/dynamic_debug</code>目录, 是不能进行动态打印的。</p>
<h3><span id="1-2-1-kai-qi-dynamic-debug">1.2.1 开启dynamic debug</span><a href="#1-2-1-kai-qi-dynamic-debug" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;module cvi_mipi_rx +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control</span><br><span class="line">echo <span class="string">&quot;file cvi_vip_cif.c +p&quot;</span> &gt;/sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<p>这两种方式都是开dynamic debug，第一种是对模块开启，第二种只对文件开启。</p>
<p>下面举一个栗子：</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/6.png" alt="img"></p>
<p>开启之后，可以看到<code>dev_dbg()</code>打印的log都会输出。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/7.png" alt="img"></p>
<p>反之，关闭<code>dynamic debug</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;module cvi_mipi_rx -p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control</span><br><span class="line">echo <span class="string">&quot;file cvi_vip_cif.c -p&quot;</span> &gt;/sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<p>除了上面的两种方式还有一种可以只开启某个function:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;func _init_resource +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/8.png" alt="img"></p>
<h1><span id="2-dev-err-x2f-dev-info-x2f-dev-warn">2 dev_err&#x2F;dev_info&#x2F;dev_warn</span><a href="#2-dev-err-x2f-dev-info-x2f-dev-warn" class="header-anchor">#</a></h1><p>在Linux驱动代码中，有大量的调试信息，那么推荐使用<code>dev_err/dev_info/dev_warn</code>这一系列函数族。这一系列函数族定义在<code>include/linux/device.h</code>。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/9.png" alt="img"></p>
<p>其实这些函数族本质上和下面printk.h中的定义也是完全一致的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pr_emerg(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_alert(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_crit(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_err(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warning(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warn pr_warning</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_notice(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>下图是示例，可以看到err级别以下的log没有打印，那么设置printk的控制台级别可以把对应的log输出到console。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/10.png" alt="img"></p>
<p>如何设置printk console level可以看上一篇<a href="https://fuzidage.github.io/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/">Linux日志管理-printk和dmesg</a>。</p>
<h1><span id="3-ke-bian-can-shu-hong">3 可变参数宏</span><a href="#3-ke-bian-can-shu-hong" class="header-anchor">#</a></h1><p>##__VA_ARGS__表示可变参数宏，可以用来传递多个参数，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> my_dbg(fmt, ...) \</span></span><br><span class="line"><span class="meta">do &#123;                        \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;[%s] [%d] &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> my_dbg(fmt...) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">　　printf(<span class="string">&quot;[%s] [%d] &quot;</span>, __func__, __LINE__); \</span></span><br><span class="line"><span class="meta">　　printf(fmt); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *name = <span class="string">&quot;robin&quot;</span>; <span class="type">int</span> age = <span class="number">18</span>; my_dbg(<span class="string">&quot;this is a test. name:%s, age:%d\n&quot;</span>, name, age);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/11.png" alt="img"></p>
<p>那和下面这种写法呢本质上是完全一样的。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/12.png" alt="img"></p>
<h1><span id="4-mo-kuai-da-yin-deng-ji-kong-zhi">4 模块打印等级控制</span><a href="#4-mo-kuai-da-yin-deng-ji-kong-zhi" class="header-anchor">#</a></h1><h2><span id="4-1-an-zhao-da-yin-deng-ji-kong-zhi">4.1 按照打印等级控制</span><a href="#4-1-an-zhao-da-yin-deng-ji-kong-zhi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _VPSS_DEBUG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _VPSS_DEBUG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/debugfs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u32 vpss_log_lv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_ERR        1   <span class="comment">/* error conditions                     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_WARN       2   <span class="comment">/* warning conditions                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_NOTICE     3   <span class="comment">/* normal but significant condition     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_INFO       4   <span class="comment">/* informational                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_DEBUG      5   <span class="comment">/* debug-level messages                 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CVI_LOG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VPSS(level, fmt, ...) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (level &lt;= vpss_log_lv) &#123; \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (level == CVI_DBG_ERR) \</span></span><br><span class="line"><span class="meta">                pr_err(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == CVI_DBG_WARN) \</span></span><br><span class="line"><span class="meta">                pr_warn(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == CVI_DBG_NOTICE) \</span></span><br><span class="line"><span class="meta">                pr_notice(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == CVI_DBG_INFO) \</span></span><br><span class="line"><span class="meta">                pr_info(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == CVI_DBG_DEBUG) \</span></span><br><span class="line"><span class="meta">                printk(KERN_DEBUG <span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VPSS(level, fmt, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _VPSS_DEBUG_H_ */</span></span></span><br></pre></td></tr></table></figure>

<p>当级别高于DBG,即可输出高于DBG的所有级别打印。</p>
<h2><span id="4-2-jing-que-kong-zhi-da-yin-deng-ji">4.2 精确控制打印等级</span><a href="#4-2-jing-que-kong-zhi-da-yin-deng-ji" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> u32 vi_log_lv;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">vi_msg_pri</span> &#123;</span></span><br><span class="line">    VI_ERR        = <span class="number">0x1</span>,</span><br><span class="line">    VI_WARN        = <span class="number">0x2</span>,</span><br><span class="line">    VI_NOTICE    = <span class="number">0x4</span>,</span><br><span class="line">    VI_INFO        = <span class="number">0x8</span>,</span><br><span class="line">    VI_DBG        = <span class="number">0x10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vi_pr(level, fmt, arg...) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (vi_log_lv &amp; level) &#123; \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (level == VI_ERR) \</span></span><br><span class="line"><span class="meta">                pr_err(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == VI_WARN) \</span></span><br><span class="line"><span class="meta">                pr_warn(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == VI_NOTICE) \</span></span><br><span class="line"><span class="meta">                pr_notice(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == VI_INFO) \</span></span><br><span class="line"><span class="meta">                pr_info(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == VI_DBG) \</span></span><br><span class="line"><span class="meta">                pr_debug(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>可以随意开启任意级别打印，比如只开启DBG，只开启WARN。</p>
<h1><span id="5-yong-hu-tai-mo-kuai-da-yin-deng-ji-kong-zhi">5 用户态模块打印等级控制</span><a href="#5-yong-hu-tai-mo-kuai-da-yin-deng-ji-kong-zhi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CVI_S32 *log_levels;</span><br><span class="line">CVI_CHAR <span class="type">const</span> *log_name[<span class="number">8</span>] = &#123;</span><br><span class="line">    (CVI_CHAR *)<span class="string">&quot;EMG&quot;</span>, (CVI_CHAR *)<span class="string">&quot;ALT&quot;</span>, (CVI_CHAR *)<span class="string">&quot;CRI&quot;</span>, (CVI_CHAR *)<span class="string">&quot;ERR&quot;</span>,</span><br><span class="line">    (CVI_CHAR *)<span class="string">&quot;WRN&quot;</span>, (CVI_CHAR *)<span class="string">&quot;NOT&quot;</span>, (CVI_CHAR *)<span class="string">&quot;INF&quot;</span>, (CVI_CHAR *)<span class="string">&quot;DBG&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVI_S32 <span class="title function_">CVI_LOG_SetLevelConf</span><span class="params">(LOG_LEVEL_CONF_S *pstConf)</span></span><br><span class="line">&#123;</span><br><span class="line">    log_levels[pstConf-&gt;enModId] = pstConf-&gt;s32Level;</span><br><span class="line">    <span class="keyword">return</span> CVI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVI_S32 <span class="title function_">CVI_LOG_GetLevelConf</span><span class="params">(LOG_LEVEL_CONF_S *pstConf)</span></span><br><span class="line">&#123;</span><br><span class="line">    pstConf-&gt;s32Level = log_levels[pstConf-&gt;enModId];</span><br><span class="line">    <span class="keyword">return</span> CVI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * File Name: include/cvi_debug.h</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CVI_DEBUG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CVI_DEBUG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cvi_common.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* End of #ifdef __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Debug Config</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_GDB_NO 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_GDB <span class="string">&quot;n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_LOG_TRACE_SUPPORT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_LOG_TRACE_ALL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_LOG_TRACE_LEVEL 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_EMERG      0   <span class="comment">/* system is unusable                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_ALERT      1   <span class="comment">/* action must be taken immediately     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_CRIT       2   <span class="comment">/* critical conditions                  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_ERR        3   <span class="comment">/* error conditions                     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_WARN       4   <span class="comment">/* warning conditions                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_NOTICE     5   <span class="comment">/* normal but significant condition     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_INFO       6   <span class="comment">/* informational                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_DEBUG      7   <span class="comment">/* debug-level messages                 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LOG_LEVEL_CONF_S</span> &#123;</span></span><br><span class="line">    MOD_ID_E  enModId;</span><br><span class="line">    CVI_S32   s32Level;</span><br><span class="line">    <span class="type">char</span>   cModName[<span class="number">16</span>];</span><br><span class="line">&#125; LOG_LEVEL_CONF_S;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_PRINT printf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic ignored <span class="string">&quot;-Wunused-variable&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> CVI_S32 * log_levels;</span><br><span class="line"><span class="keyword">extern</span> CVI_CHAR <span class="type">const</span> *log_name[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GENERATE_STRING(STRING) (#STRING),</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> MOD_STRING[] = FOREACH_MOD(_GENERATE_STRING);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_GET_MOD_NAME(id) (id &lt; CVI_ID_BUTT)? MOD_STRING[id] : <span class="string">&quot;UNDEF&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* #ifdef CVI_DEBUG */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CVI_LOG_TRACE_SUPPORT</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_ASSERT(expr)                               \</span></span><br><span class="line"><span class="meta">    do &#123;                                                   \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(expr)) &#123;                                 \</span></span><br><span class="line"><span class="meta">            printf(<span class="string">&quot;\nASSERT at:\n&quot;</span>                \</span></span><br><span class="line"><span class="meta">                   <span class="string">&quot;  &gt;Function : %s\n&quot;</span>            \</span></span><br><span class="line"><span class="meta">                   <span class="string">&quot;  &gt;Line No. : %d\n&quot;</span>            \</span></span><br><span class="line"><span class="meta">                   <span class="string">&quot;  &gt;Condition: %s\n&quot;</span>,           \</span></span><br><span class="line"><span class="meta">                   __func__, __LINE__, #expr);     \</span></span><br><span class="line"><span class="meta">            _exit(-1);                             \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FPGA_PORTING</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_TRACE(level, enModId, fmt, ...)            \</span></span><br><span class="line"><span class="meta">    do &#123;                                                   \</span></span><br><span class="line"><span class="meta">        CVI_S32 LogLevel = (log_levels == NULL) ? CONFIG_CVI_LOG_TRACE_LEVEL : log_levels[enModId];      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (level &lt;= LogLevel)           \</span></span><br><span class="line"><span class="meta">            syslog(LOG_LOCAL5|level, <span class="string">&quot;[%s-%s] &quot;</span> fmt, CVI_GET_MOD_NAME(enModId), log_name[level],    \</span></span><br><span class="line"><span class="meta">                ##__VA_ARGS__);           \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_TRACE(level, enModId, fmt, ...) \</span></span><br><span class="line"><span class="meta">        printf(fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_ASSERT(expr)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_TRACE(level, enModId, fmt...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_ID(level, id, fmt, ...)                                           \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, id, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_LOG(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_LOG, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_SYS(level, fmt, ...)                                           \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_SYS, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VB(level, fmt, ...)                                           \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VB, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_SNS(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VI, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VI(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VI, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VPSS(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VPSS, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VO(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VO, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_GDC(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_GDC, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_RGN(level, fmt, ...)                                           \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_RGN, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_MISC(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_SYS, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_DWA(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_DWA, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_DPU(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_DPU, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_STITCH(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_STITCH, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_HDMI(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_HDMI, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* __CVI_COMM_SYS_H__ */</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志管理-syslog和rsyslog</title>
    <url>/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-syslogd-jian-jie">1 syslogd简介</a><ul>
<li><a href="#1-1-ri-zhi-ge-shi">1.1 日志格式</a></li>
<li><a href="#1-2-etc-syslog-conf-fu-wu-pei-zhi">1.2 &#x2F;etc&#x2F;syslog.conf服务配置</a><ul>
<li><a href="#1-2-1-zong-pei-zhi-etc-syslog-conf">1.2.1 总配置&#x2F;etc&#x2F;syslog.conf</a></li>
<li><a href="#1-2-2-rsyslog-gui-ze-etc-rsyslog-d-conf">1.2.2 rsyslog规则（&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf）</a><ul>
<li><a href="#1-2-2-1-facility-ri-zhi-lei-xing">1.2.2.1 facility-日志类型</a></li>
<li><a href="#1-2-2-2-level-an-yan-chong-cheng-du-you-di-dao-gao-pai-xu">1.2.2.2 level-按严重程度由低到高排序</a></li>
<li><a href="#1-2-2-3-action-biao-shi-log-bao-cun-de-wei-zhi">1.2.2.3 action-表示log保存的位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-cheng-xu-ru-he-pei-zhi-syslog-zi-fu-wu-zi-ding-yi-rsyslog-gui-ze">1.3 程序如何配置syslog子服务(自定义rsyslog规则)</a></li>
</ul>
</li>
<li><a href="#2-syslog-han-shu">2 syslog()函数</a><ul>
<li><a href="#2-1-openlog-han-shu">2.1 openlog函数</a></li>
<li><a href="#2-2-syslog-han-shu">2.2 syslog函数</a></li>
<li><a href="#2-3-chong-ding-xiang-log">2.3 重定向log</a><ul>
<li><a href="#2-3-1-fang-fa-1-xiu-gai-rsyslog-conf">2.3.1 方法1-修改rsyslog.conf</a></li>
<li><a href="#2-3-2-fang-fa-2-xiu-gai-code-zhong-de-facility">2.3.2 方法2-修改code中的facility</a></li>
</ul>
</li>
<li><a href="#2-4-she-zhi-log-deng-ji">2.4 设置log等级</a></li>
<li><a href="#2-5-chong-ding-xiang-log-dao-console">2.5 重定向log到console</a></li>
</ul>
</li>
<li><a href="#3-dup-han-shu-jie-shao">3 dup函数介绍</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-syslogd-jian-jie">1 syslogd简介</span><a href="#1-syslogd-jian-jie" class="header-anchor">#</a></h1><p>syslogd不仅仅是记录kernel log的服务，还能记录user space中的日志。</p>
<p>syslogd是Linux下的一个记录日志文件服务。新版本叫做rsyslogd。</p>
<p>syslogd有一系列的子服务，例如mail、auth、cron、kern等等，这些子服务提供日志记录的功能,。当程序要记录log时,可以直接调用这些子服务将日志记录到设定的地方。</p>
<p><strong>syslogd</strong>是一个守护进程，配置这整个守护进程以及其子服务的地方就是&#x2F;etc&#x2F;syslog.conf这个文件。可以从<a href="https://www.rsyslog.com/doc/master/%E8%8E%B7%E5%8F%96%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%82">https://www.rsyslog.com/doc/master/获取官方文档。</a></p>
<h2><span id="1-1-ri-zhi-ge-shi">1.1 日志格式</span><a href="#1-1-ri-zhi-ge-shi" class="header-anchor">#</a></h2><p>如果配置好并运行了 syslogd 或 klogd，一般所有 log的信息也会追加到<code> /var/log/messages</code>。并且kernel log信息被记录在<code>/val/log/kern.log</code>。</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/1.png" alt="img"></p>
<p>可以看到基本日志格式包含以下四列:</p>
<ol>
<li>事件产生的时间(Jan 1 08:00:09)</li>
<li>发生事件的服务器的主机名 (cvitek)</li>
<li>产生事件的服务名或程序名 (kernel or local5)</li>
<li>事件的具体信息(…cif a0c2000.cif:..)</li>
</ol>
<p>当开启rsyslogd后，不能透过&#x2F;proc&#x2F;kmsg来查看kernel log。</p>
<h2><span id="1-2-x2f-etc-x2f-syslog-conf-fu-wu-pei-zhi">1.2 &#x2F;etc&#x2F;syslog.conf服务配置</span><a href="#1-2-x2f-etc-x2f-syslog-conf-fu-wu-pei-zhi" class="header-anchor">#</a></h2><ol>
<li>&#x2F;etc&#x2F;rsyslog.conf 是rsyslog服务的总配置文件</li>
<li>&#x2F;etc&#x2F;rsyslog.d 该目录是单独配置的rsyslog配置文件</li>
</ol>
<h3><span id="1-2-1-zong-pei-zhi-x2f-etc-x2f-syslog-conf">1.2.1 总配置&#x2F;etc&#x2F;syslog.conf</span><a href="#1-2-1-zong-pei-zhi-x2f-etc-x2f-syslog-conf" class="header-anchor">#</a></h3><p>rsyslog记录哪些日志，到底记录了什么样的日志，是通过这个<code>/etc/rsyslog.conf</code>配置文件来决定的，先分析一下rsyslogd的总配置文件：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/2.png" alt="img"></p>
<p>默认规则会定义在<code>/etc/rsyslog.d/50-default.conf</code>中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################</span></span><br><span class="line"><span class="comment">#### MODULES ####</span></span><br><span class="line"><span class="comment">#################</span></span><br><span class="line">module(load=<span class="string">&quot;imuxsock&quot;</span>) <span class="comment"># provides support for local system logging   ；加载提供对本地系统日志的支持</span></span><br><span class="line">module(load=<span class="string">&quot;imklog&quot;</span>)   <span class="comment"># provides kernel logging support；加载读取内核消息模块</span></span><br><span class="line"><span class="comment">#module(load=&quot;immark&quot;)  # provides --MARK-- message capability</span></span><br><span class="line"><span class="comment"># provides UDP syslog reception  （接收使用UDP 协议转发过来的日志，这里#注释掉了表示不启用）</span></span><br><span class="line"><span class="comment">#module(load=&quot;imudp&quot;)</span></span><br><span class="line"><span class="comment">#input(type=&quot;imudp&quot; port=&quot;514&quot;)  （允许514端口接收）</span></span><br><span class="line"><span class="comment"># provides TCP syslog reception （接收使用UDP 协议转发过来的日志）</span></span><br><span class="line"><span class="comment">#module(load=&quot;imtcp&quot;)</span></span><br><span class="line"><span class="comment">#input(type=&quot;imtcp&quot; port=&quot;514&quot;)（允许514端口接收）</span></span><br><span class="line"><span class="comment"># Enable non-kernel facility klog messages</span></span><br><span class="line"><span class="variable">$KLogPermitNonKernelFacility</span> on</span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#### GLOBAL DIRECTIVES ####</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use traditional timestamp format.</span></span><br><span class="line"><span class="comment"># To enable high precision timestamps, comment out the following line.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span><br><span class="line"><span class="comment"># Filter duplicated messages</span></span><br><span class="line"><span class="variable">$RepeatedMsgReduction</span> on</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the default permissions for all log files.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$FileOwner</span> syslog</span><br><span class="line"><span class="variable">$FileGroup</span> adm</span><br><span class="line"><span class="variable">$FileCreateMode</span> 0640</span><br><span class="line"><span class="variable">$DirCreateMode</span> 0755</span><br><span class="line"><span class="variable">$Umask</span> 0022</span><br><span class="line"><span class="variable">$PrivDropToUser</span> syslog</span><br><span class="line"><span class="variable">$PrivDropToGroup</span> syslog</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Where to place spool and state files</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span><br><span class="line">(记录所有日志类型的info级别以及大于info级别的信息到/var/log/messages,但是mail邮件信息,authpriv验证方面的信息和cron时间任务相关的信息除外)</span><br><span class="line"><span class="comment">#*.info;mail.none;authpriv.none;cron.none    /var/log/messages</span></span><br><span class="line"><span class="comment"># Include all config files in /etc/rsyslog.d/ </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf  （表示加载该目录中的所有配置）</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-2-rsyslog-gui-ze-x2f-etc-x2f-rsyslog-d-x2f-conf">1.2.2 rsyslog规则（&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf）</span><a href="#1-2-2-rsyslog-gui-ze-x2f-etc-x2f-rsyslog-d-x2f-conf" class="header-anchor">#</a></h3><p>rsyslog规则配置文件一般由以下3部分组成，每一行表示一个项目，格式为：facility.level action，分别表示日志类型，日志等级，日志输出路径。一般系统默认的规则定义在<code>/etc/rsyslog.d/50-default.conf</code>：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/3.png" alt="img"></p>
<p>一般所有日志类型都会被追加在<code>/val/log/messages</code>。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.info;mail.none;authpriv.none;cron.none    /var/log/messages  </span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-1-facility-ri-zhi-lei-xing">1.2.2.1 facility-日志类型</span><a href="#1-2-2-1-facility-ri-zhi-lei-xing" class="header-anchor">#</a></h4><ul>
<li>kern: 内核信息</li>
<li>user: 用户进程相关信息</li>
<li>mail: 电子邮件相关信息</li>
<li>Local0- local7: 为本地使用预留的服务</li>
<li>daemon: 后台进程相关信息</li>
<li>syslog: 系统日志信息</li>
</ul>
<h4><span id="1-2-2-2-level-an-yan-chong-cheng-du-you-di-dao-gao-pai-xu">1.2.2.2 level-按严重程度由低到高排序</span><a href="#1-2-2-2-level-an-yan-chong-cheng-du-you-di-dao-gao-pai-xu" class="header-anchor">#</a></h4><ul>
<li>none: 没有重要级</li>
<li>debug: 调试信息</li>
<li>info: 打印的信息</li>
<li>notice: 具有重要信息的普通条件</li>
<li>warning: 警告信息</li>
<li>err: 错误信息</li>
<li>crit: 阻止某些工具或子系统功能实现的错误条件</li>
<li>alert: 需要立即被修改的条件</li>
<li>emerg: 该系统不可用</li>
</ul>
<h4><span id="1-2-2-3-action-biao-shi-log-bao-cun-de-wei-zhi">1.2.2.3 action-表示log保存的位置</span><a href="#1-2-2-3-action-biao-shi-log-bao-cun-de-wei-zhi" class="header-anchor">#</a></h4><p>那下面我也抄过来一份比较全面的规则定义示例供大家参考:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录mail日志等级为error及以上日志</span></span><br><span class="line">mail.err                                                        /var/log/mail_err.log</span><br><span class="line"><span class="comment"># 记录mail所有等级为warn级别的日志（仅记录warn级别）</span></span><br><span class="line">mail.=warn                                                        /var/log/mail_err.log</span><br><span class="line"><span class="comment"># 记录kern所有日志</span></span><br><span class="line">kern.*                                                                /var/log/kern.log</span><br><span class="line"><span class="comment"># 将mail的所有信息，除了info以外，其他的都写入/var/adm/mail</span></span><br><span class="line">mail.*;mail.!=info   /var/adm/mail</span><br><span class="line"><span class="comment"># 将日志等级为crit或更高的内核消息定向到远程主机finlandia</span></span><br><span class="line"><span class="comment"># 如果主机崩溃，磁盘出现不可修复的错误，可能无法读取存储的消息。如果有日志在远程主机上，可以尝试找出崩溃的原因。</span></span><br><span class="line">kern.crit                                                     @finlandia</span><br><span class="line"><span class="comment"># 记录所有类型的warning等级及以上日志</span></span><br><span class="line">*.warning                                                        /var/log/syslog_warn.log</span><br><span class="line"><span class="comment"># 记录mail的warning日志和kern的error日志,其他所有的info日志</span></span><br><span class="line">*.info;mail.warning;kern.error                /var/log/messages</span><br><span class="line"><span class="comment"># 记录kernel的info到warning日志</span></span><br><span class="line">kern.info;kern.!err   /var/adm/kernel-info</span><br><span class="line"><span class="comment"># 将mail和news的info级别日志写入/var/adminfo</span></span><br><span class="line">mail,news.=info    /var/adm/info</span><br><span class="line"><span class="comment"># 将所有系统中所有类型的info日志和notice日志存入/var/log/massages,mail的所有日志除外。</span></span><br><span class="line">*.=info;*.=notice;\</span><br><span class="line">mail.none /var/log/messages</span><br><span class="line"><span class="comment"># 紧急消息（emerg级别）将使用wall显示给当前所有登录的用户，这里用等号表示只对emerg日志级别有效</span></span><br><span class="line">*.=emerg                   *</span><br><span class="line"><span class="comment"># 该规则将所有alert以及更高级别的消息定向到操作员的终端，即登录的用户“root”和“joey”的终端。</span></span><br><span class="line">*.alert      root,joey</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-cheng-xu-ru-he-pei-zhi-syslog-zi-fu-wu-zi-ding-yi-rsyslog-gui-ze">1.3 程序如何配置syslog子服务(自定义rsyslog规则)</span><a href="#1-3-cheng-xu-ru-he-pei-zhi-syslog-zi-fu-wu-zi-ding-yi-rsyslog-gui-ze" class="header-anchor">#</a></h2><p><strong>问题：进程如何发送消息给rsyslog守护进程，rsyslog守护进程是如何对各种日志区分开来的？</strong></p>
<p>像<code>/usr/sbin/sshd、/usr/bin/login、/usr/bin/su</code>这些进程，它们是调用一个叫syslog的系统调用, syslog系统调用是一个用于向rsyslog守护进程发送消息的的系统函数。<br><code>/usr/sbin/sshd,/usr/bin/login、/usr/bin/su</code>这些进程专门执行登录验证时，它们在调用syslog系统函数会一般会传入<code>LOG_AUTH</code>这个常量。</p>
<p>而<code>/usr/bin/crond和/usr/bin/at</code>这些在调用syslog系统调用会传入<code>LOG_CRON</code>这个常量（具体请看**syslog()**函数），日志归类规则如下：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/4.png" alt="img"></p>
<p>所以如果用<code>LOG_AUTH</code>的syslog()函数调用，那么会归类到了<code>/val/log/secure</code>。</p>
<p>如果用<code>LOG_CRON</code>的syslog()调用则归类到了<code>/val/log/cron</code>。而kernel等其他log被记录在了<code>/val/log/messages</code>中。</p>
<p>那么我们可以自定义规则如下:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/5.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syslogfacility-text：表示facility日志类型</span><br><span class="line">syslogseverity-text：表示level日志级别</span><br><span class="line"></span><br><span class="line">这里对aisdk.conf用local7日志类型产生的大于warn日志级别的<span class="built_in">log</span>都将记录到/val/log/aisdk，</span><br><span class="line">对kern.conf用kern类型产生的所有级别日志都记录到/val/log/kern，</span><br><span class="line">Local5类型的日志记录到/val/log/middleware, 并且当日志级别等于或高于4（warn）时也会追加到console.</span><br></pre></td></tr></table></figure>

<p>注意busybox要开启使能syslog.conf解析：<code>/etc/syslog.conf</code>解析，<code>CONFIG_FEATURE_SYSLOGD_CFG=y</code></p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/5-1.png" alt="img"></p>
<h1><span id="2-syslog-han-shu">2 syslog()函数</span><a href="#2-syslog-han-shu" class="header-anchor">#</a></h1><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/6.png" alt="img"></p>
<p>用户空间也可以用syslog()函数来记录自己的进程的日志，所以用户进程可以自定义日志规则。<br>调用openlog是可选择的。如果不调用openlog，则在第一次调用syslog时，会自动调用openlog。<br>syslog的相关函数和宏定义一般在toolchain中都会有定义:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/7.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span> <span class="params">(<span class="type">char</span>*ident,<span class="type">int</span> option ,<span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority,<span class="type">char</span>*format,……)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h2><span id="2-1-openlog-han-shu">2.1 openlog函数</span><a href="#2-1-openlog-han-shu" class="header-anchor">#</a></h2><p>第1个参数为ident，该参数常用来表示信息的来源。ident信息会被固定地添加在每行日志的前面：<br>第2个参数 option控制标志:</p>
<table>
<thead>
<tr>
<th>option控制标志</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>LOG_CONS</td>
<td>如果将信息发送给syslogd守护进程时发生错误，直接将相关信息输出到终端</td>
</tr>
<tr>
<td>LOG_PID</td>
<td>每条日志信息中都包括进程号</td>
</tr>
</tbody></table>
<p>第3个参数为facility：</p>
<table>
<thead>
<tr>
<th>facility参数</th>
<th>syslog.conf中对应的facility取值</th>
</tr>
</thead>
<tbody><tr>
<td>LOG_KERN</td>
<td>kern</td>
</tr>
<tr>
<td>LOG_USER</td>
<td>user</td>
</tr>
<tr>
<td>LOG_MAIL</td>
<td>mail</td>
</tr>
<tr>
<td>LOG_DAEMON</td>
<td>daemon</td>
</tr>
<tr>
<td>LOG_AUTH</td>
<td>auth</td>
</tr>
<tr>
<td>LOG_SYSLOG</td>
<td>syslog</td>
</tr>
<tr>
<td>LOG_LPR</td>
<td>lpr</td>
</tr>
<tr>
<td>LOG_NEWS</td>
<td>news</td>
</tr>
<tr>
<td>LOG_UUCP</td>
<td>uucp</td>
</tr>
<tr>
<td>LOG_CRON</td>
<td>cron</td>
</tr>
<tr>
<td>LOG_AUTHPRIV</td>
<td>authpriv</td>
</tr>
<tr>
<td>LOG_FTP</td>
<td>ftp</td>
</tr>
<tr>
<td>LOG_LOCAL0～LOG_LOCAL7</td>
<td>local0～local7</td>
</tr>
</tbody></table>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/8.png" alt="img"></p>
<h2><span id="2-2-syslog-han-shu">2.2 syslog函数</span><a href="#2-2-syslog-han-shu" class="header-anchor">#</a></h2><p>第一个参数priority表示日志级别：</p>
<table>
<thead>
<tr>
<th>priority参数</th>
<th>syslog.conf中对应的level取值</th>
</tr>
</thead>
<tbody><tr>
<td>LOG_EMERG</td>
<td>emerg</td>
</tr>
<tr>
<td>LOG_ALERT</td>
<td>alert</td>
</tr>
<tr>
<td>LOG_CRIT</td>
<td>crit</td>
</tr>
<tr>
<td>LOG_ERR</td>
<td>err</td>
</tr>
<tr>
<td>LOG_WARNING</td>
<td>warning</td>
</tr>
<tr>
<td>LOG_NOTICE</td>
<td>notice</td>
</tr>
<tr>
<td>LOG_INFO</td>
<td>info</td>
</tr>
<tr>
<td>LOG_DEBUG</td>
<td>debug</td>
</tr>
</tbody></table>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/9.png" alt="img"></p>
<p>下面是具体的例子：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/10.png" alt="img"></p>
<p>这里<code>printf(&quot;%m&quot;)等价于printf(&quot;%s&quot;,strerror(errno));</code>它表示把errno用string形式打印出来。</p>
<p>由于我这里facility为user时，是记录在&#x2F;val&#x2F;log&#x2F;syslog中的:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/11.png" alt="img"></p>
<p>因此打印log如下:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/12.png" alt="img"></p>
<h2><span id="2-3-chong-ding-xiang-log">2.3 重定向log</span><a href="#2-3-chong-ding-xiang-log" class="header-anchor">#</a></h2><p>我们也可以把log定向到自己想要的地方。</p>
<h3><span id="2-3-1-fang-fa-1-xiu-gai-rsyslog-conf">2.3.1 方法1-修改rsyslog.conf</span><a href="#2-3-1-fang-fa-1-xiu-gai-rsyslog-conf" class="header-anchor">#</a></h3><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/13.png" alt="img"></p>
<p>将<code>facility=user</code>时的所有level级别的log重定向到<code>/val/log/user.log</code>, 重启rsyslog服务:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/14.png" alt="img"></p>
<p>此时log将被写入到新配置的位置&#x2F;val&#x2F;log&#x2F;user.log, 当然&#x2F;val&#x2F;log&#x2F;syslog也会保留一份.（因为也符合&#x2F;val&#x2F;log&#x2F;syslog这条规则）</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/15.png" alt="img"></p>
<h3><span id="2-3-2-fang-fa-2-xiu-gai-code-zhong-de-facility">2.3.2 方法2-修改code中的facility</span><a href="#2-3-2-fang-fa-2-xiu-gai-code-zhong-de-facility" class="header-anchor">#</a></h3><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/16.png" alt="img"></p>
<p>那这里的facility被设置成了local0, 那也会记录在<code>/val/log/syslog</code>:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/17.png" alt="img"></p>
<h2><span id="2-4-she-zhi-log-deng-ji">2.4 设置log等级</span><a href="#2-4-she-zhi-log-deng-ji" class="header-anchor">#</a></h2><ol>
<li>这里新增一个app.conf，然后自定义log路径:</li>
</ol>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/18.png" alt="img"></p>
<p>当然还可以类似于这样子写， syslogfacility-text和syslogseverity-text是rsyslog自带的系统变量。</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/19.png" alt="img"></p>
<ol start="2">
<li><p>重启rsyslog服务</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/20.png" alt="img"></p>
</li>
</ol>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/21.png" alt="img"></p>
<p>这里切成4个文件，每个文件记录1024k。</p>
<ol start="3">
<li><p>运行程序,查看log如下:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/22.png" alt="img"></p>
</li>
</ol>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/23.png" alt="img"></p>
<ol start="4">
<li><p>那现在修改log等级为warn, 表示只有大于等于该等级的log才会记录。</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/24.png" alt="img"></p>
</li>
<li><p>再次重启rsyslog服务，运行程序，可以看到”log debug”不再打印：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/25.png" alt="img"></p>
</li>
</ol>
<h2><span id="2-5-chong-ding-xiang-log-dao-console">2.5 重定向log到console</span><a href="#2-5-chong-ding-xiang-log-dao-console" class="header-anchor">#</a></h2><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/26.png" alt="img"></p>
<p>再次重启rsyslog服务，运行程序，那么可以看到err级别的log打印在了console上，但是低于err级别还是会记录在&#x2F;val&#x2F;log&#x2F;app。</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/27.png" alt="img"></p>
<h1><span id="3-dup-han-shu-jie-shao">3 dup函数介绍</span><a href="#3-dup-han-shu-jie-shao" class="header-anchor">#</a></h1><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/28.png" alt="img"></p>
<p>用来将标准输出重定向到文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> dup_fd;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dup_fd_bak = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dup_fd</span><span class="params">(<span class="type">void</span>)</span>  &#123;</span><br><span class="line">    dup_fd = open( <span class="string">&quot;./printf_dup_log.txt &quot;</span>, O_CREAT | O_RDWR | O_TRUNC);</span><br><span class="line">    dup2(STDOUT_FILENO, dup_fd_bak);<span class="comment">/*backup stdout*/</span></span><br><span class="line">    dup2(dup_fd, STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rst_fd</span><span class="params">(<span class="type">void</span>)</span>  &#123;</span><br><span class="line">    dup2(dup_fd_bak, fileno(<span class="built_in">stdout</span>));<span class="comment">/*recover stdout*/</span></span><br><span class="line">    close(dup_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志管理-printk和demsg</title>
    <url>/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-printk">1 printk</a><ul>
<li><a href="#1-1-ri-zhi-ji-bie">1.1 日志级别</a></li>
<li><a href="#1-2-kong-zhi-tai-ji-bie">1.2 <strong>控制台级别</strong></a></li>
<li><a href="#1-3-xiu-gai-kong-zhi-tai-ji-bie">1.3 修改控制台级别</a></li>
<li><a href="#1-4-printk-dai-shi-jian-chuo-xun-xi">1.4 printk带时间戳讯息</a></li>
<li><a href="#1-5-printk-di-ceng-shi-xian">1.5 printk底层实现</a><ul>
<li><a href="#1-5-1-ming-ling-xing-can-shu-console">1.5.1 命令行参数console</a></li>
<li><a href="#1-5-2-console-qu-dong-zhu-ce-guo-cheng">1.5.2 console驱动注册过程</a><ul>
<li><a href="#1-5-2-1-chu-li-ming-ling-xing-can-shu">1.5.2.1 处理命令行参数</a></li>
<li><a href="#1-5-2-2-register-console">1.5.2.2 register_console</a></li>
<li><a href="#1-5-2-3-dev-console">1.5.2.3 &#x2F;dev&#x2F;console</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-6-nei-he-xin-xi-de-zao-qi-da-yin">1.6 内核信息的早期打印</a><ul>
<li><a href="#1-6-1-early-printk">1.6.1 early_printk</a></li>
<li><a href="#1-6-2-earlycon">1.6.2 earlycon</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-prink-h-jie-shao">2 prink.h介绍</a></li>
<li><a href="#3-dmesg-ming-ling">3 dmesg命令</a><ul>
<li><a href="#3-1-proc-kmsg">3.1 &#x2F;proc&#x2F;kmsg</a></li>
<li><a href="#3-2-xiu-gai-nei-he-ri-zhi-huan-chong-qu-da-xiao">3.2 修改内核日志缓冲区大小</a></li>
<li><a href="#3-3-dmesg">3.3 dmesg</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-printk">1 printk</span><a href="#1-printk" class="header-anchor">#</a></h1><p>printk函数主要做两件事情：第一件就是将信息记录到log中，而第二件事就是调用控制台驱动来将信息输出。printk的相关函数定义在linux&#x2F;printk.h。</p>
<h2><span id="1-1-ri-zhi-ji-bie">1.1 日志级别</span><a href="#1-1-ri-zhi-ji-bie" class="header-anchor">#</a></h2><p>printk需要设置日志级别，用来控制printk打印的这条信息是否在终端上显示的，当printk设置的日志级别高于控制台级别时，printk要打印的信息才会在控制台打印出来。</p>
<p>内核日志一共有8种级别:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_EMERG        <span class="string">&quot;&lt;0&gt;&quot;</span>        <span class="comment">/* system is unusable                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_ALERT        <span class="string">&quot;&lt;1&gt;&quot;</span>        <span class="comment">/* action must be taken immediately        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_CRIT        <span class="string">&quot;&lt;2&gt;&quot;</span>        <span class="comment">/* critical conditions                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_ERR        <span class="string">&quot;&lt;3&gt;&quot;</span>        <span class="comment">/* error conditions                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_WARNING        <span class="string">&quot;&lt;4&gt;&quot;</span>        <span class="comment">/* warning conditions                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_NOTICE        <span class="string">&quot;&lt;5&gt;&quot;</span>        <span class="comment">/* normal but significant condition        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_INFO        <span class="string">&quot;&lt;6&gt;&quot;</span>        <span class="comment">/* informational                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_DEBUG        <span class="string">&quot;&lt;7&gt;&quot;</span>        <span class="comment">/* debug-level messages                        */</span></span></span><br></pre></td></tr></table></figure>

<h2><span id="1-2-kong-zhi-tai-ji-bie">1.2 <strong>控制台级别</strong></span><a href="#1-2-kong-zhi-tai-ji-bie" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINIMUM_CONSOLE_LOGLEVEL 1 <span class="comment">/*可以使用的最小日志级别*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CONSOLE_LOGLEVEL 7 <span class="comment">/*默认的控制台级别*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MESSAGE_LOGLEVEL 4 <span class="comment">/* 默认的日志级别 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> console_printk[<span class="number">4</span>] = &#123;</span><br><span class="line">    DEFAULT_CONSOLE_LOGLEVEL,<span class="comment">/*控制台日志级别：优先级高于该值的消息将被打印至控制台*/</span></span><br><span class="line">    DEFAULT_MESSAGE_LOGLEVEL,<span class="comment">/*缺省的消息日志级别：将用该优先级来打印没有优先级的消息*/</span></span><br><span class="line">    MINIMUM_CONSOLE_LOGLEVEL,<span class="comment">/*最低的控制台日志级别：控制台日志级别可被设置的最小值（最高优先级）*/</span></span><br><span class="line">    DEFAULT_CONSOLE_LOGLEVEL,<span class="comment">/*缺省的控制台日志级别：控制台日志级别的缺省值*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> console_loglevel (console_printk[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_message_loglevel (console_printk[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> minimum_console_loglevel (console_printk[2])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_console_loglevel (console_printk[3])</span></span><br></pre></td></tr></table></figure>

<p>使用命令 <code>cat /proc/sys/kernel/printk </code>来查看这四个值:</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/1.png" alt="img"></p>
<p>结果显示了 <em>current</em>, <em>default</em>, <em>minimum</em> 和 <em>boot-time-default</em> 日志级别。</p>
<p>其中的 4 4 1 7，分别对应与：<code>console_loglevel、default_message_loglevel、minimum_console_loglevel、default_console_loglevel</code></p>
<p><strong>default_message_loglevel</strong>：</p>
<p>缺省时的消息日志级别，因此当printk未指定优先级时，将以该默认级别输出，也就是<code>DEFAULT_MESSAGE_LOGLEVEL =4， 对应KERN_WARNING。</code></p>
<p>也就是说<code>printk(&quot;hello world\n&quot;);就表示printk(KERN_WARNING &quot;hello world\n&quot;);</code></p>
<p>那如果我们将控制台级别设成&lt;4，如：</p>
<p><code>echo 3 &gt; /proc/sys/kernel/printk</code></p>
<p>那么<code>printk(&quot;hello world\n&quot;);</code>就无法输出到控制台。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">字符串</th>
<th align="left">别名函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">KERN_EMERG</td>
<td align="left">“0”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_emerg"><code>pr_emerg()</code></a></td>
</tr>
<tr>
<td align="left">KERN_ALERT</td>
<td align="left">“1”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_alert"><code>pr_alert()</code></a></td>
</tr>
<tr>
<td align="left">KERN_CRIT</td>
<td align="left">“2”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_crit"><code>pr_crit()</code></a></td>
</tr>
<tr>
<td align="left">KERN_ERR</td>
<td align="left">“3”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_err"><code>pr_err()</code></a></td>
</tr>
<tr>
<td align="left">KERN_WARNING</td>
<td align="left">“4”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_warn"><code>pr_warn()</code></a></td>
</tr>
<tr>
<td align="left">KERN_NOTICE</td>
<td align="left">“5”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_notice"><code>pr_notice()</code></a></td>
</tr>
<tr>
<td align="left">KERN_INFO</td>
<td align="left">“6”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_info"><code>pr_info()</code></a></td>
</tr>
<tr>
<td align="left">KERN_DEBUG</td>
<td align="left">“7”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_debug"><code>pr_debug()</code></a> and <a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_devel"><code>pr_devel()</code></a> 若定义了DEBUG</td>
</tr>
<tr>
<td align="left">KERN_DEFAULT</td>
<td align="left">“”</td>
<td align="left">KERN_WARNING</td>
</tr>
<tr>
<td align="left">KERN_CONT</td>
<td align="left">“c”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_cont"><code>pr_cont()</code></a></td>
</tr>
</tbody></table>
<h2><span id="1-3-xiu-gai-kong-zhi-tai-ji-bie">1.3 修改控制台级别</span><a href="#1-3-xiu-gai-kong-zhi-tai-ji-bie" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;n&quot;</span> &gt; /proc/sys/kernel/printk</span><br><span class="line"><span class="comment">#Eg:</span></span><br><span class="line"><span class="built_in">echo</span> 8 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>



<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/2.png" alt="img"></p>
<p>另一种方式，使用 <code>dmesg</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg -n 8</span><br></pre></td></tr></table></figure>

<p>此时所有的printk日志级别都会被输出到控制台，如下图所示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk ( KERN_EMERG <span class="string">&quot;Hello, EMERG.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_ALERT <span class="string">&quot;Hello, ALERT.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_CRIT <span class="string">&quot;Hello, CRIT.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_ERR <span class="string">&quot;Hello, ERR.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_WARNING <span class="string">&quot;Hello, WARNING.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_NOTICE <span class="string">&quot;Hello, NOTICE.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_INFO <span class="string">&quot;Hello, INFO.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_DEBUG <span class="string">&quot;Hello, DEBUG.\n&quot;</span> ) ;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/3.png" alt="img"></p>
<p>再来一种方法，修改bootargs：</p>
<p>Uboot中修改<code>console=ttyS0,115200</code>改为<code>loglevel=7 console=ttyS0,115200</code>,表示设置内核的<code>console_loglevel 值=7</code>，开机<code>cat /proc/sys/kernel/printk</code>，可以看到控制台级别被设置成了7:</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/4.png" alt="img"></p>
<h2><span id="1-4-printk-dai-shi-jian-chuo-xun-xi">1.4 printk带时间戳讯息</span><a href="#1-4-printk-dai-shi-jian-chuo-xun-xi" class="header-anchor">#</a></h2><p>make menuconfig开启如下:</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/5.png" alt="img"></p>
<h2><span id="1-5-printk-di-ceng-shi-xian">1.5 printk底层实现</span><a href="#1-5-printk-di-ceng-shi-xian" class="header-anchor">#</a></h2><p>源码位于<code>kernel\printk\printk.c</code>。</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/6.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk</span><br><span class="line">    <span class="comment">// linux 4.9: kernel/printk/internal.h</span></span><br><span class="line">    <span class="comment">// linux 5.4: kernel/printk/printk_safe.c</span></span><br><span class="line">    vprintk_func </span><br><span class="line">        <span class="title function_">vprintk_default</span><span class="params">(fmt, args)</span>;</span><br><span class="line">            vprintk_emit</span><br><span class="line">                vprintk_store <span class="comment">// 把要打印的信息保存在log_buf中</span></span><br><span class="line">                    log_output</span><br><span class="line">                <span class="title function_">preempt_disable</span><span class="params">()</span>;</span><br><span class="line">                <span class="keyword">if</span> (console_trylock_spinning())</span><br><span class="line">                    console_unlock();</span><br><span class="line">                preempt_enable();</span><br><span class="line">console_unlock</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(;;)</span> &#123;</span><br><span class="line">        msg = log_from_idx(console_idx);</span><br><span class="line">        <span class="keyword">if</span> (suppress_message_printing(msg-&gt;level)) &#123;</span><br><span class="line">            <span class="comment">/* 如果消息的级别数值大于console_loglevel, 则不打印此信息 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        printk_safe_enter_irqsave(flags);</span><br><span class="line">        call_console_drivers(ext_text, ext_len, text, len);</span><br><span class="line">        printk_safe_exit_irqrestore(flags);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/7.png" alt="img"></p>
<h3><span id="1-5-1-ming-ling-xing-can-shu-console">1.5.1 命令行参数console</span><a href="#1-5-1-ming-ling-xing-can-shu-console" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* IMX6ULL */</span><br><span class="line">[root@100ask:~]<span class="comment"># cat /proc/cmdline</span></span><br><span class="line">console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw</span><br></pre></td></tr></table></figure>

<p>命令行信息可以来自设备树或者环境变量:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    chosen &#123;</span><br><span class="line">                bootargs = <span class="string">&quot;console=ttymxc1,115200&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改环境变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进入IMX6ULL的UBOOT */</span></span><br><span class="line">=&gt; print mmcargs</span><br><span class="line">mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</span><br><span class="line">=&gt; print console</span><br><span class="line">console=ttymxc0</span><br><span class="line">=&gt; print baudrate</span><br><span class="line">baudrate=<span class="number">115200</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-5-2-console-qu-dong-zhu-ce-guo-cheng">1.5.2 console驱动注册过程</span><a href="#1-5-2-console-qu-dong-zhu-ce-guo-cheng" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>    name[<span class="number">16</span>];  <span class="comment">// name为&quot;ttyXXX&quot;，在cmdline中用&quot;console=ttyXXX0&quot;来匹配</span></span><br><span class="line">    <span class="comment">// 输出函数</span></span><br><span class="line">    <span class="type">void</span>    (*write)(<span class="keyword">struct</span> console *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">unsigned</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>        (*read)(<span class="keyword">struct</span> console *, <span class="type">char</span> *, <span class="type">unsigned</span>);</span><br><span class="line">    <span class="comment">// APP访问/dev/console时通过这个函数来确定是哪个(index)设备</span></span><br><span class="line">    <span class="comment">// 举例:</span></span><br><span class="line">    <span class="comment">// a. cmdline中&quot;console=ttymxc1&quot;</span></span><br><span class="line">    <span class="comment">// b. 则注册对应的console驱动时：console-&gt;index = 1</span></span><br><span class="line">    <span class="comment">// c. APP访问/dev/console时调用&quot;console-&gt;device&quot;来返回这个index</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">tty_driver</span> *(*<span class="title">device</span>)(<span class="keyword">struct</span> <span class="title">console</span> *<span class="title">co</span>, <span class="title">int</span> *<span class="title">index</span>);</span></span><br><span class="line">    <span class="type">void</span>    (*unblank)(<span class="type">void</span>);</span><br><span class="line">    <span class="comment">// 设置函数, 可设为NULL</span></span><br><span class="line">    <span class="type">int</span>        (*setup)(<span class="keyword">struct</span> console *, <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">// 匹配函数, 可设为NULL</span></span><br><span class="line">    <span class="type">int</span>        (*match)(<span class="keyword">struct</span> console *, <span class="type">char</span> *name, <span class="type">int</span> idx, <span class="type">char</span> *options); </span><br><span class="line">    <span class="type">short</span>    flags;</span><br><span class="line">    <span class="comment">// 哪个设备用作console: </span></span><br><span class="line">    <span class="comment">// a. 可以设置为-1, 表示由cmdline确定</span></span><br><span class="line">    <span class="comment">// b. 也可以直接指定</span></span><br><span class="line">    <span class="type">short</span>    index;</span><br><span class="line">    <span class="comment">// 常用: CON_PRINTBUFFER</span></span><br><span class="line">    <span class="type">int</span>        cflag;</span><br><span class="line">    <span class="type">void</span>    *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>     <span class="title">console</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="1-5-2-1-chu-li-ming-ling-xing-can-shu">1.5.2.1 处理命令行参数</span><a href="#1-5-2-1-chu-li-ming-ling-xing-can-shu" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__setup(<span class="string">&quot;console=&quot;</span>, console_setup);</span><br><span class="line">console=ttymxc0,<span class="number">115200</span>  console=ttyVIRT0</span><br></pre></td></tr></table></figure>

<p>处理u-boot通过dts传给内核的cmdline参数，比如bootparam参数。</p>
<p>对于这两个”console&#x3D;xxx”就会调用console_setup函数两次，构造得到2个数组项:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console_cmdline</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>    name[<span class="number">16</span>];            <span class="comment">/* Name of the driver        */</span></span><br><span class="line">    <span class="type">int</span>    index;                <span class="comment">/* Minor dev. to use        */</span></span><br><span class="line">    <span class="type">char</span>    *options;            <span class="comment">/* Options for the driver   */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_A11Y_BRAILLE_CONSOLE</span></span><br><span class="line">    <span class="type">char</span>    *brl_options;            <span class="comment">/* Options for braille driver */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console_cmdline</span> <span class="title">console_cmdline</span>[<span class="title">MAX_CMDLINECONSOLES</span>];</span></span><br></pre></td></tr></table></figure>

<p>在cmdline中，最后的”console&#x3D;xxx”就是”selected_console”(被选中的console，对应&#x2F;dev&#x2F;console)：</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/8.png" alt="img"></p>
<h4><span id="1-5-2-2-register-console">1.5.2.2 register_console</span><a href="#1-5-2-2-register-console" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uart_add_one_port</span><br><span class="line">    uart_configure_port</span><br><span class="line">        <span class="title function_">register_console</span><span class="params">(port-&gt;cons)</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/fuzidage/p/18203864">Linux下Uart子系统驱动 - fuzidage - 博客园 (cnblogs.com)</a></p>
<h4><span id="1-5-2-3-x2f-dev-x2f-console">1.5.2.3 &#x2F;dev&#x2F;console</span><a href="#1-5-2-3-x2f-dev-x2f-console" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tty_open</span><br><span class="line">    tty = tty_open_by_driver(device, inode, filp);</span><br><span class="line">        driver = tty_lookup_driver(device, filp, &amp;index);</span><br><span class="line">            <span class="keyword">case</span> <span class="title function_">MKDEV</span><span class="params">(TTYAUX_MAJOR, <span class="number">1</span>)</span>: &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">console_driver</span> =</span> console_device(index);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 从console_drivers链表头开始寻找</span></span><br><span class="line"><span class="comment"> * 如果console-&gt;device成功，就返回它对应的tty_driver</span></span><br><span class="line"><span class="comment"> * 这就是/dev/console对应的tty_driver</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">struct</span> tty_driver *<span class="title function_">console_device</span><span class="params">(<span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    console_lock();</span><br><span class="line">    for_each_console(c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!c-&gt;device)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        driver = c-&gt;device(c, index);</span><br><span class="line">        <span class="keyword">if</span> (driver)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    console_unlock();</span><br><span class="line">    <span class="keyword">return</span> driver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/fuzidage/p/18203864">Linux下Uart子系统驱动 - fuzidage - 博客园 (cnblogs.com)</a></p>
<h2><span id="1-6-nei-he-xin-xi-de-zao-qi-da-yin">1.6 内核信息的早期打印</span><a href="#1-6-nei-he-xin-xi-de-zao-qi-da-yin" class="header-anchor">#</a></h2><p>当我们注册了uart_driver、并调用uart_add_one_port后，它里面才注册console，在这之后才能使用printk。</p>
<p>如果想更早地使用printk函数，比如在安装UART驱动之前就使用printk，这时就需要自己去注册console。</p>
<p>更早地、单独地注册console，有两种方法：</p>
<p>early_printk：自己实现write函数，不涉及设备树，简单明了</p>
<p>earlycon：通过设备树传入硬件信息，跟内核中驱动程序匹配<br>earlycon是新的、推荐的方法，在内核已经有驱动的前提下，通过设备树或cmdline指定寄存器地址即可。</p>
<h3><span id="1-6-1-early-printk">1.6.1 early_printk</span><a href="#1-6-1-early-printk" class="header-anchor">#</a></h3><p>arch\arm\kernel\early_printk.c，必须实现这几点：</p>
<ul>
<li>配置内核，选择：CONFIG_EARLY_PRINTK</li>
<li>内核中实现：printch函数</li>
<li>cmdline中添加：earlyprintk</li>
</ul>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/9.png" alt="img"></p>
<h3><span id="1-6-2-earlycon">1.6.2 earlycon</span><a href="#1-6-2-earlycon" class="header-anchor">#</a></h3><h1><span id="2-prink-h-jie-shao">2 prink.h介绍</span><a href="#2-prink-h-jie-shao" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pr_emerg(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_alert(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_crit(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_err(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warning(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warn pr_warning</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_notice(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="comment">/* If you are writing a driver, please use dev_dbg instead */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DYNAMIC_DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/dynamic_debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dynamic_pr_debug() uses pr_fmt() internally so we don&#x27;t need it here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_debug(fmt, ...) \</span></span><br><span class="line"><span class="meta">        dynamic_pr_debug(fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_debug(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_debug(fmt, ...) \</span></span><br><span class="line"><span class="meta">        no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/10.png" alt="img"></p>
<p><code>pr_emerg到pr_info</code>都是一些基本的kernel打印函数，用来设置内核日志打印级别，可以看到它和下面这种打印本质上并无差异。</p>
<p>而<code>pr_debug</code>则有3种输出方式，当开启dynamic_debug后，则走dynamic_pr_debug流程（dynamic_debug见下一节）。当用户开启了DEBUG宏，则走printk流程，否则什么都不打印。</p>
<h1><span id="3-dmesg-ming-ling">3 dmesg命令</span><a href="#3-dmesg-ming-ling" class="header-anchor">#</a></h1><h2><span id="3-1-x2f-proc-x2f-kmsg">3.1 &#x2F;proc&#x2F;kmsg</span><a href="#3-1-x2f-proc-x2f-kmsg" class="header-anchor">#</a></h2><p><code>/proc/kmsg</code> 是一个特殊的文件，它提供了内核消息缓冲区的访问，这个缓冲区包含了内核产生的所有消息，包括各种调试和错误信息，如内核的启动打印</p>
<p><code>dmesg命令就是cat /proc/kmsg</code>。</p>
<h2><span id="3-2-xiu-gai-nei-he-ri-zhi-huan-chong-qu-da-xiao">3.2 修改内核日志缓冲区大小</span><a href="#3-2-xiu-gai-nei-he-ri-zhi-huan-chong-qu-da-xiao" class="header-anchor">#</a></h2><p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/11.png" alt="img"></p>
<h2><span id="3-3-dmesg">3.3 dmesg</span><a href="#3-3-dmesg" class="header-anchor">#</a></h2><p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/12.png" alt="img"></p>
<p>dmesg命令是从kernel ring buffer中读取内核日志信息。因此可以用dmesg命令查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-C:  直接清除ring buffer</span><br><span class="line">-c： 当完成打印显示后清除环缓冲内的内容。</span><br><span class="line">-s： 缓冲区大小</span><br><span class="line">　	定义一个大小为&quot;缓冲区大小&quot;的缓冲区用于查询内核环缓冲区。默认大小为 8196，如果你设置了一个大于默认值的环缓冲区，那你就可以用这个选项定义一个相当的缓冲区来查看完整的环缓冲区内容。</span><br><span class="line"></span><br><span class="line">-n：级别</span><br><span class="line"></span><br><span class="line">dmesg -k：打印内核信息</span><br><span class="line">dmesg -u：打印用户空间信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实用dmesg -n也是可以设置控制台打印级别:</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/13.png" alt="img"></p>
<p>有时候在调试kernel驱动时内核panic了or死锁了，那么无法敲命令，如何查看日志呢？重启后日志就没了，那么可以敲如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/kmsg &gt; /mnt/data/ker.log &amp; 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p> 用后台进程将日志导入到文件。</p>
<ol>
<li>dmesg -f：根据系统打印信息:</li>
</ol>
<p>可用系统有</p>
<pre><code>kern - kernel messages（内核信息）
user - random user-level messages（随机用户信息）
mail - mail system（邮件系统信息）
daemon - system daemons（系统守护进程信息）
auth - security/authorization messages（认证授权安全信息）
syslog - messages generated internally by syslogd（系统日志信息）
lpr - line printer subsystem（打印机信息）
news - network news subsystem（网络系统信息）
</code></pre>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/14.png" alt="img"></p>
<ol start="2">
<li>dmesg -l：根据level来打印信息:</li>
</ol>
<p>   可用的level信息有</p>
<pre><code>   emerg - system is unusable（系统无法使用）
      alert - action must be taken immediately
       crit - critical conditions（临界条件）
        err - error conditions（错误条件）
       warn - warning conditions（警告条件）
     notice - normal but significant condition
       info - informational
      debug - debug-level messages（debug）
</code></pre>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/15.png" alt="img"></p>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim配置成类似source-insight的IDE</title>
    <url>/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#qian-yan">前言</a><ul>
<li><a href="#ji-ben-an-zhuang">基本安装</a></li>
</ul>
</li>
<li><a href="#1-ctags-taglist-an-zhuang-pei-zhi">1 ctags + taglist安装配置</a><ul>
<li><a href="#1-1-ctag-zuo-yong">1.1 ctag作用</a></li>
<li><a href="#1-2-an-zhuang-ctags">1.2 安装ctags</a></li>
<li><a href="#1-3-an-zhuang-taglist">1.3 安装taglist</a></li>
<li><a href="#1-4-chuang-jian-tags-wen-jian">1.4 创建tags文件</a><ul>
<li><a href="#1-4-1-pei-zhi-xuan-xiang">1.4.1配置选项</a></li>
</ul>
</li>
<li><a href="#1-5-pei-zhi-vimrc">1.5 配置.vimrc</a></li>
</ul>
</li>
<li><a href="#2-ctags-taglist-shi-yong">2 ctags + taglist使用</a><ul>
<li><a href="#2-1-ctags-shi-yong">2.1 ctags使用</a><ul>
<li><a href="#2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan">2.1.1 <code>ctrl + ]</code>可以进行函数跳转</a></li>
<li><a href="#2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi">2.1.2 <code>ctrl + T</code>可以返回跳转之前位置</a></li>
<li><a href="#2-1-3-jia-zai-tags">2.1.3 加载tags</a></li>
<li><a href="#2-1-4-zi-dong-jia-zai-tags">2.1.4 自动加载tags</a></li>
<li><a href="#2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian">2.1.5 ts 列出所有匹配的标签</a></li>
<li><a href="#2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou">2.1.5 <code>Ctrl + W + ]</code>分割当前窗口</a></li>
<li><a href="#2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu">2.1.6 vi –t tag 找到名为 tag 的变量的定义处</a></li>
</ul>
</li>
<li><a href="#2-2-taglist-shi-yong">2.2 taglist使用</a><ul>
<li><a href="#2-2-1-f2-jian-da-kai-guan-bi-taglist">2.2.1 F2键打开关闭Taglist</a></li>
<li><a href="#2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan">2.2.2 ctrl w w键taglist和vim窗口光标切换</a></li>
<li><a href="#2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi">2.2.3 回车键taglist跳转到具体位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-nerdtree-cha-jian">3 NERDTree插件</a><ul>
<li><a href="#3-1-an-zhuang-pei-zhi-nerdtree">3.1 安装配置NERDTree</a><ul>
<li><a href="#3-1-1-an-zhuang">3.1.1 安装</a></li>
<li><a href="#3-1-2-pei-zhi">3.1.2 配置</a></li>
</ul>
</li>
<li><a href="#3-2-shi-yong-nerdtree">3.2 使用NERDTree</a><ul>
<li><a href="#3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao">3.2.1 F8键开启关闭右图文件列表</a></li>
<li><a href="#3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan">3.2.2 ctrl w w键NERDTree和vim窗口光标切换</a></li>
<li><a href="#3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi">3.2.3 回车键NERDTree跳转到具体位置</a></li>
<li><a href="#3-2-3-fan-hui-shang-yi-ceng-mu-lu">3.2.3 返回上一层目录</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao">4 SrcExpl插件（功能鸡肋先不介绍）</a><ul>
<li><a href="#4-1-srcexp-an-zhuang-pei-zhi">4.1 SrcExp安装配置</a></li>
<li><a href="#4-2-srcexpl-shi-yong">4.2 SrcExpl使用</a><ul>
<li><a href="#4-2-1-f12-qi-dong-he-jin-yong-srcexpl">4.2.1 F12启动和禁用SrcExpl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-youcompleteme-dai-ma-bu-qi-cha-jian">5 YouCompleteMe代码补齐插件</a><ul>
<li><a href="#5-1-an-zhuang-pei-zhi">5.1 安装配置</a></li>
<li><a href="#5-2-youcompleteme-shi-yong">5.2 YouCompleteMe使用</a></li>
</ul>
</li>
<li><a href="#6-cscope-cha-jian">6 cscope插件</a><ul>
<li><a href="#6-1-an-zhuang">6.1 安装</a></li>
<li><a href="#6-2-pei-zhi-chan-sheng-cscope-out">6.2 配置产生cscope.out</a></li>
<li><a href="#6-3-pei-zhi-vimrc">6.3 配置.vimrc</a></li>
<li><a href="#6-5-shi-yong">6.5 使用</a><ul>
<li><a href="#6-5-1-jian-li-shu-ju-ku-lian-jie">6.5.1 建立数据库连接</a></li>
<li><a href="#6-5-2-cha-xun-shu-ju-ku-lian-jie">6.5.2 查询数据库连接</a></li>
<li><a href="#6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi">6.5.3 查看引用调用位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-source-insight-kuo-zhan">7 source insight扩展</a><ul>
<li><a href="#7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight">7.1 将kernel工程精确快速导入到sourceinsight</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h1><h2><span id="ji-ben-an-zhuang">基本安装</span><a href="#ji-ben-an-zhuang" class="header-anchor">#</a></h2><pre><code>sudo apt-get install vim vim-scripts vim-doc
</code></pre>
<p>vim-scripts是vim的一些基本插件，包括语法高亮的支持、缩进等等。<br>整体配置好后效果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/1.png" alt="image"></p>
<h1><span id="1-ctags-taglist-an-zhuang-pei-zhi">1 ctags + taglist安装配置</span><a href="#1-ctags-taglist-an-zhuang-pei-zhi" class="header-anchor">#</a></h1><h2><span id="1-1-ctag-zuo-yong">1.1 ctag作用</span><a href="#1-1-ctag-zuo-yong" class="header-anchor">#</a></h2><p>ctags 最先是用来生成C代码的tags文件，后来扩展成可以生成各类语言的tags, 有些语言也有专有的tags生成工具（比如java的jtags, python的 ptags)，因此ctag用来进行vim阅读源码时进行函数，变量的快速定位跳转。</p>
<h2><span id="1-2-an-zhuang-ctags">1.2 安装ctags</span><a href="#1-2-an-zhuang-ctags" class="header-anchor">#</a></h2><pre><code>sudo apt-get install ctags
</code></pre>
<h2><span id="1-3-an-zhuang-taglist">1.3 安装taglist</span><a href="#1-3-an-zhuang-taglist" class="header-anchor">#</a></h2><p>taglist_46.zip压缩包：解压到~&#x2F;.vim目录下即可。<br><a href="https://www.vim.org/scripts/script.php?script_id=273">https://www.vim.org/scripts/script.php?script_id=273</a></p>
<pre><code>mkdir ~/.vim
cd ~/.vim
unzip taglist_46.zip
</code></pre>
<h2><span id="1-4-chuang-jian-tags-wen-jian">1.4 创建tags文件</span><a href="#1-4-chuang-jian-tags-wen-jian" class="header-anchor">#</a></h2><p><code>$ctags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q</code><br>如果为了简单，也可以只进行：<br><code>$ctags -R *</code><br>不过，这种成员变量没有包含在里面。所以可能有些对象的成员时无法跳转。</p>
<h3><span id="1-4-1-pei-zhi-xuan-xiang">1.4.1配置选项</span><a href="#1-4-1-pei-zhi-xuan-xiang" class="header-anchor">#</a></h3><pre><code>  $ ctags -R　　　　　　　　　　　　　  #递归的为当前目录及子目录下的所有代码文件生成tags文件 (推荐使用此命令)
  $ ctags filename.c filename1.c file.h 　#为当前目录某些源码生成tags文件
  $ ctags *.c *.h　　　　　　　　　　　   #为当前目录所有.c, .h源码生成tags文件

  为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c++参数主要是：ctags -R --c++-kinds=+px --fields=+iaS --extra=+q
  其中：
    选项c++-kinds 用于指定C++语言的 tags记录类型,  --c-kinds用于指定c语言的，  通用格式是  --&#123;language&#125;-kinds
    选项 fileds 用于指定每条标记的扩展字段域
    extra 选项用于增加额外的条目:   f表示为每个文件增加一个条目，  q为每个类增加一个条目
</code></pre>
<h2><span id="1-5-pei-zhi-vimrc">1.5 配置.vimrc</span><a href="#1-5-pei-zhi-vimrc" class="header-anchor">#</a></h2><pre><code>&quot;--------------display-----------------
set nu                          &quot;行号
syntax on                       &quot;语法高亮
set ruler                       &quot;显示当前行和列
set showcmd                     &quot;显示部分命令
set showmode            &quot;最后一行显示当前模式
&quot;set match                      &quot;显示括号匹配
&quot;--------------display-----------------

&quot;---------------input------------------
set smartindent         &quot;自动缩进
set expandtab           &quot;将tab转化为空格
set smarttab            &quot;插入tab使用shiftwidth
set shiftwidth=4        &quot;缩进列数为4
&quot;---------------input------------------

&quot;---------------search-----------------
set hlsearch            &quot;搜索结果高亮显示
&quot;set inccase                    &quot;预览搜索结果
set ignorecase          &quot;不区分大小写
set smartcase           &quot;当有大写字母时区分大小写
&quot;---------------search-----------------

&quot;---------------encoding----------------
set encoding=utf-8              &quot;设置编码格式
set fileencodings=utf-8,gb18030,gbk,gb2312,big5
set termencoding=utf-8


&quot;--------------ctags----------------
set tags=tags;
set autochdir        &quot;通用方式，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。
&quot;--------------ctags----------------


&quot;--------------taglist----------------
let Tlist_Use_Left_Window=1             &quot;vim左侧窗口显示Taglist
let Tlist_Exit_OnlyWindow=1             &quot;Taglist是最后一个窗口是退出vim
let Tlist_WinWidth=60           &quot;设置Taglist窗口宽度为60
nmap &lt;F2&gt; :Tlist&lt;CR&gt;                    &quot;设置快捷键&lt;F2&gt;打开Taglist
&quot;--------------taglist----------------
</code></pre>
<h1><span id="2-ctags-taglist-shi-yong">2 ctags + taglist使用</span><a href="#2-ctags-taglist-shi-yong" class="header-anchor">#</a></h1><h2><span id="2-1-ctags-shi-yong">2.1 ctags使用</span><a href="#2-1-ctags-shi-yong" class="header-anchor">#</a></h2><pre><code>book@100ask:~/ftp/openedv/uboot-2016$ vi drivers/usb/gadget/f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/2.png" alt="image"></p>
<h3><span id="2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan">2.1.1 <code>ctrl + ]</code>可以进行函数跳转</span><a href="#2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/3.png" alt="image"></p>
<h3><span id="2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi">2.1.2 <code>ctrl + T</code>可以返回跳转之前位置</span><a href="#2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/4.png" alt="image"></p>
<h3><span id="2-1-3-jia-zai-tags">2.1.3 加载tags</span><a href="#2-1-3-jia-zai-tags" class="header-anchor">#</a></h3><p>默认从创建tags的目录去启动vim打开文件会自动加载当前目录的tags文件，因此可以直接跳转：<br>如我是从uboot根目录建立的tags文件，然后：</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016$ vi drivers/usb/gadget/f_fastboot.c
</code></pre>
<p>这样自动加载tags文件，能够进行跳转。<br>如果进入其他目录：可以看到就无法打开tags文件。</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016$ cd  drivers/usb/gadget/
book@100ask:~/ftp/openedv/uboot-2016/drivers/usb/gadget$ vi f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/5.png" alt="image"></p>
<p>vim进入命令模式输入：</p>
<pre><code>:set tags+=&#39;/home/book/ftp/openedv/uboot-2016/tags
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/6.png" alt="image"><br>此时就可以正常跳转了。</p>
<h3><span id="2-1-4-zi-dong-jia-zai-tags">2.1.4 自动加载tags</span><a href="#2-1-4-zi-dong-jia-zai-tags" class="header-anchor">#</a></h3><p>在~&#x2F;.vimrc文件中添加下面两行：</p>
<pre><code>set tags=tags;
set autochdir
</code></pre>
<p>通用方式，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。<br>这样就可以在不用在tags根路径去使用vim了。如：</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016/drivers/usb/gadget$ vi f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/7.png" alt="image"></p>
<h3><span id="2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian">2.1.5 ts 列出所有匹配的标签</span><a href="#2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/8.png" alt="image"><br>可以看到有2处地方匹配，一个是cmd&#x2F;bootm.c，一个是include&#x2F;command.h<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/9.png" alt="image"></p>
<h3><span id="2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou">2.1.5 <code>Ctrl + W + ]</code>分割当前窗口</span><a href="#2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/10.png" alt="image"><br>输入:q退出分割窗口。</p>
<h3><span id="2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu">2.1.6 vi –t tag 找到名为 tag 的变量的定义处</span><a href="#2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu" class="header-anchor">#</a></h3><p>例如stitch_event_handler_th函数位于当前tags目录中的stitch&#x2F;common&#x2F;stitch.c的第1212行。只需确保在tags中的子目录中任意位置输入：</p>
<p><code>robin.lee@WORKSTATION5:/robin.lee/zip/A2/osdrv/interdrv/v2/dwa$ vi -t stitch_event_handler_th</code><br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/11.png" alt="image"></p>
<h2><span id="2-2-taglist-shi-yong">2.2 taglist使用</span><a href="#2-2-taglist-shi-yong" class="header-anchor">#</a></h2><h3><span id="2-2-1-f2-jian-da-kai-guan-bi-taglist">2.2.1 F2键打开关闭Taglist</span><a href="#2-2-1-f2-jian-da-kai-guan-bi-taglist" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/12.png" alt="image"></p>
<h3><span id="2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan">2.2.2 ctrl w w键taglist和vim窗口光标切换</span><a href="#2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/13.png" alt="image"></p>
<p>例如光标位置处于vim窗口的第1211行，按下ctrl w w键（w按2次），光标会跳到左边taglist窗口。按上下左右方向键可以查找宏定义，符号，函数等。再次按ctrl w w又会跳到vim的窗口。</p>
<h3><span id="2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi">2.2.3 回车键taglist跳转到具体位置</span><a href="#2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/14.png" alt="image"><br>比如现在光标位于taglist界面的stitch_src_qbuf位置，按下回车会跳转到函数定义的具体位置：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/15.png" alt="image"></p>
<h1><span id="3-nerdtree-cha-jian">3 NERDTree插件</span><a href="#3-nerdtree-cha-jian" class="header-anchor">#</a></h1><p>NERDTree是Vim界面显示树形目录的文件管理器插件，可在vim操作界面进行文件打开、目录浏览操作。</p>
<h2><span id="3-1-an-zhuang-pei-zhi-nerdtree">3.1 安装配置NERDTree</span><a href="#3-1-an-zhuang-pei-zhi-nerdtree" class="header-anchor">#</a></h2><h3><span id="3-1-1-an-zhuang">3.1.1 安装</span><a href="#3-1-1-an-zhuang" class="header-anchor">#</a></h3><p><a href="https://www.vim.org/scripts/script.php?script_id=1658">https://www.vim.org/scripts/script.php?script_id=1658</a><br>下载后放到~&#x2F;.vim目录，解压即可完成安装。</p>
<h3><span id="3-1-2-pei-zhi">3.1.2 配置</span><a href="#3-1-2-pei-zhi" class="header-anchor">#</a></h3><p><code>vi ~/.vimrc</code><br>添加如下配置：</p>
<pre><code>&quot;--------------NERDTree---------------
let NERDTreeWinPos=&#39;right&#39;		&quot;设置窗口在右侧
nmap &lt;F8&gt; :NERDTree&lt;CR&gt;			&quot;设置快捷键F8打开
let NERDTreeWinSize=40		 	&quot;窗口大小为40
&quot;--------------NERDTree---------------
</code></pre>
<h2><span id="3-2-shi-yong-nerdtree">3.2 使用NERDTree</span><a href="#3-2-shi-yong-nerdtree" class="header-anchor">#</a></h2><h3><span id="3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao">3.2.1 F8键开启关闭右图文件列表</span><a href="#3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/16.png" alt="image"></p>
<h3><span id="3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan">3.2.2 ctrl w w键NERDTree和vim窗口光标切换</span><a href="#3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/17.png" alt="image"><br>光标原本再右边窗口，输入ctrl w w(w按2次)切换到左边vim窗口。</p>
<h3><span id="3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi">3.2.3 回车键NERDTree跳转到具体位置</span><a href="#3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi" class="header-anchor">#</a></h3><p>同理，和taglist一样，也是光标移动到具体文件后回车即可跳转到具体文件。方向键上下移动选择具体文件。跳转到stitch_ctx.h：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/18.png" alt="image"></p>
<h3><span id="3-2-3-fan-hui-shang-yi-ceng-mu-lu">3.2.3 返回上一层目录</span><a href="#3-2-3-fan-hui-shang-yi-ceng-mu-lu" class="header-anchor">#</a></h3><p>选择‘up a dir’，按回车：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/19.png" alt="image"><br>返回上一层目录的结果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/20.png" alt="image"></p>
<h1><span id="4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao">4 SrcExpl插件（功能鸡肋先不介绍）</span><a href="#4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao" class="header-anchor">#</a></h1><p>SrcExpl（源资源管理器）是一个源代码资源管理器，通过显示函数或类型定义来显示当前选定的关键字或在单独的窗口中声明。该插件旨在重新创建上下文 IDE 中可用的窗口。</p>
<p>结合“Taglist”和“NERD tree”效果更佳。</p>
<h2><span id="4-1-srcexp-an-zhuang-pei-zhi">4.1 SrcExp安装配置</span><a href="#4-1-srcexp-an-zhuang-pei-zhi" class="header-anchor">#</a></h2><p>安装：<br><a href="https://github.com/wenlongche/SrcExpl">https://github.com/wenlongche/SrcExpl</a><br><a href="https://www.vim.org/scripts/script.php?script_id=2179">https://www.vim.org/scripts/script.php?script_id=2179</a><br>下载后放入<del>&#x2F;.vim进行解压即可。<br>配置：<br>打开</del>&#x2F;.vimrc,添加如下配置：</p>
<pre><code>&quot; // The switch of the Source Explorer
nmap &lt;F12&gt; :SrcExplToggle&lt;CR&gt;

&quot; // Set the height of Source Explorer window
let g:SrcExpl_winHeight = 16

&quot; // Set 100 ms for refreshing the Source Explorer
let g:SrcExpl_refreshTime = 500

&quot; // Set &quot;Enter&quot; key to jump into the exact definition context
let g:SrcExpl_jumpKey = &quot;&lt;ENTER&gt;&quot;

&quot; // Set &quot;Space&quot; key for back from the definition context
let g:SrcExpl_gobackKey = &quot;&lt;SPACE&gt;&quot;

&quot; // In order to avoid conflicts, the Source Explorer should know what plugins except
&quot; // itself are using buffers. And you need add their buffer names into below list
&quot; // according to the command &quot;:buffers!&quot;
let g:SrcExpl_pluginList = [
        \ &quot;__Tag_List__&quot;,
        \ &quot;_NERD_tree_&quot;,
        \ &quot;Source_Explorer&quot;
    \ ]

&quot; // The color schemes used by Source Explorer. There are five color schemes
&quot; // supported for now - Red, Cyan, Green, Yellow and Magenta. Source Explorer
&quot; // will pick up one of them randomly when initialization.
let g:SrcExpl_colorSchemeList = [
        \ &quot;Red&quot;,
        \ &quot;Cyan&quot;,
        \ &quot;Green&quot;,
        \ &quot;Yellow&quot;,
        \ &quot;Magenta&quot;
    \ ]

&quot; // Enable/Disable the local definition searching, and note that this is not
&quot; // guaranteed to work, the Source Explorer doesn&#39;t check the syntax for now.
&quot; // It only searches for a match with the keyword according to command &#39;gd&#39;
let g:SrcExpl_searchLocalDef = 1

&quot; // Workaround for Vim bug @https://goo.gl/TLPK4K as any plugins using autocmd for
&quot; // BufReadPre might have conflicts with Source Explorer. e.g. YCM, Syntastic etc.
let g:SrcExpl_nestedAutoCmd = 1

&quot; // Do not let the Source Explorer update the tags file when opening
let g:SrcExpl_isUpdateTags = 0

&quot; // Use &#39;Exuberant Ctags&#39; with &#39;--sort=foldcase -R .&#39; or &#39;-L cscope.files&#39; to
&quot; // create/update the tags file
let g:SrcExpl_updateTagsCmd = &quot;ctags --sort=foldcase -R .&quot;

&quot; // Set &quot;&lt;F12&gt;&quot; key for updating the tags file artificially
let g:SrcExpl_updateTagsKey = &quot;&lt;F12&gt;&quot;

&quot; // Set &quot;&lt;F3&gt;&quot; key for displaying the previous definition in the jump list
let g:SrcExpl_prevDefKey = &quot;&lt;F3&gt;&quot;

&quot; // Set &quot;&lt;F4&gt;&quot; key for displaying the next definition in the jump list
let g:SrcExpl_nextDefKey = &quot;&lt;F4&gt;&quot;
</code></pre>
<h2><span id="4-2-srcexpl-shi-yong">4.2 SrcExpl使用</span><a href="#4-2-srcexpl-shi-yong" class="header-anchor">#</a></h2><h3><span id="4-2-1-f12-qi-dong-he-jin-yong-srcexpl">4.2.1 F12启动和禁用SrcExpl</span><a href="#4-2-1-f12-qi-dong-he-jin-yong-srcexpl" class="header-anchor">#</a></h3><h1><span id="5-youcompleteme-dai-ma-bu-qi-cha-jian">5 YouCompleteMe代码补齐插件</span><a href="#5-youcompleteme-dai-ma-bu-qi-cha-jian" class="header-anchor">#</a></h1><h2><span id="5-1-an-zhuang-pei-zhi">5.1 安装配置</span><a href="#5-1-an-zhuang-pei-zhi" class="header-anchor">#</a></h2><p>先安装编译依赖工具：</p>
<pre><code>sudo apt install build-essential cmake python-dev python3-dev clang
</code></pre>
<p>下载YouCompleteMe源码：</p>
<pre><code>git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/
cd .vim/bundle/YouCompleteMe
git submodule update --init --recursive
</code></pre>
<p>编译安装 YouCompleteMe:</p>
<pre><code>./install.py --clang-completer
</code></pre>
<p>安装好后打印如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/21.png" alt="image"></p>
<h2><span id="5-2-youcompleteme-shi-yong">5.2 YouCompleteMe使用</span><a href="#5-2-youcompleteme-shi-yong" class="header-anchor">#</a></h2><p>.vimrc添加配置：</p>
<pre><code>let g:ycm_global_ycm_extra_conf = &#39;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39;
set runtimepath+=~/.vim/bundle/YouCompleteMe
autocmd InsertLeave * if pumvisible() == 0|pclose|endif
inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot;
imap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
vmap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
nmap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
</code></pre>
<p>vim版本比较低达不到插件YCM的要求从而报错【YouCompleteMe unavailable: requires Vim 8.1.2269+.】，这样也好解决，从github上重新下最新版本的vim即可。命令如下所示：</p>
<pre><code>cd /usr/local/share
sudo git clone https://github.com/vim/vim.git
cd vim/src
sudo ./configure --with-features=huge \
--enable-multibyte \
--enable-rubyinterp=yes \
--enable-pythoninterp=yes \
--enable-python3interp=yes \
--prefix=/usr/local/vim82
</code></pre>
<p>之后make和make install一下，命令如下所示：</p>
<pre><code>sudo make
sudo make install
</code></pre>
<p>在&#x2F;usr&#x2F;bin目录下建立符号链接，命令如下所示：</p>
<pre><code>sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vim82
sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vim
sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vi
</code></pre>
<p>补齐效果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/22.png" alt="image"><br>输入vim –version信息可以看vim版本号，现已经v9.1,默认应该是8.1的。<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/23.png" alt="image"></p>
<p>vim配色方案：<br><a href="https://github.com/flazz/vim-colorschemes">https://github.com/flazz/vim-colorschemes</a><br>设置函数高亮：</p>
<pre><code>vi /usr/share/vim/vim91/syntax/c.vim

&quot;highlight Functions
syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;[^()]*)(&quot;me=e-2
syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;\s*(&quot;me=e-1
hi cFunctions gui=NONE cterm=bold  ctermfg=40
</code></pre>
<h1><span id="6-cscope-cha-jian">6 cscope插件</span><a href="#6-cscope-cha-jian" class="header-anchor">#</a></h1><h2><span id="6-1-an-zhuang">6.1 安装</span><a href="#6-1-an-zhuang" class="header-anchor">#</a></h2><pre><code>sudo apt-get install cscope
</code></pre>
<h2><span id="6-2-pei-zhi-chan-sheng-cscope-out">6.2 配置产生cscope.out</span><a href="#6-2-pei-zhi-chan-sheng-cscope-out" class="header-anchor">#</a></h2><pre><code>cscope -Rbqk

-R: 在生成索引文件时，搜索子目录树中的代码
-b: 只生成索引文件，不进入cscope的界面
-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度
-k: 在生成索引文件时，不搜索/usr/include目录
-i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用”–“，表示由标准输入获得文件列表。
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/24.png" alt="image"></p>
<h2><span id="6-3-pei-zhi-vimrc">6.3 配置.vimrc</span><a href="#6-3-pei-zhi-vimrc" class="header-anchor">#</a></h2><pre><code>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
&quot; cscope setting
&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
if has(&quot;cscope&quot;)
  set csprg=/usr/bin/cscope
  set csto=1
  set cst
  set nocsverb
  &quot; add any database in current directory
  if filereadable(&quot;cscope.out&quot;)
      cs add cscope.out
  endif
  set csverb
endif

nmap &lt;C-@&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;
nmap &lt;C-@&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;

set cscopequickfix=s-,c-,d-,i-,t-,e-
</code></pre>
<h2><span id="6-5-shi-yong">6.5 使用</span><a href="#6-5-shi-yong" class="header-anchor">#</a></h2><h3><span id="6-5-1-jian-li-shu-ju-ku-lian-jie">6.5.1 建立数据库连接</span><a href="#6-5-1-jian-li-shu-ju-ku-lian-jie" class="header-anchor">#</a></h3><pre><code>:cs add ./cscope.out
</code></pre>
<h3><span id="6-5-2-cha-xun-shu-ju-ku-lian-jie">6.5.2 查询数据库连接</span><a href="#6-5-2-cha-xun-shu-ju-ku-lian-jie" class="header-anchor">#</a></h3><pre><code>:cs show
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/25.png" alt="image"></p>
<h3><span id="6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi">6.5.3 查看引用调用位置</span><a href="#6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi" class="header-anchor">#</a></h3><pre><code>:cs f s symbol #查看symbol和引用的地方, 如:cs find s IDLE_TIMEOUT_MS
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/26.png" alt="image"></p>
<h1><span id="7-source-insight-kuo-zhan">7 source insight扩展</span><a href="#7-source-insight-kuo-zhan" class="header-anchor">#</a></h1><h2><span id="7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight">7.1 将kernel工程精确快速导入到sourceinsight</span><a href="#7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight" class="header-anchor">#</a></h2><p><a href="https://github.com/tonyho/Generate_Kernel_Uboot_Project_forIDE">https://github.com/tonyho/Generate_Kernel_Uboot_Project_forIDE</a></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile-常用函数和通用模板</title>
    <url>/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-makefile-gui-ze">1 Makefile规则</a></li>
<li><a href="#2-yi-bu-yi-bu-wan-shan-makefile">2 一步一步完善 Makefile</a><ul>
<li><a href="#2-1-mo-shi-gui-ze">2.1 模式规则</a></li>
<li><a href="#2-2-zi-dong-bian-liang">2.2 自动变量</a><ul>
<li><a href="#2-2-1-han-shu-chuan-can">2.2.1 函数传参</a></li>
</ul>
</li>
<li><a href="#2-3-li-ji-bian-liang-he-yan-shi-bian-liang">2.3 立即变量和延时变量</a></li>
<li><a href="#2-3-bian-liang-dao-chu">2.3 变量导出</a></li>
<li><a href="#2-4-makefile-zhong-shi-yong-shell-ming-ling">2.4 Makefile 中使用 shell 命令</a></li>
<li><a href="#2-5-wei-mu-biao">2.5 伪目标</a></li>
<li><a href="#2-6-chan-sheng-yi-lai-wen-jian">2.6 产生依赖文件</a></li>
</ul>
</li>
<li><a href="#3-chang-yong-han-shu">3 常用函数</a><ul>
<li><a href="#3-1-zi-fu-chuan-xiang-guan">3.1 字符串相关</a><ul>
<li><a href="#3-1-1-subst">3.1.1 <code>subst</code></a></li>
<li><a href="#3-1-2-patsubst">3.1.2 <code>patsubst</code></a></li>
<li><a href="#3-1-3-strip">3.1.3 <code>strip</code></a></li>
<li><a href="#3-1-4-findstring">3.1.4 <code>findstring</code></a></li>
<li><a href="#3-1-6-filter-out">3.1.6 <code>filter-out</code></a></li>
<li><a href="#3-1-7-sort">3.1.7 <code>sort</code></a></li>
</ul>
</li>
<li><a href="#3-2-wen-jian-ming-xiang-guan">3.2 文件名相关</a><ul>
<li><a href="#3-2-1-dir">3.2.1 <code>dir</code></a></li>
<li><a href="#3-2-2-notdir">3.2.2 <code>notdir</code></a></li>
<li><a href="#3-2-3-suffix">3.2.3 <code>suffix</code></a></li>
<li><a href="#3-2-4-basename">3.2.4 <code>basename</code></a></li>
<li><a href="#3-2-5-addsuffix">3.2.5 <code>addsuffix</code></a></li>
<li><a href="#3-2-6-addprefix">3.2.6 <code>addprefix</code></a></li>
<li><a href="#3-2-7-wildcard">3.2.7 <code>wildcard</code></a></li>
<li><a href="#3-2-8-join">3.2.8<code> join</code></a></li>
<li><a href="#3-2-9-realpath">3.2.9<code>realpath</code></a></li>
<li><a href="#3-2-10-abspath">3.2.10 <code>abspath</code></a></li>
<li><a href="#3-2-11-file">3.2.11 <code>file</code></a></li>
</ul>
</li>
<li><a href="#3-3-qi-ta-han-shu">3.3 其他函数</a><ul>
<li><a href="#3-3-1-foreach">3.3.1 <code>foreach</code></a></li>
<li><a href="#3-3-2-origin">3.3.2 <code>origin</code></a></li>
<li><a href="#3-3-3-word">3.3.3 <code>word</code></a></li>
<li><a href="#3-3-4-wordlist">3.3.4<code>wordlist</code></a></li>
<li><a href="#3-3-5-words">3.3.5 <code>words</code></a></li>
<li><a href="#3-3-6-firstword-lastword">3.3.6 <code>firstword/lastword </code></a></li>
<li><a href="#3-3-7-call">3.3.7 <code>call</code></a></li>
</ul>
</li>
<li><a href="#3-4-vpath-xuan-xiang">3.4 VPATH选项</a></li>
<li><a href="#3-5-make-huan-jing-bian-liang">3.5 make环境变量</a></li>
<li><a href="#3-6-make-bian-yi-xuan-xiang">3.6 make编译选项</a></li>
</ul>
</li>
<li><a href="#4-tong-yong-xing-makefile">4 通用型<code>makefile</code></a><ul>
<li><a href="#4-1-ding-ceng-makefile">4.1 顶层<code>Makefile</code></a></li>
<li><a href="#4-2-makefile-build">4.2 <code>Makefile.build</code></a></li>
<li><a href="#4-3-make-guo-cheng-ju-li">4.3 Make过程举例</a><ul>
<li><a href="#4-3-1-zi-mu-lu-makefile-display-wei-li">4.3.1 子目录<code>MakeFIle-display</code>为例</a></li>
<li><a href="#4-3-2-bian-yi-xiang-xi-shu-chu-ri-zhi">4.3.2 编译详细输出日志</a></li>
<li><a href="#4-3-3-bian-yi-ru-kou">4.3.3 编译入口</a></li>
<li><a href="#4-3-4-bian-yi-build">4.3.4 编译<code>__build</code></a><ul>
<li><a href="#4-3-4-1-bian-yi-subdir-y">4.3.4.1 编译<code>$(subdir-y)</code></a></li>
<li><a href="#4-3-4-2-da-bao-cheng-zong-de-built-in-o">4.3.4.2 打包成总的<code>built-in.o</code></a></li>
</ul>
</li>
<li><a href="#4-3-5-bian-yi-chu-kou">4.3.5 编译出口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-tong-yong-xing-makefile2-luo-ji-ban">5 通用型<code>makefile2</code>-裸机版</a><ul>
<li><a href="#5-1-wen-jian-gong-cheng-mu-lu">5.1 文件工程目录</a></li>
<li><a href="#5-2-lds-lian-jie-jiao-ben">5.2 lds链接脚本</a></li>
<li><a href="#5-3-makefile">5.3 <code>Makefile</code></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-makefile-gui-ze">1 Makefile规则</span><a href="#1-makefile-gui-ze" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">目标(target)…: 依赖(prerequiries)…</span><br><span class="line">&lt;tab&gt;命令(command)</span><br></pre></td></tr></table></figure>

<p>如果<code>“依赖文件”</code>比<code>“目标文件”</code>更加新，那么执行<code>“命令”</code>来重新生成<code>“目标文件”</code>。</p>
<p>命令被执行的 2 个条件：依赖文件比目标文件新，或是 目标文件还没生成。</p>
<h1><span id="2-yi-bu-yi-bu-wan-shan-makefile">2 一步一步完善 Makefile</span><a href="#2-yi-bu-yi-bu-wan-shan-makefile" class="header-anchor">#</a></h1><p>第 1 个 Makefile，简单粗暴，效率低：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : main.c sub.c sub.h</span><br><span class="line">　　gcc -o test main.c sub.c</span><br></pre></td></tr></table></figure>

<p>第 2 个 Makefile，效率高，相似规则太多太啰嗦，不支持检测头文件:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : main.o sub.o</span><br><span class="line">　　gcc -o test main.o sub.o</span><br><span class="line">main.o : main.c</span><br><span class="line">　　gcc -c -o main.o main.c</span><br><span class="line">sub.o : sub.c</span><br><span class="line">　　gcc -c -o sub.o sub.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm *.o test -f</span><br></pre></td></tr></table></figure>

<p>第 3 个 Makefile，效率高，精炼，不支持检测头文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : main.o sub.o</span><br><span class="line">　　gcc -o test main.o sub.o</span><br><span class="line">%.o : %.c</span><br><span class="line">　　gcc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm *.o test -f</span><br></pre></td></tr></table></figure>

<p>第 4 个 Makefile，效率高，精炼，支持检测头文件(但是需要手工添加头文件规则)：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : main.o sub.o</span><br><span class="line">　　gcc -o test main.o sub.o</span><br><span class="line">%.o : %.c</span><br><span class="line">　　gcc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">sub.o : sub.h</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm *.o test -f</span><br></pre></td></tr></table></figure>

<h2><span id="2-1-mo-shi-gui-ze">2.1 模式规则</span><a href="#2-1-mo-shi-gui-ze" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">　　<span class="variable">$(CC)</span> -c  <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>前面第3第4个Makefile都用到了模式规则。</p>
<h2><span id="2-2-zi-dong-bian-liang">2.2 自动变量</span><a href="#2-2-zi-dong-bian-liang" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$@</span>--目标文件</span><br><span class="line"><span class="variable">$^</span>--所有的依赖文件</span><br><span class="line"><span class="variable">$&lt;</span>--第一个依赖文件</span><br><span class="line"><span class="variable">$?</span>--所有的比目标新的依赖文件</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-1-han-shu-chuan-can">2.2.1 函数传参</span><a href="#2-2-1-han-shu-chuan-can" class="header-anchor">#</a></h3><p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/1.png" alt="img"></p>
<p>函数传参也属于自动变量。上图的make结果为：</p>
<p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/2.png" alt="img"></p>
<h2><span id="2-3-li-ji-bian-liang-he-yan-shi-bian-liang">2.3 立即变量和延时变量</span><a href="#2-3-li-ji-bian-liang-he-yan-shi-bian-liang" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">A := <span class="variable">$(C)</span> //立即变量</span><br><span class="line">B = <span class="variable">$(C)</span>  // 延时变量</span><br><span class="line">C = abc  // 延时变量</span><br><span class="line"><span class="comment">#D = 100ask</span></span><br><span class="line">D ?= weidongshan//延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        @echo A = <span class="variable">$(A)</span></span><br><span class="line">        @echo B = <span class="variable">$(B)</span></span><br><span class="line">        @echo D = <span class="variable">$(D)</span></span><br><span class="line">C += 123</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/3.png" alt="img"></p>
<h2><span id="2-3-bian-liang-dao-chu">2.3 变量导出</span><a href="#2-3-bian-liang-dao-chu" class="header-anchor">#</a></h2><p><code>A makefile</code>中的变量无法在<code>B makefile</code>识别，因此要用<code>export</code>导出如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> CC = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line"><span class="keyword">export</span> BUILD_DIR=/home/book/100ask_imx6ull-sdk</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-makefile-zhong-shi-yong-shell-ming-ling">2.4 Makefile 中使用 shell 命令</span><a href="#2-4-makefile-zhong-shi-yong-shell-ming-ling" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PWD=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">CP=<span class="variable">$(<span class="built_in">shell</span> cp)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-5-wei-mu-biao">2.5 伪目标</span><a href="#2-5-wei-mu-biao" class="header-anchor">#</a></h2><p><code>.PHONY</code>表示伪目标。表示无条件执行目标。makefile将不会判断该目标是否存在或者该目标是否需要更新。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">　　rm -f <span class="variable">$(TARGET)</span></span><br><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>

<h2><span id="2-6-chan-sheng-yi-lai-wen-jian">2.6 产生依赖文件</span><a href="#2-6-chan-sheng-yi-lai-wen-jian" class="header-anchor">#</a></h2><p>第5个Makefile。效率高，精炼，支持自动检测头文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objs := main.o sub.o</span><br><span class="line">test : <span class="variable">$(objs)</span></span><br><span class="line">　　gcc -o test <span class="variable">$^</span></span><br><span class="line"><span class="comment"># 需要判断是否存在依赖文件</span></span><br><span class="line"><span class="comment"># .main.o.d .sub.o.d</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(objs)</span>, .<span class="variable">$(f)</span>.d)</span></span><br><span class="line"><span class="comment">#dep_files := $(patsubst %,.%.d, $(objs))</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"><span class="comment"># 把依赖文件包含进来</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">%.o : %.c</span><br><span class="line">gcc -Wp,-MD,.<span class="variable">$@</span>.d -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o test -f</span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">rm <span class="variable">$(dep_files)</span> *.o test -f</span><br></pre></td></tr></table></figure>

<h1><span id="3-chang-yong-han-shu">3 常用函数</span><a href="#3-chang-yong-han-shu" class="header-anchor">#</a></h1><h2><span id="3-1-zi-fu-chuan-xiang-guan">3.1 字符串相关</span><a href="#3-1-zi-fu-chuan-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-1-1-subst">3.1.1 <code>subst</code></span><a href="#3-1-1-subst" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> from,to,text)</span></span><br></pre></td></tr></table></figure>

<p>在文本<code>text</code>中使用<code>to</code>替换每一处<code>from</code>。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>fEEt on the strEEt</code></p>
<h3><span id="3-1-2-patsubst">3.1.2 <code>patsubst</code></span><a href="#3-1-2-patsubst" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br></pre></td></tr></table></figure>

<p>寻找<code>text</code>中符合格式<code>pattern</code>的字，用<code>replacement</code>替换它们。</p>
<p><code>pattern</code>和<code>replacement</code> 中可以使用通配符。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure>

<p>结果为： <code>x.c.o bar.o</code></p>
<h3><span id="3-1-3-strip">3.1.3  <code>strip</code></span><a href="#3-1-3-strip" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> string)</span></span><br></pre></td></tr></table></figure>

<p>去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a      b c )</span></span><br></pre></td></tr></table></figure>

<p>结果为：<code>foo.c bar.c baz.s</code></p>
<h3><span id="3-1-4-findstring">3.1.4 <code>findstring</code></span><a href="#3-1-4-findstring" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> find,in)</span></span><br></pre></td></tr></table></figure>

<p>在字符串<code>in</code>中搜寻<code>find</code>，如果找到，则返回值是<code>find</code>，否则返回值为空。</p>
<p>比如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,b c)</span></span><br></pre></td></tr></table></figure>

<p>将分别产生值<code>a</code>和(空字符串)</p>
<p>3.1.5 <code>filter</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern...,text)</span></span><br></pre></td></tr></table></figure>

<p>返回在<code>text</code>中由空格隔开且匹配格式<code>pattern...</code>的字，去除不符合格式<code>pattern...</code>的字。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.c %.s,foo.c bar.c baz.s ugh.h)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>foo.c bar.c baz.s</code>。</p>
<h3><span id="3-1-6-filter-out">3.1.6 <code>filter-out</code></span><a href="#3-1-6-filter-out" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern...,text)</span></span><br></pre></td></tr></table></figure>

<p>返回在<code>text</code>中由空格隔开且不匹配格式<code>pattern...</code>的字，去除符合格式<code>pattern...</code>的字。它是函数 filter 的反函数。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.c %.s,foo.c bar.c baz.s ugh.h)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>ugh.h</code>。</p>
<h3><span id="3-1-7-sort">3.1.7 <code>sort</code></span><a href="#3-1-7-sort" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> list)</span></span><br></pre></td></tr></table></figure>

<p>将<code>list</code>中的字按字母顺序排序，并去掉重复的字。输出由单个空格隔开的字的列表。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> foo bar lose)</span></span><br></pre></td></tr></table></figure>

<p>返回值是<code>bar foo lose</code></p>
<h2><span id="3-2-wen-jian-ming-xiang-guan">3.2 文件名相关</span><a href="#3-2-wen-jian-ming-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-2-1-dir">3.2.1 <code>dir</code></span><a href="#3-2-1-dir" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> names...)</span></span><br></pre></td></tr></table></figure>

<p>抽取<code>names...</code>中每一个文件名的路径部分，文件名的路径部分包括从文件名的首字符到最后一个斜杠(含斜杠)之前的一切字符。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> src/foo.c hacks)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>src/ ./</code>。</p>
<h3><span id="3-2-2-notdir">3.2.2 <code>notdir</code></span><a href="#3-2-2-notdir" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> names...)</span></span><br></pre></td></tr></table></figure>

<p>抽取<code>names...</code>中每一个文件名中除路径部分外一切字符（真正的文件名）。</p>
<p>比如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> src/foo.c hacks)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>foo.c hacks</code>。</p>
<h3><span id="3-2-3-suffix">3.2.3 <code>suffix</code></span><a href="#3-2-3-suffix" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> names...)</span></span><br></pre></td></tr></table></figure>

<p>抽取<code>names...</code>中每一个文件名的后缀。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> src/foo.c src-1.0/bar.c hacks)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>.c .c</code>。</p>
<h3><span id="3-2-4-basename">3.2.4 <code>basename</code></span><a href="#3-2-4-basename" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> names...)</span></span><br></pre></td></tr></table></figure>
<p>抽取<code>names...</code>中每一个文件名中除后缀外一切字符。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> src/foo.c src-1.0/bar hacks)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>src/foo src-1.0/bar hacks</code>。</p>
<h3><span id="3-2-5-addsuffix">3.2.5 <code>addsuffix</code></span><a href="#3-2-5-addsuffix" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> <span class="built_in">suffix</span>,names...)</span></span><br></pre></td></tr></table></figure>

<p>参数<code> names...</code>是一系列的文件名，文件名之间用空格隔开； suffix 是一个后缀名。将 suffix(后缀)的值附加在每一个独立文件名的后面，完成后将文件名串联起来，它们之间用单个空格隔开。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> .c,foo bar)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>foo.c bar.c</code>。</p>
<h3><span id="3-2-6-addprefix">3.2.6 <code>addprefix</code></span><a href="#3-2-6-addprefix" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> prefix,names...)</span></span><br></pre></td></tr></table></figure>

<p>参数<code> names</code>是一系列的文件名，文件名之间用空格隔开； prefix 是一个前缀名。将 preffix(前缀)的值附加在每一个独立文件名的前面，完成后将文件名串联起来，它们之间用单个空格隔开。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> src/,foo bar)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>src/foo src/bar</code>。</p>
<h3><span id="3-2-7-wildcard">3.2.7 <code>wildcard</code></span><a href="#3-2-7-wildcard" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span></span><br></pre></td></tr></table></figure>

<p>参数<code>pattern</code>是一个文件名格式，包含有通配符(通配符和 shell 中的用法一样)。函数 wildcard 的结果是一列和格式匹配的且真实存在的文件的名称，文件名之间用一个空格隔开。</p>
<p>比如若当前目录下有文件 1.c、 2.c、 1.h、 2.h，则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">c_src := <span class="variable">$(<span class="built_in">wildcard</span> \*.c)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>1.c 2.c</code></p>
<h3><span id="3-2-8-join">3.2.8<code> join</code></span><a href="#3-2-8-join" class="header-anchor">#</a></h3><p><code>$(join list1,list2)</code></p>
<p>逐个地将list2中的元素链接到list1。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LIST1 := foo bar</span><br><span class="line">LIST2 := .c  .p</span><br><span class="line">RESULT := $&#123;join $&#123;LIST1&#125; , $&#123;LIST2&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：<code>foo.c bar.p</code></p>
<h3><span id="3-2-9realpath">3.2.9<code>realpath</code></span><a href="#3-2-9realpath" class="header-anchor">#</a></h3><p><code>$(realpath names…)</code></p>
<p>对<code>names中</code>的每个文件，求其绝对路径，当目标为链接时，将解析链接。</p>
<h3><span id="3-2-10-abspath">3.2.10 <code>abspath</code></span><a href="#3-2-10-abspath" class="header-anchor">#</a></h3><p><code>$(abspath names…)</code></p>
<p>对<code>names中</code>的每个文件，求其绝对路径。不解析链接。</p>
<h3><span id="3-2-11-file">3.2.11 <code>file</code></span><a href="#3-2-11-file" class="header-anchor">#</a></h3><p><code>$(file op filename[,text])</code></p>
<p>向文件执行文本的输入输出.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEXT := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">RESULT := \$&#123;file &gt; test,$&#123;TEXT&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>前目录下存在test文件时，<code>&quot;hello world&quot;</code>被写入到test中，当不存在test文件时，文件被创建且同时写入<code>&quot;hello world&quot;</code>.</p>
<h2><span id="3-3-qi-ta-han-shu">3.3 其他函数</span><a href="#3-3-qi-ta-han-shu" class="header-anchor">#</a></h2><h3><span id="3-3-1-foreach">3.3.1 <code>foreach</code></span><a href="#3-3-1-foreach" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> var,list,text)</span></span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dirs := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(dirs)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*)</span>)</span><br></pre></td></tr></table></figure>

<p>这里<code>text</code>是<code>$(wildcard $(dir)/*)</code>，它的扩展过程如下：</p>
<p>第一个赋给变量<code>dir</code>的值是<code>a</code>， 扩展结果为<code>$(wildcard a/*)</code>；<br>第二个赋给变量<code>dir</code>的值是<code>b</code>， 扩展结果为<code>$(wildcard b/*)</code>；<br>第三个赋给变量<code>dir</code>的值是<code>c</code>， 扩展结果为<code>$(wildcard c/*)</code>；</p>
<p>如此继续扩展。</p>
<p>这个例子和下面的例有共同的结果：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files := <span class="variable">$(<span class="built_in">wildcard</span> a/* b/* c/* d/*)</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-3-2-origin">3.3.2 <code>origin</code></span><a href="#3-3-2-origin" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> variable)</span></span><br></pre></td></tr></table></figure>

<p>变量<code>variable</code>是一个查询变量的名称，不是对该变量的引用。所以，不能采用<code>$</code>和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。</p>
<p>函数<code>origin</code>的结果是一个字符串，该字符串变量是这样定义的：</p>
<p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/4.png" alt="img"></p>
<p>例如定义编译时用<code>verbose</code>还是<code>quiet</code>打印，<code>verbose</code>表示输出详细过程，<code>quiet</code>输出简略信息。</p>
<p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/5.png" alt="img"></p>
<p>将所有的信息都输出到同一个文件中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make xxx &gt; build_output_all.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-3-word">3.3.3 <code>word</code></span><a href="#3-3-3-word" class="header-anchor">#</a></h3><p><code>$(word n,text)</code></p>
<p>返回text列表中第n个元素.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEXT := foo.c foo.h bar.c</span><br><span class="line">RESULT := $&#123;word 2,$&#123;TEXT&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<code>foo.h</code></p>
<h3><span id="3-3-4wordlist">3.3.4<code>wordlist</code></span><a href="#3-3-4wordlist" class="header-anchor">#</a></h3><p><code>$(wordlist s,e,text)</code></p>
<p>返回text列表中指定的由s(start)开始由e(end)结尾的元素集合.</p>
<h3><span id="3-3-5-words">3.3.5 <code>words</code></span><a href="#3-3-5-words" class="header-anchor">#</a></h3><p><code>$(words text)</code></p>
<p>返回text列表中的元素数量。</p>
<h3><span id="3-3-6-firstword-lastword">3.3.6 <code>firstword/lastword </code></span><a href="#3-3-6-firstword-lastword" class="header-anchor">#</a></h3><p><code>$(firstword names…) \$(lastword names…)</code></p>
<p>返回names列表中的第一个、最后一个元素.</p>
<h3><span id="3-3-7-call">3.3.7  <code>call</code></span><a href="#3-3-7-call" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">func = $1.$2</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> func,a,b)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>

<p>结果：<code>a.b</code>, 子函数调用，数的参数会被赋值给临时参数·&#x3D;<code>\$1,\$2,\$0</code>则代表函数名本身.</p>
<h2><span id="3-4-vpath-xuan-xiang">3.4 VPATH选项</span><a href="#3-4-vpath-xuan-xiang" class="header-anchor">#</a></h2><p>VPATH中添加的目录，即使是文件处于其他目录，我们也可以像操作当前目录一样操作其他目录的文件，例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH += src</span><br><span class="line"><span class="section">all:foo.c</span></span><br><span class="line">cc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:src/foo.c</span></span><br><span class="line">cc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>但是写成下面这样是不行的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH += src</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">cc foo.c -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>这是因为：<code>VPATH</code>是<code>makefile中</code>的语法规则，而命令部分是由<code>shell</code>解析，所以<code>shell</code>并不会解析<code>VPATH</code>。</p>
<h2><span id="3-5-make-huan-jing-bian-liang">3.5 make环境变量</span><a href="#3-5-make-huan-jing-bian-liang" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AR 打包程序，默认值为ar，对目标文件进行打包，封装静态库</span><br><span class="line">AS 汇编程序，默认值为as，将汇编指令编译成机器指令</span><br><span class="line">CC c编译器，默认值为cc，通常情况下，cc是一个指向gcc的链接，负责将c程序编译成汇编程序。</span><br><span class="line">CXX c++编译器，默认值为g++</span><br><span class="line">CPP 预处理器，默认值为 &quot;$(CC) -E&quot;，注意这里的CPP不是C++，而是预处理器。</span><br><span class="line">RM 删除文件，默认值为 &quot;rm -f&quot;，-f表示强制删除</span><br></pre></td></tr></table></figure>

<h2><span id="3-6-make-bian-yi-xuan-xiang">3.6 make编译选项</span><a href="#3-6-make-bian-yi-xuan-xiang" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARFLAGS 指定$(AR)运行时的参数，默认值为&quot;ar&quot;</span><br><span class="line">ASFLAGS 指定$(AS)运行时的参数，无默认值</span><br><span class="line">CFLAGS 指定$(CC)运行时的参数，无默认值</span><br><span class="line">CXXFLAGS 指定$(CXX)运行时的参数，无默认值</span><br><span class="line">CPPFLAGS 指定$(CPP)运行时的参数，无默认值，注意这里的CPP不是C++，而是预处理器</span><br><span class="line">LDFLAGS 指定ld链接器运行时的参数，无默认值</span><br><span class="line">LDLIBS 指定ld链接器运行时的链接库参数，无默认值。</span><br><span class="line"></span><br><span class="line">make --debug</span><br><span class="line">	输出每一步输出的详细流程，对于调试时非常方便。</span><br></pre></td></tr></table></figure>

<h1><span id="4-tong-yong-xing-makefile">4 通用型<code>makefile</code></span><a href="#4-tong-yong-xing-makefile" class="header-anchor">#</a></h1><p>本<code>makefile</code>是参考linux内核的<code>makefile</code>框架改编简化，大家可以参考Linux内核中<code>built-in.o</code>的产生过程来进一步了解该流程。</p>
<p>顶层目录下，存在<code>Makefile</code>和<code>Makefile.build</code>两个文件。这两个文件非常重要，make命令能递归查找每个子目录，就是这2个<code>Makefile</code>文件的功劳。</p>
<h2><span id="4-1-ding-ceng-makefile">4.1 顶层<code>Makefile</code></span><a href="#4-1-ding-ceng-makefile" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 延时变量, 只有第一次定义赋值才成功.而该变量在/etc/profile中. 已定义为arm-linux-gnueabihf-</span></span><br><span class="line">CROSS_COMPILE ?=</span><br><span class="line"><span class="comment"># 定义延时变量</span></span><br><span class="line">AS                = <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">LD                = <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">CC                = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CPP                = <span class="variable">$(CC)</span> -E</span><br><span class="line">AR                = <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">NM                = <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line">STRIP                = <span class="variable">$(CROSS_COMPILE)</span>strip</span><br><span class="line">OBJCOPY                = <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP                = <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line"><span class="comment"># export全局变量, 可供其他Makefile使用</span></span><br><span class="line"><span class="keyword">export</span> AS LD CC CPP AR NM</span><br><span class="line"><span class="keyword">export</span> STRIP OBJCOPY OBJDUMP</span><br><span class="line">CFLAGS := -Wall -O2 -g</span><br><span class="line">CFLAGS += -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/<span class="keyword">include</span></span><br><span class="line">LDFLAGS := -lpthread -lfreetype -lm</span><br><span class="line"><span class="keyword">export</span> CFLAGS LDFLAGS</span><br><span class="line"></span><br><span class="line">TOPDIR := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="keyword">export</span> TOPDIR</span><br><span class="line"></span><br><span class="line">TARGET := test</span><br><span class="line"></span><br><span class="line">obj-y += display/</span><br><span class="line"><span class="comment"># obj-y += unittest/</span></span><br><span class="line"><span class="comment">#obj-y += input/</span></span><br><span class="line"><span class="comment">#obj-y += font/</span></span><br><span class="line">obj-y += ui/</span><br><span class="line">obj-y += page/</span><br><span class="line">obj-y += config/</span><br><span class="line">obj-y += business/</span><br><span class="line"></span><br><span class="line">all : start_recursive_build <span class="variable">$(TARGET)</span></span><br><span class="line">        @echo <span class="variable">$(TARGET)</span> has been built!</span><br><span class="line"></span><br><span class="line"><span class="section">start_recursive_build:</span></span><br><span class="line">        @echo <span class="variable">$@</span></span><br><span class="line">        @echo obj-y = $(obj-y)</span><br><span class="line">        make -C ./ -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : built-in.o</span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> built-in.o <span class="variable">$(LDFLAGS)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">        rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">        rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">        rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.d&quot;)</span></span><br><span class="line">        rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>顶层<code>Makefile</code>的作用：</p>
<ol>
<li>提供项目make命令的执行入口，提供所有编译target目标。</li>
<li>定义全局变量，编译选项，链接选项等。</li>
<li>通过<code>obj-y</code>指定要搜索的子目录。</li>
<li>切换目录，递归执行make命令，并执行根目录的<code>Makefile.build</code>文件</li>
</ol>
<h2><span id="4-2-makefile-build">4.2 <code>Makefile.build</code></span><a href="#4-2-makefile-build" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PHONY := __build echo_obj</span><br><span class="line"><span class="section">__build:</span></span><br><span class="line">obj-y :=</span><br><span class="line">subdir-y :=</span><br><span class="line">EXTRA_CFLAGS :=</span><br><span class="line"></span><br><span class="line"><span class="comment">#包含当前执行目录的Makefile</span></span><br><span class="line"><span class="keyword">include</span> Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># obj-y := a.o b.o c/ d/</span></span><br><span class="line"><span class="comment"># $(filter %/, $(obj-y))   : c/ d/</span></span><br><span class="line"><span class="comment"># __subdir-y  : c d</span></span><br><span class="line"><span class="comment"># subdir-y    : c d</span></span><br><span class="line"><span class="comment"># $(filter %/, $(obj-y)) 从变量obj-y中过滤出以&quot;/&quot;结尾的目录名</span></span><br><span class="line"><span class="comment"># $(patsubst %/,%,$(filter %/, $(obj-y))) 去掉obj-y中以&quot;/&quot;结尾的目录名中的&quot;/&quot;</span></span><br><span class="line">__subdir-y        := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-y)</span>))</span><br><span class="line">subdir-y        += $(__subdir-y)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># c/built-in.o d/built-in.o</span></span><br><span class="line"><span class="comment"># foreach(var,list,text), 意为foreach var in list, change it to text</span></span><br><span class="line"><span class="comment"># 将子目录列表subdir-y中, 每一项(每个文件名)f, 都修改为f/built-in.o</span></span><br><span class="line"><span class="comment"># 也就是说, 每个子目录, 都会对应生成一个名为 &quot;子目录名/built-in.o&quot;的文件 (.o文件是链接文件)</span></span><br><span class="line">subdir_objs := <span class="variable">$(<span class="built_in">foreach</span> f,$(subdir-y)</span>,<span class="variable">$(f)</span>/built-in.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o b.o</span></span><br><span class="line"><span class="comment"># 从obj-y中过滤掉目录名(名称以&quot;/&quot;结尾), 只剩下普通文件(.o文件)</span></span><br><span class="line">cur_objs := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-y)</span>)</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(cur_objs)</span>,.<span class="variable">$(f)</span>.d)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果依赖文件存在, 就列出来重新赋值给dep_files</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果依赖文件列表不为空, 就直接包含(include)依赖文件列表</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个子目录名(不含&quot;/&quot;)追加到伪目标</span></span><br><span class="line">PHONY += $(subdir-y)</span><br><span class="line"></span><br><span class="line"><span class="section">echo_obj:</span></span><br><span class="line">        @echo <span class="string">&quot;********************  echo_obj  *************************&quot;</span></span><br><span class="line">        @echo obj-y:$(obj-y)</span><br><span class="line">        @echo __subdir-y:$(__subdir-y)</span><br><span class="line">        @echo subdir-y:$(subdir-y)</span><br><span class="line">        @echo subdir_objs:<span class="variable">$(subdir_objs)</span></span><br><span class="line">        @echo cur_objs:<span class="variable">$(cur_objs)</span></span><br><span class="line">        @echo <span class="string">&quot;**********************************************************&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">__build: echo_obj $(subdir-y) built-in.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用顶层Makefile.build的规则去子目录去编译</span></span><br><span class="line"><span class="section">$(subdir-y):</span></span><br><span class="line">        @echo subdir-y = <span class="variable">$@</span></span><br><span class="line">        make -C <span class="variable">$@</span> -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义built-in.o依赖规则，当subdir-y为空了才开始执行</span></span><br><span class="line"><span class="comment"># cur_objs 从obj-y过滤出的普通文件(.o文件)</span></span><br><span class="line"><span class="comment"># subdir_objs 子目录下的built-in.o</span></span><br><span class="line">built-in.o : <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line">        <span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#延时变量, generate dep_file</span></span><br><span class="line">dep_file = .<span class="variable">$@</span>.d</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(EXTRA_CFLAGS)</span> $(CFLAGS_<span class="variable">$@</span>) -Wp,-MD,<span class="variable">$(dep_file)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">.PHONY : <span class="variable">$(PHONY)</span></span><br></pre></td></tr></table></figure>

<p><code>Makefile.build</code>作用：</p>
<ol>
<li>包含引用顶层Makefile。</li>
<li>取出每个子Makefile中定义的<code>.o</code>文件，再根据<code>%.o:%.c</code>模式规则，自动寻找<code>.c</code>源码文件。</li>
<li>取出每个子Makefile中定义的子目录，再用<code>make -C</code>切换到子目录，从而实现递归目录编译。</li>
<li>为每个<code>.o</code>文件生成依赖文件<code>(.d)</code>,并包含进Makefile.build。</li>
<li>为每个子目录(含有Makefile)生成一个<code>built-in.o</code>文件，便于根目录下的Makefile文件编译、链接。</li>
<li>设置伪目标。</li>
</ol>
<h2><span id="4-3-make-guo-cheng-ju-li">4.3 Make过程举例</span><a href="#4-3-make-guo-cheng-ju-li" class="header-anchor">#</a></h2><p>项目目录展开如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── led.sh</span><br><span class="line">├── business</span><br><span class="line">│   ├── main.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── config</span><br><span class="line">│   ├── config.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── display</span><br><span class="line">│   ├── disp_manager.c</span><br><span class="line">│   ├── framebuffer.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── font</span><br><span class="line">│   ├── font_manager.c</span><br><span class="line">│   ├── freetype.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── include</span><br><span class="line">│   ├── <span class="keyword">common</span>.h</span><br><span class="line">│   ├── config.h</span><br><span class="line">│   ├── disp_manager.h</span><br><span class="line">│   ├── font_manager.h</span><br><span class="line">│   ├── input_manager.h</span><br><span class="line">│   ├── page_manager.h</span><br><span class="line">│   ├── tslib.h</span><br><span class="line">│   └── ui.h</span><br><span class="line">├── <span class="keyword">input</span></span><br><span class="line">│   ├── input_manager.c</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── netinput.c</span><br><span class="line">│   └── touchscreen.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── Makefile.build</span><br><span class="line">├── page</span><br><span class="line">│   ├── main_page.c</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── page_manager.c</span><br><span class="line">├── ui</span><br><span class="line">│   ├── button.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">└── unittest</span><br><span class="line">    ├── client.c</span><br><span class="line">    ├── disp_test.c</span><br><span class="line">    ├── font_test.c</span><br><span class="line">    ├── input_manager_test.c</span><br><span class="line">    ├── Makefile</span><br><span class="line">    ├── page_test.c</span><br><span class="line">    └── ui_test.c</span><br></pre></td></tr></table></figure>

<h3><span id="4-3-1-zi-mu-lu-makefile-display-wei-li">4.3.1 子目录<code>MakeFIle-display</code>为例</span><a href="#4-3-1-zi-mu-lu-makefile-display-wei-li" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS :=</span><br><span class="line">CFLAGS_file.o :=</span><br><span class="line">obj-y += disp_manager.o</span><br><span class="line">obj-y += framebuffer.o</span><br></pre></td></tr></table></figure>

<h3><span id="4-3-2-bian-yi-xiang-xi-shu-chu-ri-zhi">4.3.2 编译详细输出日志</span><a href="#4-3-2-bian-yi-xiang-xi-shu-chu-ri-zhi" class="header-anchor">#</a></h3><p>顶层目录输入<code>make all V=1</code>来看详细的编译过程：</p>
<details>
<summary>点击查看代码</summary>
<pre><code>
start_recursive_build
obj-y = display/ ui/ page/ config/ business/
make -C ./ -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[1]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command'
********************  echo_obj  *************************
obj-y: display/ ui/ page/ config/ business/
__subdir-y:display ui page config business
subdir-y: display ui page config business
subdir_objs:display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o
cur_objs:
**********************************************************
subdir-y = display
make -C display -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/display'
********************  echo_obj  *************************
obj-y: disp_manager.o framebuffer.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:disp_manager.o framebuffer.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.disp_manager.o.d -c -o disp_manager.o disp_manager.c
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.framebuffer.o.d -c -o framebuffer.o framebuffer.c
ld -r -o built-in.o disp_manager.o framebuffer.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/display'
subdir-y = ui
make -C ui -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/ui'
********************  echo_obj  *************************
obj-y: button.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:button.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.button.o.d -c -o button.o button.c
ld -r -o built-in.o button.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/ui'
subdir-y = page
make -C page -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/page'
********************  echo_obj  *************************
obj-y: main_page.o page_manager.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:main_page.o page_manager.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.main_page.o.d -c -o main_page.o main_page.c
main_page.c:198:16: warning: ‘GetButtonByInputEvent’ defined but not used [-Wunused-function]
  198 | static Button* GetButtonByInputEvent(InputEvent *pInputEvent)
      |                ^~~~~~~~~~~~~~~~~~~~~
main_page.c:103:13: warning: ‘GenerateButtons’ defined but not used [-Wunused-function]
  103 | static void GenerateButtons(void)
      |             ^~~~~~~~~~~~~~~
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.page_manager.o.d -c -o page_manager.o page_manager.c
ld -r -o built-in.o main_page.o page_manager.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/page'
subdir-y = config
make -C config -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/config'
********************  echo_obj  *************************
obj-y: config.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:config.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.config.o.d -c -o config.o config.c
ld -r -o built-in.o config.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/config'
subdir-y = business
make -C business -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/business'
********************  echo_obj  *************************
obj-y: main.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:main.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.main.o.d -c -o main.o main.c
main.c: In function ‘main’:
main.c:12:9: warning: unused variable ‘err’ [-Wunused-variable]
   12 |     int err;
      |         ^~~
ld -r -o built-in.o main.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/business'
ld -r -o built-in.o display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o
make[1]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command'
gcc -o test built-in.o -lpthread -lfreetype -lm
test has been built!
</code></pre></details>


<h3><span id="4-3-3-bian-yi-ru-kou">4.3.3 编译入口</span><a href="#4-3-3-bian-yi-ru-kou" class="header-anchor">#</a></h3><p>首先编译目标<code>start_recursive_build</code>， 列出目标、要进行编译的子目录模块，进入当前Makefile所在目录，按照顶层<code>Makefile.build</code>的规则编译，打印如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">start_recursive_build</span><br><span class="line">obj-y = display/ ui/ page/ config/ business/</span><br></pre></td></tr></table></figure>

<h3><span id="4-3-4-bian-yi-build">4.3.4 编译<code>__build</code></span><a href="#4-3-4-bian-yi-build" class="header-anchor">#</a></h3><p>执行顶层<code>Makefile.build</code>，执行目标<code>__build</code>，执行<code>echo_obj</code>， 打印:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -C ./ -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/</span><br><span class="line">31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[1]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: display/ ui/ page/ config/ business/</span></span><br><span class="line"><span class="section">__subdir-y:display ui page config business</span></span><br><span class="line"><span class="section">subdir-y: display ui page config business</span></span><br><span class="line"><span class="section">subdir_objs:display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o</span></span><br><span class="line"><span class="section">cur_objs:</span></span><br><span class="line">**********************************************************</span><br></pre></td></tr></table></figure>

<h4><span id="4-3-4-1-bian-yi-subdir-y">4.3.4.1 编译<code>$(subdir-y)</code></span><a href="#4-3-4-1-bian-yi-subdir-y" class="header-anchor">#</a></h4><p>在每个子目录产生<code>build-in.o</code>：</p>
<p>执行<code>$(subdir-y)</code>， 又<code>$(subdir-y)=display ui page config business</code>，因此目标编译规则展开如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">display ui page config business:</span><br><span class="line">        @echo subdir-y = <span class="variable">$@</span></span><br><span class="line">        make -C <span class="variable">$@</span> -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br></pre></td></tr></table></figure>

<p>打印如下:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = display</span><br><span class="line">make -C display -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/display&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: disp_manager.o framebuffer.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:disp_manager.o framebuffer.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.disp_manager.o.d -c -o disp_manager.o disp_manager.c</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.framebuffer.o.d -c -o framebuffer.o framebuffer.c</span><br><span class="line">ld -r -o built-in.o disp_manager.o framebuffer.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/display&#x27;</span></span><br></pre></td></tr></table></figure>

<p>分析：目标是<code>display</code>，进入<code>display</code>目录，按照顶层<code>Makefile.build</code>的规则编译，再次递归调用<code>__build</code>，可以看到只有当子目录<code>subdir-y</code>为空了，才不会递归进去，那么此时会执行<code>built-in.o</code>目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">built-in.o : <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line">        <span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>

<p>此时按照推导规则进行<code>disp_manager.o， framebuffer.o</code>的编译，在<code>dispaly</code>目录下打包成<code>build-in.o</code>。</p>
<p>同理，<code>ui</code>目录编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = ui</span><br><span class="line">make -C ui -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/ui&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: button.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:button.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.button.o.d -c -o button.o button.c</span><br><span class="line">ld -r -o built-in.o button.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/ui&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同理，<code>page</code>目录编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = page</span><br><span class="line">make -C page -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/page&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: main_page.o page_manager.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:main_page.o page_manager.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.main_page.o.d -c -o main_page.o main_page.c</span><br><span class="line"><span class="section">main_page.c:198:16: warning: ‘GetButtonByInputEvent’ defined but not used [-Wunused-function]</span></span><br><span class="line">  198 | static Button* GetButtonByInputEvent(InputEvent *pInputEvent)</span><br><span class="line">      |                ^~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"><span class="section">main_page.c:103:13: warning: ‘GenerateButtons’ defined but not used [-Wunused-function]</span></span><br><span class="line">  103 | static void GenerateButtons(void)</span><br><span class="line">      |             ^~~~~~~~~~~~~~~</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.page_manager.o.d -c -o page_manager.o page_manager.c</span><br><span class="line">ld -r -o built-in.o main_page.o page_manager.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/page&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同理，<code>config</code>目录编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = config</span><br><span class="line">make -C config -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/config&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: config.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:config.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.config.o.d -c -o config.o config.c</span><br><span class="line">ld -r -o built-in.o config.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/config&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同理，<code>business</code>目录编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = business</span><br><span class="line">make -C business -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/business&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: main.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:main.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.main.o.d -c -o main.o main.c</span><br><span class="line"><span class="section">main.c: In function ‘main’:</span></span><br><span class="line"><span class="section">main.c:12:9: warning: unused variable ‘err’ [-Wunused-variable]</span></span><br><span class="line">   12 |     int err;</span><br><span class="line">      |         ^~~</span><br><span class="line">ld -r -o built-in.o main.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/business&#x27;</span></span><br></pre></td></tr></table></figure>

<h4><span id="4-3-4-2-da-bao-cheng-zong-de-built-in-o">4.3.4.2 打包成总的<code>built-in.o</code></span><a href="#4-3-4-2-da-bao-cheng-zong-de-built-in-o" class="header-anchor">#</a></h4><p>最后子目录的<code>built-in.o</code>都生成了，再来返回顶层<code>Makefile</code>，此时<code>subdir_objs和cur_objs</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subdir_objs:display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o</span></span><br><span class="line"><span class="section">cur_objs:</span></span><br></pre></td></tr></table></figure>

<p>那么继续：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">built-in.o : <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line">        <span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ld -r -o built-in.o display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o</span><br></pre></td></tr></table></figure>

<p>至此，<code>__build</code>目标执行完毕。</p>
<h3><span id="4-3-5-bian-yi-chu-kou">4.3.5 编译出口</span><a href="#4-3-5-bian-yi-chu-kou" class="header-anchor">#</a></h3><p>回到顶层<code>makefile</code>的<code>start_recursive_build</code>，回到<code>all</code>目标，执行<code>$(TARGET)</code>目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -o test built-in.o -lpthread -lfreetype -lm</span><br></pre></td></tr></table></figure>

<p>最终回到<code>all</code>目标,打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test has been built!</span><br></pre></td></tr></table></figure>

<h1><span id="5-tong-yong-xing-makefile2-luo-ji-ban">5 通用型<code>makefile2</code>-裸机版</span><a href="#5-tong-yong-xing-makefile2-luo-ji-ban" class="header-anchor">#</a></h1><h2><span id="5-1-wen-jian-gong-cheng-mu-lu">5.1 文件工程目录</span><a href="#5-1-wen-jian-gong-cheng-mu-lu" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">book@100ask:~/ftp/openedv/bak_drv_prj/05_ledc_bsp$ tree</span></span><br><span class="line">├── bsp</span><br><span class="line">│   ├── clk</span><br><span class="line">│   │   ├── bsp_clk.c</span><br><span class="line">│   │   └── bsp_clk.h</span><br><span class="line">│   ├── delay</span><br><span class="line">│   │   ├── bsp_delay.c</span><br><span class="line">│   │   └── bsp_delay.h</span><br><span class="line">│   └── led</span><br><span class="line">│       ├── bsp_led.c</span><br><span class="line">│       └── bsp_led.h</span><br><span class="line">├── imx6ul</span><br><span class="line">│   ├── cc.h</span><br><span class="line">│   ├── fsl_common.h</span><br><span class="line">│   ├── fsl_iomuxc.h</span><br><span class="line">│   ├── imx6ul.h</span><br><span class="line">│   └── MCIMX6Y2.h</span><br><span class="line">├── imx6ul.lds</span><br><span class="line">├── imxdownload</span><br><span class="line">├── Makefile</span><br><span class="line">├── obj</span><br><span class="line">└── project</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── start.S</span><br></pre></td></tr></table></figure>

<h2><span id="5-2-lds-lian-jie-jiao-ben">5.2 lds链接脚本</span><a href="#5-2-lds-lian-jie-jiao-ben" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    . = <span class="number">0X87800000</span>;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        obj/start.o </span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line">    .rodata <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span> : &#123;*(.rodata*)&#125;     </span><br><span class="line">    .data <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>   : &#123; *(.data) &#125;    </span><br><span class="line">    __bss_start = .;    </span><br><span class="line">    .bss <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>  : &#123; *(.bss)  *(COMMON) &#125;    </span><br><span class="line">    __bss_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-makefile">5.3 <code>Makefile</code></span><a href="#5-3-makefile" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE ?= arm-linux-gnueabihf-</span><br><span class="line">TARGET ?= bsp</span><br><span class="line">CC := <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">LD := <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">OBJCOPY := <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP := <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line"></span><br><span class="line">INCDIRS := imx6ul \</span><br><span class="line">　　　　　　bsp/clk \</span><br><span class="line">　　　　　　bsp/led \</span><br><span class="line">　　　　　　bsp/delay</span><br><span class="line"></span><br><span class="line">SRCDIRS := project \</span><br><span class="line">　　　　　　bsp/clk \</span><br><span class="line">　　　　　　bsp/led \</span><br><span class="line">　　　　　　bsp/delay</span><br><span class="line"></span><br><span class="line">INCLUDE := <span class="variable">$(<span class="built_in">patsubst</span> %, -I %, <span class="variable">$(INCDIRS)</span>)</span></span><br><span class="line"></span><br><span class="line">SFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(SRCDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.S)</span>)</span><br><span class="line">CFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(SRCDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"></span><br><span class="line">SFILENDIR := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(SFILES)</span>)</span></span><br><span class="line">CFILENDIR := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(CFILES)</span>)</span></span><br><span class="line"></span><br><span class="line">SOBJS := <span class="variable">$(<span class="built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)</span><br><span class="line">COBJS := <span class="variable">$(<span class="built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)</span><br><span class="line">OBJS := <span class="variable">$(SOBJS)</span> <span class="variable">$(COBJS)</span></span><br><span class="line"></span><br><span class="line">VPATH := <span class="variable">$(SRCDIRS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>.bin : <span class="variable">$(OBJS)</span></span><br><span class="line">　　<span class="variable">$(LD)</span> -Timx6ul.lds -o <span class="variable">$(TARGET)</span>.elf <span class="variable">$^</span></span><br><span class="line">　　<span class="variable">$(OBJCOPY)</span> -O binary -S <span class="variable">$(TARGET)</span>.elf <span class="variable">$@</span></span><br><span class="line">　　<span class="variable">$(OBJDUMP)</span> -D -m arm <span class="variable">$(TARGET)</span>.elf &gt; <span class="variable">$(TARGET)</span>.dis</span><br><span class="line"></span><br><span class="line"><span class="variable">$(SOBJS)</span> : obj/%.o : %.S</span><br><span class="line">　　<span class="variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(COBJS)</span> : obj/%.o : %.c</span><br><span class="line">　　<span class="variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">　　@echo INCDIRS=<span class="variable">$(INCDIRS)</span></span><br><span class="line">　　@echo SRCDIRS=<span class="variable">$(SRCDIRS)</span></span><br><span class="line">　　@echo INCLUDE=<span class="variable">$(INCLUDE)</span></span><br><span class="line">　　@echo SFILES=<span class="variable">$(SFILES)</span></span><br><span class="line">　　@echo CFILES=<span class="variable">$(CFILES)</span></span><br><span class="line">　　@echo SFILENDIR=<span class="variable">$(SFILENDIR)</span></span><br><span class="line">　　@echo CFILENDIR=<span class="variable">$(CFILENDIR)</span></span><br><span class="line">　　@echo SOBJS=<span class="variable">$(SOBJS)</span></span><br><span class="line">　　@echo COBJS=<span class="variable">$(COBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm -rf <span class="variable">$(TARGET)</span>.elf <span class="variable">$(TARGET)</span>.dis <span class="variable">$(TARGET)</span>.bin <span class="variable">$(COBJS)</span> <span class="variable">$(SOBJS)</span></span><br></pre></td></tr></table></figure>

<p>打印出目标和依赖文件:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">book@100ask:~/ftp/openedv/bak_drv_prj/05_ledc_bsp$ make print</span></span><br><span class="line">INCDIRS=imx6ul bsp/clk bsp/led bsp/delay</span><br><span class="line">SRCDIRS=project bsp/clk bsp/led bsp/delay</span><br><span class="line">INCLUDE= -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay</span><br><span class="line">SFILES= project/start.S</span><br><span class="line">CFILES= project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c</span><br><span class="line">SFILENDIR=start.S</span><br><span class="line">CFILENDIR=main.c bsp_clk.c bsp_led.c bsp_delay.c</span><br><span class="line">SOBJS= obj/start.o</span><br><span class="line">COBJS= obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br></pre></td></tr></table></figure>

<p>编译结果如下:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">book@100ask:~/ftp/openedv/bak_drv_prj/05_ledc_bsp$ make</span></span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/start.o project/start.S</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/main.o project/main.c</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/bsp_clk.o bsp/clk/bsp_clk.c</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/bsp_led.o bsp/led/bsp_led.c</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/bsp_delay.o bsp/delay/bsp_delay.c</span><br><span class="line">arm-buildroot-linux-gnueabihf-ld -Timx6ul.lds -o bsp.elf obj/start.o obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br><span class="line">arm-buildroot-linux-gnueabihf-objcopy -O binary -S bsp.elf bsp.bin</span><br><span class="line">arm-buildroot-linux-gnueabihf-objdump -D -m arm bsp.elf &gt; bsp.dis</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>linux嵌入式环境搭建</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb移植到arm开发板</title>
    <url>/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xia-zai-gdb">1.下载gdb</a></li>
<li><a href="#2-bian-yi-an-zhuang">2.编译安装</a><ul>
<li><a href="#2-1-she-zhi-gong-ju-lian">2.1 设置工具链</a></li>
<li><a href="#2-2-bian-yi-ncurses">2.2 编译ncurses</a></li>
<li><a href="#2-3-bian-yi-gdb">2.3 编译gdb</a></li>
</ul>
</li>
<li><a href="#3-yun-xing-ce-shi">3.运行测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xia-zai-gdb">1.下载gdb</span><a href="#1-xia-zai-gdb" class="header-anchor">#</a></h1><p><a href="https://ftp.gnu.org/gnu/gdb/">https://ftp.gnu.org/gnu/gdb/</a></p>
<p><a href="http://ftp.gnu.org/gnu/ncurses/">http://ftp.gnu.org/gnu/ncurses/</a></p>
<p>我这里选择的是gdb-7.12.tar.gz和ncurses-5.6.tar.gz</p>
<h1><span id="2-bian-yi-an-zhuang">2.编译安装</span><a href="#2-bian-yi-an-zhuang" class="header-anchor">#</a></h1><h2><span id="2-1-she-zhi-gong-ju-lian">2.1 设置工具链</span><a href="#2-1-she-zhi-gong-ju-lian" class="header-anchor">#</a></h2><p><code>export PATH=$PATH:/home/robin/share/cv183x/host-tools/gcc/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/</code><br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/1.png"><br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/2.png"></p>
<h2><span id="2-2-bian-yi-ncurses">2.2 编译ncurses</span><a href="#2-2-bian-yi-ncurses" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host=aarch64-linux-gnu-gcc --prefix=/home/robin/share/ncurses --without-ada --enable-termcap --with-shared CFLAGS=<span class="string">&quot;-O3 -fPIC&quot;</span></span><br><span class="line">    make</span><br><span class="line">	make install</span><br></pre></td></tr></table></figure>

<p>执行.&#x2F;configure时可能会失败，报错如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/3.png"><br>这是由于64bit machine配置引起的，进行如下操作后继续尝试。</p>
<pre><code>wget -O config.guess &#39;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD&#39;
wget -O config.sub &#39;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD&#39;
</code></pre>
<p>编译出的ncurses库如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/4.png"></p>
<h2><span id="2-3-bian-yi-gdb">2.3 编译gdb</span><a href="#2-3-bian-yi-gdb" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf gdb-7.12.tar.gz;</span><br><span class="line"><span class="built_in">cd</span> gdb-7.12</span><br><span class="line">./configure --host=aarch64-linux-gnu-gcc(--host=arm-linux-gnueabihf) --enable-shared --prefix=/home/robin/share/gdb --without-x --disable-gdbtk --disable-tui --without-included-regex --without-included-gettext  --disable-werror CFLAGS=<span class="string">&quot;-O0 -fPIC&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>.&#x2F;configure后结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/5.png"></p>
<p>make install后结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/6.png"></p>
<h1><span id="3-yun-xing-ce-shi">3.运行测试</span><a href="#3-yun-xing-ce-shi" class="header-anchor">#</a></h1><p>1.将gdb和ncureses库cp到板子运行，结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/7.png"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10搭建NFS服务</title>
    <url>/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xia-zai-hanewin-nfs-server-for-windows">1 下载haneWIN NFS Server for Windows</a></li>
<li><a href="#2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server">2 安装并且执行 haneWIN NFS Server</a><ul>
<li><a href="#2-1-xiu-gai-pei-zhi-wen-jian">2.1 修改配置文件</a></li>
<li><a href="#2-2-bao-cun-pei-zhi">2.2 保存配置</a></li>
</ul>
</li>
<li><a href="#3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang">3 让NFS服务通过防火墙</a></li>
<li><a href="#4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi">4 开发板客服端挂载测试</a></li>
<li><a href="#4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban">4.1 挂载共享目录到开发板</a></li>
<li><a href="#4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian">4.2 添加可写可执行权限</a></li>
<li><a href="#5-nfs-pei-zhi-wen-jian">5 nfs配置文件</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xia-zai-hanewin-nfs-server-for-windows">1 下载haneWIN NFS Server for Windows</span><a href="#1-xia-zai-hanewin-nfs-server-for-windows" class="header-anchor">#</a></h1><p>链接如下：<br><a href="https://www.hanewin.net/nfs-e.htm">https://www.hanewin.net/nfs-e.htm</a><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/1.png" alt="image"></p>
<h1><span id="2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server">2 安装并且执行 haneWIN NFS Server</span><a href="#2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server" class="header-anchor">#</a></h1><p>安装完后，打开hanWin如下：进入Edit-&gt;Preferences<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/2.png" alt="image"></p>
<p>进入Exports-&gt;Edit exports file<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/3.png" alt="image"></p>
<h2><span id="2-1-xiu-gai-pei-zhi-wen-jian">2.1 修改配置文件</span><a href="#2-1-xiu-gai-pei-zhi-wen-jian" class="header-anchor">#</a></h2><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/4.png" alt="image"><br>添加一行配置如下：<br><code>D:\ldc_res -name:nfs *(rw,sync,no_root_squash)</code><br>表示把D盘ldc_res目录当成nfs共享目录，-name:nfs表示客户端挂载时使用nfs表示D:\ldc_res路径<br><code>mount -t nfs -o nolock 192.168.0.100:/nfs /mnt/sd</code></p>
<h2><span id="2-2-bao-cun-pei-zhi">2.2 保存配置</span><a href="#2-2-bao-cun-pei-zhi" class="header-anchor">#</a></h2><p>勾选如下2个选项：仅对授权用户可见，通过nfs将导出添加到文件夹的上下文菜单<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/5.png" alt="image"></p>
<h1><span id="3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang">3  让NFS服务通过防火墙</span><a href="#3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang" class="header-anchor">#</a></h1><p>方法1：打开电脑防火墙设置，将专用网络和公用网络的防火墙禁用。<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/6.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/7.png" alt="image"></p>
<p>方法2：设置防火墙入栈连接规则<br>查看haneWIN NFS server的端口映射：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/8.png" alt="image"><br>可以看到haneWIN使用的端口如下：</p>
<pre><code>TCP：111, 1058, 2049
UDP：111, 1058, 2049
</code></pre>
<p>进入windows防火墙高级设置，设置入栈规则-&gt;新建规则：</p>
<pre><code>规则类型选端口，
协议选TCP, 规则应用于特定本地端口，输入刚才查看的映射端口号：111，1058， 2049
操作选允许连接
配置文件将域，专用，公用网络全部勾选
最后设置好名称和描述
</code></pre>
<p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/9.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/10.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/11.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/12.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/13.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/14.png" alt="image"></p>
<h1><span id="4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi">4 开发板客服端挂载测试</span><a href="#4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi" class="header-anchor">#</a></h1><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/15.png" alt="image"></p>
<p>设置板端IP地址：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/16.png" alt="image"><br>先确保windows和板端能ping通<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/17.png" alt="image"></p>
<h1><span id="4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban">4.1 挂载共享目录到开发板</span><a href="#4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban" class="header-anchor">#</a></h1><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/18.png" alt="image"></p>
<p><code>mount -t nfs -o nolock 192.168.0.100:/nfs /mnt/sd</code><br>可以看到已经挂载上了，并且能访问挂载目录的文件</p>
<h1><span id="4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian">4.2 添加可写可执行权限</span><a href="#4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian" class="header-anchor">#</a></h1><p>挂载上后发现没有可写权限，<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/19.png" alt="image"></p>
<p>修改配置exports选项，添加-maproot:0 -public<br><code>D:\ldc_res -name:nfs -maproot:0 -public *(rw,sync,no_root_squash)</code><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/20.png" alt="image"></p>
<p>可以可写可执行了：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/21.png" alt="image"></p>
<h1><span id="5-nfs-pei-zhi-wen-jian">5 nfs配置文件</span><a href="#5-nfs-pei-zhi-wen-jian" class="header-anchor">#</a></h1><pre><code>#
# exports example
#
# please read doc for a list of all options
# drive letters should be in upper case, because file-id returns upper case
#   by default (option setting) they are mapped to lower case for clients
# Option -range restricts access to specified address range
#   a list of addresses restricts to these clients only
# Option -readonly prohibits create/write/delete
# Option -name:&lt;x&gt; makes folder for clients avalailable as /&lt;x&gt;
# Option -maproot:&lt;uid&gt; maps unix root to specified &lt;uid&gt;
#   without it uid root -&gt; uid NOBODY
# Option -alldirs allows clients to mount folder or any subfolder
# Use UNC path specification for access to remote drive
# Hidden volumes without a drive letter can be mounted by volume GUID
#
C:\ftp -range 192.168.1.1 192.168.1.10
C:\video -readonly 192.168.1.1 192.168.1.4 192.18.1.23
C:\server -alldirs -name:server -maproot:0 -range 192.168.1.1 192.168.1.30
\\router\FRITZ.NAS\SanDisk-U3CruzerMicro-00 -name:fritz
\\?\Volume&#123;6afa3aa3-1b38-11e6-a140-0000fbaa0005&#125;\ -name:drive1
D:\ldc_res -name:nfs -public -maproot:0 *(rw,sync,no_root_squash)
E:\ -name:nfs_udisk -public -maproot:0 *(rw,sync,no_root_squash)
</code></pre>
<p>挂载：<br><code>mount -t nfs -o nolock 192.168.0.100:/nfs_udisk /mnt/</code></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/06/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span><a href="#quick-start" class="header-anchor">#</a></h2><h3><span id="create-a-new-post">Create a new post</span><a href="#create-a-new-post" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span><a href="#run-server" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span><a href="#generate-static-files" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span><a href="#deploy-to-remote-sites" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>imx6ull裸机-ADC</title>
    <url>/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-imx6ull-ji-cun-qi">1 IMX6ULL寄存器</a><ul>
<li><a href="#1-1-adcx-cfg-x-1-2-pei-zhi-ji-cun-qi">1.1 ADCx_CFG(x&#x3D;1~2) 配置寄存器</a></li>
<li><a href="#1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi">1.2 ADCx_GC 通用控制寄存器</a></li>
<li><a href="#1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi">1.3 ADCx_GS 通用状态寄存器</a></li>
<li><a href="#1-4-adcx-hs-zhuang-tai-ji-cun-qi">1.4 ADCx_HS 状态寄存器</a></li>
<li><a href="#1-5-adcx-hc0-kong-zhi-ji-cun-qi">1.5 ADCx_HC0 控制寄存器</a></li>
<li><a href="#1-6-adcx-r0-shu-ju-ji-cun-qi">1.6 ADCx_R0 数据寄存器</a></li>
</ul>
</li>
<li><a href="#2-liu-cheng-dai-ma">2 流程代码</a><ul>
<li><a href="#2-1-chu-shi-hua">2.1 初始化</a></li>
<li><a href="#2-2-zi-dong-xiao-zhun">2.2 自动校准</a></li>
<li><a href="#2-3-huo-qu-adc-yuan-shi-zhi">2.3 获取ADC原始值</a></li>
<li><a href="#2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun">2.4 获取ADC原始值(多次取平均)</a></li>
<li><a href="#2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya">2.5 获取模数转换后的电压</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-imx6ull-ji-cun-qi">1 IMX6ULL寄存器</span><a href="#1-imx6ull-ji-cun-qi" class="header-anchor">#</a></h1><h2><span id="1-1-adcx-cfg-x-x3d-1-2-pei-zhi-ji-cun-qi">1.1 ADCx_CFG(x&#x3D;1~2) 配置寄存器</span><a href="#1-1-adcx-cfg-x-x3d-1-2-pei-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/1.jpg" alt="image"><br><strong>OVWREN</strong> (bit16)：数据复写使能位，为 1 的时候使能复写功能，为 0 的时候关闭复写功能。<br><strong>AVGS</strong>(bit15:14)：硬件平均次数，只有当 ADC1_GC 寄存器的 AVGE 位为 1 的时候才有效<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/2.png" alt="image"><br><strong>ADTRG</strong>(bit13)：转换触发选择。为 0 的时候选择软件触发，为 1 的时候，不选择软件触发。<br><strong>REFSEL</strong>(bit12:11)：参考电压选择，为 00 时选择 VREFH&#x2F;VREFL 这两个引脚上的电压为参考电压，正点原子 ALPHA 开发板上 VREFH 为 3.3V，VREFL 为 0V。<br><strong>ADHSC</strong>(bit10)：高速转换使能位，当为 0 时为正常模式，为 1 时为高速模式。<br><strong>ADSTS</strong>(bit9:8)：设置 ADC 的采样周期，与 ADLSMP 位一起决定采样周期：<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/3.png" alt="image"><br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/4.png" alt="image"><br><strong>ADLSMP</strong>(bit4)：长采样周期使能位，当值为 0 时为短采样周期模式，为 1 时为长采样周期模式。搭配 ADSTS 位一起控制 ADC 的采样周期。<br><strong>MODE</strong>(bit3:2)：选择转换精度：<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/5.png" alt="image"><br><strong>ADICLK</strong>(bit1:0)：输入时钟源选择，为 00 的时候选择 IPG Clock，为 01 的时候选择 IPG Clock&#x2F;2，为 10 的时候无效，为 11 的时候选择呢 ADACK。本教程我们设置为 11，也就是选择ADACK 为 ADC 的时钟源。</p>
<h2><span id="1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi">1.2 ADCx_GC 通用控制寄存器</span><a href="#1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/6.png" alt="image"><br><strong>CAL</strong>(bit7)：当该位写入 1 时，硬件校准功能将会启动，校准过程中该位会一直保持 1，校准完成后会清 0，校准完成后需要检查一下ADC_GS[CALF]位，确认校准结果。<br><strong>ADCO</strong>(bit6)：连续转换使能位，只有在开启了硬件平均功能时有效，为 0 时只能转换一次或一组，当 ADCO 为 1 时可以连续转换或多组。<br><strong>AVGE</strong>(bit5)：硬件平均使能位。为 0 时关闭，为 1 时使能。<br><strong>ACFE</strong>(bit4)：比较功能使能位。为 0 时关闭，为 1 时使能。<br><strong>ACFGT</strong>(bit3)：配置比较方法，如果为 0 的话就比较转换结果是否小于 ADC_CV 寄存器值，如果为 1 的话就比较装换结果是否大于或等于 ADC_CV 寄存器值。<br><strong>ACREN</strong>(bit2)：范围比较功能使能位。为 0 的话仅和 ADC_CV 里的 CV1 比较，为 1 的话和 ADC_CV 里的 CV1、CV2 比较。<br><strong>ACREN</strong>(bit2)：范围比较功能使能位。为 0 的话仅和 ADC_CV 里的 CV1 比较，为 1 的话和 ADC_CV 里的 CV1、CV2 比较。<br><strong>DMAEN</strong>(bit1)：DMA 功能使能位，为 0 是关闭，为 1 是开启<br><strong>ADACKEN</strong>(bit0)：异步时钟输出使能位，为 0 是关闭，为 1 时开启</p>
<h2><span id="1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi">1.3 ADCx_GS 通用状态寄存器</span><a href="#1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/7.png" alt="image"><br><strong>AWKST</strong>(bit2)：异步唤醒中断状态，为 1 时表示发生了异步唤醒中断。为 0 时没有发生异步中断。<br><strong>CALF</strong>(bit1)：校准失败标志位，为 0 的时候表示校准正常完成，为 1 的时候表示校准失败。<br><strong>ADACT</strong>(bit0)：转换活动标志，为 0 的时候表示转换没有进行，为 1 的时候表示正在进行转换。</p>
<h2><span id="1-4-adcx-hs-zhuang-tai-ji-cun-qi">1.4 ADCx_HS 状态寄存器</span><a href="#1-4-adcx-hs-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h2><p>COCO0表示转换完成.</p>
<p><strong>COCO0</strong>(bit0)：每次转换完成此位就会被置 1。</p>
<h2><span id="1-5-adcx-hc0-kong-zhi-ji-cun-qi">1.5 ADCx_HC0 控制寄存器</span><a href="#1-5-adcx-hc0-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/8.png" alt="image"><br><strong>AIEN</strong>(bit7)：转换完成中断控制位，为 1 的时候打开转换完成中断，为 0 的时候关闭。<br><strong>ADCH</strong>(bit4:0)：转换通道选择，可以设置为 00000~01111 分别对应通道 0~15。11001 为内部通道，用于 ADC 自测。</p>
<h2><span id="1-6-adcx-r0-shu-ju-ji-cun-qi">1.6 ADCx_R0 数据寄存器</span><a href="#1-6-adcx-r0-shu-ju-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/9.png" alt="image"></p>
<h1><span id="2-liu-cheng-dai-ma">2 流程代码</span><a href="#2-liu-cheng-dai-ma" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、初始化 ADC1_CH1</span><br><span class="line"><span class="comment">//初始化 ADC1_CH1，配置 ADC 位数，时钟源，采样时间等。</span></span><br><span class="line"><span class="number">2</span>、校准 ADC</span><br><span class="line"><span class="comment">//ADC 在使用之前需要校准一次。</span></span><br><span class="line"><span class="number">3</span>、使能 ADC</span><br><span class="line"><span class="comment">//配置好 ADC 以后就可以开启了。</span></span><br><span class="line"><span class="number">4</span>、读取 ADC 值</span><br><span class="line"><span class="comment">//ADC 正常工作以后就可以读取 ADC 值。</span></span><br></pre></td></tr></table></figure>
<h2><span id="2-1-chu-shi-hua">2.1 初始化</span><a href="#2-1-chu-shi-hua" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc1ch1_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ADC1-&gt;CFG = <span class="number">0</span>;</span><br><span class="line">    ADC1-&gt;CFG |= (<span class="number">2</span> &lt;&lt; <span class="number">2</span>) | (<span class="number">3</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    ADC1-&gt;GC = <span class="number">0</span>;</span><br><span class="line">    ADC1-&gt;GC |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* CFG寄存器</span></span><br><span class="line"><span class="comment">     * bit16        0       关闭复写功能</span></span><br><span class="line"><span class="comment">     * bit15:14     00      硬件平均设置为默认值，00的时候4次平均，</span></span><br><span class="line"><span class="comment">     *                      但是得ADC_GC寄存器的AVGE位置1来使能硬件平均</span></span><br><span class="line"><span class="comment">     * bit13        0       软件触发</span></span><br><span class="line"><span class="comment">     * bit12:1      00      参考电压为VREFH/VREFL，也就是3.3V/0V</span></span><br><span class="line"><span class="comment">     * bit10        0       正常转换速度</span></span><br><span class="line"><span class="comment">     * bit9:8       00      采样时间2/12，ADLSMP=0(短采样)的时候为2个周期</span></span><br><span class="line"><span class="comment">     *                      ADLSMP=1(长采样)的时候为12个周期</span></span><br><span class="line"><span class="comment">     * bit7         0       非低功耗模式</span></span><br><span class="line"><span class="comment">     * bit6:5       00      ADC时钟源1分频 </span></span><br><span class="line"><span class="comment">     * bit4         0       短采样</span></span><br><span class="line"><span class="comment">     * bit3:2       10      12位ADC</span></span><br><span class="line"><span class="comment">     * bit1:0       11      ADC时钟源选择ADACK</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="comment">/* GC寄存器</span></span><br><span class="line"><span class="comment">     * bit7     0       先关闭校准功能，后面会校准</span></span><br><span class="line"><span class="comment">     * bit6     0       关闭持续转换</span></span><br><span class="line"><span class="comment">     * bit5     0       关闭硬件平均功能</span></span><br><span class="line"><span class="comment">     * bit4     0       关闭比较功能</span></span><br><span class="line"><span class="comment">     * bit3     0       关闭比较的Greater Than功能</span></span><br><span class="line"><span class="comment">     * bit2     0       关闭比较的Range功能</span></span><br><span class="line"><span class="comment">     * bit1     0       关闭DMA</span></span><br><span class="line"><span class="comment">     * bit0     1       使能ADACK</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h2><span id="2-2-zi-dong-xiao-zhun">2.2 自动校准</span><a href="#2-2-zi-dong-xiao-zhun" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">status_t</span> <span class="title function_">adc1_autocalibration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">status_t</span> ret  = kStatus_Success;</span><br><span class="line">	ADC1-&gt;GS |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);   <span class="comment">/* 清除CALF位，写1清零 */</span></span><br><span class="line">	ADC1-&gt;GC |= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);   <span class="comment">/* 使能校准功能 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 校准完成之前GC寄存器的CAL位会一直为1，直到校准完成此位自动清零 */</span></span><br><span class="line">	<span class="keyword">while</span>((ADC1-&gt;GC &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) != <span class="number">0</span>) &#123; </span><br><span class="line">		<span class="comment">/* 如果GS寄存器的CALF位为1的话表示校准失败 */</span></span><br><span class="line">		<span class="keyword">if</span>((ADC1-&gt;GS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">			ret = kStatus_Fail;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 校准成功以后HS寄存器的COCO0位会置1 */</span></span><br><span class="line">	<span class="keyword">if</span>((ADC1-&gt;HS  &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>) </span><br><span class="line">		ret = kStatus_Fail;</span><br><span class="line">	<span class="comment">/* 如果GS寄存器的CALF位为1的话表示校准失败 */</span></span><br><span class="line">		<span class="keyword">if</span>((ADC1-&gt;GS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>) </span><br><span class="line">		ret = kStatus_Fail;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2><span id="2-3-huo-qu-adc-yuan-shi-zhi">2.3 获取ADC原始值</span><a href="#2-3-huo-qu-adc-yuan-shi-zhi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">getadc_value</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 配置ADC通道1 */</span></span><br><span class="line">	ADC1-&gt;HC[<span class="number">0</span>] = <span class="number">0</span>;            <span class="comment">/* 关闭转换结束中断    */</span></span><br><span class="line">	ADC1-&gt;HC[<span class="number">0</span>] |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);     <span class="comment">/* 通道1            */</span></span><br><span class="line">	<span class="keyword">while</span>((ADC1-&gt;HS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>);  <span class="comment">/* 等待转换完成 */</span></span><br><span class="line">	<span class="keyword">return</span> ADC1-&gt;R[<span class="number">0</span>];    <span class="comment">/* 返回ADC值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun">2.4 获取ADC原始值(多次取平均)</span><a href="#2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">getadc_average</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> times)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp_val = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> t;</span><br><span class="line">	<span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; times; t++)&#123;</span><br><span class="line">		temp_val += getadc_value();</span><br><span class="line">		delayms(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp_val / times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya">2.5 获取模数转换后的电压</span><a href="#2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya" class="header-anchor">#</a></h2><p>由于精度为12 bit, ADC范围为[0, 4095]。同时电压满输出时为3.3v，因此当ADC数据拉满，得到3300mv，也就是3.3v</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">getadc_volt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> adcvalue=<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	adcvalue = getadc_average(<span class="number">5</span>);</span><br><span class="line">	ret = (<span class="type">float</span>)adcvalue * (<span class="number">3300.0f</span> / <span class="number">4096.0f</span>);    	<span class="comment">/* 获取计算后的带小数的实际电压值 */</span></span><br><span class="line">	<span class="keyword">return</span>  ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull裸机-SPI</title>
    <url>/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-spi-jie-shao">1 SPI介绍</a><ul>
<li><a href="#1-1-imx6ull-spi-kong-zhi-qi-jie-shao">1.1 imx6ull SPI控制器介绍</a><ul>
<li><a href="#1-1-1-te-dian">1.1.1 特点</a></li>
<li><a href="#1-1-2-kuang-tu">1.1.2 框图</a></li>
<li><a href="#1-1-3-shi-xu">1.1.3 时序</a></li>
</ul>
</li>
<li><a href="#1-2-spi-kong-zhi-qi-ji-cun-qi">1.2 SPI控制器寄存器</a><ul>
<li><a href="#1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng">1.2.1 控制器初始化流程</a></li>
<li><a href="#1-2-2-ji-cun-qi-jie-shao">1.2.2 寄存器介绍</a><ul>
<li><a href="#1-2-2-1-rxdata">1.2.2.1 RXDATA</a></li>
<li><a href="#1-2-2-2-txdata">1.2.2.2 TXDATA</a></li>
<li><a href="#1-2-2-3-conreg">1.2.2.3 CONREG</a></li>
<li><a href="#1-2-2-4-configreg">1.2.2.4 CONFIGREG</a></li>
<li><a href="#1-2-2-5-statreg">1.2.2.5 STATREG</a></li>
<li><a href="#1-2-2-6-periodreg">1.2.2.6 PERIODREG</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-spi-kong-zhi-qi-dai-ma-bian-xie">1.3 SPI控制器代码编写</a></li>
</ul>
</li>
<li><a href="#2-spi-ying-yong">2 SPI 应用</a><ul>
<li><a href="#2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g">2.1 6轴陀螺仪加速度传感器ICM-20608-G</a><ul>
<li><a href="#2-1-1-icm-20608-g-gai-shu">2.1.1 ICM-20608-G概述</a></li>
<li><a href="#2-1-2-ying-yong-chang-jing">2.1.2 应用场景</a></li>
<li><a href="#2-1-3-tuo-luo-yi-he-jia-su-du-te-xing">2.1.3 陀螺仪和加速度特性</a></li>
<li><a href="#2-1-4-dian-qi-te-xing">2.1.4 电器特性</a></li>
<li><a href="#2-1-5-jiao-liu-dian-qi-te-xing">2.1.5 交流电器特性</a></li>
<li><a href="#2-1-6-gong-zuo-mo-shi">2.1.6 工作模式</a></li>
<li><a href="#2-1-7-spi-fang-shi-ji-cun-qi-fang-wen">2.1.7 SPI方式寄存器访问</a></li>
</ul>
</li>
<li><a href="#2-2-icm-20608-g-ji-cun-qi-miao-shu">2.2 ICM-20608-G寄存器描述</a><ul>
<li><a href="#2-2-1-kong-zhi-ji-cun-qi">2.2.1 控制寄存器</a></li>
<li><a href="#2-2-2-shu-ju-ji-cun-qi">2.2.2 数据寄存器</a></li>
<li><a href="#2-2-3-who-am-i-ji-cun-qi">2.2.3 WHO_AM_I寄存器</a></li>
<li><a href="#2-2-4-pwr-mgmt-1-pwr-mgmt-2-ji-cun-qi">2.2.4 PWR_MGMT_1&#x2F;PWR_MGMT_2寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-3-dai-ma-jie-xi">2.3 代码解析</a><ul>
<li><a href="#2-3-1-ce-shi-xiao-guo">2.3.1 测试效果</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-spi-jie-shao">1 SPI介绍</span><a href="#1-spi-jie-shao" class="header-anchor">#</a></h1><p><a href="https://fuzidage.github.io/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/">s3c2440裸机编程-SPI | Hexo (fuzidage.github.io)</a>有详细介绍SPI协议。</p>
<h2><span id="1-1-imx6ull-spi-kong-zhi-qi-jie-shao">1.1 imx6ull SPI控制器介绍</span><a href="#1-1-imx6ull-spi-kong-zhi-qi-jie-shao" class="header-anchor">#</a></h2><p>NXP的6ull参考手册第Chapter 20介绍了SPI控制器，<code>Enhanced Configurable SPI (ECSPI)</code> 。</p>
<h3><span id="1-1-1-te-dian">1.1.1 特点</span><a href="#1-1-1-te-dian" class="header-anchor">#</a></h3><p>①、全双工同步串行接口。<br>②、可配置的主&#x2F;从模式。<br>③、四个硬件片选信号，支持多从机。<br>④、发送和接收都有一个 32x64 的 FIFO。<br>⑤、片选信号 SS&#x2F;CS，时钟信号 SCLK 的极性相位<code>(CPOL,CPHA)</code>可配置。<br>⑥、支持 DMA<br>⑦、SCK最高可以到输入参考时钟高达60Mhz</p>
<h3><span id="1-1-2-kuang-tu">1.1.2 框图</span><a href="#1-1-2-kuang-tu" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/1.png" alt="image"><br>最右边是引脚，SCLK,MISO,MOSI等，上面是外围总线，通过APB总线进行寄存器读写，<code>INTREG,CONREG</code>等等。TXDATA和TXDATA寄存器存放了要发送的数据和接收的收据。<br>时钟源来自<code>Reference Clock or Low Frequency Clock</code>。可选时钟源如下：这里选用<code>ecspi_clk_root</code>。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/2.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/3.png" alt="image"><br>① CSCDR2的ECSPI_CLK_SEL位设置为0，选择出PLL3_SW_CLK 进行8分频作为 ECSPI 根时钟源。PLL3_SW_CLK&#x3D;480MHz,8分频就是60MHz。<br>② CSCDR2 的 ECSPI_CLK_PODF位再次进行分频，ECSPI_CLK_PODF位设置成0，表示2^0分频，也就是1分频。<br>③ 最后ECSPI_CLK_ROOT就为60MHz</p>
<h3><span id="1-1-3-shi-xu">1.1.3 时序</span><a href="#1-1-3-shi-xu" class="header-anchor">#</a></h3><p>CPOL时钟极性 和CPHA时钟相位组合成了4种模式：</p>
<pre><code>CPOL:表示SPI CLK的初始电平（空闲状态时电平），0为低电平，1为高电平
CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿
</code></pre>
<p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/4.png" alt="image"></p>
<h2><span id="1-2-spi-kong-zhi-qi-ji-cun-qi">1.2 SPI控制器寄存器</span><a href="#1-2-spi-kong-zhi-qi-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng">1.2.1 控制器初始化流程</span><a href="#1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng" class="header-anchor">#</a></h3><p><strong>CONREG</strong>[EN]：复位，0表示复位<br><strong>CCM</strong>开启ECSPI时钟<br><strong>CONREG</strong>[EN]：复位，1表示反选复位<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/5.png" alt="image"></p>
<h3><span id="1-2-2-ji-cun-qi-jie-shao">1.2.2 寄存器介绍</span><a href="#1-2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h3><h4><span id="1-2-2-1-rxdata">1.2.2.1 RXDATA</span><a href="#1-2-2-1-rxdata" class="header-anchor">#</a></h4><p><strong>RXDATA寄存器</strong>：接收数据寄存器，RR位的状态决定接受数据是否就绪<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/6.png" alt="image"></p>
<h4><span id="1-2-2-2-txdata">1.2.2.2 TXDATA</span><a href="#1-2-2-2-txdata" class="header-anchor">#</a></h4><p><strong>TXDATA寄存器</strong>:发送数据寄存器，实际传输的位数由相应SPI控制寄存器的BURST_LENGTH位来决定。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/7.png" alt="image"></p>
<h4><span id="1-2-2-3-conreg">1.2.2.3 CONREG</span><a href="#1-2-2-3-conreg" class="header-anchor">#</a></h4><p><strong>CONREG寄存器</strong>:控制寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/8.png" alt="image"><br><strong>EN</strong>:使能位，1为使能<br><strong>SMC</strong>:为1表示当数据写入TXFIFO时，立即启动SPI突发；这里使用该模式<br><strong>CHANNEL_MODE</strong>：硬件片选模式选择，bit[7:4]分别表示通道3到通道0，这里采用通道0设定为Master mode.因此bit[7:4]配置成1<br><strong>POST_DIVIDER</strong>:后分频，0到15表示2^n次方分频，比如0就是1分频，15就是2^15分频<br><strong>PRE_DIVIDER</strong>:前分频，0到15表示1到16分频<br>前面spi clk的时钟源为ECSPI_CLK_ROOT 60MHz，这里我们用6MHz，因此可以设置POST_DIVIDER&#x3D;0，PRE_DIVIDER&#x3D;9，表示10分频。<br><strong>CHANNEL_SELECT</strong>:通道选择，也就是硬件片选SS选择，这里选择SS0,通道0<br><strong>BURST_LENGTH</strong>：突发访问长度，这里我们用一次突发8bit, 配置成0x7</p>
<h4><span id="1-2-2-4-configreg">1.2.2.4 CONFIGREG</span><a href="#1-2-2-4-configreg" class="header-anchor">#</a></h4><p><strong>CONFIGREG寄存器</strong>：配置寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/9.png" alt="image"><br><strong>SCLK_PHA</strong>：时钟相位，SCLK_PHA[3:0]分别对应通道3~0，设置为0表示第一个时钟沿采集数据，设置成1表示第二个时钟沿采集数据。（同POL组成4种模式）<br><strong>SCLK_POL</strong>：时钟极性，表示时钟初始空闲时的电平，0为低电平，1为高电平。（同PHA组成4种模式）<br><strong>SS_CTL</strong>:硬件片选的wave form select,这个用不上设置成0<br><strong>SS_POL</strong>：硬件片选的极性选择，用不上设置成0<br><strong>DATA_CTL</strong>：数据线空闲时电平状态，我们设置成0表示高电平<br><strong>SCLK_CTL</strong>：时钟线空闲时电平状态，我们设置成0表示低电平（POL设置了时钟初始空闲时的电平为低电平)<br><strong>HT_LENGTH</strong>: HT Mode不用，无需配置</p>
<h4><span id="1-2-2-5-statreg">1.2.2.5 STATREG</span><a href="#1-2-2-5-statreg" class="header-anchor">#</a></h4><p><strong>STATREG寄存器</strong>：状态寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/10.png" alt="image"><br><strong>TE</strong>:TXFIFO empty, 为1表示TXFIFO为空，0表示TXFIFO还没空，因此往TXDATA发送数据时，需要先等待TXFIFO为空。<br><strong>RR</strong>: RXFIFO Ready,1表示有数据，0表示数据还没ready.读取RXDATA需要等RXFIFO先ready。</p>
<h4><span id="1-2-2-6-periodreg">1.2.2.6 PERIODREG</span><a href="#1-2-2-6-periodreg" class="header-anchor">#</a></h4><p><strong>PERIODREG寄存器</strong>：采样周期寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/11.png" alt="image"><br><strong>SAMPLE_ PERIOD</strong>:突发访问时的等待周期，表示等待多少个时钟周期后进行一下次突发访问。我们设置为0x2000。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/12.png" alt="image"><br><strong>CSRC</strong>: 等待周期的单位，0表示以SPI clk为单位, 1表示以low-frequency reference clk 32.768KHz为单位。<br><strong>CSD_CTL</strong>:硬件片选延时，表示片选后多少个时钟周期才可以进行数据传输。（这里不用，我们用软件片选)</p>
<h2><span id="1-3-spi-kong-zhi-qi-dai-ma-bian-xie">1.3 SPI控制器代码编写</span><a href="#1-3-spi-kong-zhi-qi-dai-ma-bian-xie" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_init</span><span class="params">(ECSPI_Type *base)</span> &#123;</span><br><span class="line">	<span class="comment">/* 配置CONREG寄存器</span></span><br><span class="line"><span class="comment">	 * bit0 : 		1 	使能ECSPI</span></span><br><span class="line"><span class="comment">	 * bit3 : 		1	当向TXFIFO写入数据以后立即开启SPI突发。</span></span><br><span class="line"><span class="comment">	 * bit[7:4] : 	0001 SPI通道0主模式，根据实际情况选择，</span></span><br><span class="line"><span class="comment">	 *            	   	开发板上的ICM-20608接在SS0上，所以设置通道0为主模式</span></span><br><span class="line"><span class="comment">	 * bit[19:18]:	00 	选中通道0(其实不需要，因为片选信号我们我们自己控制)</span></span><br><span class="line"><span class="comment">	 * bit[31:20]:	0x7	突发长度为8个bit。 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;CONREG = <span class="number">0</span>; <span class="comment">/* 先清除控制寄存器 */</span></span><br><span class="line">	base-&gt;CONREG |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">3</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">7</span> &lt;&lt; <span class="number">20</span>); <span class="comment">/* 配置CONREG寄存器 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ECSPI通道0设置,即设置CONFIGREG寄存器</span></span><br><span class="line"><span class="comment">	 * bit0:	0 通道0 PHA为0</span></span><br><span class="line"><span class="comment">	 * bit4:	0 通道0 SCLK高电平有效</span></span><br><span class="line"><span class="comment">	 * bit8: 	0 通道0片选信号 当SMC为1的时候此位无效</span></span><br><span class="line"><span class="comment">	 * bit12：	0 通道0 POL为0</span></span><br><span class="line"><span class="comment">	 * bit16：	0 通道0 数据线空闲时高电平</span></span><br><span class="line"><span class="comment">	 * bit20:	0 通道0 时钟线空闲时低电平</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;CONFIGREG = <span class="number">0</span>; 		<span class="comment">/* 设置通道寄存器 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  </span></span><br><span class="line"><span class="comment">	 * ECSPI通道0设置，设置采样周期</span></span><br><span class="line"><span class="comment">	 * bit[14:0] :	0X2000  采样等待周期，比如当SPI时钟为10MHz的时候</span></span><br><span class="line"><span class="comment">	 *  		    0X2000就等于1/10000 * 0X2000 = 0.8192ms，也就是连续</span></span><br><span class="line"><span class="comment">	 *          	读取数据的时候每次之间间隔0.8ms</span></span><br><span class="line"><span class="comment">	 * bit15	 :  0  采样时钟源为SPI CLK</span></span><br><span class="line"><span class="comment">	 * bit[21:16]:  0  片选延时，可设置为0~63</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;PERIODREG = <span class="number">0X2000</span>;		<span class="comment">/* 设置采样周期寄存器 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ECSPI的SPI时钟配置，SPI的时钟源来源于pll3_sw_clk/8=480/8=60MHz</span></span><br><span class="line"><span class="comment">	 * 通过设置CONREG寄存器的PER_DIVIDER(bit[11:8])和POST_DIVEDER(bit[15:12])来</span></span><br><span class="line"><span class="comment">	 * 对SPI时钟源分频，获取到我们想要的SPI时钟：</span></span><br><span class="line"><span class="comment">	 * SPI CLK = (SourceCLK / PER_DIVIDER) / (2^POST_DIVEDER)</span></span><br><span class="line"><span class="comment">	 * 比如我们现在要设置SPI时钟为6MHz，那么PER_DIVEIDER和POST_DEIVIDER设置如下：</span></span><br><span class="line"><span class="comment">	 * PER_DIVIDER = 0X9。</span></span><br><span class="line"><span class="comment">	 * POST_DIVIDER = 0X0。</span></span><br><span class="line"><span class="comment">	 * SPI CLK = 60000000/(0X9 + 1) = 60000000=6MHz</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;CONREG &amp;= ~((<span class="number">0XF</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">0XF</span> &lt;&lt; <span class="number">8</span>));	<span class="comment">/* 清除PER_DIVDER和POST_DIVEDER以前的设置 */</span></span><br><span class="line">	base-&gt;CONREG |= (<span class="number">0X9</span> &lt;&lt; <span class="number">12</span>);					<span class="comment">/* 设置SPI CLK = 6MHz */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: SPI通道0发送/接收一个字节的数据</span></span><br><span class="line"><span class="comment"> * @param - base	: 要使用的SPI</span></span><br><span class="line"><span class="comment"> * @param - txdata	: 要发送的数据</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">spich0_readwrite_byte</span><span class="params">(ECSPI_Type *base, <span class="type">unsigned</span> <span class="type">char</span> txdata)</span> &#123; </span><br><span class="line">	<span class="type">uint32_t</span>  spirxdata = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span>  spitxdata = txdata;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 选择通道0 */</span></span><br><span class="line">	base-&gt;CONREG &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line">	base-&gt;CONREG |= (<span class="number">0</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((base-&gt;STATREG &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>)&#123;&#125; <span class="comment">/* 等待发送FIFO为空 */</span></span><br><span class="line">		base-&gt;TXDATA = spitxdata;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((base-&gt;STATREG &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)) == <span class="number">0</span>)&#123;&#125; <span class="comment">/* 等待接收FIFO有数据 */</span></span><br><span class="line">		spirxdata = base-&gt;RXDATA;</span><br><span class="line">	<span class="keyword">return</span> spirxdata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="2-spi-ying-yong">2 SPI 应用</span><a href="#2-spi-ying-yong" class="header-anchor">#</a></h1><h2><span id="2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g">2.1 6轴陀螺仪加速度传感器ICM-20608-G</span><a href="#2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g" class="header-anchor">#</a></h2><h3><span id="2-1-1-icm-20608-g-gai-shu">2.1.1 ICM-20608-G概述</span><a href="#2-1-1-icm-20608-g-gai-shu" class="header-anchor">#</a></h3><p><code>The ICM-20608-G is a 6-axis MotionTracking device that combines a 3-axis gyroscope, and a 3-axis accelerometer in a small 3x3x0.75mm (16-pin LGA) package. The gyroscope has a programmable full-scale range of ±250, ±500, ±1000, and ±2000 degrees/sec. The accelerometer has a user programmable accelerometer full-scale range of ±2g, ±4g, ±8g, and ±16g. Other industry-leading features include on-chip 16-bit ADCs, programmable digital filters, an embedded temperature sensor, and programmable interrupts. The device features I2 C and SPI serial interfaces, a VDD operating range of 1.71 to 3.45V, and a separate digital IO supply, VDDIO from 1.71V to 3.45V. Communication with all registers of the device is performed using either I2 C at 400kHz or SPI at 8MHz.</code><br>1.包含3轴陀螺仪数据和3轴加速度数据。<br>2.陀螺仪和加速度量程可设定，陀螺仪量程可设定位+-250，+-500，+-1000， +-2000角度每秒。加速度同理也可设定量程。<br>3.精度为16bit ADC转换。<br>4.使用I2C&#x2F;SPI接口通信，I2C速率高达400KHz, SPI高达8MHz。</p>
<h3><span id="2-1-2-ying-yong-chang-jing">2.1.2 应用场景</span><a href="#2-1-2-ying-yong-chang-jing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/13.png" alt="image"></p>
<h3><span id="2-1-3-tuo-luo-yi-he-jia-su-du-te-xing">2.1.3 陀螺仪和加速度特性</span><a href="#2-1-3-tuo-luo-yi-he-jia-su-du-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/14.png" alt="image"></p>
<h3><span id="2-1-4-dian-qi-te-xing">2.1.4 电器特性</span><a href="#2-1-4-dian-qi-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/15.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/16.png" alt="image"><br>可以看到FS_SEL，AFS_SEL用来选择陀螺仪和加速度计的量程。举个例子，当角速度量程为+-250时，那么ADC的数据为多少表示为1度呢？已知ADC精度16bit, 数据范围[0,65535], 假如ADC的数据为x, 那么x&#x2F;65636 &#x3D; 1&#x2F;500,算出x&#x3D; 131.272x,对应表格数据中的131。加速度的换算公式也是同理， 当AFS_SEL&#x3D;0时，x&#x2F;65536 &#x3D; 1&#x2F;4， x&#x3D;16384。</p>
<h3><span id="2-1-5-jiao-liu-dian-qi-te-xing">2.1.5 交流电器特性</span><a href="#2-1-5-jiao-liu-dian-qi-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/17.png" alt="image"><br>当用i2c通信，AD0引脚决定i2c从地址是0x68还是0x69。可以看到power-on reset上电时序，需要Valid power-on RESET时间最少0.01ms, 从启动到寄存器读写等11ms。</p>
<h3><span id="2-1-6-gong-zuo-mo-shi">2.1.6 工作模式</span><a href="#2-1-6-gong-zuo-mo-shi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/18.png" alt="image"></p>
<h3><span id="2-1-7-spi-fang-shi-ji-cun-qi-fang-wen">2.1.7 SPI方式寄存器访问</span><a href="#2-1-7-spi-fang-shi-ji-cun-qi-fang-wen" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/19.png" alt="image"><br>数据上升沿锁存，下降沿数据发生改变。最大高达8MHz时钟，一次读写需要16个或者更多时钟周期，第一个字节传输寄存器地址，第二个字节传输数据。首字节的首位表示是读还是写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_CSN(n)    (n ? gpio_pinwrite(GPIO1, 20, 1) : gpio_pinwrite(GPIO1, 20, 0))   <span class="comment">/* SPI片选信号	 */</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description  : 写ICM20608指定寄存器</span></span><br><span class="line"><span class="comment"> * @param - reg  : 要读取的寄存器地址</span></span><br><span class="line"><span class="comment"> * @param - value: 要写入的值</span></span><br><span class="line"><span class="comment"> * @return		 : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_write_reg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> value)</span> &#123;</span><br><span class="line">	<span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址</span></span><br><span class="line"><span class="comment">	 * 只有低7位有效,寄存器地址最高位是读/写标志位</span></span><br><span class="line"><span class="comment">	 * 读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	reg &amp;= ~<span class="number">0X80</span>;	</span><br><span class="line"></span><br><span class="line">	ICM20608_CSN(<span class="number">0</span>);						<span class="comment">/* 使能SPI传输			*/</span></span><br><span class="line">	spich0_readwrite_byte(ECSPI3, reg); 	<span class="comment">/* 发送寄存器地址		*/</span> </span><br><span class="line">	spich0_readwrite_byte(ECSPI3, value);	<span class="comment">/* 发送要写入的值			*/</span></span><br><span class="line">	ICM20608_CSN(<span class="number">1</span>);						<span class="comment">/* 禁止SPI传输			*/</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 读取ICM20608寄存器值</span></span><br><span class="line"><span class="comment"> * @param - reg	: 要读取的寄存器地址</span></span><br><span class="line"><span class="comment"> * @return 		: 读取到的寄存器值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">icm20608_read_reg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> reg_val;	   	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址</span></span><br><span class="line"><span class="comment">	 * 只有低7位有效,寄存器地址最高位是读/写标志位</span></span><br><span class="line"><span class="comment">	 * 读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	reg |= <span class="number">0x80</span>; 	</span><br><span class="line"></span><br><span class="line">	ICM20608_CSN(<span class="number">0</span>);               					<span class="comment">/* 使能SPI传输	 		*/</span></span><br><span class="line">	spich0_readwrite_byte(ECSPI3, reg);     		<span class="comment">/* 发送寄存器地址  		*/</span> </span><br><span class="line">	reg_val = spich0_readwrite_byte(ECSPI3, <span class="number">0XFF</span>);	<span class="comment">/* 读取寄存器的值 			*/</span></span><br><span class="line">	ICM20608_CSN(<span class="number">1</span>);                				<span class="comment">/* 禁止SPI传输 			*/</span></span><br><span class="line">	<span class="keyword">return</span>(reg_val);               	 				<span class="comment">/* 返回读取到的寄存器值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-2-icm-20608-g-ji-cun-qi-miao-shu">2.2 ICM-20608-G寄存器描述</span><a href="#2-2-icm-20608-g-ji-cun-qi-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/20.png" alt="image"><br>ICM-20608-G寄存器的地址和数据都是单字节。</p>
<h3><span id="2-2-1-kong-zhi-ji-cun-qi">2.2.1 控制寄存器</span><a href="#2-2-1-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>控制配置寄存器0x1a,0x1b,0x1c,0x1d，设置量程等配置。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/21.png" alt="image"><br>0x19设置分频，不分频，配成0<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/22.png" alt="image"><br>0x1a设置陀螺仪低通滤波带宽BW&#x3D;20Hz，配成0x4.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/23.png" alt="image"><br>0x1b设置gyro量程，配成最大0x18.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/24.png" alt="image"><br>0x1c设置加速度计的量程，也配成最大0x18.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/25.png" alt="image"><br>0x1d设置加速度计低通滤波BW&#x3D;21.2Hz<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/26.png" alt="image"><br> 0x1e设置low power，配成0，关闭低功耗.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/27.png" alt="image"><br>0x23设置fifo功能，这里配置0x0,禁用fifo.</p>
<p>设定量程，配置相关参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SMPLRT_DIV			0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_CONFIG				0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_CONFIG			0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG			0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG2			0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_LP_MODE_CFG			0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_EN				0x23</span></span><br><span class="line">icm20608_write_reg(ICM20_SMPLRT_DIV, <span class="number">0x00</span>); 	<span class="comment">/* 输出速率是内部采样率					*/</span></span><br><span class="line">icm20608_write_reg(ICM20_GYRO_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 陀螺仪±2000dps量程 				*/</span></span><br><span class="line">icm20608_write_reg(ICM20_ACCEL_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 加速度计±16G量程 					*/</span></span><br><span class="line">icm20608_write_reg(ICM20_CONFIG, <span class="number">0x04</span>); 		<span class="comment">/* 陀螺仪低通滤波BW=20Hz 				*/</span></span><br><span class="line">icm20608_write_reg(ICM20_ACCEL_CONFIG2, <span class="number">0x04</span>); 	<span class="comment">/* 加速度计低通滤波BW=21.2Hz 			*/</span></span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_2, <span class="number">0x00</span>); 	<span class="comment">/* 打开加速度计和陀螺仪所有轴 				*/</span></span><br><span class="line">icm20608_write_reg(ICM20_LP_MODE_CFG, <span class="number">0x00</span>); 	<span class="comment">/* 关闭低功耗 						*/</span></span><br><span class="line">icm20608_write_reg(ICM20_FIFO_EN, <span class="number">0x00</span>);		<span class="comment">/* 关闭FIFO						*/</span></span><br></pre></td></tr></table></figure>
<h3><span id="2-2-2-shu-ju-ji-cun-qi">2.2.2 数据寄存器</span><a href="#2-2-2-shu-ju-ji-cun-qi" class="header-anchor">#</a></h3><p>数据寄存器0x3b<del>0x48表示加速度和陀螺仪数据，可以看到该传感器的寄存器地址都是单字节，ADC精度16bit,因此需要2个寄存器来表示一个轴的坐标数据。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/28.png" alt="image"><br>0x3b-0x40表示加速度计3轴数据。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/29.png" alt="image"><br>0x42 温度数据<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/30.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/31.png" alt="image"><br>0x43</del>0x48陀螺仪3轴数据。</p>
<h3><span id="2-2-3-who-am-i-ji-cun-qi">2.2.3 WHO_AM_I寄存器</span><a href="#2-2-3-who-am-i-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/32.png" alt="image"><br>寄存器表示设备ID,默认0xAF.</p>
<h3><span id="2-2-4-pwr-mgmt-1-x2f-pwr-mgmt-2-ji-cun-qi">2.2.4 PWR_MGMT_1&#x2F;PWR_MGMT_2寄存器</span><a href="#2-2-4-pwr-mgmt-1-x2f-pwr-mgmt-2-ji-cun-qi" class="header-anchor">#</a></h3><p>电源管理模式寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/33.png" alt="image"><br>可以看到bit6默认是一个sleep mode, bit7是复位信号，复位后，默认bit6会变成1，进入睡眠模式。Bit4 陀螺仪待机，bit3关闭温度传感器等等都不要开启，设置成0，bit[2:0]时钟选择自动。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/34.png" alt="image"><br>可以看到设置成0，6轴数据全使能</p>
<p>复位初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_1			0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_WHO_AM_I 				0x75</span></span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_1, <span class="number">0x80</span>);		<span class="comment">/* 复位，复位后为0x40,睡眠模式 			*/</span></span><br><span class="line">delayms(<span class="number">50</span>);</span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_1, <span class="number">0x01</span>);		<span class="comment">/* 关闭睡眠，自动选择时钟 					*/</span></span><br><span class="line">delayms(<span class="number">50</span>);</span><br><span class="line">regvalue = icm20608_read_reg(ICM20_WHO_AM_I);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;icm20608 id = %#X\r\n&quot;</span>, regvalue);</span><br></pre></td></tr></table></figure>

<h1><span id="2-3-dai-ma-jie-xi">2.3 代码解析</span><a href="#2-3-dai-ma-jie-xi" class="header-anchor">#</a></h1><p>icm20608.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ICM20608寄存器 </span></span><br><span class="line"><span class="comment"> *复位后所有寄存器地址都为0，除了</span></span><br><span class="line"><span class="comment"> *Register 107(0X6B) Power Management 1 	= 0x40</span></span><br><span class="line"><span class="comment"> *Register 117(0X75) WHO_AM_I 				= 0xAF或0xAE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 陀螺仪和加速度自测(出产时设置，用于与用户的自检输出值比较） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_GYRO		0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_GYRO		0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_GYRO		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_ACCEL		0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_ACCEL		0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_ACCEL		0x0F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRH			0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRL			0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRH			0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRL			0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRH			0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRL			0x18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SMPLRT_DIV			0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_CONFIG				0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_CONFIG			0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG			0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG2			0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_LP_MODE_CFG			0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_WOM_THR			0x1F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_EN				0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FSYNC_INT				0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_PIN_CFG			0x37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_ENABLE			0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_STATUS			0x3A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加速度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_H			0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_L			0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_H			0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_L			0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_H			0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_L			0x40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 温度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_H			0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_L			0x42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_H			0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_L			0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_H			0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_L			0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_H			0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_L			0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SIGNAL_PATH_RESET		0x68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_INTEL_CTRL 		0x69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_USER_CTRL				0x6A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_1			0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_2			0x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTH			0x72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTL			0x73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_R_W				0x74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_WHO_AM_I 				0x75</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加速度静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_H			0x77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_L			0x78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_H			0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_L			0x7B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_H			0x7D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_L 			0x7E</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ICM20608结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev_struc</span> &#123;</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_adc;		<span class="comment">/* 陀螺仪X轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_y_adc;		<span class="comment">/* 陀螺仪Y轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_z_adc;		<span class="comment">/* 陀螺仪Z轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_adc;		<span class="comment">/* 加速度计X轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_y_adc;		<span class="comment">/* 加速度计Y轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_z_adc;		<span class="comment">/* 加速度计Z轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_adc;		<span class="comment">/* 温度原始值 				*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面是计算得到的实际值，扩大100倍 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_act;		<span class="comment">/* 陀螺仪X轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_y_act;		<span class="comment">/* 陀螺仪Y轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_z_act;		<span class="comment">/* 陀螺仪Z轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_act;		<span class="comment">/* 加速度计X轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_y_act;		<span class="comment">/* 加速度计Y轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_z_act;		<span class="comment">/* 加速度计Z轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_act;		<span class="comment">/* 温度实际值 				*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev_struc</span> <span class="title">icm20608_dev</span>;</span>	<span class="comment">/* icm20608设备 */</span></span><br></pre></td></tr></table></figure>
<p><code>icm20608.h</code>定义了该模块的6轴数据寄存器地址和值。<br> 连续顺序读写模块：前一个字节得写入寄存器地址，然后每次突发读取1字节数据，注意：这里不用每次都发送寄存器地址，顺序访问时，地址自动增长，即可顺序依次访问寄存器。如：向<code>0x00~0x05</code>地址依次发送<code>6 byte</code>数据，<code>icm20608_read_len(0x00, buf, 6)</code>;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">icm20608_read_len</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;  </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址，只有低7位有效,</span></span><br><span class="line"><span class="comment">	 * 寄存器地址最高位是读/写标志位读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	reg |= <span class="number">0x80</span>; </span><br><span class="line">	ICM20608_CSN(<span class="number">0</span>);               				<span class="comment">/* 使能SPI传输	 		*/</span></span><br><span class="line">	spich0_readwrite_byte(ECSPI3, reg);			<span class="comment">/* 发送寄存器地址  		*/</span>   	   </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)					<span class="comment">/* 顺序读取寄存器的值 			*/</span></span><br><span class="line">		buf[i] = spich0_readwrite_byte(ECSPI3, <span class="number">0XFF</span>);	</span><br><span class="line">	ICM20608_CSN(<span class="number">1</span>);                			<span class="comment">/* 禁止SPI传输 			*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>icm20608_gyro_scaleget()</code>和<code>icm20608_accel_scaleget()</code>是获取陀螺仪和加速度计的最小单位：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">icm20608_gyro_scaleget</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">	<span class="type">float</span> gyroscale;</span><br><span class="line">	data = (icm20608_read_reg(ICM20_GYRO_CONFIG) &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0X3</span>;</span><br><span class="line">	<span class="keyword">switch</span>(data) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">			gyroscale = <span class="number">131</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			gyroscale = <span class="number">65.5</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			gyroscale = <span class="number">32.8</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			gyroscale = <span class="number">16.4</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gyroscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 获取加速度计的分辨率</span></span><br><span class="line"><span class="comment"> * @param		: 无</span></span><br><span class="line"><span class="comment"> * @return		: 获取到的分辨率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">icm20608_accel_scaleget</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> accelscale;</span><br><span class="line">	data = (icm20608_read_reg(ICM20_ACCEL_CONFIG) &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0X3</span>;</span><br><span class="line">	<span class="keyword">switch</span>(data) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">			accelscale = <span class="number">16384</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			accelscale = <span class="number">8192</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			accelscale = <span class="number">4096</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			accelscale = <span class="number">2048</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> accelscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 读取ICM20608的加速度、陀螺仪和温度原始值</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_getdata</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">float</span> gyroscale;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> accescale;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">	icm20608_read_len(ICM20_ACCEL_XOUT_H, data, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">	gyroscale = icm20608_gyro_scaleget();</span><br><span class="line">	accescale = icm20608_accel_scaleget();</span><br><span class="line"></span><br><span class="line">	icm20608_dev.accel_x_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">1</span>]);</span><br><span class="line">	icm20608_dev.accel_y_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">3</span>]);</span><br><span class="line">	icm20608_dev.accel_z_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">5</span>]);</span><br><span class="line">	icm20608_dev.temp_adc    = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">7</span>]);</span><br><span class="line">	icm20608_dev.gyro_x_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">8</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">9</span>]);</span><br><span class="line">	icm20608_dev.gyro_y_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">10</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">11</span>]);</span><br><span class="line">	icm20608_dev.gyro_z_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">13</span>]);</span><br><span class="line">	<span class="comment">/* 计算实际值 */</span></span><br><span class="line">	icm20608_dev.gyro_x_act = ((<span class="type">float</span>)(icm20608_dev.gyro_x_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line">	icm20608_dev.gyro_y_act = ((<span class="type">float</span>)(icm20608_dev.gyro_y_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line">	icm20608_dev.gyro_z_act = ((<span class="type">float</span>)(icm20608_dev.gyro_z_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	icm20608_dev.accel_x_act = ((<span class="type">float</span>)(icm20608_dev.accel_x_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line">	icm20608_dev.accel_y_act = ((<span class="type">float</span>)(icm20608_dev.accel_y_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line">	icm20608_dev.accel_z_act = ((<span class="type">float</span>)(icm20608_dev.accel_z_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	icm20608_dev.temp_act = (((<span class="type">float</span>)(icm20608_dev.temp_adc) - <span class="number">25</span> ) / <span class="number">326.8</span> + <span class="number">25</span>) * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于前面设置的陀螺仪和加速度计量程都是拉满的设置的<code>0x18</code>，因此<code>gyroscale</code>读出来就是对应<code>16.4</code>（最小单位），<code>accescale</code>读出来就是对应<code>2048</code>（最小单位）<br>然后读出<code>14 byte</code>数据，组装成short类型数据，16位ADC, 一轴数据刚好16位数据。最后转成人眼直观的实际的陀螺仪和加速度计数据，放大了100倍，放大一百倍目的是为了能够将小数的部分也能记录下来。<br>以陀螺仪为例：量程位<code>+-2000</code>时，换算出16.4为<code>1°</code>。同理以加速度计为例：量程为<code>+-16</code>是，换算出<code>2048</code>为1g。</p>
<p>可以看到用到了浮点运算，那么IMX6ULL属于armv7,支持硬件浮点运算：执行浮点运算前调用<code>imx6ul_hardfpu_enable()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 使能I.MX6U的硬件NEON和FPU</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">imx6ul_hardfpu_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> cpacr;</span><br><span class="line">	<span class="type">uint32_t</span> fpexc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使能NEON和FPU */</span></span><br><span class="line">	cpacr = __get_CPACR();</span><br><span class="line">	cpacr = (cpacr &amp; ~(CPACR_ASEDIS_Msk | CPACR_D32DIS_Msk))</span><br><span class="line">		   |  (<span class="number">3UL</span> &lt;&lt; CPACR_cp10_Pos) | (<span class="number">3UL</span> &lt;&lt; CPACR_cp11_Pos);</span><br><span class="line">	__set_CPACR(cpacr);</span><br><span class="line">	fpexc = __get_FPEXC();</span><br><span class="line">	fpexc |= <span class="number">0x40000000</span>UL;</span><br><span class="line">	__set_FPEXC(fpexc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开<code>Cortex-A7 MPCore Technical Reference Manual</code>的<code>4.3.34 Non-Secure Access Control Register</code>介绍：开启硬件NEON和FPU<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/35.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/36.png" alt="image"><br>打开<code>ARM®Architecture Reference Manual ARMv7-A and ARMv7-R edition</code>介绍FPEXC寄存器， bit30置1，使能浮点运算<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/37.png" alt="image"></p>
<p>打开IM6ULL 参考手册：可见IMX6U支持浮点单元：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/38.png" alt="image"><br>编译选项开启硬件浮点编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(COBJS)</span> : obj/%.o : %.c</span><br><span class="line">		`<span class="variable">$(CC)</span> -Wall **-march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard -Wa,-mimplicit-it=thumb** -nostdlib -fno-builtin -c -O2  <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span>`</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-1-ce-shi-xiao-guo">2.3.1 测试效果</span><a href="#2-3-1-ce-shi-xiao-guo" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 指定的位置显示小数数据,比如5123，显示为51.23</span></span><br><span class="line"><span class="comment"> * @param - x	: X轴位置</span></span><br><span class="line"><span class="comment"> * @param - y 	: Y轴位置</span></span><br><span class="line"><span class="comment"> * @param - size: 字体大小</span></span><br><span class="line"><span class="comment"> * @param - num : 要显示的数据，实际小数扩大100倍，</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decimals_display</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> x, <span class="type">unsigned</span> <span class="type">short</span> y, <span class="type">unsigned</span> <span class="type">char</span> size, <span class="type">signed</span> <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> integ; 	<span class="comment">/* 整数部分 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> fract;	<span class="comment">/* 小数部分 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> uncomptemp = num; </span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">		uncomptemp = -uncomptemp;</span><br><span class="line">	integ = uncomptemp / <span class="number">100</span>;</span><br><span class="line">	fract = uncomptemp % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">sprintf</span>(buf, <span class="string">&quot;-%d.%d&quot;</span>, integ, fract);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d.%d&quot;</span>, integ, fract);</span><br><span class="line">	lcd_fill(x, y, x + <span class="number">60</span>, y + size, tftlcd_dev.backcolor);</span><br><span class="line">	lcd_show_string(x, y, <span class="number">60</span>, size, size, buf); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/39.png" alt="image"><br>静止时，有一个z方向的加速度2048，也就是1g,刚好时重力加速度。静止时，陀螺仪几乎没有角速度，因此3轴数据都几乎为0°。</p>
<p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/40.png" alt="image"><br>左右晃动时，陀螺仪数据明显增加。</p>
]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>ini_parse配置解析功能移植</title>
    <url>/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-ini-parse-yi-zhi">1 ini_parse移植</a><ul>
<li><a href="#1-1-xia-zai-ini-jie-xi-yuan-ma">1.1 下载ini解析源码</a></li>
<li><a href="#1-2-shi-yong-ini-parse-gong-neng">1.2 使用ini_parse功能</a><ul>
<li><a href="#1-2-1-zi-ding-yi-ini-wen-jian">1.2.1 自定义ini文件</a></li>
<li><a href="#1-2-2-zhi-chi-yu-fa-jian-ce">1.2.2 支持语法检测</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-minini-yi-zhi-shi-yong">2 minIni移植使用</a><ul>
<li><a href="#2-1-xia-zai-minini">2.1 下载minIni</a></li>
<li><a href="#2-2-te-zheng">2.2 特征</a></li>
<li><a href="#2-3-ini-wen-jian-yu-fa">2.3 INI 文件语法</a></li>
<li><a href="#2-4-minini-zhi-chi-wen-jian-xi-tong">2.4 minIni支持文件系统</a></li>
<li><a href="#2-5-minini-de-api-jie-shao">2.5 minIni的API介绍</a><ul>
<li><a href="#2-5-1-ini-gets">2.5.1 ini_gets()</a><ul>
<li><a href="#2-5-1-1-getkeystring">2.5.1.1 getkeystring</a></li>
</ul>
</li>
<li><a href="#2-5-2-ini-getl">2.5.2 ini_getl()</a></li>
<li><a href="#2-5-3-ini-puts">2.5.3 ini_puts()</a></li>
<li><a href="#2-5-4-ini-putl">2.5.4 ini_putl()</a></li>
<li><a href="#2-5-5-section-key-enumeration">2.5.5 section&#x2F;key enumeration</a></li>
<li><a href="#2-5-6-section-key-cun-zai-xing-jian-cha">2.5.6 section&#x2F;key存在性检查</a></li>
<li><a href="#2-5-7-pei-zhi-wen-jian-yue-du-da-yin">2.5.7 配置文件阅读打印</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-ini-parse-yi-zhi">1 ini_parse移植</span><a href="#1-ini-parse-yi-zhi" class="header-anchor">#</a></h1><h2><span id="1-1-xia-zai-ini-jie-xi-yuan-ma">1.1 下载ini解析源码</span><a href="#1-1-xia-zai-ini-jie-xi-yuan-ma" class="header-anchor">#</a></h2><p>源码的github地址<a href="https://github.com/benhoyt/inih">https://github.com/benhoyt/ini</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/benhoyt/inih.git</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/1.png" alt="img"></p>
<h2><span id="1-2-shi-yong-ini-parse-gong-neng">1.2 使用ini_parse功能</span><a href="#1-2-shi-yong-ini-parse-gong-neng" class="header-anchor">#</a></h2><p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/2.png" alt="img"></p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/3.png" alt="img"></p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/4.png" alt="img"></p>
<p>可以看到核心就是一个ini_parse函数。用户自定义一个callback函数去解析自己的配置ini。测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ini.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SAMPLE_INI_CFG_S</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> bus_id;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">char</span> name2[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> bus_id2;</span><br><span class="line">        <span class="type">int</span> age2;</span><br><span class="line">&#125; SAMPLE_INI_CFG_S;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_handler</span><span class="params">(<span class="type">void</span> *user, <span class="type">const</span> <span class="type">char</span> *section, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">        SAMPLE_INI_CFG_S *cfg = (SAMPLE_INI_CFG_S *)user;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section, <span class="string">&quot;person1&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;name&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">strcpy</span>(cfg-&gt;name, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;bus_id&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        cfg-&gt;bus_id = atoi(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;age&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        cfg-&gt;age = atoi(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* unknown section/name */</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section, <span class="string">&quot;person2&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;name&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">strcpy</span>(cfg-&gt;name2, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;bus_id&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        cfg-&gt;bus_id2 = atoi(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;age&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        cfg-&gt;age2 = atoi(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">/* unknown section/name */</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* unknown section/name */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">        SAMPLE_INI_CFG_S ini_cfg;</span><br><span class="line">        <span class="type">int</span> ret = ini_parse(<span class="string">&quot;./sensor_cfg.ini&quot;</span>, parse_handler, &amp;ini_cfg);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Parse err in %d line.\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Parse incomplete, use default cfg ./sensor_cfg.ini\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s, %d, %d\n&quot;</span>, ini_cfg.name, ini_cfg.bus_id, ini_cfg.age);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s, %d, %d\n&quot;</span>, ini_cfg.name2, ini_cfg.bus_id2, ini_cfg.age2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-1-zi-ding-yi-ini-wen-jian">1.2.1 自定义ini文件</span><a href="#1-2-1-zi-ding-yi-ini-wen-jian" class="header-anchor">#</a></h3><p>ini配置文件sensor_cfg.ini如下：</p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/5.png" alt="img"></p>
<p><code>gcc test.c ini.c</code>。我的callback定义是<code>parse_handler</code>，从ini中解析section，每个section会调用一次callback，解析出所有的section。</p>
<p>运行代码:</p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/6.png" alt="img"></p>
<h3><span id="1-2-2-zhi-chi-yu-fa-jian-ce">1.2.2 支持语法检测</span><a href="#1-2-2-zhi-chi-yu-fa-jian-ce" class="header-anchor">#</a></h3><p>ini_parse还支持语法检测。但ini写的不和语法规范会报错。手工制造ini语法错误，测试结果如下：</p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/7.png" alt="img"></p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/8.png" alt="img"></p>
<h1><span id="2-minini-yi-zhi-shi-yong">2 minIni移植使用</span><a href="#2-minini-yi-zhi-shi-yong" class="header-anchor">#</a></h1><p>MiniINI 是一个用来解析 INI&#x2F;CFG 配置文件的 C++ 库，主要特点是可移植性、性能和小体积。支持上千种 INI 格式配置，易用简单。</p>
<h2><span id="2-1-xia-zai-minini">2.1 下载minIni</span><a href="#2-1-xia-zai-minini" class="header-anchor">#</a></h2><p><a href="https://github.com/compuphase/minIni">GitHub - compuphase&#x2F;minIni: A small and portable INI file library with read&#x2F;write support</a></p>
<h2><span id="2-2-te-zheng">2.2 特征</span><a href="#2-2-te-zheng" class="header-anchor">#</a></h2><ul>
<li>minIni 支持读取senction外部的key，因此它支持不使用section的配置文件（但在其他方面与 INI 文件兼容）。</li>
<li>可以使用冒号分隔键和值;冒号等价于等号。也就是说，字符串“Name： Value”和“Name&#x3D;Value”具有相同的含义。</li>
<li>minIni 不需要标准 C&#x2F;C++ 库中的 文件 I&#x2F;O 函数，且允许通过宏配置要选择文件 I&#x2F;O 接口。</li>
<li>哈希字符 （“#”） 是分号开始注释的替代方法。允许尾随注释（即在一行上的键&#x2F;值对后面）。</li>
<li>key名称和val周围的前导和尾随空格将被忽略。</li>
<li>当写入包含注释字符（“;”或“#”）的值时，该值将自动放在双引号之间;读取值时，将删除这些引号。当设置中出现双引号本身时，这些字符将被转义。</li>
<li>支持section和key枚举。</li>
<li>您可以选择设置 minIni 将使用的行终止符（对于文本文件）。（这是编译时设置，而不是运行时设置)。</li>
<li>由于写入速度远低于闪存（SD&#x2F;MMC 卡、U 盘）中的读取速度，因此 minIni 以双倍“文件读取”为代价将“文件写入”降至最低。</li>
<li>内存占用是确定性的。没有动态内存分配。</li>
</ul>
<h2><span id="2-3-ini-wen-jian-yu-fa">2.3 INI 文件语法</span><a href="#2-3-ini-wen-jian-yu-fa" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Network]  <span class="comment">#section</span></span><br><span class="line">hostname=My Computer  <span class="comment">#key = val</span></span><br><span class="line">address=dhcp</span><br><span class="line">dns = <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-4-minini-zhi-chi-wen-jian-xi-tong">2.4 minIni支持文件系统</span><a href="#2-4-minini-zhi-chi-wen-jian-xi-tong" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INI_FILETYPE                  FILE*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_openread(filename,file)   ((*(file) = fopen((filename),<span class="string">&quot;r&quot;</span>)) != NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_openwrite(filename,file)  ((*(file) = fopen((filename),<span class="string">&quot;w&quot;</span>)) != NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_close(file)               (fclose(*(file)) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_read(buffer,size,file)    (fgets((buffer),(size),*(file)) != NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_write(buffer,file)        (fputs((buffer),*(file)) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_rename(source,dest)       (rename((source), (dest)) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_remove(filename)          (remove(filename) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INI_FILEPOS                   fpos_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_tell(file,pos)            (fgetpos(*(file), (pos)) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_seek(file,pos)            (fsetpos(*(file), (pos)) == 0)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-5-minini-de-api-jie-shao">2.5 minIni的API介绍</span><a href="#2-5-minini-de-api-jie-shao" class="header-anchor">#</a></h2><p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/9.png" alt="image-20240602144015881"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minIni.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sizearray(a)  (sizeof(a) / sizeof((a)[0]))</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> inifile[] = <span class="string">&quot;example.ini&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> section[<span class="number">50</span>];</span><br><span class="line">    <span class="type">long</span> n;</span><br><span class="line"></span><br><span class="line">    n = ini_gets(<span class="string">&quot;Network&quot;</span>, <span class="string">&quot;address&quot;</span>, <span class="string">&quot;dummy&quot;</span>, str, sizearray(str), inifile);</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Network/address=%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    n = ini_getl(<span class="string">&quot;Network&quot;</span>, <span class="string">&quot;timeout&quot;</span>, <span class="number">-1</span>, inifile);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Network/timeout=%ld\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>example.ini如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Network]</span><br><span class="line">hostname=My Computer</span><br><span class="line">address=dhcp</span><br><span class="line">dns=<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">timeout=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Network/address=dhcp</span><br><span class="line">Network/timeout=10</span><br></pre></td></tr></table></figure>

<h3><span id="2-5-1-ini-gets">2.5.1 ini_gets()</span><a href="#2-5-1-ini-gets" class="header-anchor">#</a></h3><p>获取字符串类型的值.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>   <span class="title function_">ini_gets</span><span class="params">(<span class="type">const</span> mTCHAR *Section, <span class="type">const</span> mTCHAR *Key, <span class="type">const</span> mTCHAR *DefValue, mTCHAR *Buffer, <span class="type">int</span> BufferSize, <span class="type">const</span> mTCHAR *Filename)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数 1 是 Section;</span></span><br><span class="line"><span class="comment">参数 2 是 Key;</span></span><br><span class="line"><span class="comment">参数 3 是获取不到值时的默认值;</span></span><br><span class="line"><span class="comment">参数 4 是用于保存目标键值的 Buffer;</span></span><br><span class="line"><span class="comment">参数 5 是 Buffer 的长度;</span></span><br><span class="line"><span class="comment">参数 6 是 INI 文件的路径;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/10.png" alt="image-20240602144722018"></p>
<p>先打开文件，然后用 <code>getkeystring() </code>找到目标键值，最后拷贝给调用者。</p>
<h4><span id="2-5-1-1-getkeystring">2.5.1.1 getkeystring</span><a href="#2-5-1-1-getkeystring" class="header-anchor">#</a></h4><p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/11.png" alt="image-20240602150058567"></p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/12.png" alt="image-20240602145619533"></p>
<ol>
<li>用 fgets 进行逐行读取，用 strrchr 找到包含 ‘[‘ 和 ‘]’ 的行，然后再用 strncasecmp 找到目标 Section 所在的行。</li>
<li>继续用 fgets 进行逐行读取，用 strrchr 找到包含 ‘&#x3D;’ 的行，然后再用 strncasecmp 找到目标 Key 所在的行。</li>
<li>用 strncpy 将目标 Key 的值拷贝给调用者。</li>
</ol>
<p>大致就是这3个关键步骤，当然还有很多其他异常处理，语法检测和边界判断的逻辑，这里不做展示。</p>
<h3><span id="2-5-2-ini-getl">2.5.2 ini_getl()</span><a href="#2-5-2-ini-getl" class="header-anchor">#</a></h3><p><code>ini_getl() </code>用于获取整型类型的值，也是间接调用<code>int_gets</code>， 最后将字符串转换成数字。</p>
<h3><span id="2-5-3-ini-puts">2.5.3 ini_puts()</span><a href="#2-5-3-ini-puts" class="header-anchor">#</a></h3><p>写出参数到ini,保存到ini。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** ini_puts()</span></span><br><span class="line"><span class="comment"> * \param Section     the name of the section to write the string in</span></span><br><span class="line"><span class="comment"> * \param Key         the name of the entry to write, or NULL to erase all keys in the section</span></span><br><span class="line"><span class="comment"> * \param Value       a pointer to the buffer the string, or NULL to erase the key</span></span><br><span class="line"><span class="comment"> * \param Filename    the name and full path of the .ini file to write to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return            1 if successful, otherwise 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ini_puts</span><span class="params">(<span class="type">const</span> TCHAR *Section, <span class="type">const</span> TCHAR *Key, <span class="type">const</span> TCHAR *Value, <span class="type">const</span> TCHAR *Filename)</span></span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="title function_">ini_putl</span><span class="params">(<span class="string">&quot;second&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">20</span>, inifile)</span>;</span><br><span class="line">n = ini_puts(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;alt&quot;</span>, <span class="literal">NULL</span>, inifile);<span class="comment">//当val等于NULL表示删除该key</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-4-ini-putl">2.5.4 ini_putl()</span><a href="#2-5-4-ini-putl" class="header-anchor">#</a></h3><p><code>ini_putl() </code>用于写出整型类型的值，也是间接调用<code>int_puts</code>， 将数字转换成字符串,然后保存字符串到ini。</p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/13.png" alt="image-20240602171648913"></p>
<h3><span id="2-5-5-section-x2f-key-enumeration">2.5.5 section&#x2F;key enumeration</span><a href="#2-5-5-section-x2f-key-enumeration" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4. Section/key enumeration, file structure follows\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>; ini_getsection(s, section, sizearray(section), inifile) &gt; <span class="number">0</span>; s++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;    [%s]\n&quot;</span>, section);</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; ini_getkey(section, k, str, sizearray(str), inifile) &gt; <span class="number">0</span>; k++) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;\t%s\n&quot;</span>, str);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;<span class="comment">//对section和key进行枚举</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-6-section-x2f-key-cun-zai-xing-jian-cha">2.5.6 section&#x2F;key存在性检查</span><a href="#2-5-6-section-x2f-key-cun-zai-xing-jian-cha" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* section/key presence check */</span></span><br><span class="line">assert(ini_hassection(<span class="string">&quot;first&quot;</span>, inifile));<span class="comment">//检查是否有first 段</span></span><br><span class="line">assert(!ini_hassection(<span class="string">&quot;fourth&quot;</span>, inifile));</span><br><span class="line">assert(ini_haskey(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;val&quot;</span>, inifile));<span class="comment">//检查first段是否有val这个key</span></span><br><span class="line">assert(!ini_haskey(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;test&quot;</span>, inifile));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;5. checking presence of sections and keys passed\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="2-5-7-pei-zhi-wen-jian-yue-du-da-yin">2.5.7 配置文件阅读打印</span><a href="#2-5-7-pei-zhi-wen-jian-yue-du-da-yin" class="header-anchor">#</a></h3><p><code>ini_browse</code>用来打印出每个段的每个key的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Callback</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *section, <span class="type">const</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">void</span> *userdata)</span> &#123;</span><br><span class="line">	(<span class="type">void</span>)userdata; <span class="comment">/* this parameter is not used in this example */</span></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;    [%s]\t%s=%s\n&quot;</span>, section, key, value);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* browsing through the file */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;6. browse through all settings, file field list follows\n&quot;</span>);</span><br><span class="line">ini_browse(Callback, <span class="literal">NULL</span>, inifile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (access(filename, F_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">&quot;open %s fail&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/14.png" alt="image-20240602173647362"></p>
]]></content>
      <tags>
        <tag>开源插件</tag>
        <tag>ini解析</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull裸机-定时器</title>
    <url>/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-rtc-ding-shi-qi">1 RTC定时器</a><ul>
<li><a href="#1-1-rtc-ding-shi-qi-jie-shao">1.1 RTC定时器介绍</a></li>
<li><a href="#1-2-rtc-ding-shi-qi-yuan-li">1.2 RTC定时器原理</a></li>
<li><a href="#1-3-rtc-ding-shi-qi-ji-cun-qi">1.3 RTC定时器寄存器</a></li>
<li><a href="#1-4-rtc-luo-ji-yuan-ma-zhan-shi">1.4 RTC裸机源码展示</a></li>
</ul>
</li>
<li><a href="#2-pwm-ding-shi-qi">2 PWM定时器</a><ul>
<li><a href="#2-1-pwm-ding-shi-qi-jie-shao">2.1 pwm定时器介绍</a></li>
<li><a href="#2-2-pwm-kong-zhi-qi">2.2 PWM控制器</a><ul>
<li><a href="#2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi">2.2.1 PWMx_PWMPR寄存器-周期设置</a></li>
<li><a href="#2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi">2.2.2 PWMx_PWMSAR寄存器-占空比</a></li>
<li><a href="#2-2-3-pwmcr-kong-zhi-ji-cun-qi">2.2.3 PWMCR 控制寄存器</a></li>
<li><a href="#2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi">2.2.4 PWM1_PWMIR中断控制寄存器</a></li>
<li><a href="#2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi">2.2.5 PWM1_PWMSR 状态寄存器</a></li>
</ul>
</li>
<li><a href="#2-3-ce-shi">2.3 测试</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-rtc-ding-shi-qi">1 RTC定时器</span><a href="#1-rtc-ding-shi-qi" class="header-anchor">#</a></h1><h2><span id="1-1-rtc-ding-shi-qi-jie-shao">1.1 RTC定时器介绍</span><a href="#1-1-rtc-ding-shi-qi-jie-shao" class="header-anchor">#</a></h2><p>RTC定时器被叫做实时时钟（real time clock）。 CPU内部有很多定时器，像看门狗WDT，PWM定时器，高精度定时器Timer等等, 只在“启动”即“通电时”运行，断电时停止。当然，如果时钟不能连续跟踪时间，则必须手动设置。那么当关机后就没办法自动计数统计时间了。<br>定时器的本质就是计数器，有向上计数，也有向下计数。RTC有一个与主机单独分离的电源，如纽扣电池（备用电池），即使主机电源关闭，它也保持计数定时功能。这也是为什么我们手机关机后时间还能保持准确。再比如以前的老诺基亚手机，拆掉电池就时间不准了，因为rtc电源被切断了，无法在计数，RTC定时器的计数器会被清0，需要手动设置当前时间。<br>RTC一般都是用纽扣电池给外部晶振和电路供电。<br>!<img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/1.png" alt="image"></p>
<h2><span id="1-2-rtc-ding-shi-qi-yuan-li">1.2 RTC定时器原理</span><a href="#1-2-rtc-ding-shi-qi-yuan-li" class="header-anchor">#</a></h2><p>以IMX6U芯片的RTC定时器为例，I.MX6U 内部也有 个 RTC 模块，但是不叫作“RTC”，而是叫做“SNVS”。<br>RTC模块结构图如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/2.png" alt="image"><br>SNVS 分为两个子模块：SNVS_HP 和 SNVS_LP，也就是高功耗域(SNVS_HP)和低功耗域(SNVS_LP)，这两个域的电源来源如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SNVS_LP：专用的 always-powered-on 电源域，系统主电源和备用电源都可以为其供电。</span><br><span class="line">SNVS_HP：系统(芯片)电源。 </span><br></pre></td></tr></table></figure>
<p>系统主电源断电以后 SNVS_HP 也会断电，但是在备用电源支持下，SNVS_LP 是不会断电的，而且 SNVS_LP 是和芯片复位隔离开的，因此 SNVS_LP 相关的寄存器的值会一直保存着, 也就是low Power Domain是不受系统电源影响。<br>上图各个序号含义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> VDD_HIGH_IN 是系统(芯片)主电源，这个电源会同时供给给 SNVS_HP 和 SNVS_LP。</span><br><span class="line"><span class="number">2.</span> VDD_SNVS_IN 是纽扣电池供电的电源，这个电源只会供给给 SNVS_LP，保证在系统主电源 VDD_HIGH_IN 掉电以后 SNVS_LP 会继续运行。</span><br><span class="line"><span class="number">3.</span> SNVS_HP 部分。</span><br><span class="line"><span class="number">4.</span> SNVS_LP 部分，此部分有个 SRTC，这个就是要使用的 RTC。</span><br></pre></td></tr></table></figure>
<p>SRTC 需要外界提供一个 32.768KHz 的时钟，I.MX6U-ALPHA 核心板上的 32.768KHz 的晶振就是提供这个时钟的。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/3.png" alt="image"></p>
<h2><span id="1-3-rtc-ding-shi-qi-ji-cun-qi">1.3 RTC定时器寄存器</span><a href="#1-3-rtc-ding-shi-qi-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SNVS_SRTCMR[<span class="number">14</span>:<span class="number">0</span>]代表SRTC计数器的高<span class="number">15</span>位</span><br><span class="line">SNVS_SRTCLR[<span class="number">31</span>:<span class="number">15</span>]代表SRTC计数器的低<span class="number">17</span>位</span><br><span class="line">注意：是以 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日<span class="number">0</span>点<span class="number">0</span>分<span class="number">0</span>秒为起点，加上经过的总秒数即可得到现在的时间点。 </span><br><span class="line">SNVS_HPCOMR[<span class="number">31</span>], NPSWA_EN位，非特权软件访问控制位，如果非特权软件要访问 SNVS 的话此位必须为 <span class="number">1</span>。</span><br><span class="line">SNVS_LPCR[<span class="number">0</span>], SRTC_ENV位，使能 STC 计数器。</span><br></pre></td></tr></table></figure>
<h2><span id="1-4-rtc-luo-ji-yuan-ma-zhan-shi">1.4 RTC裸机源码展示</span><a href="#1-4-rtc-luo-ji-yuan-ma-zhan-shi" class="header-anchor">#</a></h2><p>NXP 官方 SDK 包是针对 I.MX6ULL 编写的，因此文件 MCIMX6Y2.h中的结构体 SNVS_Type 里面的寄存器是不全的，我们需要在其中加入本章实验所需要的寄存器，修改 SNVS_Type 为如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup SNVS_Peripheral_Access_Layer SNVS Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** SNVS - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPLR;                              <span class="comment">/**&lt; SNVS_HP Lock register, offset: 0x0 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPCOMR;                            <span class="comment">/**&lt; SNVS_HP Command register, offset: 0x4 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPCR;                              <span class="comment">/**&lt; SNVS_HP Control register, offset: 0x8 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSICR;                              <span class="comment">/**&lt; SNVS_HP Control register, offset: 0x8 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSVCR;   </span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSR;   </span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSVSR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPHACIVR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPHACR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPRTCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPRTCLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPTAMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPTALR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPMKCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSVCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTGFCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTDCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSRTCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSRTCLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTAR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSMCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSMCLR;</span><br><span class="line">&#125;SNVS_Type;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BSP_RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSP_RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ul.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 相关宏定义 */</span>	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_DAY 		(86400) <span class="comment">/* 一天86400秒	 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_HOUR 		(3600)	<span class="comment">/* 一个小时3600秒 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_MINUTE 	(60)	<span class="comment">/* 一分钟60秒  		 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAYS_IN_A_YEAR 			(365)	<span class="comment">/* 一年365天 			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR_RANGE_START 		(1970)	<span class="comment">/* 开始年份1970年 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR_RANGE_END 			(2099)	<span class="comment">/* 结束年份2099年 		*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时间日期结构体 */</span>	</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_datetime</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> year;  <span class="comment">/* 范围为:1970 ~ 2099 		*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> month;  <span class="comment">/* 范围为:1 ~ 12				*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> day;    <span class="comment">/* 范围为:1 ~ 31 (不同的月，天数不同).*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hour;   <span class="comment">/* 范围为:0 ~ 23 			*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> minute; <span class="comment">/* 范围为:0 ~ 59				*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> second; <span class="comment">/* 范围为:0 ~ 59				*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_disable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_coverdate_to_seconds</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_getseconds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_setdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_getdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置HPCOMR寄存器</span></span><br><span class="line"><span class="comment">     * bit[31] 1 : 允许访问SNVS寄存器，一定要置1</span></span><br><span class="line"><span class="comment">     * bit[8]  1 : 此位置1，需要签署NDA协议才能看到此位的详细说明，</span></span><br><span class="line"><span class="comment">     *             这里不置1也没问题</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SNVS-&gt;HPCOMR |= (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_datetime</span> <span class="title">rtcdate</span>;</span></span><br><span class="line">	rtcdate.year = <span class="number">2018U</span>;</span><br><span class="line">    rtcdate.month = <span class="number">12U</span>;</span><br><span class="line">    rtcdate.day = <span class="number">13U</span>;</span><br><span class="line">    rtcdate.hour = <span class="number">14U</span>;</span><br><span class="line">    rtcdate.minute = <span class="number">52</span>;</span><br><span class="line">    rtcdate.second = <span class="number">0</span>;</span><br><span class="line">	rtc_setDatetime(&amp;rtcdate); <span class="comment">//初始化时间和日期</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	rtc_enable();	<span class="comment">//使能RTC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * LPCR寄存器bit0置1，使能RTC</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">	SNVS-&gt;LPCR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;	</span><br><span class="line">	<span class="keyword">while</span>(!(SNVS-&gt;LPCR &amp; <span class="number">0X01</span>));<span class="comment">//等待使能完成</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * LPCR寄存器bit0置0，关闭RTC</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">	SNVS-&gt;LPCR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);	</span><br><span class="line">	<span class="keyword">while</span>(SNVS-&gt;LPCR &amp; <span class="number">0X01</span>);<span class="comment">//等待关闭完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 判断指定年份是否为闰年，闰年条件如下:</span></span><br><span class="line"><span class="comment"> * @param - year: 要判断的年份</span></span><br><span class="line"><span class="comment"> * @return 		: 1 是闰年，0 不是闰年</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">rtc_isleapyear</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> year)</span> &#123;	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">		value = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">			value = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			value = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 将时间转换为秒数</span></span><br><span class="line"><span class="comment"> * @param - datetime: 要转换日期和时间。</span></span><br><span class="line"><span class="comment"> * @return 			: 转换后的秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_coverdate_to_seconds</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> days = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> monthdays[] = &#123;<span class="number">0U</span>, <span class="number">0U</span>, <span class="number">31U</span>, <span class="number">59U</span>, <span class="number">90U</span>, <span class="number">120U</span>, <span class="number">151U</span>, <span class="number">181U</span>, <span class="number">212U</span>, <span class="number">243U</span>, <span class="number">273U</span>, <span class="number">304U</span>, <span class="number">334U</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1970</span>; i &lt; datetime-&gt;year; i++) &#123;</span><br><span class="line">		days += DAYS_IN_A_YEAR; 		<span class="comment">/* 平年，每年365天 */</span></span><br><span class="line">		<span class="keyword">if</span>(rtc_isleapyear(i)) days += <span class="number">1</span>;<span class="comment">/* 闰年多加一天 		*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	days += monthdays[datetime-&gt;month];</span><br><span class="line">	<span class="keyword">if</span>(rtc_isleapyear(i) &amp;&amp; (datetime-&gt;month &gt;= <span class="number">3</span>)) days += <span class="number">1</span>;<span class="comment">/* 闰年，并且当前月份大于等于3月的话加一天 */</span></span><br><span class="line"></span><br><span class="line">	days += datetime-&gt;day - <span class="number">1</span>;</span><br><span class="line">	seconds = days * SECONDS_IN_A_DAY + </span><br><span class="line">				datetime-&gt;hour * SECONDS_IN_A_HOUR +</span><br><span class="line">				datetime-&gt;minute * SECONDS_IN_A_MINUTE +</span><br><span class="line">				datetime-&gt;second;</span><br><span class="line">	<span class="keyword">return</span> seconds;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 设置时间和日期</span></span><br><span class="line"><span class="comment"> * @param - datetime: 要设置的日期和时间</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_setdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tmp = SNVS-&gt;LPCR; </span><br><span class="line">	rtc_disable();	<span class="comment">/* 设置寄存器HPRTCMR和HPRTCLR的时候一定要先关闭RTC */</span></span><br><span class="line">	<span class="comment">/* 先将时间转换为秒 */</span></span><br><span class="line">	seconds = rtc_coverdate_to_seconds(datetime);</span><br><span class="line">	SNVS-&gt;LPSRTCMR = (<span class="type">unsigned</span> <span class="type">int</span>)(seconds &gt;&gt; <span class="number">17</span>); <span class="comment">/* 设置高16位 */</span></span><br><span class="line">	SNVS-&gt;LPSRTCLR = (<span class="type">unsigned</span> <span class="type">int</span>)(seconds &lt;&lt; <span class="number">15</span>); <span class="comment">/* 设置地16位 */</span></span><br><span class="line">	<span class="comment">/* 如果此前RTC是打开的在设置完RTC时间以后需要重新打开RTC */</span></span><br><span class="line">	<span class="keyword">if</span> (tmp &amp; <span class="number">0x1</span>)</span><br><span class="line">		rtc_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 将秒数转换为时间</span></span><br><span class="line"><span class="comment"> * @param - seconds	: 要转换的秒数</span></span><br><span class="line"><span class="comment"> * @param - datetime: 转换后的日期和时间</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_convertseconds_to_datetime</span><span class="params">(u64 seconds, <span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line">    u64 x;</span><br><span class="line">    u64  secondsRemaining, days;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> daysInYear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每个月的天数       */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> daysPerMonth[] = &#123;<span class="number">0U</span>, <span class="number">31U</span>, <span class="number">28U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>&#125;;</span><br><span class="line">    secondsRemaining = seconds; <span class="comment">/* 剩余秒数初始化 */</span></span><br><span class="line">    days = secondsRemaining / SECONDS_IN_A_DAY + <span class="number">1</span>; 		<span class="comment">/* 根据秒数计算天数,加1是当前天数 */</span></span><br><span class="line">    secondsRemaining = secondsRemaining % SECONDS_IN_A_DAY; <span class="comment">/*计算天数以后剩余的秒数 */</span></span><br><span class="line">	<span class="comment">/* 计算时、分、秒 */</span></span><br><span class="line">    datetime-&gt;hour = secondsRemaining / SECONDS_IN_A_HOUR;</span><br><span class="line">    secondsRemaining = secondsRemaining % SECONDS_IN_A_HOUR;</span><br><span class="line">    datetime-&gt;minute = secondsRemaining / <span class="number">60</span>;</span><br><span class="line">    datetime-&gt;second = secondsRemaining % SECONDS_IN_A_MINUTE;</span><br><span class="line">    <span class="comment">/* 计算年 */</span></span><br><span class="line">    daysInYear = DAYS_IN_A_YEAR;</span><br><span class="line">    datetime-&gt;year = YEAR_RANGE_START;</span><br><span class="line">    <span class="keyword">while</span>(days &gt; daysInYear) &#123;</span><br><span class="line">        <span class="comment">/* 根据天数计算年 */</span></span><br><span class="line">        days -= daysInYear;</span><br><span class="line">        datetime-&gt;year++;</span><br><span class="line">        <span class="comment">/* 处理闰年 */</span></span><br><span class="line">        <span class="keyword">if</span> (!rtc_isleapyear(datetime-&gt;year))</span><br><span class="line">            daysInYear = DAYS_IN_A_YEAR;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">/*闰年，天数加一 */</span></span><br><span class="line">            daysInYear = DAYS_IN_A_YEAR + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*根据剩余的天数计算月份 */</span></span><br><span class="line">    <span class="keyword">if</span>(rtc_isleapyear(datetime-&gt;year)) <span class="comment">/* 如果是闰年的话2月加一天 */</span></span><br><span class="line">        daysPerMonth[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt;= <span class="number">12</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (days &lt;= daysPerMonth[x]) &#123;</span><br><span class="line">            datetime-&gt;month = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            days -= daysPerMonth[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    datetime-&gt;day = days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 获取RTC当前秒数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 当前秒数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_getseconds</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">	seconds = (SNVS-&gt;LPSRTCMR &lt;&lt; <span class="number">17</span>) | (SNVS-&gt;LPSRTCLR &gt;&gt; <span class="number">15</span>);</span><br><span class="line">	<span class="keyword">return</span> seconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 获取当前时间</span></span><br><span class="line"><span class="comment"> * @param - datetime: 获取到的时间，日期等参数</span></span><br><span class="line"><span class="comment"> * @return 			: 无 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_getdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line">	<span class="comment">//unsigned int seconds = 0;</span></span><br><span class="line">	u64 seconds;</span><br><span class="line">	seconds = rtc_getseconds();</span><br><span class="line">	rtc_convertseconds_to_datetime(seconds, datetime);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到RTC定时器是以秒为计时单位的，每过1s SRTC计数器的值加1。<br>首先调用<code>rtc_init</code>初始化并启动，然后调用<code>rtc_setdatetime</code>设定当前日期时间，调用<code>rtc_getdatetime</code>获取当前日期时间，期间会利用<code>rtc_convertseconds_to_datetime</code>把总秒数转换成当前的日期和时间。</p>
<h1><span id="2-pwm-ding-shi-qi">2 PWM定时器</span><a href="#2-pwm-ding-shi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-pwm-ding-shi-qi-jie-shao">2.1 pwm定时器介绍</span><a href="#2-1-pwm-ding-shi-qi-jie-shao" class="header-anchor">#</a></h2><p>imx6ull一共有 8 路 PWM 信号，每个 PWM 包含一个 16 位的计数器和一个 4 x 16 的数据 FIFO。一路框图如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">①、此部分是一个选择器，用于选择 PWM 信号的时钟源，一共有三种时钟源：ipg_clk,pg_clk_highfreq 和 ipg_clk_32k。</span><br><span class="line">②、这是一个 <span class="number">12</span> 位的分频器，可以对①中选择的时钟源进行分频。</span><br><span class="line">③、这是 PWM 的 <span class="number">16</span> 位计数器寄存器，保存着 PWM 的计数值。</span><br><span class="line">④、这是 PWM 的 <span class="number">16</span> 位周期寄存器，此寄存器用来控制 PWM 的频率。</span><br><span class="line">⑤、这是 PWM 的 <span class="number">16</span> 位采样寄存器，此寄存器用来控制 PWM 的占空比。</span><br><span class="line">⑥、此部分是 PWM 的中断信号，PWM 是提供中断功能的，如果使能了相应的中断的话就会产生中断。</span><br><span class="line">⑦、此部分是 PWM 对应的输出 IO，产生的 PWM 信号就会从对应的 IO 中输出。</span><br></pre></td></tr></table></figure>
<h2><span id="2-2-pwm-kong-zhi-qi">2.2 PWM控制器</span><a href="#2-2-pwm-kong-zhi-qi" class="header-anchor">#</a></h2><h3><span id="2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi">2.2.1 PWMx_PWMPR寄存器-周期设置</span><a href="#2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi" class="header-anchor">#</a></h3><p>PWM 的 16 位计数器是个上计数器，此计数器会从 0X0000 开始计数，直到计数值等于寄存器PWMx_PWMPR(x&#x3D;1~8)+ 1，然后计数器就会重新从0X0000 开始计数，如此往复。PWMx_PWMPR设置频率。PWM周期公式如下：<br>    PWM_FRE &#x3D; PWM_CLK &#x2F; (PERIOD + 2)<br>    也就是PWMO(Hz) &#x3D; PCLK(Hz) &#x2F; (PERIOD + 2)<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/5.png" alt="image"></p>
<p>比如当前PWM_CLK&#x3D;1MHz, 要产生1KHz的PWM，那么PERIOD &#x3D; 1000000&#x2F;1K - 2 &#x3D; 	998。,如下设置1000，即可得到PERIOD&#x3D;998，也就是1khz.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setperiod_value</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> regvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(value &lt; <span class="number">2</span>)</span><br><span class="line">		regvalue = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		regvalue = value - <span class="number">2</span>;</span><br><span class="line">	PWM1-&gt;PWMPR = (regvalue &amp; <span class="number">0XFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi">2.2.2 PWMx_PWMSAR寄存器-占空比</span><a href="#2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi" class="header-anchor">#</a></h3><p>设置Sample采样寄存器，Sample数据会写入到FIFO中。当计数器的值小于 SAMPLE 的时候输出高电平(或低电平)。当计数器值大于等于 SAMPLE，小于寄存器PWM1_PWMPR 的 PERIO 的时候输出低电平(或高电平)。<br>假如我们要设置 PWM 信号的占空比为 50%，那么就可以将 SAMPLE 设置为(PERIOD + 2) &#x2F; 2 &#x3D; 1000 &#x2F; 2&#x3D;500。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/6.png" alt="image"></p>
<p>如下设置50，即可得到sample&#x3D;500，也就是占空比50%.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backlight_dev_struc</span> &#123;</span>	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> pwm_duty;		<span class="comment">/* 占空比	*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backlight_dev_struc</span> <span class="title">backlight_dev</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setsample_value</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	PWM1-&gt;PWMSAR = (value &amp; <span class="number">0XFFFF</span>);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setduty</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> duty)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> preiod;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> sample;</span><br><span class="line">	backlight_dev.pwm_duty = duty;</span><br><span class="line">	preiod = PWM1-&gt;PWMPR + <span class="number">2</span>;</span><br><span class="line">	sample = preiod * backlight_dev.pwm_duty / <span class="number">100</span>;</span><br><span class="line">	pwm1_setsample_value(sample);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-3-pwmcr-kong-zhi-ji-cun-qi">2.2.3 PWMCR 控制寄存器</span><a href="#2-2-3-pwmcr-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/7.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FWM(bit27:<span class="number">26</span>)：FIFO 水位线，用来设置 FIFO 空余位置为多少的时候表示 FIFO 为空。</span><br><span class="line">	设置为 <span class="number">0</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">1</span> 的时候 FIFO 为空；</span><br><span class="line">	设置为 <span class="number">1</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">2</span> 的时候 FIFO 为空；</span><br><span class="line">	设置为 <span class="number">2</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">3</span> 的时候FIFO 为空；</span><br><span class="line">	设置为 <span class="number">3</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">4</span> 的时候 FIFO 为空。</span><br><span class="line">STOPEN(bit25)：此位用来设置停止模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在停止模式下PWM 不工作，为 <span class="number">1</span> 的话表示停止模式下激活 PWM。</span><br><span class="line">DOZEN(bit24)：此位用来设置休眠模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在休眠模式下PWM 不工作，为 <span class="number">1</span> 的话表示休眠模式下激活 PWM。</span><br><span class="line">WAITEN(bit23)：此位用来设置等待模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在等待模式下PWM 不工作，为 <span class="number">1</span> 的话表示等待模式下激活 PWM。</span><br><span class="line">DEGEN(bit22)：此位用来设置调试模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在调试模式下PWM 不工作，为 <span class="number">1</span> 的话表示调试模式下激活 PWM。</span><br><span class="line">BCTR(bit21)：字节交换控制位，用来控制 <span class="number">16</span> 位的数据进入 FIFO 的字节顺序。为 <span class="number">0</span> 的时候不进行字节交换，为 <span class="number">1</span> 的时候进行字节交换。</span><br><span class="line">HCRT(bit20)：半字交换控制位，用来决定从 <span class="number">32</span> 位 IP 总线接口传输来的哪个半字数据写入采样寄存器的低 <span class="number">16</span> 位中。</span><br><span class="line">POUTC(bit19:<span class="number">18</span>)：PWM 输出控制控制位，用来设置 PWM 输出模式，</span><br><span class="line">	为 <span class="number">0</span> 的时候表示PWM 先输出高电平，当计数器值和采样值相等的话就输出低电平。</span><br><span class="line">	为 <span class="number">1</span> 的时候相反，当为 <span class="number">2</span> 或者 <span class="number">3</span> 的时候 PWM 信号不输出。本章我们设置为 <span class="number">0</span>，</span><br><span class="line">	也就是一开始输出高电平，当计数器值和采样值相等的话就改为低电平，这样采样值越大高电平时间就越长，占空比就越大。</span><br><span class="line">CLKSRC(bit17:<span class="number">16</span>)：PWM 时钟源选择，</span><br><span class="line">	为 <span class="number">0</span> 的话关闭；</span><br><span class="line">	为 <span class="number">1</span> 的话选择 ipg_clk 为时钟源；</span><br><span class="line">	为 <span class="number">2</span> 的话选择 ipg_clk_highfreq 为时钟源；</span><br><span class="line">	为 <span class="number">3</span> 的话选择 ipg_clk_32k 为时钟源。本章我们设置为 <span class="number">1</span>，也就是选择 ipg_clk 为 PWM 的时钟源，因此 PWM 时钟源频率为 <span class="number">66</span>MHz。</span><br><span class="line">PRESCALER(bit15:<span class="number">4</span>)：分频值，可设置为 <span class="number">0</span>~<span class="number">4095</span>，对应着 <span class="number">1</span>~<span class="number">4096</span> 分频。</span><br><span class="line">SWR(bit3)：软件复位，向此位写 <span class="number">1</span> 就复位 PWM，此位是自清零的，当复位完成以后此位会自动清零。</span><br><span class="line">REPEAT(bit2:<span class="number">1</span>)：重复采样设置，此位用来设置 FIFO 中的每个数据能用几次。</span><br><span class="line">	可设置 <span class="number">0</span>~<span class="number">3</span>，分别表示 FIFO 中的每个数据能用 <span class="number">1</span>~<span class="number">4</span> 次。本章我们设置为 <span class="number">0</span>，即 FIFO 中的每个数据只能用一次。</span><br><span class="line">EN(bit0)：PWM 使能位，为 <span class="number">1</span> 的时候使能 PWM，为 <span class="number">0</span> 的时候关闭 PWM。</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	PWM1-&gt;PWMCR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	PWM1-&gt;PWMCR = <span class="number">0</span>;	<span class="comment">/* 寄存器先清零 */</span></span><br><span class="line">	PWM1-&gt;PWMCR |= (<span class="number">1</span> &lt;&lt; <span class="number">26</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">65</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置PWM周期为1000,那么PWM频率就是1M/1000 = 1KHz。 */</span></span><br><span class="line">	pwm1_setperiod_value(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置占空比，默认50%占空比   ,写四次是因为有4个FIFO */</span></span><br><span class="line">	backlight_dev.pwm_duty = <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		pwm1_setduty(backlight_dev.pwm_duty);	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使能FIFO空中断，设置寄存器PWMIR寄存器的bit0为1 */</span></span><br><span class="line">	PWM1-&gt;PWMIR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">	system_register_irqhandler(PWM1_IRQn, (<span class="type">system_irq_handler_t</span>)pwm1_irqhandler, <span class="literal">NULL</span>);	<span class="comment">/* 注册中断服务函数 */</span></span><br><span class="line">	GIC_EnableIRQ(PWM1_IRQn);	<span class="comment">/* 使能GIC中对应的中断 */</span></span><br><span class="line">	PWM1-&gt;PWMSR = <span class="number">0</span>;			<span class="comment">/* PWM中断状态寄存器清零 */</span></span><br><span class="line"></span><br><span class="line">	pwm1_enable();				<span class="comment">/* 使能PWM1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bit[<span class="number">27</span>:<span class="number">26</span>]	: <span class="number">01</span>  当FIFO中空余位置大于等于<span class="number">2</span>的时候FIFO空标志值位</span><br><span class="line">bit[<span class="number">25</span>]		:<span class="number">0</span>  停止模式下PWM不工作</span><br><span class="line">bit[<span class="number">24</span>]		: <span class="number">0</span>	  休眠模式下PWM不工作</span><br><span class="line">bit[<span class="number">23</span>]		: <span class="number">0</span>   等待模式下PWM不工作</span><br><span class="line">bit[<span class="number">22</span>]		: <span class="number">0</span>   调试模式下PWM不工作</span><br><span class="line">it[<span class="number">21</span>]		: <span class="number">0</span>   关闭字节交换</span><br><span class="line">bit[<span class="number">20</span>]		: <span class="number">0</span>	  关闭半字数据交换</span><br><span class="line">bit[<span class="number">19</span>:<span class="number">18</span>]	: <span class="number">00</span>  PWM输出引脚在计数器重新计数的时候输出高电平,在计数器计数值达到比较值以后输出低电平</span><br><span class="line">bit[<span class="number">17</span>:<span class="number">16</span>]	: <span class="number">01</span>  PWM时钟源选择IPG CLK = <span class="number">66</span>MHz</span><br><span class="line">bit[<span class="number">15</span>:<span class="number">4</span>]	: <span class="number">65</span>  分频系数为<span class="number">65</span>+<span class="number">1</span>=<span class="number">66</span>，PWM时钟源 = <span class="number">66</span>MHZ/<span class="number">66</span>=<span class="number">1</span>MHz</span><br><span class="line">bit[<span class="number">3</span>]		: <span class="number">0</span>	  PWM不复位</span><br><span class="line">bit[<span class="number">2</span>:<span class="number">1</span>]	: <span class="number">00</span>  FIFO中的sample数据每个只能使用一次。</span><br><span class="line">bit[<span class="number">0</span>]		: <span class="number">0</span>   先关闭PWM，后面再使能</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi">2.2.4 PWM1_PWMIR中断控制寄存器</span><a href="#2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/8.png" alt="image"><br><strong>CIE</strong>(bit2)：比较中断使能位，为 1 的时候使能比较中断，为 0 的时候关闭比较中断。<br><strong>RIE</strong>(bit1)：翻转中断使能位，当计数器值等于采样值并回滚到 0X0000 的时候就会产生此中断，为 1 的时候使能翻转中断，为 0 的时候关闭翻转中断。<br><strong>FIE</strong>(bit0)：FIFO 空中断，为 1 的时候使能，为 0 的时候关闭。前面代码写的是使能FIFO空中断.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使能FIFO空中断，设置寄存器PWMIR寄存器的bit0为1 */</span></span><br><span class="line">PWM1-&gt;PWMIR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi">2.2.5 PWM1_PWMSR 状态寄存器</span><a href="#2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/9.png" alt="image"><br><strong>FWE</strong>(bit6)：FIFO 写错误事件，为 1 的时候表示发生了 FIFO 写错误。<br><strong>CMP</strong>(bit5)：FIFO 比较事件发标志位，为 1 的时候表示发生 FIFO 比较事件。<br><strong>ROV</strong>(bit4)：翻转事件标志位，为 1 的话表示翻转事件发生。<br><strong>FE</strong>(bit3)：FIFO 空标志位，为 1 的时候表示 FIFO 位空。<br><strong>FIFOAV</strong>(bit2:0)：此位记录 FIFO 中的有效数据个数，有效值为 0<del>4，分别表示 FIFO 中有0</del>4 个有效数据</p>
<p>初始化先清0，中断服务程序读取状态，并且清中断。FIFO 中的采样值每个周期都会少一个，所以需要不断的向 FIFO 中写入采样值，防止其为空。我们可以使能 FIFO 空中断，这样当 FIFO 为空的时候就会触发相应的中断，然后在中断处理函数中向 FIFO 写入采样值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_irqhandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(PWM1-&gt;PWMSR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)) 	<span class="comment">/* FIFO为空中断 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 将占空比信息写入到FIFO中,其实就是设置占空比 */</span></span><br><span class="line">		pwm1_setduty(backlight_dev.pwm_duty);</span><br><span class="line">		PWM1-&gt;PWMSR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>); <span class="comment">/* 写1清除中断标志位 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system_register_irqhandler(PWM1_IRQn, (<span class="type">system_irq_handler_t</span>)pwm1_irqhandler, <span class="literal">NULL</span>);	<span class="comment">/* 注册中断服务函数 */</span></span><br><span class="line">GIC_EnableIRQ(PWM1_IRQn);	<span class="comment">/* 使能GIC中对应的中断 */</span></span><br><span class="line">PWM1-&gt;PWMSR = <span class="number">0</span>;			<span class="comment">/* PWM中断状态寄存器清零 */</span></span><br><span class="line">pwm1_enable();				<span class="comment">/* 使能PWM1 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-3-ce-shi">2.3 测试</span><a href="#2-3-ce-shi" class="header-anchor">#</a></h2><p>初始化时设置占空比为50%，测试代码读取按键，每次该按键按下就对占空比加10%，如果占空比超过100%，重新从10%开始。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	keyvalue = key_getvalue();</span><br><span class="line">	<span class="keyword">if</span>(keyvalue == KEY0_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		duty += <span class="number">10</span>;				<span class="comment">/* 占空比加10% */</span></span><br><span class="line">		<span class="keyword">if</span>(duty &gt; <span class="number">100</span>)			<span class="comment">/* 如果占空比超过100%，重新从10%开始 */</span></span><br><span class="line">			duty = <span class="number">10</span>;</span><br><span class="line">		lcd_shownum(<span class="number">50</span> + <span class="number">72</span>, <span class="number">90</span>, duty, <span class="number">3</span>, <span class="number">16</span>);</span><br><span class="line">		pwm1_setduty(duty);		<span class="comment">/* 设置占空比 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	delayms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>占空比10%时亮度波形如下，亮度很暗。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/10.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/11.png" alt="image"><br>占空比90%时亮度如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/12.png" alt="image"></p>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>linux搭建nfs服务</title>
    <url>/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xia-zai-an-zhuang-nfs-fu-wu">1 下载安装NFS服务</a></li>
<li><a href="#2-guan-bi-fang-huo-qiang">2 关闭防火墙</a></li>
<li><a href="#3-chuang-jian-nfs-gong-xiang-wen-jian-jia">3 创建NFS共享文件夹</a></li>
<li><a href="#4-pei-zhi-nfs">4 配置NFS</a></li>
<li><a href="#5-qi-dong-nfs-fu-wu">5 启动NFS服务</a></li>
<li><a href="#6-ke-hu-duan-jin-xing-nfs-gua-zai">6 客户端进行NFS挂载</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xia-zai-an-zhuang-nfs-fu-wu">1 下载安装NFS服务</span><a href="#1-xia-zai-an-zhuang-nfs-fu-wu" class="header-anchor">#</a></h1><p><code>sudo apt-get install nfs-kernel-server nfs-common</code></p>
<h1><span id="2-guan-bi-fang-huo-qiang">2 关闭防火墙</span><a href="#2-guan-bi-fang-huo-qiang" class="header-anchor">#</a></h1><p><code>sudo ufw disable</code></p>
<h1><span id="3-chuang-jian-nfs-gong-xiang-wen-jian-jia">3 创建NFS共享文件夹</span><a href="#3-chuang-jian-nfs-gong-xiang-wen-jian-jia" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/book/nfs_share</span><br><span class="line">sudo <span class="built_in">chown</span> book:book /home/book/nfs_share</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /home/book/nfs_share -R</span><br></pre></td></tr></table></figure>
<h1><span id="4-pei-zhi-nfs">4 配置NFS</span><a href="#4-pei-zhi-nfs" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br><span class="line">/home/book/nfs_share *(rw,<span class="built_in">sync</span>,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/1.png" alt="1"></p>
<h1><span id="5-qi-dong-nfs-fu-wu">5 启动NFS服务</span><a href="#5-qi-dong-nfs-fu-wu" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart nfs-kernel-serve</span><br><span class="line">或者sudo service nfs-kernel-server restart</span><br><span class="line">或者sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure>

<h1><span id="6-ke-hu-duan-jin-xing-nfs-gua-zai">6 客户端进行NFS挂载</span><a href="#6-ke-hu-duan-jin-xing-nfs-gua-zai" class="header-anchor">#</a></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">运行开发板</span><br><span class="line"><span class="meta prompt_">[root@book]~# </span><span class="language-bash">mount -t nfs -o nolock -o tcp 192.168.2.100:/home/book/nfs_share /mnt/nfs</span></span><br><span class="line">-t nfs                          #挂载类型</span><br><span class="line">-o nolock                       #读写的时候不锁定</span><br><span class="line">-o tcp                          #tcp模式</span><br><span class="line">客户端退出NFS挂载</span><br><span class="line">umount /mnt/nfs</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本命令集合</title>
    <url>/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-qian-yan-can-kao-zi-liao">1 前言-参考资料</a></li>
<li><a href="#2-linux-ming-ling">2 linux 命令</a><ul>
<li><a href="#1-1-ci-pan-xiang-guan">1.1 磁盘相关</a><ul>
<li><a href="#1-1-1-fdisk">1.1.1 fdisk</a><ul>
<li><a href="#1-1-1-1-cha-kan-fen-qu">1.1.1.1 查看分区</a></li>
<li><a href="#1-1-1-2-shan-chu-fen-qu">1.1.1.2 删除分区</a></li>
<li><a href="#1-1-1-3-chuang-jian-fen-qu">1.1.1.3 创建分区</a></li>
</ul>
</li>
<li><a href="#1-1-2-ci-pan-ge-shi-hua-ming-ling-mkfs">1.1.2 磁盘格式化命令-mkfs</a><ul>
<li><a href="#1-1-2-1-mount">1.1.2.1 mount</a></li>
</ul>
</li>
<li><a href="#1-1-3-du">1.1.3 du</a></li>
<li><a href="#1-1-4-df">1.1.4 df</a></li>
</ul>
</li>
<li><a href="#1-2-wen-jian-zi-fu-cao-zuo-ming-ling">1.2 文件字符操作命令</a><ul>
<li><a href="#1-2-1-xargs">1.2.1 xargs</a></li>
<li><a href="#1-2-2-grep">1.2.2 grep</a></li>
</ul>
</li>
<li><a href="#1-3-wang-luo-ming-ling">1.3 网络命令</a></li>
</ul>
</li>
<li><a href="#3-shell-jiao-ben-ming-ling">3 shell脚本命令</a><ul>
<li><a href="#3-1-jie-shi-qi">3.1 解释器</a></li>
<li><a href="#3-2-duan-dai-ma-zhu-shi">3.2 段代码注释</a></li>
<li><a href="#3-3-read-ming-ling">3.3 read命令</a></li>
<li><a href="#3-4-test-ming-ling">3.4 test命令</a></li>
<li><a href="#3-5-ming-ling-xing-can-shu">3.5 命令行参数</a></li>
<li><a href="#3-6-tiao-jian-yu-ju">3.6 条件语句</a></li>
<li><a href="#3-7-case-yu-ju">3.7 case语句</a></li>
<li><a href="#3-8-han-shu">3.8 函数</a></li>
<li><a href="#3-9-xun-huan-yu-ju">3.9 循环语句</a></li>
<li><a href="#3-10-typeset-huo-zhe-declare">3.10 typeset或者declare</a></li>
<li><a href="#3-11-unset">3.11 unset</a></li>
<li><a href="#3-12-readonly">3.12 readonly</a></li>
<li><a href="#3-13-sed">3.13 sed</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-qian-yan-can-kao-zi-liao">1 前言-参考资料</span><a href="#1-qian-yan-can-kao-zi-liao" class="header-anchor">#</a></h1><p>正点原子：<a href="http://www.openedv.com/docs/boards/arm-linux/zdyz-i.mx6ull.html">http://www.openedv.com/docs/boards/arm-linux/zdyz-i.mx6ull.html</a></p>
<h1><span id="2-linux-ming-ling">2 linux 命令</span><a href="#2-linux-ming-ling" class="header-anchor">#</a></h1><h2><span id="1-1-ci-pan-xiang-guan">1.1 磁盘相关</span><a href="#1-1-ci-pan-xiang-guan" class="header-anchor">#</a></h2><h3><span id="1-1-1-fdisk">1.1.1 fdisk</span><a href="#1-1-1-fdisk" class="header-anchor">#</a></h3><h4><span id="1-1-1-1-cha-kan-fen-qu">1.1.1.1 查看分区</span><a href="#1-1-1-1-cha-kan-fen-qu" class="header-anchor">#</a></h4><p><code>fdisk -l</code>显示磁盘分区使用情况</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/0.png" alt="image"></p>
<h4><span id="1-1-1-2-shan-chu-fen-qu">1.1.1.2 删除分区</span><a href="#1-1-1-2-shan-chu-fen-qu" class="header-anchor">#</a></h4><p><code>fdisk /dev/sdb1 </code>用来对sdb1进行分区.</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/1.png" alt="image"></p>
<p>输入m表示获取帮助，默认有分区sdb1, 然后输入d删除分区1，p打印出分区表，i表示打印出详细分区信息，n表示新增分区信息，w表示保存，q表示退出。</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/2.png" alt="image"></p>
<p>来看dev&#x2F;sd*信息，发现已经没有了sdb1.</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/3.png" alt="image"></p>
<h4><span id="1-1-1-3-chuang-jian-fen-qu">1.1.1.3 创建分区</span><a href="#1-1-1-3-chuang-jian-fen-qu" class="header-anchor">#</a></h4><p>再来看如何建立分区1：<br>先建立一个1GB的分区，<code>1GB= 1024 * 1024 * 1024=1073741824 B = 2097152</code>个sector，一个sector有512 byte,再加上2048 个sector，那么等于2099200个sector。</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/4.png" alt="image"></p>
<p>再来何建立分区2：</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/5.png" alt="image"></p>
<p>这里First sector使用默认值2101248，Last sector使用4198400（1G是2097152， 2101248 + 2097152 &#x3D; 4198400），分区2也是1GB<br>再来何建立分区3：</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/6.png" alt="image"></p>
<p>First sector和Last sector使用默认，那么最终分区3有26.8GiB。</p>
<p>最后输入w保存退出，来看下分区:</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/7.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/8.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/9.png" alt="image"></p>
<h3><span id="1-1-2-ci-pan-ge-shi-hua-ming-ling-mkfs">1.1.2 磁盘格式化命令-mkfs</span><a href="#1-1-2-ci-pan-ge-shi-hua-ming-ling-mkfs" class="header-anchor">#</a></h3><p>mkfs命令用来对磁盘分区格式化，将格式化好的sd卡放入windows系统查看，可以看到3个盘:</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/10.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/11.png" alt="image"></p>
<h4><span id="1-1-2-1-mount">1.1.2.1 mount</span><a href="#1-1-2-1-mount" class="header-anchor">#</a></h4><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/mount.png" alt="image"></p>
<h3><span id="1-1-3-du">1.1.3 du</span><a href="#1-1-3-du" class="header-anchor">#</a></h3><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/12.png" alt="image"></p>
<h3><span id="1-1-4-df">1.1.4 df</span><a href="#1-1-4-df" class="header-anchor">#</a></h3><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/13.png" alt="image"></p>
<h2><span id="1-2-wen-jian-zi-fu-cao-zuo-ming-ling">1.2 文件字符操作命令</span><a href="#1-2-wen-jian-zi-fu-cao-zuo-ming-ling" class="header-anchor">#</a></h2><h3><span id="1-2-1-xargs">1.2.1 xargs</span><a href="#1-2-1-xargs" class="header-anchor">#</a></h3><p><code>find -name *.sh |xargs grep -rn &quot;build_all&quot;</code></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/14.png" alt="image"></p>
<h3><span id="1-2-2-grep">1.2.2 grep</span><a href="#1-2-2-grep" class="header-anchor">#</a></h3><p><code>find /path/to/directory -type f -name &quot;*.txt&quot; | grep &quot;keyword&quot;</code></p>
<p>-w 全词匹配。<br>-v 反向搜索<br>-i 不区分大小写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$匹配以字符串结尾的行</span><br><span class="line">^ 匹配以字符串开头的行</span><br><span class="line"></span><br><span class="line">找出空行 grep <span class="string">&quot;^$&quot;</span> test.txt -n</span><br><span class="line">找出unix开头的行grep <span class="string">&quot;^unix&quot;</span> geekfile.txt</span><br><span class="line">找出.结尾的行 grep <span class="string">&quot;\.$&quot;</span> test.txt -n -o</span><br><span class="line">找出os.结尾的行，grep <span class="string">&quot;os.$&quot;</span> geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>[abc]中括号</strong></p>
<p>匹配abc字符中的任意一个:</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/15.png" alt="image"></p>
<p>匹配a-z:</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/16.png" alt="image"></p>
<p>下面一个脚本用grep -v排除掉不需要的行，也就是删除包含指定字符的行从一个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 定义要删除的特定字符</span></span><br><span class="line">pattern=<span class="string">&quot;特定字符&quot;</span></span><br><span class="line"><span class="comment"># 定义要处理的文件名</span></span><br><span class="line">filename=<span class="string">&quot;文件名&quot;</span></span><br><span class="line"><span class="comment"># 使用grep命令找到含有特定字符的行，并将结果输出到一个临时文件中</span></span><br><span class="line">grep -v <span class="string">&quot;<span class="variable">$pattern</span>&quot;</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> &gt; temp.txt</span><br><span class="line"><span class="comment"># 将临时文件的内容复制回原始文件</span></span><br><span class="line"><span class="built_in">cat</span> temp.txt &gt; <span class="string">&quot;<span class="variable">$filename</span>&quot;</span></span><br><span class="line"><span class="comment"># 删除临时文件</span></span><br><span class="line"><span class="built_in">rm</span> temp.txt</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-wang-luo-ming-ling">1.3 网络命令</span><a href="#1-3-wang-luo-ming-ling" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up/down</span><br><span class="line">udhcpc -i eth0 //通过路由器分配 IP 地址</span><br><span class="line">ifconfig eth0 192.168.1.251 netmask 255.255.255.0 //设置 IP 地址和子网掩码</span><br><span class="line">route add default gw 192.168.1.1 //添加默认网关</span><br></pre></td></tr></table></figure>

<h1><span id="3-shell-jiao-ben-ming-ling">3 shell脚本命令</span><a href="#3-shell-jiao-ben-ming-ling" class="header-anchor">#</a></h1><h2><span id="3-1-jie-shi-qi">3.1 解释器</span><a href="#3-1-jie-shi-qi" class="header-anchor">#</a></h2><ol>
<li><p>sh解释器</p>
</li>
<li><p>bash解释器<br>脚本开头用<code>#！</code>用来申明用什么解释器，如：</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/17.png" alt="image"></p>
</li>
</ol>
<h2><span id="3-2-duan-dai-ma-zhu-shi">3.2 段代码注释</span><a href="#3-2-duan-dai-ma-zhu-shi" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;EOF</span><br><span class="line">...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/18.png" alt="image"></p>
<h2><span id="3-3-read-ming-ling">3.3 read命令</span><a href="#3-3-read-ming-ling" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/19.png" alt="image"></p>
<h2><span id="3-4-test-ming-ling">3.4 test命令</span><a href="#3-4-test-ming-ling" class="header-anchor">#</a></h2><p>测试文件，数值，权限，字符串等参数。</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/20.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/21.png" alt="image"></p>
<p>中括号也能表示测试，里面只能用&#x3D;&#x3D;或!&#x3D;。</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/22.png" alt="image"></p>
<h2><span id="3-5-ming-ling-xing-can-shu">3.5 命令行参数</span><a href="#3-5-ming-ling-xing-can-shu" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$0</span>, <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span>...</span><br><span class="line"><span class="variable">$0</span>表示脚本文件名</span><br><span class="line"><span class="variable">$1</span>表示第一个参数</span><br><span class="line"><span class="variable">$n</span>表示第n个参数</span><br><span class="line"><span class="variable">$#</span>表示一共有多少个命令行参数</span><br><span class="line"><span class="variable">$@</span>表示所有的命令行参数集合，<span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span> ... <span class="variable">$n</span></span><br><span class="line">$*表示等价<span class="variable">$@</span></span><br><span class="line">$?表示上一条命令是否返回成功，成功为0,错误非0</span><br><span class="line">$$表示当前脚本的进程号</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/23.png" alt="image"></p>
<h2><span id="3-6-tiao-jian-yu-ju">3.6 条件语句</span><a href="#3-6-tiao-jian-yu-ju" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/24.png" alt="image"></p>
<h2><span id="3-7-case-yu-ju">3.7 case语句</span><a href="#3-7-case-yu-ju" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/25.png" alt="image"></p>
<h2><span id="3-8-han-shu">3.8 函数</span><a href="#3-8-han-shu" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/26.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/27.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/28.png" alt="image"></p>
<h2><span id="3-9-xun-huan-yu-ju">3.9 循环语句</span><a href="#3-9-xun-huan-yu-ju" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/29.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/30.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/31.png" alt="image"></p>
<h2><span id="3-10-typeset-huo-zhe-declare">3.10 typeset或者declare</span><a href="#3-10-typeset-huo-zhe-declare" class="header-anchor">#</a></h2><p>sh脚本默认所有变量都是字符串，比如val&#x3D;1，也表示val是一个字符串“1”。那么需要如何声明一个变量类型，用typeset或者declare。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">typeset</span> -i data=1</span><br></pre></td></tr></table></figure>

<h2><span id="3-11-unset">3.11 unset</span><a href="#3-11-unset" class="header-anchor">#</a></h2><p>清除变量值.</p>
<h2><span id="3-12-readonly">3.12 readonly</span><a href="#3-12-readonly" class="header-anchor">#</a></h2><p>只读变量.</p>
<h2><span id="3-13-sed">3.13 sed</span><a href="#3-13-sed" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/dir -<span class="built_in">type</span> f -name <span class="string">&quot;*.[c-h]&quot;</span> -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/oldstring/newstring/g&#x27;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/dir：找到指定目录/path/to/dir下的所有文件。</span><br><span class="line">-<span class="built_in">type</span> f：仅查找文件。</span><br><span class="line">-name <span class="string">&quot;*.txt&quot;</span>：限制文件名以.txt结尾。</span><br><span class="line">-<span class="built_in">exec</span>：对找到的每个文件执行后面的命令。</span><br><span class="line">sed -i：使用sed进行替换，-i表示直接修改文件内容。</span><br><span class="line"><span class="string">&#x27;s/oldstring/newstring/g&#x27;</span>：sed的替换表达式，g表示全局替换。</span><br><span class="line">&#123;&#125;：表示find找到的文件名。</span><br><span class="line">+：结束-<span class="built_in">exec</span>命令，批量处理匹配到的文件。</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux搭建samba服务</title>
    <url>/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-an-zhuang-fu-wu">1 安装服务</a></li>
<li><a href="#2-guan-bi-fang-huo-qiang">2 关闭防火墙</a></li>
<li><a href="#3-tian-jia-yong-hu-book">3 添加用户book</a></li>
<li><a href="#4-chong-qi-fu-wu">4 重启服务</a></li>
<li><a href="#5-windows-jin-xing-samba-ying-she">5 windows进行samba映射</a></li>
<li><a href="#6-chang-jian-wen-ti">6 常见问题</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-an-zhuang-fu-wu">1 安装服务</span><a href="#1-an-zhuang-fu-wu" class="header-anchor">#</a></h1><p><code>sudo apt-get install samba samba-common</code></p>
<h1><span id="2-guan-bi-fang-huo-qiang">2 关闭防火墙</span><a href="#2-guan-bi-fang-huo-qiang" class="header-anchor">#</a></h1><p><code>sudo systemctl stop ufw</code></p>
<h1><span id="3-tian-jia-yong-hu-book">3 添加用户book</span><a href="#3-tian-jia-yong-hu-book" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a book</span><br><span class="line">配置samba</span><br><span class="line">sudo vim /etc/samba/smb.conf</span><br><span class="line">[book_share_samba_dir]</span><br><span class="line">        comment = share samba <span class="built_in">dir</span></span><br><span class="line">        path = /home/book/ftp</span><br><span class="line">        valid <span class="built_in">users</span> = book</span><br><span class="line">        force user = book</span><br><span class="line">        force group = book</span><br><span class="line">        creat mask = 0644</span><br><span class="line">        directory mask = 0755</span><br><span class="line">        browseable= <span class="built_in">yes</span></span><br><span class="line">        available = <span class="built_in">yes</span></span><br><span class="line">        public = <span class="built_in">yes</span></span><br><span class="line">        <span class="built_in">read</span> only = no</span><br><span class="line">        writeable = <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<h1><span id="4-chong-qi-fu-wu">4 重启服务</span><a href="#4-chong-qi-fu-wu" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ sudo service smbd restart</span><br><span class="line">~$ sudo /etc/init.d/smbd restart</span><br><span class="line">~$ /etc/init.d/smbd restart</span><br></pre></td></tr></table></figure>



<h1><span id="5-windows-jin-xing-samba-ying-she">5 windows进行samba映射</span><a href="#5-windows-jin-xing-samba-ying-she" class="header-anchor">#</a></h1><p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/1.png" alt="img"></p>
<p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/2.png" alt="img"></p>
<p>注意不能用NAT虚拟网络IP访问samba, 要用桥接网络ip，不过ssh可以两种方式访问，但是NAT虚拟网络是用来虚拟机上网的IP地址可能会发生变化，还是建议用桥接网络IP地址。</p>
<p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/3.png" alt="img"></p>
<h1><span id="6-chang-jian-wen-ti">6 常见问题</span><a href="#6-chang-jian-wen-ti" class="header-anchor">#</a></h1><p>samba不允许一个用户使用一个以上用户名与一个服务器或共享资源的多重连接，因此需要windows进入cmd</p>
<p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/4.png" alt="img"></p>
<p>可以windows cmd下用 net use 命令查看下当前的共享访问到底有没有它。</p>
<p>有的话，net use * &#x2F;del &#x2F;y</p>
<p>重新映射网络驱动器即可</p>
<p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/5.png" alt="img"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux搭建tftp和ftp服务</title>
    <url>/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-an-zhuang-tftp-fu-wu-he-ke-hu-duan">1 安装tftp服务和客户端</a><ul>
<li><a href="#1-1-pei-zhi">1.1 配置</a></li>
<li><a href="#1-2-chuang-jian-tftp-gong-xiang-mu-lu">1.2 创建tftp共享目录</a></li>
<li><a href="#1-3-ce-shi-yan-zheng-gong-neng">1.3 测试验证功能</a><ul>
<li><a href="#1-3-1-ben-ji-ce-shi">1.3.1 本机测试</a></li>
<li><a href="#1-3-2-kai-fa-ban-ce-shi">1.3.2 开发板测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ftp-fu-wu">2 ftp服务</a><ul>
<li><a href="#2-1-windows-ke-hu-duan">2.1 windows客户端</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-an-zhuang-tftp-fu-wu-he-ke-hu-duan">1 安装tftp服务和客户端</span><a href="#1-an-zhuang-tftp-fu-wu-he-ke-hu-duan" class="header-anchor">#</a></h1><pre><code>sudo apt-get install xinetd tftp tftpd
</code></pre>
<h2><span id="1-1-pei-zhi">1.1 配置</span><a href="#1-1-pei-zhi" class="header-anchor">#</a></h2><p>vim &#x2F;etc&#x2F;xinetd.d&#x2F;tftp<br>内容如下：</p>
<pre><code>service tftp
&#123;
        socket_type     		= dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server          		= /usr/sbin/in.tftpd
        server_args     		= -s /home/lyb/tftpshare/
        disable         		= no
        per_source      		=11
        cps                     = 100 2
        flags                   = IPv4
&#125;
</code></pre>
<h2><span id="1-2-chuang-jian-tftp-gong-xiang-mu-lu">1.2 创建tftp共享目录</span><a href="#1-2-chuang-jian-tftp-gong-xiang-mu-lu" class="header-anchor">#</a></h2><pre><code>1.创建服务器目录
mkdir /home/lyb/tftpshare/
2.然后修改目录权限
chmod 777 /home/lyb/tftpshare/
3.重启xinetd服务
sudo /etc/init.d/xinetd restart（如果启动失败先关闭防火墙 service iptables stop）
</code></pre>
<h2><span id="1-3-ce-shi-yan-zheng-gong-neng">1.3 测试验证功能</span><a href="#1-3-ce-shi-yan-zheng-gong-neng" class="header-anchor">#</a></h2><h3><span id="1-3-1-ben-ji-ce-shi">1.3.1 本机测试</span><a href="#1-3-1-ben-ji-ce-shi" class="header-anchor">#</a></h3><pre><code>重新启动一个终端，
输入命令 tftp 192.168.1.11（我的虚拟机ip）进入tftp,
输入get test,这样就可以获取到test文件,
输入q退出tftp
</code></pre>
<p>如下图所示：<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/1.png" alt="1"></p>
<h3><span id="1-3-2-kai-fa-ban-ce-shi">1.3.2 开发板测试</span><a href="#1-3-2-kai-fa-ban-ce-shi" class="header-anchor">#</a></h3><p>2440开发板的uboot可以支持tftp下载功能，在uboot命令行输入：</p>
<pre><code>tftp 0x30000000  uImage_4.3
</code></pre>
<p>如下图所示。<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/2.png" alt="2"></p>
<h1><span id="2-ftp-fu-wu">2 ftp服务</span><a href="#2-ftp-fu-wu" class="header-anchor">#</a></h1><pre><code>sudo apt install vsftpd
vi /etc/vsftpd.conf

local_enable=YES
write_enable=YES
sudo /etc/init.d/vsftpd restart
</code></pre>
<p><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/3.png" alt="3"></p>
<h2><span id="2-1-windows-ke-hu-duan">2.1 windows客户端</span><a href="#2-1-windows-ke-hu-duan" class="header-anchor">#</a></h2><p><a href="https://filezilla-project.org/">https://filezilla-project.org/</a></p>
<p>新建站点，配置ftp协议, 主机输入ubuntu IP地址，用户密码信息，即可连接成功。<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/4.png" alt="4"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法教程</title>
    <url>/2024/05/26/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-duo-ji-biao-ti-mu-lu-jie-gou">1 多级标题目录结构</a></li>
<li><a href="#yi-ji-biao-ti">一级标题</a><ul>
<li><a href="#er-ji-biao-ti">二级标题</a><ul>
<li><a href="#san-ji-biao-ti">三级标题</a><ul>
<li><a href="#si-ji-biao-ti">四级标题</a><ul>
<li><a href="#wu-ji-biao-ti">五级标题</a><ul>
<li><a href="#liu-ji-biao-ti">六级标题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-duan-luo">2 段落</a><ul>
<li><a href="#2-1-huan-xing">2.1 换行</a></li>
</ul>
</li>
<li><a href="#3-zi-ti">3 字体</a></li>
<li><a href="#4-zi-ti-yan-se-da-xiao">4 字体颜色,大小</a></li>
<li><a href="#5-zi-ti-bei-jing-yan-se">5 字体背景颜色</a></li>
<li><a href="#5-xia-hua-xian">5 下划线</a></li>
<li><a href="#6-lie-biao-xiang">6 列表项</a></li>
<li><a href="#7-dai-ma-kuai-yu-yu-fa-gao-liang">7 代码块与语法高亮</a><ul>
<li><a href="#7-1-xing-nei-dai-ma">7.1 行内代码</a></li>
<li><a href="#7-2-kuai-dai-ma">7.2 块代码</a></li>
</ul>
</li>
<li><a href="#8-dai-ma-zhe-die">8 代码折叠</a></li>
<li><a href="#9-cha-ru-lian-jie">9 插入链接</a><ul>
<li><a href="#9-1-zi-dong-lian-jie">9.1 自动链接</a></li>
</ul>
</li>
<li><a href="#10-tian-jia-tu-pian">10 添加图片</a></li>
<li><a href="#11-biao-ge">11 表格</a></li>
<li><a href="#12-zhuan-yi-zi-fu">12 转义字符</a></li>
<li><a href="#mao-dian">锚点</a><ul>
<li><a href="#mu-lu">目录</a><ul>
<li><a href="#di-yi-jie">第一节</a></li>
<li><a href="#di-er-jie">第二节</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-duo-ji-biao-ti-mu-lu-jie-gou">1 多级标题目录结构</span><a href="#1-duo-ji-biao-ti-mu-lu-jie-gou" class="header-anchor">#</a></h1><pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre>
<p>效果如下：</p>
<h1><span id="yi-ji-biao-ti">一级标题</span><a href="#yi-ji-biao-ti" class="header-anchor">#</a></h1><h2><span id="er-ji-biao-ti">二级标题</span><a href="#er-ji-biao-ti" class="header-anchor">#</a></h2><h3><span id="san-ji-biao-ti">三级标题</span><a href="#san-ji-biao-ti" class="header-anchor">#</a></h3><h4><span id="si-ji-biao-ti">四级标题</span><a href="#si-ji-biao-ti" class="header-anchor">#</a></h4><h5><span id="wu-ji-biao-ti">五级标题</span><a href="#wu-ji-biao-ti" class="header-anchor">#</a></h5><h6><span id="liu-ji-biao-ti">六级标题</span><a href="#liu-ji-biao-ti" class="header-anchor">#</a></h6><h1><span id="2-duan-luo">2 段落</span><a href="#2-duan-luo" class="header-anchor">#</a></h1><h2><span id="2-1-huan-xing">2.1 换行</span><a href="#2-1-huan-xing" class="header-anchor">#</a></h2><p>Markdown段落的换行是使用两个以上空格加上回车，当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p>
<h1><span id="3-zi-ti">3 字体</span><a href="#3-zi-ti" class="header-anchor">#</a></h1><pre><code>*斜体*
**粗体**
***加粗斜体***

&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;
&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;
&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;
</code></pre>
<p>效果：</p>
<p><em>斜体</em><br><strong>粗体</strong><br><em><strong>加粗斜体</strong></em></p>
<p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font></p>
<h1><span id="4-zi-ti-yan-se-da-xiao">4 字体颜色,大小</span><a href="#4-zi-ti-yan-se-da-xiao" class="header-anchor">#</a></h1><pre><code>&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;
&lt;font color=gray size=5&gt;gray&lt;/font&gt;
&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;
</code></pre>
<p>效果：</p>
<p><font color="#0099ff" size="12" face="黑体">黑体</font><br><font color="gray" size="5">gray</font><br><font color="#00ffff" size="3">null</font></p>
<h1><span id="5-zi-ti-bei-jing-yan-se">5 字体背景颜色</span><a href="#5-zi-ti-bei-jing-yan-se" class="header-anchor">#</a></h1><pre><code>&lt;table&gt;&lt;td bgcolor=pink&gt; 
背景色是pink &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=LightGoldenRodYellow&gt; 
LightGoldenRodYellow &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=PeachPuff&gt; 
PeachPuff &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=PapayaWhip&gt; 
PapayaWhip &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=PaleGreen&gt; 
PaleGreen &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=PaleGoldenRod&gt; 
PaleGoldenRod &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=MistyRose&gt; 
MistyRose &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=Linen&gt; 
Linen &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=LightPink&gt; 
LightPink &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=BurlyWood&gt; 
BurlyWood &lt;/table&gt;
</code></pre>
<p>效果：</p>
<table><td bgcolor="pink"> 
背景色是pink </td></table>

<table><td bgcolor="LightGoldenRodYellow"> 
LightGoldenRodYellow </td></table>

<table><td bgcolor="PeachPuff"> 
PeachPuff </td></table>

<table><td bgcolor="PapayaWhip"> 
PapayaWhip </td></table>

<table><td bgcolor="PaleGreen"> 
PaleGreen </td></table>

<table><td bgcolor="PaleGoldenRod"> 
PaleGoldenRod </td></table>

<table><td bgcolor="MistyRose"> 
MistyRose </td></table>

<table><td bgcolor="Linen"> 
Linen </td></table>

<table><td bgcolor="LightPink"> 
LightPink </td></table>

<table><td bgcolor="BurlyWood"> 
BurlyWood </td></table>


<h1><span id="5-xia-hua-xian">5 下划线</span><a href="#5-xia-hua-xian" class="header-anchor">#</a></h1><p>写法：<br>    <code>&lt;u&gt;下划线&lt;/u&gt;</code></p>
<p>效果如下：<br><u>下划线</u></p>
<h1><span id="6-lie-biao-xiang">6 列表项</span><a href="#6-lie-biao-xiang" class="header-anchor">#</a></h1><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p>
<pre><code>* 第一项
* 第二项
* 第三项
</code></pre>
<p>显示效果：  </p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p>有序列表使用数字并加上 <code>.</code> 号来表示： 	<br>    1. 第一项<br>        1. 小一项<br>        2. 小二项<br>    2. 第二项<br>    3. 第三项<br>显示效果： </p>
<ol>
<li>第一项<ol>
<li>小一项</li>
<li>小二项</li>
</ol>
</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h1><span id="7-dai-ma-kuai-yu-yu-fa-gao-liang">7 代码块与语法高亮</span><a href="#7-dai-ma-kuai-yu-yu-fa-gao-liang" class="header-anchor">#</a></h1><h2><span id="7-1-xing-nei-dai-ma">7.1 行内代码</span><a href="#7-1-xing-nei-dai-ma" class="header-anchor">#</a></h2><p>用反引号 &#96;&#96; 来标记或插入代码区段</p>
<p>效果：<br><code>int main(void)</code></p>
<h2><span id="7-2-kuai-dai-ma">7.2 块代码</span><a href="#7-2-kuai-dai-ma" class="header-anchor">#</a></h2><p>用tab键或者用&#96;&#96;&#96;</p>
<p>效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(vpod)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="8-dai-ma-zhe-die">8 代码折叠</span><a href="#8-dai-ma-zhe-die" class="header-anchor">#</a></h1><p>写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;点击展开代码&lt;/summary&gt;</span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<details>
<summary>点击展开代码</summary>
<pre><code>
    #include &lt;stdio.h&gt;
    int main(int argc, char **argv)
    &#123;
        printf("hello world\n");
        return 0;
    &#125;

<p></p></code></pre><p></p>
</details>

<h1><span id="9-cha-ru-lian-jie">9 插入链接</span><a href="#9-cha-ru-lian-jie" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用:</span><br><span class="line">[fuzidage的博客](https://www.cnblogs.com/fuzidage/)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><a href="https://www.cnblogs.com/fuzidage/">fuzidage的博客</a></p>
<h2><span id="9-1-zi-dong-lian-jie">9.1 自动链接</span><a href="#9-1-zi-dong-lian-jie" class="header-anchor">#</a></h2><p>只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接：</p>
<p>效果：<br><a href="https://github.com/fuzidage">https://github.com/fuzidage</a></p>
<h1><span id="10-tian-jia-tu-pian">10 添加图片</span><a href="#10-tian-jia-tu-pian" class="header-anchor">#</a></h1><pre><code>写法：![](https://img2018.cnblogs.com/blog/1876680/201912/1876680-20191214155002138-1798053565.png)
当然如果是本地图片写法：
![](./markdown语法教程/1.png)
</code></pre>
<p>引用网络效果：</p>
<p><img src="https://img2018.cnblogs.com/blog/1876680/201912/1876680-20191214155002138-1798053565.png"></p>
<p>引用本地图片效果：<br><img src="/2024/05/26/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/1.png" alt="image-20240526174126727"></p>
<h1><span id="11-biao-ge">11 表格</span><a href="#11-biao-ge" class="header-anchor">#</a></h1><p>写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----:|</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h1><span id="12-zhuan-yi-zi-fu">12 转义字符</span><a href="#12-zhuan-yi-zi-fu" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>显示结果</th>
<th>描述</th>
<th>输入</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格</td>
<td>&amp;nbsp；</td>
<td>&amp;#160；</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&amp;lt；</td>
<td>&amp;#60；</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&amp;gt；</td>
<td>&amp;#62；</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;amp；</td>
<td>&amp;#38；</td>
</tr>
<tr>
<td>“</td>
<td>引号</td>
<td>&amp;quot；</td>
<td>&amp;#34；</td>
</tr>
<tr>
<td>‘</td>
<td>撇号</td>
<td>&amp;apos；</td>
<td>(IE不支持)	&amp;#39；</td>
</tr>
<tr>
<td>￠</td>
<td>分</td>
<td>&amp;cent；</td>
<td>&amp;#162；</td>
</tr>
<tr>
<td>£</td>
<td>镑</td>
<td>&amp;pound；</td>
<td>&amp;#163；</td>
</tr>
<tr>
<td>¥</td>
<td>日圆</td>
<td>&amp;yen；</td>
<td>&amp;#165；</td>
</tr>
<tr>
<td>§</td>
<td>节</td>
<td>&amp;sect；</td>
<td>&amp;#167；</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&amp;copy；</td>
<td>&amp;#169；</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&amp;reg；</td>
<td>&amp;#174；</td>
</tr>
<tr>
<td>×</td>
<td>乘号</td>
<td>&amp;times；</td>
<td>&amp;#215；</td>
</tr>
<tr>
<td>÷</td>
<td>除号</td>
<td>&amp;divide；</td>
<td>&amp;#247；</td>
</tr>
</tbody></table>
<h1><span id="mao-dian">锚点</span><a href="#mao-dian" class="header-anchor">#</a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 目录</span></span><br><span class="line">[跳转到第一节](<span class="comment">#a)</span></span><br><span class="line">[跳转到第二节](<span class="comment">#b)</span></span><br><span class="line"></span><br><span class="line">&lt;a name=<span class="string">&quot;a&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="comment">### 第一节</span></span><br><span class="line">这是第一节的内容。</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;a name=<span class="string">&quot;b&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="comment">### 第二节</span></span><br><span class="line">这是第二节的内容。</span><br></pre></td></tr></table></figure>

<h2><span id="mu-lu">目录</span><a href="#mu-lu" class="header-anchor">#</a></h2><p><a href="#a">跳转到第一节</a><br><a href="#b">跳转到第二节</a></p>
<p><a name="a"></a></p>
<h3><span id="di-yi-jie">第一节</span><a href="#di-yi-jie" class="header-anchor">#</a></h3><p>这是第一节的内容。<br>…<br>…<br>…<br>…<br>…<br>…<br>…<br>…<br>…<br>…<br>…<br><a name="b"></a></p>
<h3><span id="di-er-jie">第二节</span><a href="#di-er-jie" class="header-anchor">#</a></h3><p>这是第二节的内容。</p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>mipi-csi软件篇</title>
    <url>/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mipi-csi2-de-fa-song-he-jie-shou">1 MIPI CSI2的发送和接收</a></li>
<li><a href="#2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi">2 D-PHY(DSI和CSI的物理层定义)</a><ul>
<li><a href="#2-1-chuan-shu-mo-shi">2.1 传输模式</a></li>
<li><a href="#2-2-lane-states">2.2 lane states</a></li>
<li><a href="#2-3-lane-levels">2.3 Lane Levels</a></li>
<li><a href="#2-4-cao-zuo-mo-shi">2.4 操作模式</a></li>
<li><a href="#2-5-shi-zhong-mo-shi">2.5 时钟模式</a></li>
<li><a href="#2-6-shi-xu-yao-qiu">2.6 时序要求</a></li>
<li><a href="#2-7-start-of-transmission-sot-guo-cheng">2.7 Start-of-Transmission ( SoT )过程</a></li>
<li><a href="#2-8-end-of-transmission-eot-guo-cheng">2.8 End-of-Transmission ( EoT )过程</a></li>
</ul>
</li>
<li><a href="#3-csi-2-shu-ju-bao-xie-yi">3 CSI-2数据包协议</a><ul>
<li><a href="#3-1-yi-ge-shu-ju-bao-jie-gou">3.1 一个数据包结构</a></li>
<li><a href="#3-2-bao-lei-xing">3.2 包类型</a><ul>
<li><a href="#3-2-1-duan-bao-jie-gou">3.2.1 短包结构</a></li>
<li><a href="#3-2-2-pack-footer-pf-de-jie-gou">3.2.2 pack footer(PF)的结构</a></li>
<li><a href="#3-2-3-chang-bao-jie-gou">3.2.3 长包结构</a></li>
<li><a href="#3-2-4-h-blanking-v-blanking">3.2.4 H-blanking &amp; V-blanking</a></li>
<li><a href="#3-2-5-mipi-zheng-shu-ju-lei-xing-di">3.2.5 MIPI帧数据类型DI</a><ul>
<li><a href="#3-2-5-1-vc-virtual-channel">3.2.5.1 VC(virtual channel)</a></li>
<li><a href="#3-2-5-2-dt-data-type">3.2.5.2 DT(data type)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-mipi-zhi-chi-de-tu-xiang-ge-shi">4 mipi支持的图像格式</a><ul>
<li><a href="#4-1-rgb-ge-shi">4.1 RGB格式</a></li>
<li><a href="#4-2-yuv-ge-shi">4.2 YUV格式</a><ul>
<li><a href="#4-2-1-yuv-cai-yang-mo-shi-subsamping">4.2.1 YUV采样模式(subsamping)</a><ul>
<li><a href="#4-2-1-1-yuv444-cai-yang">4.2.1.1 YUV444采样</a></li>
<li><a href="#4-2-1-2-yuv422-cai-yang">4.2.1.2 YUV422采样</a></li>
<li><a href="#4-2-1-3-yuv420-cai-yang">4.2.1.3 YUV420采样</a></li>
</ul>
</li>
<li><a href="#4-2-2-yuv-cun-chu-fang-shi">4.2.2 YUV存储方式</a><ul>
<li><a href="#4-2-2-1-planner-cun-chu">4.2.2.1 planner存储</a><ul>
<li><a href="#4-2-2-1-1-yuv420-planner">4.2.2.1.1 yuv420 planner</a></li>
<li><a href="#4-2-2-1-2-yuv420sp">4.2.2.1.2 yuv420sp</a></li>
<li><a href="#4-2-2-1-3-yuv422-planner">4.2.2.1.3 yuv422 planner</a></li>
<li><a href="#4-2-2-1-4-yuv422sp">4.2.2.1.4 yuv422sp</a></li>
</ul>
</li>
<li><a href="#4-2-2-2-packed-cun-chu">4.2.2.2 packed存储</a><ul>
<li><a href="#4-2-2-2-1-yuyv">4.2.2.2.1 yuyv</a></li>
<li><a href="#4-2-2-2-2-yvyu">4.2.2.2.2 yvyu</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-3-raw-ge-shi">4.3 RAW 格式</a><ul>
<li><a href="#4-3-1-bayer-zhen-lie">4.3.1 bayer阵列</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-mipi-csi-shu-ju-bao-chuan-shu">5 mipi csi数据包传输</a></li>
<li><a href="#6-se-cai-shen-du">6 色彩深度</a></li>
<li><a href="#7-tu-xiang-jie-xi-du-fen-bian-lu">7 图像解析度&#x2F;分辨率</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-mipi-csi2-de-fa-song-he-jie-shou">1 MIPI CSI2的发送和接收</span><a href="#1-mipi-csi2-de-fa-song-he-jie-shou" class="header-anchor">#</a></h1><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/1.png" alt="img"></p>
<p>上图反映了sensor 和 soc 的数据关系，soc 通过 CCI (Camera Control Interface) 控制 sensor 寄存器，配置正确，sensor 将会通过 mipi 接口输出图像数据。</p>
<p>控制信息是 soc 通过 CCI 发送到 sensor，CCI 接口一般的就是 I2C 接口,最大支持400KHz。</p>
<p>data信息是CSI DPHY发送者发送到CSI DPHY接收者，由sensor端发送到soc的mipi-rx。</p>
<h1><span id="2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi">2 D-PHY(DSI和CSI的物理层定义)</span><a href="#2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi" class="header-anchor">#</a></h1><p>D-PHY 是 MIPI 聯盟發布的高速物理層標準，規定了接口層的物理特性和傳輸協議。 DPHY 採用了 200mV 源同步的低压差分信號技術，每個 Lane 的數據綠率範圍支持到2500Mbps。 D-PHY 可以工作在低功耗 (Low Power, LP) 和高速 (High Speed, HS) 兩種模式下。</p>
<h2><span id="2-1-chuan-shu-mo-shi">2.1 传输模式</span><a href="#2-1-chuan-shu-mo-shi" class="header-anchor">#</a></h2><p><strong>LP（Low-Power） 模式</strong>：用于传输控制信号，最高速率 10 MHz</p>
<p><strong>HS（High-Speed）模</strong>式：用于高速传输数据，速率范围 [80 Mbps， 2.5Gbps] per Lane</p>
<p>传输的最小单元为 1 个字节，采用小端的方式，也就是 LSB first，MSB last。</p>
<p><strong>相关缩写名</strong>词：</p>
<p>HS-RX：高速接收器<br>HS-TX：高速发送器<br>LP-RX：低功耗接收器<br>LP-TX：低功耗发送器<br>LPS:  Low Power State, 封包之間的spacing間距。<br>ST:    Start of Transmission (SoT), 封包的起始訊號, 一般為低速轉換為高速的暫態訊號。<br>ET:    End of Transmission (EoT), 封包的結束訊號, 一般為高速轉換為低速的暫態訊號。<br>PH:   Packet Header, 32 bit表示, 為封包的標頭。<br>PF:    Packet Footer, 16 bit表示, 為封包的結尾。</p>
<h2><span id="2-2-lane-states">2.2 lane states</span><a href="#2-2-lane-states" class="header-anchor">#</a></h2><p>*  LP mode 有 4 种状态： LP00、LP01（<strong>0</strong>）、LP10（<strong>1</strong>）、LP11 （Dp、Dn）</p>
<p>* HS mode 有 2 种状态： HS-0、HS-1</p>
<p>HS 发送器发送的数据 LP 接收器看到的都是 LP00。</p>
<h2><span id="2-3-lane-levels">2.3 Lane Levels</span><a href="#2-3-lane-levels" class="header-anchor">#</a></h2><p>* LP： 0 ~ 1.2V</p>
<p>* HS： 100 ~ 300mV，HS common level &#x3D; 200mV，swing &#x3D; 200 mv</p>
<h2><span id="2-4-cao-zuo-mo-shi">2.4 操作模式</span><a href="#2-4-cao-zuo-mo-shi" class="header-anchor">#</a></h2><p> • 数据Lane的3种操作模式 </p>
<ul>
<li><p>Escape mode,</p>
</li>
<li><p>High-Speed(Burst) mode</p>
</li>
<li><p>Control mode</p>
<p><strong>①Escape mode request</strong><br> LP-11→LP-10→LP-00→LP-01→LP-00<br> exit:LP-10 -&gt; LP-11</p>
</li>
</ul>
<p>当进入 Escape mode 需要发送 8-bit entry command 表明请求的动作，比如要进行低速数据传输则需要发送 cmd： 0x87，进入超低功耗模式则发送 cmd： 0x78。</p>
<p>  <strong>②High-Speed mode request :</strong><br>    LP-11→LP-01→LP-00-&gt;SOT(0001_1101)<br>    exit: EOT -&gt; LP-11</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/2.png" alt="img"></p>
<p><strong>③Turnaround request</strong><br>    LP-11→LP-10→LP-00→LP-10→LP-00</p>
<p>这是开启 BTA 的时序，一般用于从 slave 返回数据如 ACK： 0x84.<br>    exit：LP00→LP10→LP11</p>
<p> 最常用的就是“低功耗进入高速模式”如下图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/3.png" alt="img"></p>
<p>我们的D0-D4都是一个差分信号，它从lowpower state进入到HS后，从hi speed mode 中sync出我们的data。</p>
<p>sensor控制的信号由绿色框圈出来，主要是以下三个讯号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HS-Prepare：表示从low power mode进入到hi speed mode需要prepare一段时间</span><br><span class="line">Hs-zero: 表示从low power mode进入到hi speed mode需要keep LP-00状态一段时间</span><br><span class="line">Hs-trail:表示送完1 st data后需要keep一段时间后才允许进入low power mode，进行下一轮数据传输。</span><br></pre></td></tr></table></figure>

<p>soc端的控制的信号由黄色框圈出来:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hs-settle:表示soc要等一段时间才去开始去parse “sync code”, 当抓到sync code后表示sensor已经进入了hi speed mode， 这个时候就可以sync data了。</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1.每次EOT(end of trans)结束讯号后，都会进入low power mode，而不是sensor 工作后就一直处于hi speed mode。也就是每传一个package，都会走一遍上述的过程。</p>
<p>2.hs-settle为mclk&#x2F;8 *n(这个n表示配置几个clk，对应code的话配置这个mipi_dev_attr_s-&gt;dphy)</p>
<p>当hs-settle的时间太长会压到data中的“sync code”,那么就会出现sync code parse不到,出现ecc err. 又或者从data中parse到一个假的“sync code”，那么最后就会出现数据不太对，出现ecc err.</p>
<p>Ecc还有一种出现可能就是lane mapping 出错，当我们传输数据出现ecc err, 有可能就是传输short pack时，4 byte的short pack拼接的不对（详见CSI的数据包结构），导致出现ecc error.</p>
<p>3.如果hs-trail持续的太短（拉高的太快），有可能会压到最后面的data，所以会出现crc&#x2F;wc(word count ) err.另外，如果hs -settle太大，也有可能hs-trail也会是错误的数据，所以出现wc, crc err，因此不一定是hs-trail的问题，得先确保前面的ecc&#x2F;decode无误后再来调整hs-trail。</p>
<p>一般排查流程如下：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/4.png" alt="img"></p>
<h2><span id="2-5-shi-zhong-mo-shi">2.5 时钟模式</span><a href="#2-5-shi-zhong-mo-shi" class="header-anchor">#</a></h2><ul>
<li>连续时钟模式：数据包传输间隔，clk lane 保持在高速模式；</li>
<li>非连续时钟模式：数据包传输间隔，clk lane 进入 LP-11 状态，退出hi speed mode；</li>
</ul>
<h2><span id="2-6-shi-xu-yao-qiu">2.6 时序要求</span><a href="#2-6-shi-xu-yao-qiu" class="header-anchor">#</a></h2><p>在调试 DSI 或者 CSI 的时候， HS mode 下的几个时序非常重要：T_LPX，T_HS-SETTLE ≈ T_HS-PREPARE + T_HS-ZERO，T_HS-TRAIL，一般遵循的原则为：Host 端的 T_HS-SETTLE &gt; Slave 端的 T_HS-SETTLE。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/5.png" alt="img"></p>
<h2><span id="2-7-start-of-transmission-sot-guo-cheng">2.7 Start-of-Transmission ( SoT )过程</span><a href="#2-7-start-of-transmission-sot-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/6.png" alt="img"></p>
<p>当要进行数据传输的时候，data lane 将会通过信号（SoT）退出停止状态，进入高速模式。过程如下：</p>
<table>
<thead>
<tr>
<th><strong>TX Side</strong></th>
<th><strong>RX Side</strong></th>
</tr>
</thead>
<tbody><tr>
<td>退出停止状态 ( LP-11 )</td>
<td>检测停止状态</td>
</tr>
<tr>
<td>进入 HS-Rqst 状态 ( LP-01 )，并处于该状态的时间间隔为 TLPX</td>
<td>检测到 lane 从 LP-11 转变为 LP-01</td>
</tr>
<tr>
<td>进入 Bridge 状态 ( LP-00 )，并处于该状态的时间间隔为 THS-PREPARE</td>
<td>检测到 lane 从 LP-01 转变为 LP-00，间隔 TD-TERM-EN 时间之后将使能传输</td>
</tr>
<tr>
<td>同时退出低功耗模式，进入高速模式</td>
<td></td>
</tr>
<tr>
<td>处于 HS-0 状态，时长为 THS-ZERO</td>
<td>使能 HS-RX 并等待 THS-SETTLE，以忽略转换状态</td>
</tr>
<tr>
<td></td>
<td>开始从数据流中等待同步序列</td>
</tr>
<tr>
<td>时钟上升边缘插入 HS 同步序列 ‘00011101’</td>
<td></td>
</tr>
<tr>
<td></td>
<td>识别到同步序列 ‘00011101’</td>
</tr>
<tr>
<td>高速模式开始传输有效数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td>接收到有效数据</td>
</tr>
</tbody></table>
<h2><span id="2-8-end-of-transmission-eot-guo-cheng">2.8 End-of-Transmission ( EoT )过程</span><a href="#2-8-end-of-transmission-eot-guo-cheng" class="header-anchor">#</a></h2><p>在数据完成传输时，通过结束传输（EoT）过程，数据通道退出高速模式并进入停止状态，这个过程状态变化如下：</p>
<table>
<thead>
<tr>
<th><strong>TX Side</strong></th>
<th><strong>RX Side</strong></th>
</tr>
</thead>
<tbody><tr>
<td>传输数据</td>
<td>接收到数据</td>
</tr>
<tr>
<td>在完成最后一个字节数据的传输之后，保持该状态的时间间隔为 THS-TRAIL</td>
<td></td>
</tr>
<tr>
<td>关闭 HS-TX，启用 LP-TX，并在 THS-EXIT一段时间内处于停止状态 ( LP-11 )</td>
<td>检测到 lane 状态进入停止状态 ( LP-11 )，关闭传输功能</td>
</tr>
<tr>
<td></td>
<td>忽略 THS-SKIP一段时间内的 lane 变化，以忽略转换状态</td>
</tr>
<tr>
<td></td>
<td>检测有效数据的最后一次转换，确定最后一次有效数据并忽略包尾序列</td>
</tr>
</tbody></table>
<p>接收器是如何判断数据将要开始传输了呢？</p>
<p>当出现LP11→LP01→LP00时，接收器将会判断，将会有数据达到，同时，使用示波器查看mipi波形，将会发现在PL00（THS-PREPARE）时会有一个小脉冲（峰刺），一般的，在这个小脉冲之后，接收器将会打开比较器（由于在THS-PREPARE会有这个小脉冲的存在，所以在接收器中，会通过设置接收器的settle time，避开这个小脉冲，在这个脉冲之后再打开比较器），准备接收数据。而HS-00011101则表示有效数据开始，同时数据的开头，将会有数据表明将要数据的数据量，所以mipi接收器将会按其数据量接收，直到接收完成。<br>每根 lane（data lane&#x2F;clk lane）从 LP 模式切换到 HS 模式都会有 LP11→LP01→LP00 这样的一个时序，同时还要检查 HS-00011101 ，HS-00011101 主要是用于同步，只有前面正确采集到 00011101 ，才能保证 clk 和 data 相位一一对应。</p>
<p><strong>mipi csi调试助手：</strong><br>测量 sensor 有相应的 mipi 信号输出，但是主控并没有接收到数据，通过查看主控的 mipi 寄存器发现，mipi接收器还处于 LP 模式，这种情况一般是mipi没有检测到sensor发送的从 LP 进入 HS 的时序。此时可测量sensor 开始输出图像数据时，clk lane 是否有 LP11→LP01→LP00 这样的一个时序。同时，应该先开 mipi，sensor 再开始 mipi 数据传输；<br>由于THS-PREPARE会有一个小脉冲的存在，所以，主控在接收mipi数据的时候，需要通过设置主控的settle time，这个时间需要在这个小脉冲之后，这样接收才不会有问题；<br>当出现 sensor 有数据输出，但是主控没有接收成功，这个情况一般是 mipi 的时序问题，sensor 端的时序没有和主控端的配合好，这个时候，可以尝试的减小sensor端的THS-PREPARE，增大THS-ZERO和THS-TRAIL；<br>由于一些主控的需求，在一帧数据完成之后，需要一定的时间才可以进行相应的ISP处理，当一帧传输完毕之后的LP11时间达不到主控ISP的时间要求导致ISP报错，可通过调节THS-TRAIL时间，以此得到ISP对帧间的时序长度要求 。</p>
<h1><span id="3-csi-2-shu-ju-bao-xie-yi">3 CSI-2数据包协议</span><a href="#3-csi-2-shu-ju-bao-xie-yi" class="header-anchor">#</a></h1><p>CSI-2 是針對攝像頭的數據協議， 規定了主機與外設通信的數據包格式。CSI-2 可以支持不同像素格式的圖像應用， 數據傳輸的最小粒度是字節。 為增加 CSI-2 的性能，可以選擇數據 Lane 的數量， CSI-2 協議規訂了發送端將像素數據打包成字節的機制， 並指明多個數據 Lane 分配和管理的方式。字節數據以數據包的形式組織，數據包在SoT 與 EoT 之間傳輸。 接收端根據協議解析相應的數據包， 恢復出原始的像素數據。</p>
<p>CSI-2 的數據包分為長包和短包兩種，包含有校驗碼，能進行誤碼糾正和錯誤檢測。長包和短包都是在 SoT 和 EoT 之間傳輸，在數據傳送的間隙， D-PHY 處於 LP 模式。 CSI-2數據包的傳輸機制如圖所示。 PH 和 PF 分別表示 Packet Header 和 Packet Footer。</p>
<h2><span id="3-1-yi-ge-shu-ju-bao-jie-gou">3.1 一个数据包结构</span><a href="#3-1-yi-ge-shu-ju-bao-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/7.png" alt="img"></p>
<h2><span id="3-2-bao-lei-xing">3.2 包类型</span><a href="#3-2-bao-lei-xing" class="header-anchor">#</a></h2><p>• 短包：4 bytes (固定)<br>• 长包：6~65541 bytes (可变) </p>
<h3><span id="3-2-1-duan-bao-jie-gou">3.2.1 短包结构</span><a href="#3-2-1-duan-bao-jie-gou" class="header-anchor">#</a></h3><p><strong>一个short packet（也叫做pack head(PH)）</strong></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/8.png" alt="img"></p>
<p>包结构（4个字节）：<br>    • 数据标识(DI) 1个字节<br>    • WC （长度固定为2个字节）<br>    • 错误检测(ECC) 1个字节</p>
<p>包大小：<br>    • 长度固定为4个字节</p>
<h3><span id="3-2-2-pack-footer-pf-de-jie-gou">3.2.2 pack footer(PF)的结构</span><a href="#3-2-2-pack-footer-pf-de-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/9.png" alt="img"></p>
<h3><span id="3-2-3-chang-bao-jie-gou">3.2.3 长包结构</span><a href="#3-2-3-chang-bao-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/10.png" alt="img"></p>
<p>包头部（4个字节）（PH）：<br>• 　　数据标识(DI) 1个字节<br>• 　　数据计数WC (2个字节 )（PH和PF之間的資料個數）<br>• 　　错误检测(ECC) 1个字节<br>•　    数据填充(0~65535 字节)<br>•       长度&#x3D;WC*字节</p>
<p>包尾：校验和（2个字节）(PF)</p>
<p>长包 &#x3D; 短包（包头） + 数据 + 包尾 </p>
<p>包大小：<br>    4 + (0~65535) + 2 &#x3D; 6 ~ 65541 字节</p>
<h3><span id="3-2-4-h-blanking-amp-v-blanking">3.2.4 H-blanking &amp; V-blanking</span><a href="#3-2-4-h-blanking-amp-v-blanking" class="header-anchor">#</a></h3><p>传输多个pack和传输一个pack时对应的图像如下, VVALID&#x2F;HVALID&#x2F;DVALID可以先把它想成是影像的同步訊號VSync&#x2F;HSync&#x2F;DE，而Data就是影像資料，以方便理解。</p>
<p>从图中可以看到，当水平同步讯号HVALID为Low的这段区间，剛好就是每行的Blanking间隔, 也就是H-blanking。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/11.png" alt="img"></p>
<p>从下图可以看到上一FE到下一FS之间的间隔为V-blanking.</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/12.png" alt="img"></p>
<p>frame的封包示意图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/13.png" alt="img"></p>
<h3><span id="3-2-5-mipi-zheng-shu-ju-lei-xing-di">3.2.5 MIPI帧数据类型DI</span><a href="#3-2-5-mipi-zheng-shu-ju-lei-xing-di" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/14.png" alt="img"></p>
<p> Data Identifier (DI) 为虚拟通道(VC, 2 bit)和资料类型(DT, 6 bit)组成。</p>
<h4><span id="3-2-5-1-vc-virtual-channel">3.2.5.1 VC(virtual channel)</span><a href="#3-2-5-1-vc-virtual-channel" class="header-anchor">#</a></h4><p>可以看出MIPI最多可以輸入4组影像来源，其ID为0~3，且內容可以是任意的內容，下图就表示用virtual chn来传输不同格式的数据。比如一般Sony, OV的HDR 模式基本都是VC mode，包括2帧HDR, 3帧HDR。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/15.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/16.png" alt="img"></p>
<h4><span id="3-2-5-2-dt-data-type">3.2.5.2 DT(data type)</span><a href="#3-2-5-2-dt-data-type" class="header-anchor">#</a></h4><p>Data Type目前定义多种资料形态，范围从0x00<del>0x3F，其中0x00</del>0x0F为短封包类型，0x10~0x3F为長封包类型，如下表：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/17.png" alt="img"></p>
<p>用于同步的短包Data Type:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/18.png" alt="img"></p>
<p>从<strong>soc到外设</strong>发送的包类型:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/19.png" alt="img"></p>
<p>从<strong>外设到soc</strong>的数据包类型:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/20.png" alt="img"></p>
<h1><span id="4-mipi-zhi-chi-de-tu-xiang-ge-shi">4 mipi支持的图像格式</span><a href="#4-mipi-zhi-chi-de-tu-xiang-ge-shi" class="header-anchor">#</a></h1><p>MIPI CSI 共支持五種pixel資料格式的傳輸， 包含 YUV422-8bit、 YUV422-10bit、 RAW8、RAW10 和 RAW12。</p>
<h2><span id="4-1-rgb-ge-shi">4.1 RGB格式</span><a href="#4-1-rgb-ge-shi" class="header-anchor">#</a></h2><p>传统的红绿蓝格式，比如RGB565，RGB888，其16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RGB565</td>
<td>1. 每个像素用16位表示，RGB分量分别使用5位、6位、5位。2. 内存中排列（高字节-&gt;低字节）：R R R R R G G G G G G B B B B B</td>
</tr>
<tr>
<td>RGB555</td>
<td>1. 每个像素用16位表示，RGB分量都使用5位（剩下1位不用）2. 内存中排列（高字节-&gt;低字节）：X R R R R G G G G G B B B B B（X表示不用，可以忽略）</td>
</tr>
<tr>
<td>RGB24（RGB888）</td>
<td>1. 每个像素用24位表示，RGB分量各使用8位。在内存中RGB各分量的排列顺序为：BGR BGR BGR ……2. 内存中排列（高字节-&gt;低字节）：B B B B B B B B G G G G G G G G R R R R R R R R</td>
</tr>
<tr>
<td>ARGB32（ARGB8888）</td>
<td>1. 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）2. 内存中排列（高字节-&gt;低字节）：B B B B B B B B G G G G G G G G R R R R R R R R A A A A A A A A</td>
</tr>
</tbody></table>
<h2><span id="4-2-yuv-ge-shi">4.2 YUV格式</span><a href="#4-2-yuv-ge-shi" class="header-anchor">#</a></h2><p>YUV是一种色彩编码方法，是一种彩色编码系统，相对于RGB色彩空间，YUV传输带宽占用更低，传输数据不易出错。</p>
<p>Y’UV、YUV、YCbCr、YPbPr 几个概念其实是一回事儿。由于历史关系，Y’UV、YUV 主要是用在彩色电视中，用于模拟信号表示。YCbCr 是用在数字视频、图像的压缩和传输，如 MPEG、JPEG。今天大家所讲的 YUV 其实就是指 YCbCr。Y 表示亮度（luma），CbCr 表示色度（chroma）。</p>
<p>人眼的视觉特点是对亮度更敏感，对位置、色彩相对来说不敏感。所以在视频编码系统中为了降低带宽，可以保存更多的亮度信息(luma)，保存较少的色差信息(chroma)。</p>
<p>luminance 亮度，luma 是在视频编码系统中指亮度值；</p>
<p>chrominance 色度，chroma 是在视频编码系统中指色度值。</p>
<p>Y’UV 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是(UV)，那么在彩色电视显示的时候只显示亮度信息。</p>
<p>YUV是一个比较笼统地说法，针对它的具体排列方式，可以分为很多种具体的格式。色度(UV)定义了颜色的两个方面─色调与饱和度，分别用CB和CR表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。</p>
<h3><span id="4-2-1-yuv-cai-yang-mo-shi-subsamping">4.2.1 YUV采样模式(subsamping)</span><a href="#4-2-1-yuv-cai-yang-mo-shi-subsamping" class="header-anchor">#</a></h3><p>原则：在数字图像中<br>    1) 每一个图形像素都要包含 luma（亮度）值；<br>    2）几个图形像素共用一个 Cb + Cr 值，一般是 2、4、8 个像素。</p>
<p>主要的采样格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和 YCbCr 4:4:4。</p>
<h4><span id="4-2-1-1-yuv444-cai-yang">4.2.1.1 YUV444采样</span><a href="#4-2-1-1-yuv444-cai-yang" class="header-anchor">#</a></h4><p>全采样，对每个像素点的的YUV分量都进行采样，这样的三个分量信息量完整。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br></pre></td></tr></table></figure>
<p>那么1920<em>1080文件的大小：1920</em>1080*3（B），那么一个像素对应3个字节。</p>
<h4><span id="4-2-1-2-yuv422-cai-yang">4.2.1.2 YUV422采样</span><a href="#4-2-1-2-yuv422-cai-yang" class="header-anchor">#</a></h4><p>部分采样，可节省1&#x2F;3存储空间和1&#x2F;3的数据传输量。UV分量是Y分量采样的一半，Y分量和UV 分量按照2 : 1的比例采样。如果水平方向有10个像素点，那么采样了10个Y分量，而只采样了5个UV分量。其中，每采样过一个像素点，都会采样其Y分量，而U、V分量就会间隔一个采集一个。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[y u] [y v] [y u] [y v]</span><br><span class="line">[y v] [y u] [y v] [y u]</span><br><span class="line">[y u] [y v] [y u] [y v]</span><br><span class="line">[y v] [y u] [y v] [y u]</span><br></pre></td></tr></table></figure>
<p>1920<em>1080文件的大小：1920</em>1080+1920<em>1080</em>0.5+1920<em>1080</em>0.5（B），那么UV的数量减少了一半，相对于YUV444空间节省了1&#x2F;3。</p>
<h4><span id="4-2-1-3-yuv420-cai-yang">4.2.1.3 YUV420采样</span><a href="#4-2-1-3-yuv420-cai-yang" class="header-anchor">#</a></h4><p>部分采样，可节省1&#x2F;2存储空间和1&#x2F;2的数据传输量。YUV 420采样，并不是指只采样U分量而不采样V分量。而是指，在每一行扫描时，只扫描一种色度分量（U或者V）和Y分量按照2 : 1的方式采样。比如，第一行扫描时，YU 按照 2 : 1的方式采样，那么第二行扫描时，YV分量按照 2:1的方式采样。对于每个色度分量来说，它的水平方向和竖直方向的采样和Y分量相比都是2:1 。其实yuv420的取名方式不是很高明，更确切的命名为yuv420yuv402，也就是第一行只有U，而第二行只有V。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[y u] [y] [y u] [y]</span><br><span class="line">[y v] [y] [y v] [y]</span><br><span class="line">[y u] [y] [y u] [y]</span><br><span class="line">[y v] [y] [y v] [y]</span><br></pre></td></tr></table></figure>

<p>1920<em>1080文件的大小：1920</em>1080+1920<em>1080</em>0.25+1920<em>1080</em>0.25（B）相对于YUV444空间节省1&#x2F;2，因此也是比较主流的采样方式。</p>
<h3><span id="4-2-2-yuv-cun-chu-fang-shi">4.2.2 YUV存储方式</span><a href="#4-2-2-yuv-cun-chu-fang-shi" class="header-anchor">#</a></h3><p>YUV的格式有两大类：<strong>planar（平面格式）和packed（打包格式）</strong>。</p>
<h4><span id="4-2-2-1-planner-cun-chu">4.2.2.1 planner存储</span><a href="#4-2-2-1-planner-cun-chu" class="header-anchor">#</a></h4><p>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。</p>
<p>一般默认是3个平面，即y平面，u平面，v平面。但还有一种semi-planar是两个平面。也就是说uv为同一个平面，即一个y平面，一个uv平面。</p>
<h5><span id="4-2-2-1-1-yuv420-planner">4.2.2.1.1 yuv420 planner</span><a href="#4-2-2-1-1-yuv420-planner" class="header-anchor">#</a></h5><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/21.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/22.png" alt="img"></p>
<p>例如：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/23.png" alt="img"></p>
<p>可以看到第一行的Y1Y2和第二行的Y7Y8共同使用一组U1V1。</p>
<h5><span id="4-2-2-1-2-yuv420sp">4.2.2.1.2 yuv420sp</span><a href="#4-2-2-1-2-yuv420sp" class="header-anchor">#</a></h5><p> two-planer双平面，Y一个平面，UV在同一个平面交叉存储。也叫做semi-planar的YUV格式。</p>
<ol>
<li><p>nv12</p>
<p>先存储全部的Y分量，然后UV分量交叉存储。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/24.png" alt="img"></p>
</li>
<li><p>nv21</p>
<p>先UV分量交叉存储, 然后存储全部的Y分量。</p>
</li>
</ol>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/25.png" alt="img"></p>
<h5><span id="4-2-2-1-3-yuv422-planner">4.2.2.1.3 yuv422 planner</span><a href="#4-2-2-1-3-yuv422-planner" class="header-anchor">#</a></h5><p>3平面，数据量：u&#x3D;v&#x3D;y&#x2F;2，不画图展示</p>
<h5><span id="4-2-2-1-4-yuv422sp">4.2.2.1.4 yuv422sp</span><a href="#4-2-2-1-4-yuv422sp" class="header-anchor">#</a></h5><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/26.png" alt="img"></p>
<p>可以看到y0y82个像素公用一组u0v0。</p>
<h4><span id="4-2-2-2-packed-cun-chu">4.2.2.2 packed存储</span><a href="#4-2-2-2-packed-cun-chu" class="header-anchor">#</a></h4><p>packed的YUV格式，每个像素点的Y、U、V都是连续交叉存储的。</p>
<h5><span id="4-2-2-2-1-yuyv">4.2.2.2.1 yuyv</span><a href="#4-2-2-2-1-yuyv" class="header-anchor">#</a></h5><p>该格式属于4：2：2类型，且是用packed形式存储的，相邻的2个像素共用一个Cb(U)和Cr(V)，以16个像素为例如下图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/27.png" alt="img"></p>
<h5><span id="4-2-2-2-2-yvyu">4.2.2.2.2 yvyu</span><a href="#4-2-2-2-2-yvyu" class="header-anchor">#</a></h5><p>与YUYV相似，只是存储时UV分量顺序不同而已。</p>
<p>4.2.2.2.2 uyvy</p>
<p>与YUYV相似，只是存储时UV分量顺序不同而已。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/28.png" alt="img"></p>
<h2><span id="4-3-raw-ge-shi">4.3 RAW 格式</span><a href="#4-3-raw-ge-shi" class="header-anchor">#</a></h2><p>RAW图像就是CMOS或者CCD图像感应器将捕捉到的光源信号转化为数字信号的原始数据。RAW文件是一种记录了数码相机传感器的原始信息，同时记录了由相机拍摄所产生的一些元数据（Metadata，如ISO的设置、快门速度、光圈值、白平衡等）的文件。RAW是未经处理、也未经压缩的格式，可以把RAW概念化为“原始图像编码数据”或更形象的称为“数字底片”。Raw data（Raw RGB）经过彩色插值就变成RGB。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/29.png" alt="img"></p>
<p>sensor上每个像素只采集特定颜色的光的强度，因此sensor每个像素只能为R或G或B 。</p>
<h3><span id="4-3-1-bayer-zhen-lie">4.3.1 bayer阵列</span><a href="#4-3-1-bayer-zhen-lie" class="header-anchor">#</a></h3><p>人眼对绿色比较敏感，所以一般bayer格式的图片绿色格式的像素是是r和g像素的和，那么bayer格式一般有下面4种：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/30.png" alt="img"></p>
<h1><span id="5-mipi-csi-shu-ju-bao-chuan-shu">5 mipi csi数据包传输</span><a href="#5-mipi-csi-shu-ju-bao-chuan-shu" class="header-anchor">#</a></h1><p>raw8格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/31.png" alt="img"></p>
<p>raw10格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/32.png" alt="img"></p>
<p>raw12格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/33.png" alt="img"></p>
<p> 从图像看，RAW8是一传输个字节对应一个pixel， 而raw10是5个byte去对应4个pixel，第5个byte用来存储pixel 0~3的bit[0:1]。同理raw12用3个byte存储2个pixel。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/34.png" alt="img"></p>
<h1><span id="6-se-cai-shen-du">6 色彩深度</span><a href="#6-se-cai-shen-du" class="header-anchor">#</a></h1><p>8位彩色，有256种深度。<br>16位彩色：65,536种颜色。<br>24位彩色：每种原色都有256个层次，它们的组合便有256<em>256</em>256种颜色。<br>32位彩色：除了24位彩色的颜色外，额外的8位是储存重叠图层的图形资料(alpha透明度)。</p>
<h1><span id="7-tu-xiang-jie-xi-du-x2f-fen-bian-lu">7 图像解析度&#x2F;分辨率</span><a href="#7-tu-xiang-jie-xi-du-x2f-fen-bian-lu" class="header-anchor">#</a></h1><p>Resolution：</p>
<table>
<thead>
<tr>
<th>1280 * 720 &#x3D; 921600</th>
<th>1M</th>
<th>100万像素</th>
<th>720P</th>
<th>H65 sensor</th>
</tr>
</thead>
<tbody><tr>
<td>1920 * 1080 &#x3D; 2073600</td>
<td>2M</td>
<td>200万像素</td>
<td>1080P</td>
<td>Imx307&#x2F;imx327 sensor</td>
</tr>
<tr>
<td>2560 * 1440 &#x3D; 36864002560 * 1600 &#x3D; 40960002592 * 1944 &#x3D; 5038848</td>
<td>4M&#x2F;5M</td>
<td>400万像素500万像素</td>
<td>2K</td>
<td>Imx335&#x2F;sc4210 sensor</td>
</tr>
<tr>
<td>3840 * 2160 &#x3D; 8294400</td>
<td>8M</td>
<td>800万像素</td>
<td>4K</td>
<td>Imx334 sensor</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>mipi图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>mipi-csi硬件篇</title>
    <url>/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mipi-csi-ying-jian">1 mipi-csi硬件</a><ul>
<li><a href="#1-1-mipi-csi-gai-nian">1.1 mipi-csi概念</a></li>
<li><a href="#1-2-mipi-vs-dvp">1.2 MIPI vs DVP</a></li>
<li><a href="#1-3-csi-gui-ge">1.3 CSI规格</a></li>
<li><a href="#1-4-csi-jie-kou-lei-xing">1.4 CSI接口類型</a></li>
<li><a href="#1-5-csi-ying-jian-yin-jiao-ji-jie-xian">1.5 CSI 硬件引脚及接线</a><ul>
<li><a href="#1-5-1-mipi-sensor-yin-jiao-miao-shu">1.5.1 mipi sensor引脚描述:</a></li>
<li><a href="#1-5-2-dian-lu-tu-xian-lu-jie-gou">1.5.2 电路图线路结构</a></li>
</ul>
</li>
<li><a href="#1-6-chai-fen-xin-hao-jie-shao">1.6 差分信号介绍</a></li>
<li><a href="#1-7-mipi-sensor-de-power-on-shi-xu">1.7 MIPI sensor的 power on时序</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# 1 mipi-csi硬件

<h2><span id="1-1-mipi-csi-gai-nian">1.1 mipi-csi概念</span><a href="#1-1-mipi-csi-gai-nian" class="header-anchor">#</a></h2><p><strong>DSI （Display serial interface）</strong>定义了一个位于处理器和显示模组之间的高速串行接口,对应MIPI-TX.<br><strong>CSI(Camera Serial Interface）</strong>定义了一个位于处理器和摄像模组之间的高速串行接口,也就是接下来要讲的MIPI-RX。</p>
<p>MIPI Rx (Mobile Industry Processor Interface Receiver) 模塊主要功能為接收由 CMOS sensor 所傳送的視頻數據， 支持 MIPI D-PHY、 sub-LVDS (Low-Voltage Differential Signal)、 HiSPi (High-Speed Serial Pixel Interface) 等不同的串行視頻信號輸入， 並將其處理轉化為內部視頻時序，傳遞給下一級的視頻處理模塊 (ISP)。MIPI Rx 模塊中可細分為 PHY 和 Controller 兩部分，其中 PHY 模塊集成了模擬和數字兩個部分，主要將串行信號轉換為並行信號，而 Controller 模塊則負責解碼不同的視頻數據格式，傳送給後端的視頻處理模塊 (ISP)。功能框圖及在系統中的位置如下图所示:</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/1.png" alt="img"></p>
<h2><span id="1-2-mipi-vs-dvp">1.2 MIPI vs DVP</span><a href="#1-2-mipi-vs-dvp" class="header-anchor">#</a></h2><p><strong>DVP:</strong></p>
<p>并口传输数据需要帧同步信号（Vsync）、行同步信号（Hsync）和八条数据线，共十根数据线, DVP 接口在信号完整性方面受限制，速率也受限制。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/2.png" alt="img"></p>
<p><strong>MIPI:</strong></p>
<p>MIPI 传输只需要帧同步信号（Vsync）、行同步信号（Hsync）、mipi 时钟（mipi_clk）、mipi 数据（mipi_data）和像素时钟（PCLK）5 根数据线。对比MIPI 接口比 DVP 的接口信号线少，由于是低压差分信号，产生的干扰小，抗干扰能力也强。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/3.png" alt="img"></p>
<h2><span id="1-3-csi-gui-ge">1.3 CSI规格</span><a href="#1-3-csi-gui-ge" class="header-anchor">#</a></h2><p>可同時支持 2 路 sensor 輸入（2组D-PHY， 每组5对差分线（1C4D））</p>
<p>• sensor 0 最大支持 4K2K @60fps HDR or @30fps 線性輸入</p>
<p>• sensor 1 最大支持 3M(2304x1296) @60fps HDR or linear 輸入</p>
<p>• 單路最多支持 4-Lane MIPI D-PHY 接口，最大支持 2.5Gbps&#x2F;Lane</p>
<p>• 單路最多支持 4-Lane sub-LVDS&#x2F; HiSPi 接口，最大支持 1.5Gbps&#x2F;Lane</p>
<p>• 支持 RAW8&#x2F; RAW10&#x2F; RAW12 數據類型的解析</p>
<p>• 支持 YUV422 8-bit&#x2F; YUV422 10-bit 數據類型的解析</p>
<p>• 最多支持 2 幀 WDR，支持多種 WDR 時序</p>
<p>• 支持 sub-LVDS&#x2F; HiSPi 模式像素&#x2F;同步碼大小端配置</p>
<p>• 支持 Lane 數和 Lane 順序可配置</p>
<p>MIPI Rx 的帶寬有兩部分限制： PHY 的接口數據率和內部處理速度。</p>
<p>輸入接口最大支持 2.5Gbps&#x2F;Lane，內部處理速度最大為 600M*1pixels&#x2F;s（MAC clk）</p>
<h2><span id="1-4-csi-jie-kou-lei-xing">1.4 CSI接口類型</span><a href="#1-4-csi-jie-kou-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>Common modevoltage</th>
<th>Differential modevoltage</th>
<th>Maximum clockfrequency</th>
<th>Maximum datarate per lane</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MIPI DPHY</strong> 200mV</td>
<td>200mV</td>
<td>1.25GHz</td>
<td>2.5Gbps</td>
</tr>
<tr>
<td>Sub-LVDS 900mV</td>
<td>150mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
<tr>
<td>HiSPi(HiVCM) 900mV</td>
<td>280mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
<tr>
<td>HiSPi(SLVDS) 200mV</td>
<td>200mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
</tbody></table>
<h2><span id="1-5-csi-ying-jian-yin-jiao-ji-jie-xian">1.5 CSI 硬件引脚及接线</span><a href="#1-5-csi-ying-jian-yin-jiao-ji-jie-xian" class="header-anchor">#</a></h2><p>常用的电脑摄像头是USB接口, 主流的智能手机摄像头是MIPI接口, 下面讲解常用的智能手机 camera MIPI接口。</p>
<p>MIPI CSI一般会有1对I2C通信引脚，1对MIPI差分时钟引脚和1~4对MIPI差分数据信号引脚, 也就是1CD4(1 clk lane &amp; 4 data lane)。</p>
<h3><span id="1-5-1-mipi-sensor-yin-jiao-miao-shu">1.5.1 mipi sensor引脚描述:</span><a href="#1-5-1-mipi-sensor-yin-jiao-miao-shu" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>信号名</th>
<th>引脚类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DOVDD</td>
<td>电源</td>
<td>1.8V IO 电源</td>
</tr>
<tr>
<td>DVDD</td>
<td>电源</td>
<td>1.2V 数字电源</td>
</tr>
<tr>
<td>AVDD</td>
<td>电源</td>
<td>2.8V 模拟电源</td>
</tr>
<tr>
<td>SCL</td>
<td>输入</td>
<td>I2C 时钟线</td>
</tr>
<tr>
<td>SDA</td>
<td>输入&#x2F;输出</td>
<td>I2C 数据线(open drain)</td>
</tr>
<tr>
<td>SID0</td>
<td>输入</td>
<td>I2C Device ID 的选择 0 (内置下拉电阻，默认Device ID 是 7’h30)</td>
</tr>
<tr>
<td>SID1</td>
<td>输入</td>
<td>I2C Device ID 的选择 1 (内置下拉电阻，默认Device ID 是 7’h30)</td>
</tr>
<tr>
<td>XSHUTDN （RST）</td>
<td>输入</td>
<td>复位信号输入(内置上拉电阻，低电位有效)</td>
</tr>
<tr>
<td>EXTCLK</td>
<td>输入</td>
<td>时钟输入</td>
</tr>
<tr>
<td>PWDNB</td>
<td>输入</td>
<td>Power Down 信号输入(内置上拉电阻， 低电位有效)</td>
</tr>
<tr>
<td>D&lt;3&gt;(MD3P)</td>
<td>输出</td>
<td>DVP 输出 bit[3]&#x2F;MIPI 数据 3 正极信号</td>
</tr>
<tr>
<td>D&lt;5&gt;(MD1P)</td>
<td>输出</td>
<td>DVP 输出 bit[5]&#x2F;MIPI 数据 1 正极信号</td>
</tr>
<tr>
<td>D&lt;7&gt;(MCP)</td>
<td>输出</td>
<td>DVP 输出 bit[7]&#x2F;MIPI 时钟正极信号</td>
</tr>
<tr>
<td>D&lt;8&gt;(MD0P)</td>
<td>输出</td>
<td>DVP 输出 bit[8]&#x2F;MIPI 数据 0 正极信号</td>
</tr>
<tr>
<td>D&lt;10&gt;(MD2P)</td>
<td>输出</td>
<td>DVP 输出 bit[10]&#x2F;MIPI 数据 2 正极信号</td>
</tr>
<tr>
<td>D&lt;4&gt;(MD3N)</td>
<td>输出</td>
<td>DVP 输出 bit[4]&#x2F;MIPI 数据 3 负极信号</td>
</tr>
<tr>
<td>D&lt;6&gt;(MD1N)</td>
<td>输出</td>
<td>DVP 输出 bit[6]&#x2F;MIPI 数据 1 负极信号</td>
</tr>
<tr>
<td>PCLK(MCN)</td>
<td>输出</td>
<td>DVP 输出时钟&#x2F;MIPI 时钟负极信号</td>
</tr>
<tr>
<td>D&lt;9&gt;(MD0N)</td>
<td>输出</td>
<td>DVP 输出 bit[9]&#x2F;MIPI 数据 0 负极信号</td>
</tr>
<tr>
<td>D&lt;11&gt;(MD2N)</td>
<td>输出</td>
<td>DVP 输出 bit[11]&#x2F;MIPI 数据 2 负极信号</td>
</tr>
</tbody></table>
<h3><span id="1-5-2-dian-lu-tu-xian-lu-jie-gou">1.5.2 电路图线路结构</span><a href="#1-5-2-dian-lu-tu-xian-lu-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/4.png" alt="img"></p>
<p>一般mipi接口的sensor支持4 lane，2 lane，1 lane等数据传输方式。上图硬件上的连接了1组clk lane, 4组data lane。这幅图只连接了i2c和lane总线，还有EXTCLK ，PWDN, RST, VDD等引脚的连线需要外部soc去提供。这里就需要驱动人员会看原理图，知道lane id和pn swap的接线。clk lane, data lane等。</p>
<h2><span id="1-6-chai-fen-xin-hao-jie-shao">1.6 差分信号介绍</span><a href="#1-6-chai-fen-xin-hao-jie-shao" class="header-anchor">#</a></h2><p>我们用一个方法对差分信号做一下比喻，差分信号就好比是跷跷板上的两个人，当一个人被跷上去的时候，另一个人被跷下来了 - 但是他们的平均位置是不变的。继续跷跷板的类推，正值可以表示左边的人比右边的人高，而负值表示右边的人比左边的人高。0 表示两个人都是同一水平。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/5.png" alt="img"></p>
<p>下图，应用到电学上，这两个跷跷板用一对标识为V+和V-的导线来表示。当V+ &gt; V-时，信号定义成正极信号，V+ &lt; V-时，信号定义成负极信号。 差分对的平均电压设置成 2.5V。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/6.png" alt="img"></p>
<h2><span id="1-7-mipi-sensor-de-power-on-shi-xu">1.7 MIPI sensor的 power on时序</span><a href="#1-7-mipi-sensor-de-power-on-shi-xu" class="header-anchor">#</a></h2><p><strong>Sony imx334：</strong></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/7.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/8.png" alt="img"></p>
<p><strong>SC4210：</strong></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/9.png" alt="img"></p>
<p>这里列举了sony imx334和格科微gc2093, sc4210的上电时序，现在市面上大部分的mipi接口sensor都可以让VDD，PWDN, RST，EXTCLK讯号同时发出，然后过一段时间后就可以进行I2c通信了。</p>
<p>在HW交接到SW后，要确保最基本的power on时序是ok的，最好是用示波器对VDD，PWDN, RST，EXTCLK，I2c等波形进行测量无误后再porting到SW手上。</p>
]]></content>
      <tags>
        <tag>mipi图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-ADC</title>
    <url>/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-adc-ying-jian-yuan-li">1 ADC硬件原理</a><ul>
<li><a href="#1-1-adc-shu-xing">1.1 ADC属性</a></li>
<li><a href="#1-2-adc-kuang-tu">1.2 ADC框图</a></li>
</ul>
</li>
<li><a href="#2-adc-ji-cun-qi">2 ADC寄存器</a><ul>
<li><a href="#2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</a></li>
<li><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</a></li>
<li><a href="#2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</a></li>
</ul>
</li>
<li><a href="#3-bian-cheng-ce-shi">3 编程测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-adc-ying-jian-yuan-li">1 ADC硬件原理</span><a href="#1-adc-ying-jian-yuan-li" class="header-anchor">#</a></h1><p>模数转换器即A&#x2F;D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。</p>
<p>如图，把可变电阻上的电压值变换的模拟信号通过ADC转换，输出数字信号。以s3c2440为例：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/1.jpg"></p>
<h2><span id="1-1-adc-shu-xing">1.1  ADC属性</span><a href="#1-1-adc-shu-xing" class="header-anchor">#</a></h2><p>对于数字信号我们需要得到它的2个属性：</p>
<ol>
<li><p>转换精度：<br>用多少位来存储这个数据（假如是10 bit）。那么最大值0b111111111对应3.3v， 0b0对应0v。</p>
</li>
<li><p>采样&#x2F;转换速度：</p>
</li>
</ol>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/2.png"><br>可以看出s3c2440的转换精度可达10 bit, 转换速率可达 500ksps.</p>
<h2><span id="1-2-adc-kuang-tu">1.2 ADC框图</span><a href="#1-2-adc-kuang-tu" class="header-anchor">#</a></h2><p>下图是s3c2440芯片的ADC转换框图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/3.png"></p>
<p>可以看出AD converter前有一个MUX选择器，用来选择模拟输入源，这里选择A[3:0]作为输入源。</p>
<p>下面是编写程序要做的步骤：</p>
<pre><code>1.确定是哪一路信号：设置8：1MUX
2.设置工作时钟
3.启动ADC
4.读状态，判断ADC转换是否成功。
5.读数据
</code></pre>
<h1><span id="2-adc-ji-cun-qi">2 ADC寄存器</span><a href="#2-adc-ji-cun-qi" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</span><a href="#2-1-kong-zhi-ji-cun-qi-adccon" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/4.png"></p>
<pre><code>bit[15]：只读，用来表示转换是否完成
bit[14:6]:用来设置adc频率（如果是auto TSC则不用设置该位）
bit[5：3]:用来选择模拟输入源
bit[2]:用来设置是否待机
bit[0]:用来启动adc
</code></pre>
<h2><span id="2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</span><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/5.png"></p>
<h2><span id="2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</span><a href="#2-3-shu-ju-ji-cun-qi-adcdat0" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/6.png"></p>
<pre><code>bit[9:0]表示转换后的数据
</code></pre>
<h1><span id="3-bian-cheng-ce-shi">3 编程测试</span><a href="#3-bian-cheng-ce-shi" class="header-anchor">#</a></h1><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/7.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>); <span class="comment">//设置输入源AIN0, ADC时钟为1Mhz,并且使能预分频</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">adc_read_ain0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">		<span class="comment">/* 启动ADC */</span></span><br><span class="line">	ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!(ADCCON &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)));  <span class="comment">/* 等待ADC结束 */</span></span><br><span class="line">	<span class="keyword">return</span> ADCDAT0 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核顶层Makefile详解</title>
    <url>/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-kernel-bian-yi-chu-ti-yan">1 kernel编译初体验</a></li>
<li><a href="#2-kernel-yuan-ma-mu-lu-jie-gou-fen-xi">2 kernel源码目录结构分析</a><ul>
<li><a href="#2-1-arch-mu-lu">2.1 arch 目录</a></li>
<li><a href="#2-1-1-arch-arm-configs">2.1.1 arch&#x2F;arm&#x2F;configs</a></li>
<li><a href="#2-1-2-arch-arm-boot-dts">2.1.2 arch&#x2F;arm&#x2F;boot&#x2F;dts</a></li>
<li><a href="#2-1-3-arch-arm-boot">2.1.3 arch&#x2F;arm&#x2F;boot</a></li>
<li><a href="#2-1-4-arch-arm-mach-xxx">2.1.4 arch&#x2F;arm&#x2F;mach-xxx</a></li>
<li><a href="#2-2-block-mu-lu">2.2 block 目录</a></li>
<li><a href="#2-3-crypto-mu-lu">2.3 crypto 目录</a></li>
<li><a href="#2-4-documentation-mu-lu">2.4 Documentation 目录</a></li>
<li><a href="#2-5-drivers-mu-lu">2.5 drivers 目录</a></li>
<li><a href="#2-6-firmware-mu-lu">2.6 firmware 目录</a></li>
<li><a href="#2-7-fs-mu-lu">2.7 fs 目录</a></li>
<li><a href="#2-8-init-mu-lu">2.8 init 目录</a></li>
<li><a href="#2-9-ipc-mu-lu">2.9 ipc 目录</a></li>
</ul>
</li>
<li><a href="#3-vscode-gong-cheng-chuang-jian">3 VSCode 工程创建</a></li>
<li><a href="#4-linux-ding-ceng-makefile-fen-xi">4 linux顶层 Makefile分析</a><ul>
<li><a href="#4-1-ban-ben-hao">4.1 版本号</a></li>
<li><a href="#4-2-makeflags-bian-liang">4.2 MAKEFLAGS 变量</a></li>
<li><a href="#4-3-ming-ling-shu-chu-xiang-xi-cheng-du">4.3 命令输出详细程度</a></li>
<li><a href="#4-4-she-zhi-bian-yi-jie-guo-shu-chu-mu-lu">4.4 设置编译结果输出目录</a></li>
<li><a href="#4-5-dai-ma-jian-cha">4.5 代码检查</a></li>
<li><a href="#4-6-zi-mo-kuai-bian-yi">4.6 子模块编译</a></li>
<li><a href="#4-7-she-zhi-mu-biao-jia-gou-he-jiao-cha-bian-yi-qi">4.7 设置目标架构和交叉编译器</a></li>
<li><a href="#4-8-diao-yong-scripts-kbuild-include">4.8 调用 scripts&#x2F;Kbuild.include</a></li>
<li><a href="#4-9-tou-wen-jian-lu-jing-bian-liang">4.9 头文件路径变量</a></li>
<li><a href="#4-10-he-xin-bian-liang-dao-chu">4.10 核心变量导出</a></li>
</ul>
</li>
<li><a href="#5-linux-nei-he-defconfig-guo-cheng">5 linux内核defconfig过程</a><ul>
<li><a href="#5-1-pei-zhi-bian-liang">5.1 配置变量</a></li>
<li><a href="#5-2-zhi-xing-3-ge-yi-lai">5.2 执行3个依赖</a><ul>
<li><a href="#5-2-1-scripts-basic">5.2.1 scripts_basic</a><ul>
<li><a href="#5-2-1-1-scripts-makefile-build-fen-xi">5.2.1.1 scripts&#x2F;Makefile.build分析</a></li>
</ul>
</li>
<li><a href="#5-2-2-outputmakefile">5.2.2 outputmakefile：</a></li>
<li><a href="#5-2-3-force">5.2.3 FORCE：</a></li>
</ul>
</li>
<li><a href="#5-3-chan-sheng-config">5.3 产生.config</a><ul>
<li><a href="#5-3-1-ji-xu-scripts-makefile-build-fen-xi">5.3.1 继续scripts&#x2F;Makefile.build分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-nei-he-bian-yi-xuan-xiang">6 内核编译选项</a><ul>
<li><a href="#6-1-ccflags-y-asflags-y-he-ldflags-y">6.1 ccflags-y asflags-y和ldflags-y</a></li>
<li><a href="#6-2-subdir-ccflags-y-subdir-asflags-y">6.2 subdir-ccflags-y, subdir-asflags-y</a></li>
<li><a href="#6-3-cflags-mod-xxx">6.3 CFLAGS_MOD_XXX</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-kernel-bian-yi-chu-ti-yan">1 kernel编译初体验</span><a href="#1-kernel-bian-yi-chu-ti-yan" class="header-anchor">#</a></h1><p>编译内核之前需要先在 ubuntu 上安装 lzop 库：<br><code>sudo apt-get install lzop</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_v7_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all -j16</span><br></pre></td></tr></table></figure>

<p>这里选择的是imx_v7_defconfig:<br><code>scripts/kconfig/conf  --defconfig=arch/arm/configs/imx_v7_defconfig Kconfig</code><br>Linux 的图行界面配置和 uboot 是一样的，这里我们不需要做任何的配置，直接按两下 ESC键退出，退出图形界面以后会自动开始编译Linux：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/1.png" alt="image"><br>编译完成后如下图：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/2.png" alt="image"><br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/3.png" alt="image"><br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/4.png" alt="image"><br>先编译出zimage,各种dtb，最后编译出ko。</p>
<details>
<summary>distclean过程</summary>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean V=1</span><br><span class="line">make -f ./scripts/Makefile.clean obj=.</span><br><span class="line">  rm -f ./kernel/bounds.s ./arch/arm/kernel/asm-offsets.s</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/common</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/crypto</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/firmware</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/kernel</span><br><span class="line">  rm -f arch/arm/kernel/vmlinux.lds</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/kvm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/lib</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/mm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/net</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/nwfpe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/oprofile</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/probes</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/probes/kprobes</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/probes/uprobes</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/vdso</span><br><span class="line">  rm -f arch/arm/vdso/vdso.lds arch/arm/vdso/vgettimeofday.o arch/arm/vdso/datapage.o arch/arm/vdso/vdso.so arch/arm/vdso/vdso.so.dbg arch/arm/vdso/vdso.so.raw arch/arm/vdso/vdso.lds arch/arm/vdso/vdsomunge</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/vfp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/xen</span><br><span class="line">make -f ./scripts/Makefile.clean obj=block</span><br><span class="line">make -f ./scripts/Makefile.clean obj=block/partitions</span><br><span class="line">make -f ./scripts/Makefile.clean obj=crypto</span><br><span class="line">make -f ./scripts/Makefile.clean obj=crypto/asymmetric_keys</span><br><span class="line">make -f ./scripts/Makefile.clean obj=crypto/async_tx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/accessibility</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/accessibility/braille</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/acpi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/acpi/acpica</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/acpi/apei</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/amba</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/android</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ata</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/atm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/auxdisplay</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/base</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/base/power</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/base/regmap</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/bcma</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/block</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/block/drbd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/block/mtip32xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/block/rsxx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/block/xen-blkback</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/block/zram</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/block/aoe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/block/paride</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/bluetooth</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/bus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/cdrom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/agp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/hw_random</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/imx_amp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/mwave</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/pcmcia</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/tpm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/tpm/st33zp24</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/xilinx_hwicap</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/xillybus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/char/ipmi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/at91</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/bcm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/berlin</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/hisilicon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/keystone</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/mvebu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/mxs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/pistachio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/pxa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/qcom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/rockchip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/samsung</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/shmobile</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/sirf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/socfpga</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/spear</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/st</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/sunxi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/tegra</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/ti</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/ux500</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/versatile</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/x86</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clk/zynq</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/clocksource</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/connector</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/cpufreq</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/cpuidle</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/cpuidle/governors</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/amcc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/caam</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/ccp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/nx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/qat</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/qat/qat_common</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/qat/qat_dh895xcc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/qce</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/ux500</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/ux500/cryp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/ux500/hash</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/crypto/vmx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dca</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/devfreq</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/devfreq/event</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/devfreq/exynos</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/bestcomm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/dw</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/hsu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/ioat</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/ipu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/ppc4xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/pxp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/sh</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma/xilinx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/dma-buf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/edac</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/eisa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/extcon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/firewire</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/firmware</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/firmware/efi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/firmware/efi/libstub</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/firmware/google</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/fmc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/amd/amdkfd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/armada</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/ast</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/atmel-hlcdc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/bochs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/bridge</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/cirrus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/exynos</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/gma500</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/i2c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/i810</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/i915</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/imx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/mga</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/mgag200</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/msm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/nouveau</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/omapdrm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/panel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/qxl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/r128</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/radeon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/rcar-du</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/rockchip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/savage</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/shmobile</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/sis</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/sti</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/tdfx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/tegra</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/tilcdc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/ttm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/udl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/vgem</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/via</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/vivante</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/drm/vmwgfx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/host1x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/ipu-v3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/gpu/vga</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hid</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hid/i2c-hid</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hid/usbhid</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hsi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hsi/clients</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hsi/controllers</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hwmon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hwmon/pmbus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hwspinlock</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/hwtracing/coresight</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/i2c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/i2c/algos</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/i2c/busses</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/i2c/muxes</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ide</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/idle</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/accel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/adc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/amplifiers</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/common</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/common/hid-sensors</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/common/ssp_sensors</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/common/st_sensors</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/dac</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/frequency</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/gyro</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/humidity</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/imu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/imu/inv_mpu6050</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/light</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/magnetometer</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/orientation</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/pressure</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/proximity</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/temperature</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iio/trigger</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/amso1100</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/cxgb3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/cxgb4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/ehca</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/ipath</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/mlx4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/mlx5</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/mthca</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/nes</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/ocrdma</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/qib</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/hw/usnic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/ulp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/ulp/ipoib</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/ulp/iser</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/ulp/isert</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/ulp/srp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/infiniband/ulp/srpt</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/joystick</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/joystick/iforce</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/keyboard</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/misc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/mouse</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/tablet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/touchscreen</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/touchscreen/vtl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/gameport</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/input/serio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/iommu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ipack</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ipack/carriers</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ipack/devices</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/irqchip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/act2000</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/capi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/divert</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/gigaset</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/hardware</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/hardware/avm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/hardware/eicon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/hardware/mISDN</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/hisax</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/hysdn</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/i4l</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/icn</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/isdnloop</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/mISDN</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/pcbit</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/isdn/sc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/leds</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/leds/trigger</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/lguest</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/macintosh</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/macintosh/ams</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mailbox</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mcb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/md</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/md/bcache</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/md/persistent-data</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/common</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/common/b2c2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/common/saa7146</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/common/siano</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/dvb-core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/dvb-frontends</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/dvb-frontends/drx39xyj</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/firewire</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/i2c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/i2c/cx25840</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/i2c/m5mols</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/i2c/s5c73m3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/i2c/smiapp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/i2c/soc_camera</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/mmc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/mmc/siano</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/b2c2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/bt8xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/cx18</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/cx23885</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/cx25821</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/cx88</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/ddbridge</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/dm1105</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/ivtv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/mantis</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/meye</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/ngene</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/pluto2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/pt1</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/pt3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/saa7134</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/saa7146</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/saa7164</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/smipcie</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/solo6x10</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/sta2x11</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/ttpci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/tw68</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/pci/zoran</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/am437x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/blackfin</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/coda</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/davinci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/exynos-gsc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/exynos4-is</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/marvell-ccic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/mxc/capture</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/mxc/output</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/mxc/subdev</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/omap</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/omap3isp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/s3c-camif</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/s5p-g2d</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/s5p-jpeg</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/s5p-mfc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/s5p-tv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/soc_camera</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/ti-vpe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/vivid</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/vsp1</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/platform/xilinx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/radio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/radio/si470x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/radio/si4713</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/radio/wl128x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/rc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/rc/img-ir</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/rc/keymaps</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/tuners</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/airspy</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/as102</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/au0828</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/b2c2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/cpia2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/cx231xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/dvb-usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/dvb-usb-v2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/em28xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/go7007</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/gspca</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/gspca/gl860</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/gspca/m5602</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/gspca/stv06xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/hackrf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/hdpvr</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/msi2500</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/pvrusb2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/pwc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/s2255</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/siano</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/stk1160</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/stkwebcam</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/tm6000</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/ttusb-budget</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/ttusb-dec</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/usbtv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/usbvision</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/uvc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/usb/zr364xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/media/v4l2-core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/memory</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/memory/tegra</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/memstick</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/memstick/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/memstick/host</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/message</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/message/fusion</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mfd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/altera-stapl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/c2port</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/carma</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/cb710</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/cxl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/echo</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/eeprom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/genwqe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/ibmasm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/lis3lv02d</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/mei</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/mic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/mic/bus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/mic/card</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/mic/host</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/sgi-gru</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/sgi-xp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/ti-st</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/misc/vmw_vmci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mmc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mmc/card</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mmc/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mmc/host</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/chips</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/devices</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/lpddr</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/maps</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/nand</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/nand/bcm47xxnflash</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/nand/gpmi-nand</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/onenand</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/spi-nor</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/tests</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mtd/ubi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mxc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mxc/gpu-viv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mxc/hdmi-cec</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mxc/ipu3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mxc/mipi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mxc/mlb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mxc/sim</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/mxc/vpu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/appletalk</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/arcnet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/bonding</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/caif</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/c_can</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/cc770</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/m_can</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/mscan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/sja1000</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/softing</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/spi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/can/usb/peak_usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/cris</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/dsa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/3com</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/8390</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/adaptec</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/adi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/aeroflex</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/agere</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/allwinner</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/alteon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/altera</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/amd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/amd/xgbe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/apm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/apm/xgene</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/apple</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/arc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/atheros</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/atheros/alx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/atheros/atl1c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/atheros/atl1e</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/atheros/atlx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/broadcom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/broadcom/bnx2x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/broadcom/genet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/brocade</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/brocade/bna</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/cadence</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/calxeda</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/chelsio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/chelsio/cxgb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/chelsio/cxgb3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/chelsio/cxgb4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/chelsio/cxgb4vf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/cirrus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/cisco</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/cisco/enic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/davicom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/dec</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/dec/tulip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/dlink</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/emulex</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/emulex/benet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/faraday</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/freescale</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/freescale/fs_enet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/fujitsu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/hisilicon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/hp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/i825xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/ibm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/ibm/ehea</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/ibm/emac</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/icplus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/e1000</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/e1000e</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/fm10k</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/i40e</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/i40evf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/igb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/igbvf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/ixgb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/ixgbe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/intel/ixgbevf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/marvell</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/mellanox</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/mellanox/mlx4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/mellanox/mlx5/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/micrel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/microchip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/moxa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/myricom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/myricom/myri10ge</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/natsemi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/neterion</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/neterion/vxge</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/nuvoton</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/nvidia</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/nxp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/octeon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/oki-semi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/oki-semi/pch_gbe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/packetengines</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/pasemi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/qlogic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/qlogic/netxen</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/qlogic/qlcnic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/qlogic/qlge</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/qualcomm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/rdc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/realtek</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/renesas</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/rocker</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/samsung</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/samsung/sxgbe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/seeq</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/sfc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/sgi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/silan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/sis</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/smsc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/stmicro</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/stmicro/stmmac</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/sun</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/tehuti</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/ti</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/tile</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/toshiba</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/tundra</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/via</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/wiznet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/xilinx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/xircom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ethernet/xscale</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/fddi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/fddi/skfp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/hamradio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/hippi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/hyperv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ieee802154</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ipvlan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/irda</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/phy</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/plip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/ppp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/slip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/team</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/vmxnet3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wan/lmc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wimax</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wimax/i2400m</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath/ar5523</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath/ath10k</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath/ath5k</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath/ath6kl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath/ath9k</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath/carl9170</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath/wcn36xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ath/wil6210</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/b43</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/b43legacy</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/bcmdhd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/brcm80211</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/brcm80211/brcmfmac</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/brcm80211/brcmsmac</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/brcm80211/brcmutil</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/cw1200</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/hostap</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ipw2x00</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/iwlegacy</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/iwlwifi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/iwlwifi/dvm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/iwlwifi/mvm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/libertas</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/libertas_tf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/mwifiex</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/orinoco</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/p54</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/prism54</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rsi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rt2x00</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtl818x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtl818x/rtl8180</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtl818x/rtl8187</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtl8192cu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/btcoexist</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8188EUS</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8188ee</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8192c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8192ce</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8192cu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8192de</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8192ee</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8192se</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8723ae</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8723be</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8723com</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/rtlwifi/rtl8821ae</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ti</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ti/wl1251</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ti/wl12xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ti/wl18xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/ti/wlcore</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/wireless/zd1211rw</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/net/xen-netback</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/nfc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/nfc/microread</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/nfc/nfcmrvl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/nfc/nxp-nci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/nfc/pn544</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/nfc/st21nfca</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/nfc/st21nfcb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ntb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/nubus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/of</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/of/unittest-data</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/parisc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/parport</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pci/host</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pci/hotplug</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pci/pcie</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pci/pcie/aer</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pcmcia</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/phy</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/bcm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/berlin</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/freescale</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/intel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/mediatek</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/meson</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/mvebu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/nomadik</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/qcom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/samsung</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/sh-pfc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/sirf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/spear</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/sunxi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pinctrl/vt8500</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/platform</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/platform/chrome</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/platform/goldfish</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/platform/mips</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/platform/olpc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/platform/x86</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pnp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pnp/isapnp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pnp/pnpacpi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pnp/pnpbios</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/power</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/power/avs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/power/reset</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/powercap</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pps</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pps/clients</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pps/generators</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ps3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ptp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/pwm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/rapidio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/rapidio/devices</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/rapidio/switches</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ras</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/regulator</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/remoteproc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/reset</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/reset/sti</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/rpmsg</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/rtc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sbus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sbus/char</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/aacraid</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/aic7xxx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/aic7xxx/aicasm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/aic94xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/arcmsr</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/arm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/be2iscsi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/bfa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/bnx2fc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/bnx2i</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/csiostor</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/cxgbi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/cxgbi/cxgb3i</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/cxgbi/cxgb4i</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/device_handler</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/esas2r</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/fcoe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/fnic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/ibmvscsi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/isci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/libfc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/libsas</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/lpfc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/megaraid</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/mpt2sas</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/mpt3sas</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/mvsas</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/osd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/pcmcia</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/pm8001</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/qla2xxx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/qla4xxx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/sym53c8xx_2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/scsi/ufs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sfi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sh</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sh/clk</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sh/intc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sh/maple</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sh/superhyway</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/sn</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/soc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/soc/mediatek</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/soc/qcom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/soc/tegra</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/soc/tegra/fuse</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/soc/ti</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/soc/versatile</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/spi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/spmi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/ssb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/android</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/android/ion</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/android/ion/tegra</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/board</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/clocking-wizard</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/comedi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/comedi/drivers</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/comedi/kcomedilib</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/dgap</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/dgnc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/emxx_udc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/fbtft</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/fsl-mc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/fsl-mc/bus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/ft1000</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/ft1000/ft1000-pcmcia</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/ft1000/ft1000-usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/fwserial</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/gdm724x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/gdm72xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/goldfish</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/gs_fpgaboot</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/i2o</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/accel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/adc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/addac</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/cdc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/frequency</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/gyro</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/impedance-analyzer</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/light</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/magnetometer</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/meter</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/resolver</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/iio/trigger</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lnet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lnet/klnds</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lnet/klnds/o2iblnd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lnet/klnds/socklnd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lnet/lnet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lnet/selftest</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/fid</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/fld</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/libcfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/llite</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/lmv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/lov</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/mdc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/mgc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/obdclass</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/obdecho</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/osc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/lustre/lustre/ptlrpc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media/bcm2048</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media/cxd2099</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media/davinci_vpfe</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media/dt3155v4l</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media/lirc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media/mn88472</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media/mn88473</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/media/omap4iss</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/mt29f_spinand</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/netlogic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/nvec</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/octeon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/octeon-usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/olpc_dcon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/ozwpan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/panel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/rtl8188eu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/rtl8192e</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/rtl8192e/rtl8192e</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/rtl8192u</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/rtl8712</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/rtl8723au</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/rts5208</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/skein</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/slicoss</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/sm750fb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/sm7xxfb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/speakup</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/ste_rmi4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/unisys</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/unisys/uislib</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/unisys/virthba</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/unisys/virtpci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/unisys/visorchannel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/unisys/visorchipset</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/unisys/visorutil</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/vme</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/vme/devices</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/vt6655</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/vt6656</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/wlan-ng</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/staging/xgifb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/target</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/target/iscsi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/target/loopback</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/target/sbp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/target/tcm_fc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/thermal</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/thermal/int340x_thermal</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/thermal/samsung</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/thermal/st</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/thermal/ti-soc-thermal</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/thunderbolt</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tty</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tty/hvc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tty/ipwireless</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tty/serial</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tty/serial/8250</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tty/serial/cpm_uart</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tty/serial/jsm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/tty/vt</span><br><span class="line">  rm -f drivers/tty/vt/consolemap_deftbl.c drivers/tty/vt/defkeymap.c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/uio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/atm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/c67x00</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/chipidea</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/class</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/common</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/dwc2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/dwc3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/early</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/gadget</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/gadget/function</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/gadget/legacy</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/gadget/udc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/gadget/udc/bdc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/host</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/host/whci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/image</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/isp1760</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/misc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/misc/sisusbvga</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/mon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/musb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/phy</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/renesas_usbhs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/serial</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/storage</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/usbip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/usb/wusbcore</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/uwb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/uwb/i1480</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/uwb/i1480/dfu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/vfio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/vfio/pci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/vfio/platform</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/vhost</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/backlight</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/console</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/aty</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/exynos</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/geode</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/kyro</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/matrox</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/mb862xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/mbx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/mmp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/mmp/fb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/mmp/hw</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/mmp/panel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/msm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/mxc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/nvidia</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/omap</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/omap2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/omap2/displays-new</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/omap2/dss</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/omap2/omapfb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/riva</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/savage</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/sis</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/vermilion</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/via</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/logo</span><br><span class="line">  rm -f drivers/video/logo/logo_superh_mono.c drivers/video/logo/logo_linux_mono.c drivers/video/logo/logo_superh_vga16.c drivers/video/logo/logo_linux_vga16.c drivers/video/logo/logo_blackfin_vga16.c drivers/video/logo/clut_vga16.c drivers/video/logo/logo_superh_clut224.c drivers/video/logo/logo_mac_clut224.c drivers/video/logo/logo_sun_clut224.c drivers/video/logo/logo_dec_clut224.c drivers/video/logo/logo_linux_clut224.c drivers/video/logo/logo_parisc_clut224.c drivers/video/logo/logo_blackfin_clut224.c drivers/video/logo/logo_spe_clut224.c drivers/video/logo/logo_m32r_clut224.c drivers/video/logo/logo_sgi_clut224.c drivers/video/logo/built-in.o drivers/video/logo/logo.o drivers/video/logo/logo_linux_mono.o drivers/video/logo/logo_linux_vga16.o drivers/video/logo/logo_linux_clut224.o drivers/video/logo/logo_superh_mono.c drivers/video/logo/logo_linux_mono.c drivers/video/logo/logo_blackfin_vga16.c drivers/video/logo/clut_vga16.c drivers/video/logo/logo_superh_vga16.c drivers/video/logo/logo_linux_vga16.c drivers/video/logo/logo_dec_clut224.c drivers/video/logo/logo_blackfin_clut224.c drivers/video/logo/logo_m32r_clut224.c drivers/video/logo/logo_sgi_clut224.c drivers/video/logo/logo_mac_clut224.c drivers/video/logo/logo_superh_clut224.c drivers/video/logo/logo_spe_clut224.c drivers/video/logo/logo_sun_clut224.c drivers/video/logo/logo_linux_clut224.c drivers/video/logo/logo_parisc_clut224.c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/i810</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/video/fbdev/intelfb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/virt</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/virtio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/vlynq</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/vme</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/vme/boards</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/vme/bridges</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/w1</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/w1/masters</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/w1/slaves</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/watchdog</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/xen</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/xen/events</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/xen/xen-pciback</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/xen/xenbus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/xen/xenfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=drivers/zorro</span><br><span class="line">make -f ./scripts/Makefile.clean obj=firmware</span><br><span class="line">  rm -f firmware/imx/sdma/sdma-imx6q.bin firmware/imx/sdma/sdma-imx7d.bin firmware/imx/sdma/sdma-imx7d.bin.gen.S firmware/imx/sdma/sdma-imx6q.bin.gen.S</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/9p</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/adfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/affs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/afs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/autofs4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/befs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/bfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/btrfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/cachefiles</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ceph</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/cifs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/coda</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/configfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/cramfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/debugfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/devpts</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/dlm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ecryptfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/efivarfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/efs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/exofs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/exportfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ext2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ext3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ext4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/f2fs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/fat</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/freevxfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/fscache</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/fuse</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/gfs2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/hfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/hfsplus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/hostfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/hpfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/hppfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/hugetlbfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/isofs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/jbd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/jbd2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/jffs2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/jfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/kernfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/lockd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/logfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/minix</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ncpfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nfs/blocklayout</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nfs/filelayout</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nfs/flexfilelayout</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nfs/objlayout</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nfs_common</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nfsd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nilfs2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/nls</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/notify</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/notify/dnotify</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/notify/fanotify</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/notify/inotify</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ntfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ocfs2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ocfs2/cluster</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ocfs2/dlm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ocfs2/dlmfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/omfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/openpromfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/overlayfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/proc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/pstore</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/qnx4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/qnx6</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/quota</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ramfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/reiserfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/romfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/squashfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/sysfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/sysv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/tracefs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ubifs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/udf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/ufs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=fs/xfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=init</span><br><span class="line">make -f ./scripts/Makefile.clean obj=ipc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/bpf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/debug</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/debug/kdb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/events</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/gcov</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/irq</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/livepatch</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/locking</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/power</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/printk</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/rcu</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/sched</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/time</span><br><span class="line">  rm -f kernel/time/hz.bc kernel/time/timeconst.h</span><br><span class="line">make -f ./scripts/Makefile.clean obj=kernel/trace</span><br><span class="line">  rm -f kernel/config_data.gz kernel/config_data.h</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/fonts</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/lz4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/lzo</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/mpi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/raid6</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/reed_solomon</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/xz</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/zlib_deflate</span><br><span class="line">make -f ./scripts/Makefile.clean obj=lib/zlib_inflate</span><br><span class="line">  rm -f lib/crc32table.h lib/oid_registry_data.c lib/gen_crc32table</span><br><span class="line">make -f ./scripts/Makefile.clean obj=mm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=mm/kasan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/6lowpan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/802</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/9p</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/appletalk</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/atm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ax25</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/batman-adv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/bluetooth</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/bluetooth/bnep</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/bluetooth/cmtp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/bluetooth/hidp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/bluetooth/rfcomm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/bridge</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/bridge/netfilter</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/caif</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/can</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ceph</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/dccp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/decnet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/decnet/netfilter</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/dns_resolver</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/dsa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ethernet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/hsr</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ieee802154</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ieee802154/6lowpan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ipv4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ipv4/netfilter</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ipv6</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ipv6/netfilter</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/ipx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/irda</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/irda/ircomm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/irda/irlan</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/irda/irnet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/iucv</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/key</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/l2tp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/lapb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/llc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/mac80211</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/mac802154</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/mpls</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/netfilter</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/netfilter/ipset</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/netfilter/ipvs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/netlabel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/netlink</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/netrom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/nfc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/nfc/hci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/nfc/nci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/openvswitch</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/packet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/phonet</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/rds</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/rfkill</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/rose</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/rxrpc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/sched</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/sctp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/sunrpc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/sunrpc/auth_gss</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/sunrpc/xprtrdma</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/tipc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/unix</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/vmw_vsock</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/wimax</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/wireless</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/x25</span><br><span class="line">make -f ./scripts/Makefile.clean obj=net/xfrm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/apparmor</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/integrity</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/integrity/evm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/integrity/ima</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/keys</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/keys/encrypted-keys</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/selinux</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/smack</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/tomoyo</span><br><span class="line">make -f ./scripts/Makefile.clean obj=security/yama</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/aoa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/aoa/codecs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/aoa/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/aoa/fabrics</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/aoa/soundbus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/aoa/soundbus/i2sbus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/arm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/atmel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/core</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/core/oss</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/core/seq</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/drivers</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/drivers/mpu401</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/drivers/opl3</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/drivers/opl4</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/drivers/pcsp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/drivers/vx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/firewire</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/firewire/bebob</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/firewire/dice</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/firewire/fireworks</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/firewire/oxfw</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/hda</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/i2c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/i2c/other</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/ad1816a</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/ad1848</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/cs423x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/es1688</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/galaxy</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/gus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/msnd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/opti9xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/sb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/wavefront</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/isa/wss</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/mips</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/oss</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/oss/dmasound</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/parisc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/ac97</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/ali5451</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/asihpi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/au88x0</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/aw2</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/ca0106</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/cs46xx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/cs5535audio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/ctxfi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/echoaudio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/emu10k1</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/hda</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/ice1712</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/korg1212</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/lola</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/lx6464es</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/mixart</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/nm256</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/oxygen</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/pcxhr</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/riptide</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/rme9652</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/trident</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/vx222</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pci/ymfpci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pcmcia</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pcmcia/pdaudiocf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/pcmcia/vx</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/ppc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/sh</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/adi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/atmel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/au1x</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/bcm</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/blackfin</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/cirrus</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/codecs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/davinci</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/dwc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/fsl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/generic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/intel</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/intel/atom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/intel/atom/sst</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/intel/baytrail</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/intel/boards</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/intel/common</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/intel/haswell</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/jz4740</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/kirkwood</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/mxs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/nuc900</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/omap</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/pxa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/qcom</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/rockchip</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/samsung</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/sh</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/sh/rcar</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/sirf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/spear</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/tegra</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/txx9</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/ux500</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/soc/xtensa</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/sparc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/spi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/synth</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/synth/emux</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/usb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/usb/6fire</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/usb/bcd2000</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/usb/caiaq</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/usb/hiface</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/usb/line6</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/usb/misc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=sound/usb/usx2y</span><br><span class="line">make -f ./scripts/Makefile.clean obj=usr</span><br><span class="line">  rm -f usr/initramfs_data.cpio.gz usr/gen_init_cpio</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/accounting</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/auxdisplay</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/blackfin</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/connector</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/filesystems</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/filesystems/configfs</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/ia64</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/laptops</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/mic</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/mic/mpssd</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/misc-devices</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/misc-devices/mei</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/networking</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/networking/timestamping</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/pcmcia</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/prctl</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/ptp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/spi</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/timers</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/vDSO</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/video4linux</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/watchdog</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/watchdog/src</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/hidraw</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/hw_breakpoint</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/kdb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/kfifo</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/kobject</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/kprobes</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/livepatch</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/rpmsg</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/seccomp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=samples/trace_events</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/boot</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/boot/bootp</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/boot/compressed</span><br><span class="line">  rm -f arch/arm/boot/compressed/piggy.lzo arch/arm/boot/compressed/lib1funcs.S arch/arm/boot/compressed/ashldi3.S arch/arm/boot/compressed/bswapsdi2.S arch/arm/boot/compressed/hyp-stub.S arch/arm/boot/compressed/vmlinux arch/arm/boot/compressed/vmlinux.lds arch/arm/boot/compressed/lib1funcs.o arch/arm/boot/compressed/lib1funcs.S arch/arm/boot/compressed/ashldi3.o arch/arm/boot/compressed/ashldi3.S arch/arm/boot/compressed/bswapsdi2.o arch/arm/boot/compressed/bswapsdi2.S arch/arm/boot/compressed/head.o arch/arm/boot/compressed/misc.o arch/arm/boot/compressed/misc.o arch/arm/boot/compressed/decompress.o arch/arm/boot/compressed/string.o</span><br><span class="line">make -f ./scripts/Makefile.clean obj=arch/arm/boot/dts</span><br><span class="line">  rm -f arch/arm/boot/dts/imx6dl-sabreauto-flexcan1.dtb arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev2-interleave-android-ldo.dtb arch/arm/boot/dts/imx6sxscm-1gb-evb-lcdif1-ldo.dtb arch/arm/boot/dts/imx6sxscm-1gb-evb-ldo.dtb arch/arm/boot/dts/imx6dl-tx6u-811x.dtb arch/arm/boot/dts/imx6ul-14x14-evk-btwifi.dtb arch/arm/boot/dts/imx6dl-aristainetos_7.dtb arch/arm/boot/dts/imx6dl-nitrogen6x.dtb arch/arm/boot/dts/imx6dl-tx6u-801x.dtb arch/arm/boot/dts/imx6q-arm2-hsic.dtb arch/arm/boot/dts/imx6dqscm-1gb-evb-fix-ldo.dtb arch/arm/boot/dts/imx6q-udoo.dtb arch/arm/boot/dts/imx6q-gw5400-a.dtb arch/arm/boot/dts/imx6sx-19x19-arm2-ldo.dtb arch/arm/boot/dts/imx6qp-sabresd-ldo.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-emmc.dtb arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev3-fix-ldo.dtb arch/arm/boot/dts/imx6ull-14x14-nand-10.1-1280x800-c.dtb arch/arm/boot/dts/imx6dl-wandboard.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2.dtb arch/arm/boot/dts/imx53-tx53-x13x.dtb arch/arm/boot/dts/imx6sx-sabreauto.dtb arch/arm/boot/dts/imx6q-sabreauto-enetirq.dtb arch/arm/boot/dts/imx6ull-14x14-emmc-7-800x480-c.dtb arch/arm/boot/dts/imx6ull-14x14-emmc-4.3-480x272-c.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-ecspi.dtb arch/arm/boot/dts/imx53-tx53-x03x.dtb arch/arm/boot/dts/imx7d-sdb-reva-touch.dtb arch/arm/boot/dts/imx6q-dfi-fs700-m60.dtb arch/arm/boot/dts/imx6dl-cubox-i.dtb arch/arm/boot/dts/vf610-colibri-eval-v3.dtb arch/arm/boot/dts/imx7d-sdb-gpmi-weim.dtb arch/arm/boot/dts/imx6qp-sabreauto-flexcan1.dtb arch/arm/boot/dts/imx6dl-wandboard-revb1.dtb arch/arm/boot/dts/imx7d-sdb-epdc.dtb arch/arm/boot/dts/imx6ul-14x14-evk-csi.dtb arch/arm/boot/dts/imx53-ard.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-ecspi.dtb arch/arm/boot/dts/imx7d-sdb.dtb arch/arm/boot/dts/imx7d-sdb-reva-m4.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-enet2.dtb arch/arm/boot/dts/imx6sx-sdb-lcdif1.dtb arch/arm/boot/dts/imx6q-sabreauto-flexcan1.dtb arch/arm/boot/dts/imx7d-sdb-reva-wm8960.dtb arch/arm/boot/dts/vf610-twr.dtb arch/arm/boot/dts/imx6dl-sabreauto.dtb arch/arm/boot/dts/imx6sl-evk.dtb arch/arm/boot/dts/imx6sl-warp.dtb arch/arm/boot/dts/imx6sl-evk-csi.dtb arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev2-fix-ldo.dtb arch/arm/boot/dts/imx6q-gk802.dtb arch/arm/boot/dts/imx53-smd.dtb arch/arm/boot/dts/imx6ull-14x14-evk-usb-certi.dtb arch/arm/boot/dts/imx6q-nitrogen6x.dtb arch/arm/boot/dts/imx6ul-14x14-evk-usb-certi.dtb arch/arm/boot/dts/imx6q-tbs2910.dtb arch/arm/boot/dts/imx6dl-riotboard.dtb arch/arm/boot/dts/imx53-qsrb.dtb arch/arm/boot/dts/imx6ull-14x14-evk-emmc.dtb arch/arm/boot/dts/imx6sxscm-epop-evb-ldo.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-adc.dtb arch/arm/boot/dts/imx6sl-evk-btwifi.dtb arch/arm/boot/dts/imx6q-wandboard.dtb arch/arm/boot/dts/imx6sll-evk-reva.dtb arch/arm/boot/dts/imx7d-sdb-m4.dtb arch/arm/boot/dts/imx6q-tx6q-1110.dtb arch/arm/boot/dts/imx6dl-sabresd-hdcp.dtb arch/arm/boot/dts/imx7d-sdb-reva-gpmi-weim.dtb arch/arm/boot/dts/imx6sx-19x19-arm2-gpmi-weim.dtb arch/arm/boot/dts/imx6q-tx6q-1010.dtb arch/arm/boot/dts/imx6q-gw552x.dtb arch/arm/boot/dts/imx6q-tx6q-1010-comtft.dtb arch/arm/boot/dts/imx6ul-14x14-evk-emmc.dtb arch/arm/boot/dts/imx6sx-19x19-arm2.dtb arch/arm/boot/dts/imx6q-hummingboard.dtb arch/arm/boot/dts/imx6ull-9x9-evk-btwifi.dtb arch/arm/boot/dts/imx6dl-sabresd-btwifi.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-flexcan2.dtb arch/arm/boot/dts/imx6q-rex-pro.dtb arch/arm/boot/dts/imx6sll-lpddr2-arm2.dtb arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-emmc.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-mipi_dsi.dtb arch/arm/boot/dts/imx6ull-14x14-emmc-10.1-1280x800-c.dtb arch/arm/boot/dts/imx6q-gw53xx.dtb arch/arm/boot/dts/imx6qp-sabresd-hdcp.dtb arch/arm/boot/dts/imx53-voipac-bsb.dtb arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev2-wifi-fix-ldo.dtb arch/arm/boot/dts/imx6dl-gw552x.dtb arch/arm/boot/dts/imx6sx-sdb-m4.dtb arch/arm/boot/dts/imx6ull-14x14-evk.dtb arch/arm/boot/dts/imx6sll-evk-btwifi.dtb arch/arm/boot/dts/imx6sx-sdb-ldo.dtb arch/arm/boot/dts/imx6dl-sabresd-enetirq.dtb arch/arm/boot/dts/imx6dl-tx6dl-comtft.dtb arch/arm/boot/dts/imx6q-sbc6x.dtb arch/arm/boot/dts/imx6q-sabresd-hdcp.dtb arch/arm/boot/dts/imx6ull-14x14-nand-7-800x480-c.dtb arch/arm/boot/dts/imx6q-sabresd-ldo.dtb arch/arm/boot/dts/imx6q-sabresd-enetirq.dtb arch/arm/boot/dts/imx6qp-sabreauto-ecspi.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-uart2.dtb arch/arm/boot/dts/imx7d-sdb-reva-epdc.dtb arch/arm/boot/dts/imx6sxscm-1gb-evb-m4-ldo.dtb arch/arm/boot/dts/imx7d-sdb-reva.dtb arch/arm/boot/dts/imx6q-wandboard-revb1.dtb arch/arm/boot/dts/imx6q-pop-arm2.dtb arch/arm/boot/dts/imx6q-sabreauto-ecspi.dtb arch/arm/boot/dts/imx6dqscm-1gb-evb-hdcp-fix-ldo.dtb arch/arm/boot/dts/imx7d-sdb-reva-hdmi-audio.dtb arch/arm/boot/dts/imx6dl-gw54xx.dtb arch/arm/boot/dts/imx6sll-lpddr3-arm2-ecspi.dtb arch/arm/boot/dts/imx7d-19x19-lpddr2-arm2.dtb arch/arm/boot/dts/imx6ull-alientek-nand.dtb arch/arm/boot/dts/imx6dl-aristainetos_4.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-epdc.dtb arch/arm/boot/dts/imx6dl-sabrelite.dtb arch/arm/boot/dts/imx6ul-9x9-evk-ldo.dtb arch/arm/boot/dts/imx6q-arm2.dtb arch/arm/boot/dts/imx6sx-sdb-btwifi.dtb arch/arm/boot/dts/imx6qp-sabresd-btwifi.dtb arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev3-hdcp-fix-ldo.dtb arch/arm/boot/dts/imx6sx-14x14-arm2.dtb arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-wm8958.dtb arch/arm/boot/dts/imx6q-sabresd-btwifi.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-m4.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-pcie.dtb arch/arm/boot/dts/imx6dl-gw51xx.dtb arch/arm/boot/dts/imx6sx-sabreauto-m4.dtb arch/arm/boot/dts/imx6ul-14x14-evk-gpmi-weim.dtb arch/arm/boot/dts/imx6sll-lpddr3-arm2-spdif.dtb arch/arm/boot/dts/imx6sx-sdb-sai.dtb arch/arm/boot/dts/imx6ul-9x9-evk-csi.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-wm8958.dtb arch/arm/boot/dts/imx53-mba53.dtb arch/arm/boot/dts/imx6qp-sabresd-ldo-pcie-cert.dtb arch/arm/boot/dts/imx6q-tx6q-1020-comtft.dtb arch/arm/boot/dts/imx6q-gw51xx.dtb arch/arm/boot/dts/imx6ull-14x14-evk-btwifi.dtb arch/arm/boot/dts/imx6ull-alientek-emmc.dtb arch/arm/boot/dts/imx6sll-lpddr3-arm2-csi.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-cs42888.dtb arch/arm/boot/dts/imx6sxscm-1gb-evb-mqs-ldo.dtb arch/arm/boot/dts/imx6sx-sdb-emmc.dtb arch/arm/boot/dts/imx6ull-14x14-nand-4.3-480x272-c.dtb arch/arm/boot/dts/imx6sxscm-1gb-evb-btwifi-ldo.dtb arch/arm/boot/dts/imx6ull-14x14-emmc-vga.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-tsc.dtb arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev3-btwifi-fix-ldo.dtb arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev2-hdcp-fix-ldo.dtb arch/arm/boot/dts/imx7d-sdb-mipi-dsi.dtb arch/arm/boot/dts/imx6q-gw52xx.dtb arch/arm/boot/dts/imx6sll-evk.dtb arch/arm/boot/dts/imx6ul-9x9-evk-btwifi.dtb arch/arm/boot/dts/imx6dl-phytec-pbab01.dtb arch/arm/boot/dts/imx6dqscm-1gb-evb-enetirq-fix-ldo.dtb arch/arm/boot/dts/imx53-m53evk.dtb arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-gpmi-weim.dtb arch/arm/boot/dts/imx6dl-sabresd.dtb arch/arm/boot/dts/imx6ull-14x14-evk-gpmi-weim.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-ldo.dtb arch/arm/boot/dts/imx6q-cm-fx6.dtb arch/arm/boot/dts/imx6sx-19x19-arm2-csi.dtb arch/arm/boot/dts/imx6ul-14x14-evk.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-mqs.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-qspi.dtb arch/arm/boot/dts/imx6ull-14x14-nand-vga.dtb arch/arm/boot/dts/imx6dqscm-1gb-evb-interleave-android-ldo.dtb arch/arm/boot/dts/imx6sxscm-epop-evb-m4-ldo.dtb arch/arm/boot/dts/imx6dl-rex-basic.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-sai.dtb arch/arm/boot/dts/imx6dl-udoo.dtb arch/arm/boot/dts/imx6dl-gw53xx.dtb arch/arm/boot/dts/imx50-evk.dtb arch/arm/boot/dts/imx7d-sdb-qspi.dtb arch/arm/boot/dts/imx6sl-evk-uart.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-lcdif.dtb arch/arm/boot/dts/imx6q-sabrelite.dtb arch/arm/boot/dts/imx6dl-sabreauto-enetirq.dtb arch/arm/boot/dts/imx6ull-9x9-evk-ldo.dtb arch/arm/boot/dts/imx6dqscm-1gb-evb-btwifi-fix-ldo.dtb arch/arm/boot/dts/imx6q-sabreauto-gpmi-weim.dtb arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-spdif.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-usb.dtb arch/arm/boot/dts/imx6dl-dfi-fs700-m60.dtb arch/arm/boot/dts/vf500-colibri-eval-v3.dtb arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-flexcan.dtb arch/arm/boot/dts/imx6sx-sdb.dtb arch/arm/boot/dts/imx6qp-sabresd.dtb arch/arm/boot/dts/imx6q-phytec-pbab01.dtb arch/arm/boot/dts/vf610-cosmic.dtb arch/arm/boot/dts/imx6sx-sdb-reva-ldo.dtb arch/arm/boot/dts/imx6q-sabresd.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-gpmi-weim.dtb arch/arm/boot/dts/imx6dl-hummingboard.dtb arch/arm/boot/dts/imx7d-sdb-reva-qspi.dtb arch/arm/boot/dts/imx6q-cubox-i.dtb arch/arm/boot/dts/imx6qp-sabreauto-gpmi-weim.dtb arch/arm/boot/dts/imx6ull-14x14-emmc-7-1024x600-c.dtb arch/arm/boot/dts/imx6ull-14x14-emmc-hdmi.dtb arch/arm/boot/dts/imx6qp-sabreauto.dtb arch/arm/boot/dts/imx6ull-14x14-nand-4.3-800x480-c.dtb arch/arm/boot/dts/imx6ul-14x14-lpddr2-arm2.dtb arch/arm/boot/dts/imx6ul-9x9-evk.dtb arch/arm/boot/dts/imx6q-gw54xx.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-qspi-all.dtb arch/arm/boot/dts/imx6sx-sdb-mqs.dtb arch/arm/boot/dts/imx53-qsb.dtb arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-mqs.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2.dtb arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-qspi.dtb arch/arm/boot/dts/imx6q-sabreauto.dtb arch/arm/boot/dts/imx6ull-14x14-nand-7-1024x600-c.dtb arch/arm/boot/dts/imx6sll-lpddr3-arm2.dtb arch/arm/boot/dts/imx7d-12x12-ddr3-arm2.dtb arch/arm/boot/dts/imx6dl-sabreauto-gpmi-weim.dtb arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-flexcan2.dtb arch/arm/boot/dts/imx6dl-sabresd-ldo.dtb arch/arm/boot/dts/imx6sxscm-1gb-evb-sai-ldo.dtb arch/arm/boot/dts/imx6ull-9x9-evk.dtb arch/arm/boot/dts/imx6ull-14x14-emmc-4.3-800x480-c.dtb arch/arm/boot/dts/imx6sx-sdb-reva.dtb arch/arm/boot/dts/imx6dl-sabreauto-ecspi.dtb arch/arm/boot/dts/imx6q-dmo-edmqmx6.dtb arch/arm/boot/dts/imx6ull-14x14-nand-hdmi.dtb arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2.dtb arch/arm/boot/dts/imx6sl-evk-ldo.dtb arch/arm/boot/dts/imx6q-tx6q-1020.dtb arch/arm/boot/dts/imx6dl-gw52xx.dtb</span><br><span class="line">  rm -f arch/arm/boot/Image arch/arm/boot/zImage</span><br><span class="line">/bin/bash ./scripts/link-vmlinux.sh clean</span><br><span class="line">+ &#x27;[&#x27; clean = clean &#x27;]&#x27;</span><br><span class="line">+ cleanup</span><br><span class="line">+ rm -f .old_version</span><br><span class="line">+ rm -f .tmp_System.map</span><br><span class="line">+ rm -f .tmp_kallsyms1.o .tmp_kallsyms2.o</span><br><span class="line">+ rm -f .tmp_version</span><br><span class="line">+ rm -f .tmp_vmlinux1 .tmp_vmlinux2</span><br><span class="line">+ rm -f System.map</span><br><span class="line">+ rm -f vmlinux</span><br><span class="line">+ rm -f vmlinux.o</span><br><span class="line">+ exit 0</span><br><span class="line">  rm -rf .tmp_versions</span><br><span class="line">  rm -f</span><br><span class="line">make -f ./scripts/Makefile.clean obj=Documentation/DocBook</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/basic</span><br><span class="line">  rm -f scripts/basic/fixdep scripts/basic/fixdep scripts/basic/bin2c</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/dtc</span><br><span class="line">  rm -f scripts/dtc/dtc scripts/dtc/dtc-lexer.lex.c scripts/dtc/dtc-parser.tab.c scripts/dtc/dtc-parser.tab.h scripts/dtc/dtc</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/gdb</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/gdb/linux</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/genksyms</span><br><span class="line">  rm -f scripts/genksyms/genksyms scripts/genksyms/keywords.hash.c scripts/genksyms/lex.lex.c scripts/genksyms/parse.tab.c scripts/genksyms/parse.tab.h scripts/genksyms/genksyms</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/kconfig</span><br><span class="line">  rm -f scripts/kconfig/zconf.tab.c scripts/kconfig/zconf.lex.c scripts/kconfig/zconf.hash.c scripts/kconfig/conf</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/mod</span><br><span class="line">  rm -f scripts/mod/modpost scripts/mod/mk_elfconfig scripts/mod/devicetable-offsets.h scripts/mod/elfconfig.h scripts/mod/modpost scripts/mod/mk_elfconfig</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/package</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/selinux</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/selinux/genheaders</span><br><span class="line">make -f ./scripts/Makefile.clean obj=scripts/selinux/mdp</span><br><span class="line">  rm -f scripts/kallsyms scripts/pnmtologo scripts/conmakehash scripts/sortextable</span><br><span class="line">  rm -rf include/config include/generated arch/arm/include/generated</span><br><span class="line">  rm -f .config .version Module.symvers</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>defconfig日志</summary>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -f ./scripts/Makefile.build obj=scripts/basic</span><br><span class="line">  gcc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89     -o scripts/basic/fixdep scripts/basic/fixdep.c  </span><br><span class="line">rm -f .tmp_quiet_recordmcount</span><br><span class="line">make -f ./scripts/Makefile.build obj=scripts/kconfig imx_v7_defconfig</span><br><span class="line">  gcc -Wp,-MD,scripts/kconfig/.conf.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89   -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=600 -DCURSES_LOC=&quot;&lt;ncurses.h&gt;&quot; -DNCURSES_WIDECHAR=1 -DLOCALE   -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c</span><br><span class="line">  cat scripts/kconfig/zconf.tab.c_shipped &gt; scripts/kconfig/zconf.tab.c</span><br><span class="line">  cat scripts/kconfig/zconf.lex.c_shipped &gt; scripts/kconfig/zconf.lex.c</span><br><span class="line">  cat scripts/kconfig/zconf.hash.c_shipped &gt; scripts/kconfig/zconf.hash.c</span><br><span class="line">  gcc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89   -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=600 -DCURSES_LOC=&quot;&lt;ncurses.h&gt;&quot; -DNCURSES_WIDECHAR=1 -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c</span><br><span class="line">In file included from scripts/kconfig/zconf.tab.c:2534:</span><br><span class="line">scripts/kconfig/confdata.c: In function ‘conf_write’:</span><br><span class="line">scripts/kconfig/confdata.c:773:19: warning: ‘%s’ directive writing likely 7 or more bytes into a region of size between 1 and 4097 [-Wformat-overflow=]</span><br><span class="line">  773 |  sprintf(newname, &quot;%s%s&quot;, dirname, basename);</span><br><span class="line">      |                   ^~~~~~</span><br><span class="line">scripts/kconfig/confdata.c:773:19: note: assuming directive output of 7 bytes</span><br><span class="line">In file included from /usr/include/stdio.h:867,</span><br><span class="line">                 from scripts/kconfig/zconf.tab.c:84:</span><br><span class="line">/usr/include/x86_64-linux-gnu/bits/stdio2.h:36:10: note: ‘__builtin___sprintf_chk’ output 1 or more bytes (assuming 4104) into a destination of size 4097</span><br><span class="line">   36 |   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,</span><br><span class="line">      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">   37 |       __bos (__s), __fmt, __va_arg_pack ());</span><br><span class="line">      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">In file included from scripts/kconfig/zconf.tab.c:2534:</span><br><span class="line">scripts/kconfig/confdata.c:776:20: warning: ‘.tmpconfig.’ directive writing 11 bytes into a region of size between 1 and 4097 [-Wformat-overflow=]</span><br><span class="line">  776 |   sprintf(tmpname, &quot;%s.tmpconfig.%d&quot;, dirname, (int)getpid());</span><br><span class="line">      |                    ^~~~~~~~~~~~~~~~~</span><br><span class="line">In file included from /usr/include/stdio.h:867,</span><br><span class="line">                 from scripts/kconfig/zconf.tab.c:84:</span><br><span class="line">/usr/include/x86_64-linux-gnu/bits/stdio2.h:36:10: note: ‘__builtin___sprintf_chk’ output between 13 and 4119 bytes into a destination of size 4097</span><br><span class="line">   36 |   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,</span><br><span class="line">      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">   37 |       __bos (__s), __fmt, __va_arg_pack ());</span><br><span class="line">      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">  gcc  -o scripts/kconfig/conf scripts/kconfig/conf.o scripts/kconfig/zconf.tab.o  </span><br><span class="line">scripts/kconfig/conf  --defconfig=arch/arm/configs/imx_v7_defconfig Kconfig</span><br><span class="line">#</span><br><span class="line"># configuration written to .config</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>make all日志</summary>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scripts/kconfig/conf  --silentoldconfig Kconfig</span><br><span class="line">  CHK     include/config/kernel.release</span><br><span class="line">  UPD     include/config/kernel.release</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/bitsperlong.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/cputime.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/current.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/emergency-restart.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/errno.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/exec.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/ioctl.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/ipcbuf.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/irq_regs.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/kdebug.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/local.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/local64.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/mcs_spinlock.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/msgbuf.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/param.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/parport.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/poll.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/preempt.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/resource.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/rwsem.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/scatterlist.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/seccomp.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/sections.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/segment.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/sembuf.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/serial.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/shmbuf.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/siginfo.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/simd.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/sizes.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/socket.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/sockios.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/termbits.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/termios.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/timex.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/trace_clock.h</span><br><span class="line">  WRAP    arch/arm/include/generated/asm/unaligned.h</span><br><span class="line">  CHK     include/generated/uapi/linux/version.h</span><br><span class="line">  UPD     include/generated/uapi/linux/version.h</span><br><span class="line">  CHK     include/generated/utsrelease.h</span><br><span class="line">  UPD     include/generated/utsrelease.h</span><br><span class="line">  HOSTCC  scripts/basic/bin2c</span><br><span class="line">  Generating include/generated/mach-types.h</span><br><span class="line">  CC      kernel/bounds.s</span><br><span class="line">  CHK     include/generated/bounds.h</span><br><span class="line">  UPD     include/generated/bounds.h</span><br><span class="line">  CC      arch/arm/kernel/asm-offsets.s</span><br><span class="line">  CHK     include/generated/asm-offsets.h</span><br><span class="line">  UPD     include/generated/asm-offsets.h</span><br><span class="line">  CALL    scripts/checksyscalls.sh</span><br><span class="line">  HOSTCC  scripts/dtc/dtc.o</span><br><span class="line">  HOSTCC  scripts/dtc/flattree.o</span><br><span class="line">  HOSTCC  scripts/dtc/fstree.o</span><br><span class="line">  HOSTCC  scripts/dtc/data.o</span><br><span class="line">  HOSTCC  scripts/dtc/livetree.o</span><br><span class="line">  HOSTCC  scripts/dtc/treesource.o</span><br><span class="line">  HOSTCC  scripts/dtc/srcpos.o</span><br><span class="line">  HOSTCC  scripts/dtc/checks.o</span><br><span class="line">  HOSTCC  scripts/dtc/util.o</span><br><span class="line">  SHIPPED scripts/dtc/dtc-lexer.lex.c</span><br><span class="line">  SHIPPED scripts/dtc/dtc-parser.tab.h</span><br><span class="line">  HOSTCC  scripts/dtc/dtc-lexer.lex.o</span><br><span class="line">  SHIPPED scripts/dtc/dtc-parser.tab.c</span><br><span class="line">  HOSTCC  scripts/dtc/dtc-parser.tab.o</span><br><span class="line">  HOSTLD  scripts/dtc/dtc</span><br><span class="line">  HOSTCC  scripts/genksyms/genksyms.o</span><br><span class="line">  SHIPPED scripts/genksyms/parse.tab.c</span><br><span class="line">  HOSTCC  scripts/genksyms/parse.tab.o</span><br><span class="line">  SHIPPED scripts/genksyms/lex.lex.c</span><br><span class="line">  SHIPPED scripts/genksyms/keywords.hash.c</span><br><span class="line">  SHIPPED scripts/genksyms/parse.tab.h</span><br><span class="line">  HOSTCC  scripts/genksyms/lex.lex.o</span><br><span class="line">  HOSTLD  scripts/genksyms/genksyms</span><br><span class="line">  CC      scripts/mod/empty.o</span><br><span class="line">  HOSTCC  scripts/mod/mk_elfconfig</span><br><span class="line">  MKELF   scripts/mod/elfconfig.h</span><br><span class="line">  HOSTCC  scripts/mod/modpost.o</span><br><span class="line">  CC      scripts/mod/devicetable-offsets.s</span><br><span class="line">  GEN     scripts/mod/devicetable-offsets.h</span><br><span class="line">  HOSTCC  scripts/mod/file2alias.o</span><br><span class="line">  HOSTCC  scripts/mod/sumversion.o</span><br><span class="line">  HOSTLD  scripts/mod/modpost</span><br><span class="line">  HOSTCC  scripts/kallsyms</span><br><span class="line">  HOSTCC  scripts/pnmtologo</span><br><span class="line">  HOSTCC  scripts/conmakehash</span><br><span class="line">  HOSTCC  scripts/sortextable</span><br><span class="line">  CC      init/main.o</span><br><span class="line">  CHK     include/generated/compile.h</span><br><span class="line">  UPD     include/generated/compile.h</span><br><span class="line">  CC      init/version.o</span><br><span class="line">  CC      init/do_mounts.o</span><br><span class="line">  CC      init/do_mounts_rd.o</span><br><span class="line">  CC      init/do_mounts_initrd.o</span><br><span class="line">  LD      init/mounts.o</span><br><span class="line">  CC      init/initramfs.o</span><br><span class="line">  CC      init/calibrate.o</span><br><span class="line">  CC      init/init_task.o</span><br><span class="line">  LD      init/built-in.o</span><br><span class="line">  HOSTCC  usr/gen_init_cpio</span><br><span class="line">  GEN     usr/initramfs_data.cpio.gz</span><br><span class="line">  AS      usr/initramfs_data.o</span><br><span class="line">  LD      usr/built-in.o</span><br><span class="line">  CC      arch/arm/vfp/vfpmodule.o</span><br><span class="line">  AS      arch/arm/vfp/entry.o</span><br><span class="line">  AS      arch/arm/vfp/vfphw.o</span><br><span class="line">  CC      arch/arm/vfp/vfpsingle.o</span><br><span class="line">  CC      arch/arm/vfp/vfpdouble.o</span><br><span class="line">  LD      arch/arm/vfp/vfp.o</span><br><span class="line">  LD      arch/arm/vfp/built-in.o</span><br><span class="line">  LDS     arch/arm/vdso/vdso.lds</span><br><span class="line">  CC      arch/arm/vdso/vgettimeofday.o</span><br><span class="line">  AS      arch/arm/vdso/datapage.o</span><br><span class="line">  VDSO    arch/arm/vdso/vdso.so.raw</span><br><span class="line">  HOSTCC  arch/arm/vdso/vdsomunge</span><br><span class="line">  MUNGE   arch/arm/vdso/vdso.so.dbg</span><br><span class="line">  OBJCOPY arch/arm/vdso/vdso.so</span><br><span class="line">  AS      arch/arm/vdso/vdso.o</span><br><span class="line">  LD      arch/arm/vdso/built-in.o</span><br><span class="line">  CC      arch/arm/kernel/elf.o</span><br><span class="line">  AS      arch/arm/kernel/entry-common.o</span><br><span class="line">  CC      arch/arm/kernel/irq.o</span><br><span class="line">  CC      arch/arm/kernel/opcodes.o</span><br><span class="line">  CC      arch/arm/kernel/process.o</span><br><span class="line">  CC      arch/arm/kernel/ptrace.o</span><br><span class="line">  CC      arch/arm/kernel/reboot.o</span><br><span class="line">  CC      arch/arm/kernel/return_address.o</span><br><span class="line">  CC      arch/arm/kernel/setup.o</span><br><span class="line">  CC      arch/arm/kernel/signal.o</span><br><span class="line">  AS      arch/arm/kernel/sigreturn_codes.o</span><br><span class="line">  CC      arch/arm/kernel/stacktrace.o</span><br><span class="line">  CC      arch/arm/kernel/sys_arm.o</span><br><span class="line">  CC      arch/arm/kernel/time.o</span><br><span class="line">  CC      arch/arm/kernel/traps.o</span><br><span class="line">  CC      arch/arm/kernel/atags_parse.o</span><br><span class="line">  AS      arch/arm/kernel/entry-armv.o</span><br><span class="line">  CC      arch/arm/kernel/cpuidle.o</span><br><span class="line">  CC      arch/arm/kernel/fiq.o</span><br><span class="line">  AS      arch/arm/kernel/fiqasm.o</span><br><span class="line">  CC      arch/arm/kernel/armksyms.o</span><br><span class="line">  CC      arch/arm/kernel/module.o</span><br><span class="line">  AS      arch/arm/kernel/sleep.o</span><br><span class="line">  CC      arch/arm/kernel/suspend.o</span><br><span class="line">  CC      arch/arm/kernel/smp.o</span><br><span class="line">  CC      arch/arm/kernel/smp_tlb.o</span><br><span class="line">  CC      arch/arm/kernel/smp_scu.o</span><br><span class="line">  CC      arch/arm/kernel/smp_twd.o</span><br><span class="line">  CC      arch/arm/kernel/arch_timer.o</span><br><span class="line">  CC      arch/arm/kernel/unwind.o</span><br><span class="line">  CC      arch/arm/kernel/devtree.o</span><br><span class="line">  CC      arch/arm/kernel/hw_breakpoint.o</span><br><span class="line">  CC      arch/arm/kernel/perf_regs.o</span><br><span class="line">  CC      arch/arm/kernel/perf_callchain.o</span><br><span class="line">  CC      arch/arm/kernel/perf_event.o</span><br><span class="line">  CC      arch/arm/kernel/perf_event_cpu.o</span><br><span class="line">  CC      arch/arm/kernel/topology.o</span><br><span class="line">  CC      arch/arm/kernel/vdso.o</span><br><span class="line">  CC      arch/arm/kernel/io.o</span><br><span class="line">  AS      arch/arm/kernel/hyp-stub.o</span><br><span class="line">  LD      arch/arm/kernel/built-in.o</span><br><span class="line">  AS      arch/arm/kernel/head.o</span><br><span class="line">  LDS     arch/arm/kernel/vmlinux.lds</span><br><span class="line">  CC      arch/arm/mm/dma-mapping.o</span><br><span class="line">  CC      arch/arm/mm/extable.o</span><br><span class="line">  CC      arch/arm/mm/fault.o</span><br><span class="line">  CC      arch/arm/mm/init.o</span><br><span class="line">  CC      arch/arm/mm/iomap.o</span><br><span class="line">  CC      arch/arm/mm/fault-armv.o</span><br><span class="line">  CC      arch/arm/mm/flush.o</span><br><span class="line">  CC      arch/arm/mm/idmap.o</span><br><span class="line">  CC      arch/arm/mm/ioremap.o</span><br><span class="line">  CC      arch/arm/mm/mmap.o</span><br><span class="line">  CC      arch/arm/mm/pgd.o</span><br><span class="line">  CC      arch/arm/mm/mmu.o</span><br><span class="line">  CC      arch/arm/mm/pageattr.o</span><br><span class="line">  CC      arch/arm/mm/proc-syms.o</span><br><span class="line">  CC      arch/arm/mm/alignment.o</span><br><span class="line">  CC      arch/arm/mm/highmem.o</span><br><span class="line">  AS      arch/arm/mm/abort-ev7.o</span><br><span class="line">  AS      arch/arm/mm/pabort-v7.o</span><br><span class="line">  AS      arch/arm/mm/cache-v7.o</span><br><span class="line">  CC      arch/arm/mm/copypage-v6.o</span><br><span class="line">  CC      arch/arm/mm/context.o</span><br><span class="line">  AS      arch/arm/mm/tlb-v7.o</span><br><span class="line">  AS      arch/arm/mm/proc-v7.o</span><br><span class="line">  CC      arch/arm/mm/l2c-common.o</span><br><span class="line">  CC      arch/arm/mm/cache-l2x0.o</span><br><span class="line">  AS      arch/arm/mm/l2c-l2x0-resume.o</span><br><span class="line">  LD      arch/arm/mm/built-in.o</span><br><span class="line">  CC      arch/arm/common/firmware.o</span><br><span class="line">  LD      arch/arm/common/built-in.o</span><br><span class="line">  LD      arch/arm/probes/built-in.o</span><br><span class="line">  LD      arch/arm/net/built-in.o</span><br><span class="line">  LD      arch/arm/crypto/built-in.o</span><br><span class="line">  LD      arch/arm/firmware/built-in.o</span><br><span class="line">  CC      arch/arm/mach-imx/time.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpu.o</span><br><span class="line">  CC      arch/arm/mach-imx/system.o</span><br><span class="line">  CC      arch/arm/mach-imx/irq-common.o</span><br><span class="line">  CC      arch/arm/mach-imx/common.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpu-imx5.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-imx51-imx53.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-cpu.o</span><br><span class="line">  CC      arch/arm/mach-imx/pm-imx5.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-pllv1.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-pllv2.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-pllv3.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-gate2.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-pfd.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-busy.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-fixup-div.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-fixup-mux.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-gate-exclusive.o</span><br><span class="line">  CC      arch/arm/mach-imx/tzic.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpuidle-imx5.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpuidle-imx6q.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpuidle-imx6sl.o</span><br><span class="line">  AS      arch/arm/mach-imx/imx6sl_low_power_idle.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpuidle-imx6sx.o</span><br><span class="line">  AS      arch/arm/mach-imx/imx6sx_low_power_idle.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpuidle-imx6ul.o</span><br><span class="line">  AS      arch/arm/mach-imx/imx6ul_low_power_idle.o</span><br><span class="line">  AS      arch/arm/mach-imx/imx6ull_low_power_idle.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpuidle-imx6sll.o</span><br><span class="line">  AS      arch/arm/mach-imx/imx6sll_low_power_idle.o</span><br><span class="line">  CC      arch/arm/mach-imx/cpuidle-imx7d.o</span><br><span class="line">  AS      arch/arm/mach-imx/imx7d_low_power_idle.o</span><br><span class="line">  AS      arch/arm/mach-imx/ssi-fiq.o</span><br><span class="line">  CC      arch/arm/mach-imx/ssi-fiq-ksym.o</span><br><span class="line">  CC      arch/arm/mach-imx/anatop.o</span><br><span class="line">  CC      arch/arm/mach-imx/gpc.o</span><br><span class="line">  CC      arch/arm/mach-imx/gpcv2.o</span><br><span class="line">  CC      arch/arm/mach-imx/mmdc.o</span><br><span class="line">  CC      arch/arm/mach-imx/ddrc.o</span><br><span class="line">  CC      arch/arm/mach-imx/src.o</span><br><span class="line">  CC      arch/arm/mach-imx/mu.o</span><br><span class="line">  CC      arch/arm/mach-imx/imx_rpmsg.o</span><br><span class="line">  AS      arch/arm/mach-imx/headsmp.o</span><br><span class="line">  CC      arch/arm/mach-imx/platsmp.o</span><br><span class="line">  CC      arch/arm/mach-imx/hotplug.o</span><br><span class="line">  CC      arch/arm/mach-imx/busfreq_lpddr2.o</span><br><span class="line">  CC      arch/arm/mach-imx/busfreq-imx.o</span><br><span class="line">  CC      arch/arm/mach-imx/busfreq_ddr3.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-imx6q.o</span><br><span class="line">  CC      arch/arm/mach-imx/mach-imx6q.o</span><br><span class="line">  AS      arch/arm/mach-imx/ddr3_freq_imx6.o</span><br><span class="line">  AS      arch/arm/mach-imx/smp_wfe_imx6.o</span><br><span class="line">  AS      arch/arm/mach-imx/lpddr2_freq_imx6q.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-imx6sl.o</span><br><span class="line">  CC      arch/arm/mach-imx/mach-imx6sl.o</span><br><span class="line">  AS      arch/arm/mach-imx/lpddr2_freq_imx6.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-imx6sll.o</span><br><span class="line">  AS      arch/arm/mach-imx/lpddr2_freq_imx6sll.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-imx6sx.o</span><br><span class="line">  CC      arch/arm/mach-imx/mach-imx6sx.o</span><br><span class="line">  AS      arch/arm/mach-imx/ddr3_freq_imx6sx.o</span><br><span class="line">  AS      arch/arm/mach-imx/lpddr2_freq_imx6sx.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-imx6ul.o</span><br><span class="line">  CC      arch/arm/mach-imx/mach-imx6ul.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-imx7d.o</span><br><span class="line">  CC      arch/arm/mach-imx/mach-imx7d.o</span><br><span class="line">  AS      arch/arm/mach-imx/suspend-imx6.o</span><br><span class="line">  AS      arch/arm/mach-imx/suspend-imx7.o</span><br><span class="line">  CC      arch/arm/mach-imx/pm-imx6.o</span><br><span class="line">  CC      arch/arm/mach-imx/pm-imx7.o</span><br><span class="line">  AS      arch/arm/mach-imx/ddr3_freq_imx7d.o</span><br><span class="line">  AS      arch/arm/mach-imx/smp_wfe.o</span><br><span class="line">  AS      arch/arm/mach-imx/lpddr3_freq_imx.o</span><br><span class="line">  CC      arch/arm/mach-imx/mach-imx50.o</span><br><span class="line">  CC      arch/arm/mach-imx/mach-imx53.o</span><br><span class="line">  CC      arch/arm/mach-imx/clk-vf610.o</span><br><span class="line">  CC      arch/arm/mach-imx/mach-vf610.o</span><br><span class="line">  CC      arch/arm/mach-imx/devices/devices.o</span><br><span class="line">  CC      arch/arm/mach-imx/devices/platform-gpio-mxc.o</span><br><span class="line">  CC      arch/arm/mach-imx/devices/platform-imx-dma.o</span><br><span class="line">  LD      arch/arm/mach-imx/devices/built-in.o</span><br><span class="line">  LD      arch/arm/mach-imx/built-in.o</span><br><span class="line">  CC      kernel/fork.o</span><br><span class="line">  CC      kernel/exec_domain.o</span><br><span class="line">  CC      kernel/panic.o</span><br><span class="line">  CC      kernel/cpu.o</span><br><span class="line">  CC      kernel/exit.o</span><br><span class="line">  CC      kernel/softirq.o</span><br><span class="line">  CC      kernel/resource.o</span><br><span class="line">  CC      kernel/sysctl.o</span><br><span class="line">  CC      kernel/sysctl_binary.o</span><br><span class="line">  CC      kernel/capability.o</span><br><span class="line">  CC      kernel/ptrace.o</span><br><span class="line">  CC      kernel/user.o</span><br><span class="line">  CC      kernel/signal.o</span><br><span class="line">  CC      kernel/sys.o</span><br><span class="line">  CC      kernel/kmod.o</span><br><span class="line">  CC      kernel/workqueue.o</span><br><span class="line">  CC      kernel/pid.o</span><br><span class="line">  CC      kernel/task_work.o</span><br><span class="line">  CC      kernel/extable.o</span><br><span class="line">  CC      kernel/params.o</span><br><span class="line">  CC      kernel/kthread.o</span><br><span class="line">  CC      kernel/sys_ni.o</span><br><span class="line">  CC      kernel/nsproxy.o</span><br><span class="line">  CC      kernel/notifier.o</span><br><span class="line">  CC      kernel/ksysfs.o</span><br><span class="line">  CC      kernel/cred.o</span><br><span class="line">  CC      kernel/reboot.o</span><br><span class="line">  CC      kernel/async.o</span><br><span class="line">  CC      kernel/range.o</span><br><span class="line">  CC      kernel/smpboot.o</span><br><span class="line">  CC      kernel/groups.o</span><br><span class="line">  CC      kernel/bpf/core.o</span><br><span class="line">  LD      kernel/bpf/built-in.o</span><br><span class="line">  CC      kernel/events/core.o</span><br><span class="line">  CC      kernel/events/ring_buffer.o</span><br><span class="line">  CC      kernel/events/callchain.o</span><br><span class="line">  CC      kernel/events/hw_breakpoint.o</span><br><span class="line">  LD      kernel/events/built-in.o</span><br><span class="line">  CC      kernel/irq/irqdesc.o</span><br><span class="line">  CC      kernel/irq/handle.o</span><br><span class="line">  CC      kernel/irq/manage.o</span><br><span class="line">  CC      kernel/irq/spurious.o</span><br><span class="line">  CC      kernel/irq/resend.o</span><br><span class="line">  CC      kernel/irq/chip.o</span><br><span class="line">  CC      kernel/irq/dummychip.o</span><br><span class="line">  CC      kernel/irq/devres.o</span><br><span class="line">  CC      kernel/irq/generic-chip.o</span><br><span class="line">  CC      kernel/irq/autoprobe.o</span><br><span class="line">  CC      kernel/irq/irqdomain.o</span><br><span class="line">  CC      kernel/irq/proc.o</span><br><span class="line">  CC      kernel/irq/pm.o</span><br><span class="line">  LD      kernel/irq/built-in.o</span><br><span class="line">  LD      kernel/livepatch/built-in.o</span><br><span class="line">  CC      kernel/locking/mutex.o</span><br><span class="line">  CC      kernel/locking/semaphore.o</span><br><span class="line">  CC      kernel/locking/rwsem.o</span><br><span class="line">  CC      kernel/locking/spinlock.o</span><br><span class="line">  CC      kernel/locking/osq_lock.o</span><br><span class="line">  CC      kernel/locking/lglock.o</span><br><span class="line">  CC      kernel/locking/rtmutex.o</span><br><span class="line">  CC      kernel/locking/rwsem-xadd.o</span><br><span class="line">  LD      kernel/locking/built-in.o</span><br><span class="line">  CC      kernel/power/qos.o</span><br><span class="line">  CC      kernel/power/main.o</span><br><span class="line">  CC      kernel/power/console.o</span><br><span class="line">  CC      kernel/power/process.o</span><br><span class="line">  CC      kernel/power/suspend.o</span><br><span class="line">  CC      kernel/power/suspend_test.o</span><br><span class="line">  CC      kernel/power/poweroff.o</span><br><span class="line">  LD      kernel/power/built-in.o</span><br><span class="line">  CC      kernel/printk/printk.o</span><br><span class="line">  LD      kernel/printk/built-in.o</span><br><span class="line">  CC      kernel/rcu/update.o</span><br><span class="line">  CC      kernel/rcu/srcu.o</span><br><span class="line">  CC      kernel/rcu/tree.o</span><br><span class="line">  LD      kernel/rcu/built-in.o</span><br><span class="line">  CC      kernel/sched/core.o</span><br><span class="line">  CC      kernel/sched/proc.o</span><br><span class="line">  CC      kernel/sched/clock.o</span><br><span class="line">  CC      kernel/sched/cputime.o</span><br><span class="line">  CC      kernel/sched/idle_task.o</span><br><span class="line">  CC      kernel/sched/fair.o</span><br><span class="line">  CC      kernel/sched/rt.o</span><br><span class="line">  CC      kernel/sched/deadline.o</span><br><span class="line">  CC      kernel/sched/stop_task.o</span><br><span class="line">  CC      kernel/sched/wait.o</span><br><span class="line">  CC      kernel/sched/completion.o</span><br><span class="line">  CC      kernel/sched/idle.o</span><br><span class="line">  CC      kernel/sched/cpupri.o</span><br><span class="line">  CC      kernel/sched/cpudeadline.o</span><br><span class="line">  LD      kernel/sched/built-in.o</span><br><span class="line">  HZFILE  kernel/time/hz.bc</span><br><span class="line">  BC      kernel/time/timeconst.h</span><br><span class="line">  CC      kernel/time/time.o</span><br><span class="line">  CC      kernel/time/timer.o</span><br><span class="line">  CC      kernel/time/hrtimer.o</span><br><span class="line">  CC      kernel/time/itimer.o</span><br><span class="line">  CC      kernel/time/posix-timers.o</span><br><span class="line">  CC      kernel/time/posix-cpu-timers.o</span><br><span class="line">  CC      kernel/time/timekeeping.o</span><br><span class="line">  CC      kernel/time/ntp.o</span><br><span class="line">  CC      kernel/time/clocksource.o</span><br><span class="line">  CC      kernel/time/jiffies.o</span><br><span class="line">  CC      kernel/time/timer_list.o</span><br><span class="line">  CC      kernel/time/timeconv.o</span><br><span class="line">  CC      kernel/time/timecounter.o</span><br><span class="line">  CC      kernel/time/posix-clock.o</span><br><span class="line">  CC      kernel/time/alarmtimer.o</span><br><span class="line">  CC      kernel/time/clockevents.o</span><br><span class="line">  CC      kernel/time/tick-common.o</span><br><span class="line">  CC      kernel/time/tick-broadcast.o</span><br><span class="line">  CC      kernel/time/tick-broadcast-hrtimer.o</span><br><span class="line">  CC      kernel/time/sched_clock.o</span><br><span class="line">  CC      kernel/time/tick-oneshot.o</span><br><span class="line">  CC      kernel/time/tick-sched.o</span><br><span class="line">  CC      kernel/time/timekeeping_debug.o</span><br><span class="line">  LD      kernel/time/built-in.o</span><br><span class="line">  CC      kernel/freezer.o</span><br><span class="line">  CC      kernel/futex.o</span><br><span class="line">  CC      kernel/smp.o</span><br><span class="line">  CC      kernel/uid16.o</span><br><span class="line">  CC      kernel/module.o</span><br><span class="line">  CC      kernel/kallsyms.o</span><br><span class="line">  CC      kernel/cgroup.o</span><br><span class="line">  GZIP    kernel/config_data.gz</span><br><span class="line">  CHK     kernel/config_data.h</span><br><span class="line">  UPD     kernel/config_data.h</span><br><span class="line">  CC      kernel/configs.o</span><br><span class="line">  CC      kernel/stop_machine.o</span><br><span class="line">  CC      kernel/relay.o</span><br><span class="line">  CC      kernel/utsname_sysctl.o</span><br><span class="line">  CC      kernel/elfcore.o</span><br><span class="line">  CC      kernel/irq_work.o</span><br><span class="line">  CC      kernel/cpu_pm.o</span><br><span class="line">  LD      kernel/built-in.o</span><br><span class="line">  CC      mm/filemap.o</span><br><span class="line">  CC      mm/mempool.o</span><br><span class="line">  CC      mm/oom_kill.o</span><br><span class="line">  CC      mm/maccess.o</span><br><span class="line">  CC      mm/page_alloc.o</span><br><span class="line">  CC      mm/page-writeback.o</span><br><span class="line">  CC      mm/readahead.o</span><br><span class="line">  CC      mm/swap.o</span><br><span class="line">  CC      mm/truncate.o</span><br><span class="line">  CC      mm/vmscan.o</span><br><span class="line">  CC      mm/shmem.o</span><br><span class="line">  CC      mm/util.o</span><br><span class="line">  CC      mm/mmzone.o</span><br><span class="line">  CC      mm/vmstat.o</span><br><span class="line">  CC      mm/backing-dev.o</span><br><span class="line">  CC      mm/mm_init.o</span><br><span class="line">  CC      mm/mmu_context.o</span><br><span class="line">  CC      mm/percpu.o</span><br><span class="line">  CC      mm/slab_common.o</span><br><span class="line">  CC      mm/compaction.o</span><br><span class="line">  CC      mm/vmacache.o</span><br><span class="line">  CC      mm/interval_tree.o</span><br><span class="line">  CC      mm/list_lru.o</span><br><span class="line">  CC      mm/workingset.o</span><br><span class="line">  CC      mm/debug.o</span><br><span class="line">  CC      mm/gup.o</span><br><span class="line">  CC      mm/highmem.o</span><br><span class="line">  CC      mm/memory.o</span><br><span class="line">  CC      mm/mincore.o</span><br><span class="line">  CC      mm/mlock.o</span><br><span class="line">  CC      mm/mmap.o</span><br><span class="line">  CC      mm/mprotect.o</span><br><span class="line">  CC      mm/mremap.o</span><br><span class="line">  CC      mm/msync.o</span><br><span class="line">  CC      mm/rmap.o</span><br><span class="line">  CC      mm/vmalloc.o</span><br><span class="line">  CC      mm/pagewalk.o</span><br><span class="line">  CC      mm/pgtable-generic.o</span><br><span class="line">  CC      mm/process_vm_access.o</span><br><span class="line">  CC      mm/init-mm.o</span><br><span class="line">  CC      mm/nobootmem.o</span><br><span class="line">  CC      mm/fadvise.o</span><br><span class="line">  CC      mm/madvise.o</span><br><span class="line">  CC      mm/memblock.o</span><br><span class="line">  CC      mm/page_io.o</span><br><span class="line">  CC      mm/swap_state.o</span><br><span class="line">  CC      mm/swapfile.o</span><br><span class="line">  CC      mm/dmapool.o</span><br><span class="line">  CC      mm/slub.o</span><br><span class="line">  CC      mm/migrate.o</span><br><span class="line">  CC      mm/page_isolation.o</span><br><span class="line">  CC      mm/cma.o</span><br><span class="line">  LD      mm/built-in.o</span><br><span class="line">  CC      fs/open.o</span><br><span class="line">  CC      fs/read_write.o</span><br><span class="line">  CC      fs/file_table.o</span><br><span class="line">  CC      fs/super.o</span><br><span class="line">  CC      fs/char_dev.o</span><br><span class="line">  CC      fs/stat.o</span><br><span class="line">  CC      fs/exec.o</span><br><span class="line">  CC      fs/pipe.o</span><br><span class="line">  CC      fs/namei.o</span><br><span class="line">  CC      fs/fcntl.o</span><br><span class="line">  CC      fs/ioctl.o</span><br><span class="line">  CC      fs/readdir.o</span><br><span class="line">  CC      fs/select.o</span><br><span class="line">  CC      fs/dcache.o</span><br><span class="line">  CC      fs/inode.o</span><br><span class="line">  CC      fs/attr.o</span><br><span class="line">  CC      fs/bad_inode.o</span><br><span class="line">  CC      fs/file.o</span><br><span class="line">  CC      fs/filesystems.o</span><br><span class="line">  CC      fs/namespace.o</span><br><span class="line">  CC      fs/seq_file.o</span><br><span class="line">  CC      fs/xattr.o</span><br><span class="line">  CC      fs/libfs.o</span><br><span class="line">  CC      fs/fs-writeback.o</span><br><span class="line">  CC      fs/pnode.o</span><br><span class="line">  CC      fs/splice.o</span><br><span class="line">  CC      fs/sync.o</span><br><span class="line">  CC      fs/utimes.o</span><br><span class="line">  CC      fs/stack.o</span><br><span class="line">  CC      fs/fs_struct.o</span><br><span class="line">  CC      fs/statfs.o</span><br><span class="line">  CC      fs/fs_pin.o</span><br><span class="line">  CC      fs/nsfs.o</span><br><span class="line">  CC      fs/buffer.o</span><br><span class="line">  CC      fs/block_dev.o</span><br><span class="line">  CC      fs/direct-io.o</span><br><span class="line">  CC      fs/mpage.o</span><br><span class="line">  CC      fs/proc_namespace.o</span><br><span class="line">  CC      fs/autofs4/init.o</span><br><span class="line">  CC      fs/autofs4/inode.o</span><br><span class="line">  CC      fs/autofs4/root.o</span><br><span class="line">  CC      fs/autofs4/symlink.o</span><br><span class="line">  CC      fs/autofs4/waitq.o</span><br><span class="line">  CC      fs/autofs4/expire.o</span><br><span class="line">  CC      fs/autofs4/dev-ioctl.o</span><br><span class="line">  LD      fs/autofs4/autofs4.o</span><br><span class="line">  LD      fs/autofs4/built-in.o</span><br><span class="line">  LD      fs/configfs/built-in.o</span><br><span class="line">  CC [M]  fs/configfs/inode.o</span><br><span class="line">  CC [M]  fs/configfs/file.o</span><br><span class="line">  CC [M]  fs/configfs/dir.o</span><br><span class="line">  CC [M]  fs/configfs/symlink.o</span><br><span class="line">  CC [M]  fs/configfs/mount.o</span><br><span class="line">  CC [M]  fs/configfs/item.o</span><br><span class="line">  LD [M]  fs/configfs/configfs.o</span><br><span class="line">  CC      fs/debugfs/inode.o</span><br><span class="line">  CC      fs/debugfs/file.o</span><br><span class="line">  LD      fs/debugfs/debugfs.o</span><br><span class="line">  LD      fs/debugfs/built-in.o</span><br><span class="line">  CC      fs/devpts/inode.o</span><br><span class="line">  LD      fs/devpts/devpts.o</span><br><span class="line">  LD      fs/devpts/built-in.o</span><br><span class="line">  LD      fs/exofs/built-in.o</span><br><span class="line">  CC      fs/ext2/balloc.o</span><br><span class="line">  CC      fs/ext2/dir.o</span><br><span class="line">  CC      fs/ext2/file.o</span><br><span class="line">  CC      fs/ext2/ialloc.o</span><br><span class="line">  CC      fs/ext2/inode.o</span><br><span class="line">  CC      fs/ext2/ioctl.o</span><br><span class="line">  CC      fs/ext2/namei.o</span><br><span class="line">  CC      fs/ext2/super.o</span><br><span class="line">  CC      fs/ext2/symlink.o</span><br><span class="line">  CC      fs/ext2/xattr.o</span><br><span class="line">  CC      fs/ext2/xattr_user.o</span><br><span class="line">  CC      fs/ext2/xattr_trusted.o</span><br><span class="line">  CC      fs/ext2/acl.o</span><br><span class="line">  CC      fs/ext2/xattr_security.o</span><br><span class="line">  LD      fs/ext2/ext2.o</span><br><span class="line">  LD      fs/ext2/built-in.o</span><br><span class="line">  CC      fs/ext3/balloc.o</span><br><span class="line">  CC      fs/ext3/bitmap.o</span><br><span class="line">  CC      fs/ext3/dir.o</span><br><span class="line">  CC      fs/ext3/file.o</span><br><span class="line">  CC      fs/ext3/fsync.o</span><br><span class="line">  CC      fs/ext3/ialloc.o</span><br><span class="line">  CC      fs/ext3/inode.o</span><br><span class="line">  CC      fs/ext3/ioctl.o</span><br><span class="line">  CC      fs/ext3/namei.o</span><br><span class="line">  CC      fs/ext3/super.o</span><br><span class="line">  CC      fs/ext3/symlink.o</span><br><span class="line">  CC      fs/ext3/hash.o</span><br><span class="line">  CC      fs/ext3/resize.o</span><br><span class="line">  CC      fs/ext3/ext3_jbd.o</span><br><span class="line">  CC      fs/ext3/xattr.o</span><br><span class="line">  CC      fs/ext3/xattr_user.o</span><br><span class="line">  CC      fs/ext3/xattr_trusted.o</span><br><span class="line">  CC      fs/ext3/acl.o</span><br><span class="line">  CC      fs/ext3/xattr_security.o</span><br><span class="line">  LD      fs/ext3/ext3.o</span><br><span class="line">  LD      fs/ext3/built-in.o</span><br><span class="line">  CC      fs/ext4/balloc.o</span><br><span class="line">  CC      fs/ext4/bitmap.o</span><br><span class="line">  CC      fs/ext4/dir.o</span><br><span class="line">  CC      fs/ext4/file.o</span><br><span class="line">  CC      fs/ext4/fsync.o</span><br><span class="line">  CC      fs/ext4/ialloc.o</span><br><span class="line">  CC      fs/ext4/inode.o</span><br><span class="line">  CC      fs/ext4/page-io.o</span><br><span class="line">  CC      fs/ext4/ioctl.o</span><br><span class="line">  CC      fs/ext4/namei.o</span><br><span class="line">  CC      fs/ext4/super.o</span><br><span class="line">  CC      fs/ext4/symlink.o</span><br><span class="line">  CC      fs/ext4/hash.o</span><br><span class="line">  CC      fs/ext4/resize.o</span><br><span class="line">  CC      fs/ext4/extents.o</span><br><span class="line">  CC      fs/ext4/ext4_jbd2.o</span><br><span class="line">  CC      fs/ext4/migrate.o</span><br><span class="line">  CC      fs/ext4/mballoc.o</span><br><span class="line">  CC      fs/ext4/block_validity.o</span><br><span class="line">  CC      fs/ext4/move_extent.o</span><br><span class="line">  CC      fs/ext4/mmp.o</span><br><span class="line">  CC      fs/ext4/indirect.o</span><br><span class="line">  CC      fs/ext4/extents_status.o</span><br><span class="line">  CC      fs/ext4/xattr.o</span><br><span class="line">  CC      fs/ext4/xattr_user.o</span><br><span class="line">  CC      fs/ext4/xattr_trusted.o</span><br><span class="line">  CC      fs/ext4/inline.o</span><br><span class="line">  CC      fs/ext4/readpage.o</span><br><span class="line">  CC      fs/ext4/acl.o</span><br><span class="line">  CC      fs/ext4/xattr_security.o</span><br><span class="line">  LD      fs/ext4/ext4.o</span><br><span class="line">  LD      fs/ext4/built-in.o</span><br><span class="line">  CC      fs/fat/cache.o</span><br><span class="line">  CC      fs/fat/dir.o</span><br><span class="line">  CC      fs/fat/fatent.o</span><br><span class="line">  CC      fs/fat/file.o</span><br><span class="line">  CC      fs/fat/inode.o</span><br><span class="line">  CC      fs/fat/misc.o</span><br><span class="line">  CC      fs/fat/nfs.o</span><br><span class="line">  LD      fs/fat/fat.o</span><br><span class="line">  CC      fs/fat/namei_vfat.o</span><br><span class="line">  LD      fs/fat/vfat.o</span><br><span class="line">  LD      fs/fat/built-in.o</span><br><span class="line">  CC [M]  fs/fat/namei_msdos.o</span><br><span class="line">  LD [M]  fs/fat/msdos.o</span><br><span class="line">  CC      fs/fuse/dev.o</span><br><span class="line">  CC      fs/fuse/dir.o</span><br><span class="line">  CC      fs/fuse/file.o</span><br><span class="line">  CC      fs/fuse/inode.o</span><br><span class="line">  CC      fs/fuse/control.o</span><br><span class="line">  LD      fs/fuse/fuse.o</span><br><span class="line">  LD      fs/fuse/built-in.o</span><br><span class="line">  LD      fs/isofs/built-in.o</span><br><span class="line">  CC [M]  fs/isofs/namei.o</span><br><span class="line">  CC [M]  fs/isofs/inode.o</span><br><span class="line">  CC [M]  fs/isofs/dir.o</span><br><span class="line">  CC [M]  fs/isofs/util.o</span><br><span class="line">  CC [M]  fs/isofs/rock.o</span><br><span class="line">  CC [M]  fs/isofs/export.o</span><br><span class="line">  CC [M]  fs/isofs/joliet.o</span><br><span class="line">  CC [M]  fs/isofs/compress.o</span><br><span class="line">  LD [M]  fs/isofs/isofs.o</span><br><span class="line">  CC      fs/jbd/transaction.o</span><br><span class="line">  CC      fs/jbd/commit.o</span><br><span class="line">  CC      fs/jbd/recovery.o</span><br><span class="line">  CC      fs/jbd/checkpoint.o</span><br><span class="line">  CC      fs/jbd/revoke.o</span><br><span class="line">  CC      fs/jbd/journal.o</span><br><span class="line">  LD      fs/jbd/jbd.o</span><br><span class="line">  LD      fs/jbd/built-in.o</span><br><span class="line">  CC      fs/jbd2/transaction.o</span><br><span class="line">  CC      fs/jbd2/commit.o</span><br><span class="line">  CC      fs/jbd2/recovery.o</span><br><span class="line">  CC      fs/jbd2/checkpoint.o</span><br><span class="line">  CC      fs/jbd2/revoke.o</span><br><span class="line">  CC      fs/jbd2/journal.o</span><br><span class="line">  LD      fs/jbd2/jbd2.o</span><br><span class="line">  LD      fs/jbd2/built-in.o</span><br><span class="line">  CC      fs/jffs2/compr.o</span><br><span class="line">  CC      fs/jffs2/dir.o</span><br><span class="line">  CC      fs/jffs2/file.o</span><br><span class="line">  CC      fs/jffs2/ioctl.o</span><br><span class="line">  CC      fs/jffs2/nodelist.o</span><br><span class="line">  CC      fs/jffs2/malloc.o</span><br><span class="line">  CC      fs/jffs2/read.o</span><br><span class="line">  CC      fs/jffs2/nodemgmt.o</span><br><span class="line">  CC      fs/jffs2/readinode.o</span><br><span class="line">  CC      fs/jffs2/write.o</span><br><span class="line">  CC      fs/jffs2/scan.o</span><br><span class="line">  CC      fs/jffs2/gc.o</span><br><span class="line">  CC      fs/jffs2/symlink.o</span><br><span class="line">  CC      fs/jffs2/build.o</span><br><span class="line">  CC      fs/jffs2/erase.o</span><br><span class="line">  CC      fs/jffs2/background.o</span><br><span class="line">  CC      fs/jffs2/fs.o</span><br><span class="line">  CC      fs/jffs2/writev.o</span><br><span class="line">  CC      fs/jffs2/super.o</span><br><span class="line">  CC      fs/jffs2/debug.o</span><br><span class="line">  CC      fs/jffs2/wbuf.o</span><br><span class="line">  CC      fs/jffs2/compr_rtime.o</span><br><span class="line">  CC      fs/jffs2/compr_zlib.o</span><br><span class="line">  LD      fs/jffs2/jffs2.o</span><br><span class="line">  LD      fs/jffs2/built-in.o</span><br><span class="line">  CC      fs/kernfs/mount.o</span><br><span class="line">  CC      fs/kernfs/inode.o</span><br><span class="line">  CC      fs/kernfs/dir.o</span><br><span class="line">  CC      fs/kernfs/file.o</span><br><span class="line">  CC      fs/kernfs/symlink.o</span><br><span class="line">  LD      fs/kernfs/built-in.o</span><br><span class="line">  CC      fs/lockd/clntlock.o</span><br><span class="line">  CC      fs/lockd/clntproc.o</span><br><span class="line">  CC      fs/lockd/clntxdr.o</span><br><span class="line">  CC      fs/lockd/host.o</span><br><span class="line">  CC      fs/lockd/svc.o</span><br><span class="line">  CC      fs/lockd/svclock.o</span><br><span class="line">  CC      fs/lockd/svcshare.o</span><br><span class="line">  CC      fs/lockd/svcproc.o</span><br><span class="line">  CC      fs/lockd/svcsubs.o</span><br><span class="line">  CC      fs/lockd/mon.o</span><br><span class="line">  CC      fs/lockd/xdr.o</span><br><span class="line">  CC      fs/lockd/clnt4xdr.o</span><br><span class="line">  CC      fs/lockd/xdr4.o</span><br><span class="line">  CC      fs/lockd/svc4proc.o</span><br><span class="line">  CC      fs/lockd/procfs.o</span><br><span class="line">  LD      fs/lockd/lockd.o</span><br><span class="line">  LD      fs/lockd/built-in.o</span><br><span class="line">  CC      fs/nfs/client.o</span><br><span class="line">  CC      fs/nfs/dir.o</span><br><span class="line">  CC      fs/nfs/file.o</span><br><span class="line">  CC      fs/nfs/getroot.o</span><br><span class="line">  CC      fs/nfs/inode.o</span><br><span class="line">  CC      fs/nfs/super.o</span><br><span class="line">  CC      fs/nfs/direct.o</span><br><span class="line">  CC      fs/nfs/pagelist.o</span><br><span class="line">  CC      fs/nfs/read.o</span><br><span class="line">  CC      fs/nfs/symlink.o</span><br><span class="line">  CC      fs/nfs/unlink.o</span><br><span class="line">  CC      fs/nfs/write.o</span><br><span class="line">  CC      fs/nfs/namespace.o</span><br><span class="line">  CC      fs/nfs/mount_clnt.o</span><br><span class="line">  CC      fs/nfs/nfstrace.o</span><br><span class="line">  CC      fs/nfs/nfsroot.o</span><br><span class="line">  CC      fs/nfs/sysctl.o</span><br><span class="line">  LD      fs/nfs/nfs.o</span><br><span class="line">  CC      fs/nfs/nfs2super.o</span><br><span class="line">  CC      fs/nfs/proc.o</span><br><span class="line">  CC      fs/nfs/nfs2xdr.o</span><br><span class="line">  LD      fs/nfs/nfsv2.o</span><br><span class="line">  CC      fs/nfs/nfs3super.o</span><br><span class="line">  CC      fs/nfs/nfs3client.o</span><br><span class="line">  CC      fs/nfs/nfs3proc.o</span><br><span class="line">  CC      fs/nfs/nfs3xdr.o</span><br><span class="line">  CC      fs/nfs/nfs3acl.o</span><br><span class="line">  LD      fs/nfs/nfsv3.o</span><br><span class="line">  CC      fs/nfs/nfs4proc.o</span><br><span class="line">  CC      fs/nfs/nfs4xdr.o</span><br><span class="line">  CC      fs/nfs/nfs4state.o</span><br><span class="line">  CC      fs/nfs/nfs4renewd.o</span><br><span class="line">  CC      fs/nfs/nfs4super.o</span><br><span class="line">  CC      fs/nfs/nfs4file.o</span><br><span class="line">  CC      fs/nfs/delegation.o</span><br><span class="line">  CC      fs/nfs/nfs4idmap.o</span><br><span class="line">  CC      fs/nfs/callback.o</span><br><span class="line">  CC      fs/nfs/callback_xdr.o</span><br><span class="line">  CC      fs/nfs/callback_proc.o</span><br><span class="line">  CC      fs/nfs/nfs4namespace.o</span><br><span class="line">  CC      fs/nfs/nfs4getroot.o</span><br><span class="line">  CC      fs/nfs/nfs4client.o</span><br><span class="line">  CC      fs/nfs/nfs4session.o</span><br><span class="line">  CC      fs/nfs/dns_resolve.o</span><br><span class="line">  CC      fs/nfs/nfs4trace.o</span><br><span class="line">  CC      fs/nfs/nfs4sysctl.o</span><br><span class="line">  LD      fs/nfs/nfsv4.o</span><br><span class="line">  LD      fs/nfs/built-in.o</span><br><span class="line">  CC      fs/nfs_common/nfsacl.o</span><br><span class="line">  LD      fs/nfs_common/nfs_acl.o</span><br><span class="line">  CC      fs/nfs_common/grace.o</span><br><span class="line">  LD      fs/nfs_common/built-in.o</span><br><span class="line">  CC      fs/nls/nls_base.o</span><br><span class="line">  CC      fs/nls/nls_cp437.o</span><br><span class="line">  CC      fs/nls/nls_ascii.o</span><br><span class="line">  CC      fs/nls/nls_iso8859-1.o</span><br><span class="line">  CC      fs/nls/nls_utf8.o</span><br><span class="line">  LD      fs/nls/built-in.o</span><br><span class="line">  CC [M]  fs/nls/nls_iso8859-15.o</span><br><span class="line">  CC      fs/notify/fsnotify.o</span><br><span class="line">  CC      fs/notify/notification.o</span><br><span class="line">  CC      fs/notify/group.o</span><br><span class="line">  CC      fs/notify/inode_mark.o</span><br><span class="line">  CC      fs/notify/mark.o</span><br><span class="line">  CC      fs/notify/vfsmount_mark.o</span><br><span class="line">  CC      fs/notify/fdinfo.o</span><br><span class="line">  CC      fs/notify/dnotify/dnotify.o</span><br><span class="line">  LD      fs/notify/dnotify/built-in.o</span><br><span class="line">  LD      fs/notify/fanotify/built-in.o</span><br><span class="line">  CC      fs/notify/inotify/inotify_fsnotify.o</span><br><span class="line">  CC      fs/notify/inotify/inotify_user.o</span><br><span class="line">  LD      fs/notify/inotify/built-in.o</span><br><span class="line">  LD      fs/notify/built-in.o</span><br><span class="line">  CC      fs/proc/task_mmu.o</span><br><span class="line">  CC      fs/proc/inode.o</span><br><span class="line">  CC      fs/proc/root.o</span><br><span class="line">  CC      fs/proc/base.o</span><br><span class="line">  CC      fs/proc/generic.o</span><br><span class="line">  CC      fs/proc/array.o</span><br><span class="line">  CC      fs/proc/fd.o</span><br><span class="line">  CC      fs/proc/proc_tty.o</span><br><span class="line">  CC      fs/proc/cmdline.o</span><br><span class="line">  CC      fs/proc/consoles.o</span><br><span class="line">  CC      fs/proc/cpuinfo.o</span><br><span class="line">  CC      fs/proc/devices.o</span><br><span class="line">  CC      fs/proc/interrupts.o</span><br><span class="line">  CC      fs/proc/loadavg.o</span><br><span class="line">  CC      fs/proc/meminfo.o</span><br><span class="line">  CC      fs/proc/stat.o</span><br><span class="line">  CC      fs/proc/uptime.o</span><br><span class="line">  CC      fs/proc/version.o</span><br><span class="line">  CC      fs/proc/softirqs.o</span><br><span class="line">  CC      fs/proc/namespaces.o</span><br><span class="line">  CC      fs/proc/self.o</span><br><span class="line">  CC      fs/proc/thread_self.o</span><br><span class="line">  CC      fs/proc/proc_sysctl.o</span><br><span class="line">  CC      fs/proc/proc_net.o</span><br><span class="line">  CC      fs/proc/kmsg.o</span><br><span class="line">  CC      fs/proc/page.o</span><br><span class="line">  LD      fs/proc/proc.o</span><br><span class="line">  LD      fs/proc/built-in.o</span><br><span class="line">  CC      fs/quota/dquot.o</span><br><span class="line">  CC      fs/quota/quota.o</span><br><span class="line">  CC      fs/quota/kqid.o</span><br><span class="line">  CC      fs/quota/netlink.o</span><br><span class="line">  LD      fs/quota/built-in.o</span><br><span class="line">  CC      fs/ramfs/inode.o</span><br><span class="line">  CC      fs/ramfs/file-mmu.o</span><br><span class="line">  LD      fs/ramfs/ramfs.o</span><br><span class="line">  LD      fs/ramfs/built-in.o</span><br><span class="line">  CC      fs/sysfs/file.o</span><br><span class="line">  CC      fs/sysfs/dir.o</span><br><span class="line">  CC      fs/sysfs/symlink.o</span><br><span class="line">  CC      fs/sysfs/mount.o</span><br><span class="line">  CC      fs/sysfs/group.o</span><br><span class="line">  LD      fs/sysfs/built-in.o</span><br><span class="line">  CC      fs/ubifs/shrinker.o</span><br><span class="line">  CC      fs/ubifs/journal.o</span><br><span class="line">  CC      fs/ubifs/file.o</span><br><span class="line">  CC      fs/ubifs/dir.o</span><br><span class="line">  CC      fs/ubifs/super.o</span><br><span class="line">  CC      fs/ubifs/sb.o</span><br><span class="line">  CC      fs/ubifs/io.o</span><br><span class="line">  CC      fs/ubifs/tnc.o</span><br><span class="line">  CC      fs/ubifs/master.o</span><br><span class="line">  CC      fs/ubifs/scan.o</span><br><span class="line">  CC      fs/ubifs/replay.o</span><br><span class="line">  CC      fs/ubifs/log.o</span><br><span class="line">  CC      fs/ubifs/commit.o</span><br><span class="line">  CC      fs/ubifs/gc.o</span><br><span class="line">  CC      fs/ubifs/orphan.o</span><br><span class="line">  CC      fs/ubifs/budget.o</span><br><span class="line">  CC      fs/ubifs/find.o</span><br><span class="line">  CC      fs/ubifs/tnc_commit.o</span><br><span class="line">  CC      fs/ubifs/compress.o</span><br><span class="line">  CC      fs/ubifs/lpt.o</span><br><span class="line">  CC      fs/ubifs/lprops.o</span><br><span class="line">  CC      fs/ubifs/recovery.o</span><br><span class="line">  CC      fs/ubifs/ioctl.o</span><br><span class="line">  CC      fs/ubifs/lpt_commit.o</span><br><span class="line">  CC      fs/ubifs/tnc_misc.o</span><br><span class="line">  CC      fs/ubifs/xattr.o</span><br><span class="line">  CC      fs/ubifs/debug.o</span><br><span class="line">  LD      fs/ubifs/ubifs.o</span><br><span class="line">  LD      fs/ubifs/built-in.o</span><br><span class="line">  LD      fs/udf/built-in.o</span><br><span class="line">  CC [M]  fs/udf/balloc.o</span><br><span class="line">  CC [M]  fs/udf/dir.o</span><br><span class="line">  CC [M]  fs/udf/file.o</span><br><span class="line">  CC [M]  fs/udf/ialloc.o</span><br><span class="line">  CC [M]  fs/udf/inode.o</span><br><span class="line">  CC [M]  fs/udf/lowlevel.o</span><br><span class="line">  CC [M]  fs/udf/namei.o</span><br><span class="line">  CC [M]  fs/udf/partition.o</span><br><span class="line">  CC [M]  fs/udf/super.o</span><br><span class="line">  CC [M]  fs/udf/truncate.o</span><br><span class="line">  CC [M]  fs/udf/symlink.o</span><br><span class="line">  CC [M]  fs/udf/directory.o</span><br><span class="line">  CC [M]  fs/udf/misc.o</span><br><span class="line">  CC [M]  fs/udf/udftime.o</span><br><span class="line">  CC [M]  fs/udf/unicode.o</span><br><span class="line">  LD [M]  fs/udf/udf.o</span><br><span class="line">  CC      fs/eventpoll.o</span><br><span class="line">  CC      fs/anon_inodes.o</span><br><span class="line">  CC      fs/signalfd.o</span><br><span class="line">  CC      fs/timerfd.o</span><br><span class="line">  CC      fs/eventfd.o</span><br><span class="line">  CC      fs/aio.o</span><br><span class="line">  CC      fs/locks.o</span><br><span class="line">  CC      fs/binfmt_script.o</span><br><span class="line">  CC      fs/binfmt_elf.o</span><br><span class="line">  CC      fs/mbcache.o</span><br><span class="line">  CC      fs/posix_acl.o</span><br><span class="line">  CC      fs/coredump.o</span><br><span class="line">  CC      fs/drop_caches.o</span><br><span class="line">  LD      fs/built-in.o</span><br><span class="line">  CC [M]  fs/binfmt_misc.o</span><br><span class="line">  CC      ipc/util.o</span><br><span class="line">  CC      ipc/msgutil.o</span><br><span class="line">  CC      ipc/msg.o</span><br><span class="line">  CC      ipc/sem.o</span><br><span class="line">  CC      ipc/shm.o</span><br><span class="line">  CC      ipc/syscall.o</span><br><span class="line">  CC      ipc/ipc_sysctl.o</span><br><span class="line">  LD      ipc/built-in.o</span><br><span class="line">  CC      security/keys/gc.o</span><br><span class="line">  CC      security/keys/key.o</span><br><span class="line">  CC      security/keys/keyring.o</span><br><span class="line">  CC      security/keys/keyctl.o</span><br><span class="line">  CC      security/keys/permission.o</span><br><span class="line">  CC      security/keys/process_keys.o</span><br><span class="line">  CC      security/keys/request_key.o</span><br><span class="line">  CC      security/keys/request_key_auth.o</span><br><span class="line">  CC      security/keys/user_defined.o</span><br><span class="line">  CC      security/keys/proc.o</span><br><span class="line">  CC      security/keys/sysctl.o</span><br><span class="line">  LD      security/keys/built-in.o</span><br><span class="line">  CC      security/commoncap.o</span><br><span class="line">  CC      security/min_addr.o</span><br><span class="line">  CC      security/inode.o</span><br><span class="line">  LD      security/built-in.o</span><br><span class="line">  CC      crypto/api.o</span><br><span class="line">  CC      crypto/cipher.o</span><br><span class="line">  CC      crypto/compress.o</span><br><span class="line">  CC      crypto/memneq.o</span><br><span class="line">  LD      crypto/crypto.o</span><br><span class="line">  CC      crypto/crypto_wq.o</span><br><span class="line">  CC      crypto/algapi.o</span><br><span class="line">  CC      crypto/scatterwalk.o</span><br><span class="line">  CC      crypto/proc.o</span><br><span class="line">  LD      crypto/crypto_algapi.o</span><br><span class="line">  CC      crypto/aead.o</span><br><span class="line">  CC      crypto/ablkcipher.o</span><br><span class="line">  CC      crypto/blkcipher.o</span><br><span class="line">  LD      crypto/crypto_blkcipher.o</span><br><span class="line">  CC      crypto/chainiv.o</span><br><span class="line">  CC      crypto/eseqiv.o</span><br><span class="line">  CC      crypto/seqiv.o</span><br><span class="line">  CC      crypto/ahash.o</span><br><span class="line">  CC      crypto/shash.o</span><br><span class="line">  LD      crypto/crypto_hash.o</span><br><span class="line">  CC      crypto/pcompress.o</span><br><span class="line">  CC      crypto/algboss.o</span><br><span class="line">  CC      crypto/testmgr.o</span><br><span class="line">  LD      crypto/cryptomgr.o</span><br><span class="line">  CC      crypto/crypto_user.o</span><br><span class="line">  CC      crypto/cmac.o</span><br><span class="line">  CC      crypto/crypto_null.o</span><br><span class="line">  CC      crypto/md4.o</span><br><span class="line">  CC      crypto/md5.o</span><br><span class="line">  CC      crypto/rmd128.o</span><br><span class="line">  CC      crypto/rmd160.o</span><br><span class="line">  CC      crypto/rmd256.o</span><br><span class="line">  CC      crypto/rmd320.o</span><br><span class="line">  CC      crypto/sha1_generic.o</span><br><span class="line">  CC      crypto/sha256_generic.o</span><br><span class="line">  CC      crypto/sha512_generic.o</span><br><span class="line">  CC      crypto/wp512.o</span><br><span class="line">  CC      crypto/tgr192.o</span><br><span class="line">  CC      crypto/gf128mul.o</span><br><span class="line">  CC      crypto/ecb.o</span><br><span class="line">  CC      crypto/cbc.o</span><br><span class="line">  CC      crypto/cts.o</span><br><span class="line">  CC      crypto/lrw.o</span><br><span class="line">  CC      crypto/xts.o</span><br><span class="line">  CC      crypto/ctr.o</span><br><span class="line">  CC      crypto/gcm.o</span><br><span class="line">  CC      crypto/ccm.o</span><br><span class="line">  CC      crypto/des_generic.o</span><br><span class="line">  CC      crypto/blowfish_generic.o</span><br><span class="line">  CC      crypto/blowfish_common.o</span><br><span class="line">  CC      crypto/twofish_generic.o</span><br><span class="line">  CC      crypto/twofish_common.o</span><br><span class="line">  CC      crypto/aes_generic.o</span><br><span class="line">  CC      crypto/camellia_generic.o</span><br><span class="line">  CC      crypto/arc4.o</span><br><span class="line">  CC      crypto/deflate.o</span><br><span class="line">  CC      crypto/michael_mic.o</span><br><span class="line">  CC      crypto/crc32c_generic.o</span><br><span class="line">  CC      crypto/crct10dif_common.o</span><br><span class="line">  CC      crypto/crct10dif_generic.o</span><br><span class="line">  CC      crypto/authenc.o</span><br><span class="line">  CC      crypto/authencesn.o</span><br><span class="line">  CC      crypto/lzo.o</span><br><span class="line">  CC      crypto/rng.o</span><br><span class="line">  CC      crypto/krng.o</span><br><span class="line">  CC      crypto/ghash-generic.o</span><br><span class="line">  LD      crypto/built-in.o</span><br><span class="line">  CC [M]  crypto/tcrypt.o</span><br><span class="line">  CC      block/bio.o</span><br><span class="line">  CC      block/elevator.o</span><br><span class="line">  CC      block/blk-core.o</span><br><span class="line">  CC      block/blk-tag.o</span><br><span class="line">  CC      block/blk-sysfs.o</span><br><span class="line">  CC      block/blk-flush.o</span><br><span class="line">  CC      block/blk-settings.o</span><br><span class="line">  CC      block/blk-ioc.o</span><br><span class="line">  CC      block/blk-map.o</span><br><span class="line">  CC      block/blk-exec.o</span><br><span class="line">  CC      block/blk-merge.o</span><br><span class="line">  CC      block/blk-softirq.o</span><br><span class="line">  CC      block/blk-timeout.o</span><br><span class="line">  CC      block/blk-iopoll.o</span><br><span class="line">  CC      block/blk-lib.o</span><br><span class="line">  CC      block/blk-mq.o</span><br><span class="line">  CC      block/blk-mq-tag.o</span><br><span class="line">  CC      block/blk-mq-sysfs.o</span><br><span class="line">  CC      block/blk-mq-cpu.o</span><br><span class="line">  CC      block/blk-mq-cpumap.o</span><br><span class="line">  CC      block/ioctl.o</span><br><span class="line">  CC      block/genhd.o</span><br><span class="line">  CC      block/scsi_ioctl.o</span><br><span class="line">  CC      block/partition-generic.o</span><br><span class="line">  CC      block/ioprio.o</span><br><span class="line">  CC      block/partitions/check.o</span><br><span class="line">  CC      block/partitions/msdos.o</span><br><span class="line">  CC      block/partitions/efi.o</span><br><span class="line">  LD      block/partitions/built-in.o</span><br><span class="line">  CC      block/bounce.o</span><br><span class="line">  CC      block/noop-iosched.o</span><br><span class="line">  CC      block/deadline-iosched.o</span><br><span class="line">  CC      block/cfq-iosched.o</span><br><span class="line">  LD      block/built-in.o</span><br><span class="line">  LD      drivers/amba/built-in.o</span><br><span class="line">  CC      drivers/ata/libata-core.o</span><br><span class="line">  CC      drivers/ata/libata-scsi.o</span><br><span class="line">  CC      drivers/ata/libata-eh.o</span><br><span class="line">  CC      drivers/ata/libata-transport.o</span><br><span class="line">  CC      drivers/ata/libata-trace.o</span><br><span class="line">  CC      drivers/ata/libata-sff.o</span><br><span class="line">  CC      drivers/ata/libata-pmp.o</span><br><span class="line">  LD      drivers/ata/libata.o</span><br><span class="line">  CC      drivers/ata/ahci_platform.o</span><br><span class="line">  CC      drivers/ata/libahci.o</span><br><span class="line">  CC      drivers/ata/libahci_platform.o</span><br><span class="line">  CC      drivers/ata/ahci_imx.o</span><br><span class="line">  CC      drivers/ata/pata_imx.o</span><br><span class="line">  LD      drivers/ata/built-in.o</span><br><span class="line">  LD      drivers/auxdisplay/built-in.o</span><br><span class="line">  CC      drivers/base/component.o</span><br><span class="line">  CC      drivers/base/core.o</span><br><span class="line">  CC      drivers/base/bus.o</span><br><span class="line">  CC      drivers/base/dd.o</span><br><span class="line">  CC      drivers/base/syscore.o</span><br><span class="line">  CC      drivers/base/driver.o</span><br><span class="line">  CC      drivers/base/class.o</span><br><span class="line">  CC      drivers/base/platform.o</span><br><span class="line">  CC      drivers/base/cpu.o</span><br><span class="line">  CC      drivers/base/firmware.o</span><br><span class="line">  CC      drivers/base/init.o</span><br><span class="line">  CC      drivers/base/map.o</span><br><span class="line">  CC      drivers/base/devres.o</span><br><span class="line">  CC      drivers/base/attribute_container.o</span><br><span class="line">  CC      drivers/base/transport_class.o</span><br><span class="line">  CC      drivers/base/topology.o</span><br><span class="line">  CC      drivers/base/container.o</span><br><span class="line">  CC      drivers/base/property.o</span><br><span class="line">  CC      drivers/base/cacheinfo.o</span><br><span class="line">  CC      drivers/base/devtmpfs.o</span><br><span class="line">  CC      drivers/base/dma-contiguous.o</span><br><span class="line">  CC      drivers/base/power/sysfs.o</span><br><span class="line">  CC      drivers/base/power/generic_ops.o</span><br><span class="line">  CC      drivers/base/power/common.o</span><br><span class="line">  CC      drivers/base/power/qos.o</span><br><span class="line">  CC      drivers/base/power/runtime.o</span><br><span class="line">  CC      drivers/base/power/main.o</span><br><span class="line">  CC      drivers/base/power/wakeup.o</span><br><span class="line">  CC      drivers/base/power/opp.o</span><br><span class="line">  CC      drivers/base/power/domain.o</span><br><span class="line">  CC      drivers/base/power/domain_governor.o</span><br><span class="line">  CC      drivers/base/power/clock_ops.o</span><br><span class="line">  LD      drivers/base/power/built-in.o</span><br><span class="line">  CC      drivers/base/regmap/regmap.o</span><br><span class="line">  CC      drivers/base/regmap/regcache.o</span><br><span class="line">  CC      drivers/base/regmap/regcache-rbtree.o</span><br><span class="line">  CC      drivers/base/regmap/regcache-lzo.o</span><br><span class="line">  CC      drivers/base/regmap/regcache-flat.o</span><br><span class="line">  CC      drivers/base/regmap/regmap-debugfs.o</span><br><span class="line">  CC      drivers/base/regmap/regmap-i2c.o</span><br><span class="line">  CC      drivers/base/regmap/regmap-spi.o</span><br><span class="line">  CC      drivers/base/regmap/regmap-mmio.o</span><br><span class="line">  CC      drivers/base/regmap/regmap-irq.o</span><br><span class="line">  LD      drivers/base/regmap/built-in.o</span><br><span class="line">  CC      drivers/base/dma-mapping.o</span><br><span class="line">  CC      drivers/base/dma-coherent.o</span><br><span class="line">  CC      drivers/base/firmware_class.o</span><br><span class="line">  CC      drivers/base/module.o</span><br><span class="line">  CC      drivers/base/soc.o</span><br><span class="line">  CC      drivers/base/pinctrl.o</span><br><span class="line">  LD      drivers/base/built-in.o</span><br><span class="line">  CC      drivers/block/brd.o</span><br><span class="line">  CC      drivers/block/loop.o</span><br><span class="line">  LD      drivers/block/built-in.o</span><br><span class="line">  CC      drivers/bluetooth/hci_ldisc.o</span><br><span class="line">  CC      drivers/bluetooth/hci_h4.o</span><br><span class="line">  CC      drivers/bluetooth/hci_bcsp.o</span><br><span class="line">  CC      drivers/bluetooth/hci_ath.o</span><br><span class="line">  LD      drivers/bluetooth/hci_uart.o</span><br><span class="line">  CC      drivers/bluetooth/bcm203x.o</span><br><span class="line">  CC      drivers/bluetooth/btusb.o</span><br><span class="line">  CC      drivers/bluetooth/btintel.o</span><br><span class="line">  CC      drivers/bluetooth/ath3k.o</span><br><span class="line">  CC      drivers/bluetooth/btbcm.o</span><br><span class="line">  LD      drivers/bluetooth/built-in.o</span><br><span class="line">  CC [M]  drivers/bluetooth/rtk_coex.o</span><br><span class="line">  CC [M]  drivers/bluetooth/rtk_bt.o</span><br><span class="line">  LD [M]  drivers/bluetooth/rtk_btusb.o</span><br><span class="line">  CC      drivers/bus/arm-cci.o</span><br><span class="line">  CC      drivers/bus/imx-weim.o</span><br><span class="line">  LD      drivers/bus/built-in.o</span><br><span class="line">  LD      drivers/cdrom/built-in.o</span><br><span class="line">  CC      drivers/char/mem.o</span><br><span class="line">  CC      drivers/char/random.o</span><br><span class="line">  CC      drivers/char/misc.o</span><br><span class="line">  CC      drivers/char/fsl_otp.o</span><br><span class="line">  CC      drivers/char/ap3216c.o</span><br><span class="line">  CC      drivers/char/apm-emulation.o</span><br><span class="line">  LD      drivers/char/agp/built-in.o</span><br><span class="line">  CC      drivers/char/hw_random/core.o</span><br><span class="line">  LD      drivers/char/hw_random/rng-core.o</span><br><span class="line">  CC      drivers/char/hw_random/imx-rng.o</span><br><span class="line">  LD      drivers/char/hw_random/built-in.o</span><br><span class="line">  CC      drivers/char/imx_amp/imx_sema4.o</span><br><span class="line">  LD      drivers/char/imx_amp/built-in.o</span><br><span class="line">  LD      drivers/char/built-in.o</span><br><span class="line">  CC      drivers/clk/clk-devres.o</span><br><span class="line">  CC      drivers/clk/clkdev.o</span><br><span class="line">  CC      drivers/clk/clk.o</span><br><span class="line">  CC      drivers/clk/clk-divider.o</span><br><span class="line">  CC      drivers/clk/clk-fixed-factor.o</span><br><span class="line">  CC      drivers/clk/clk-fixed-rate.o</span><br><span class="line">  CC      drivers/clk/clk-gate.o</span><br><span class="line">  CC      drivers/clk/clk-mux.o</span><br><span class="line">  CC      drivers/clk/clk-composite.o</span><br><span class="line">  CC      drivers/clk/clk-fractional-divider.o</span><br><span class="line">  CC      drivers/clk/clk-gpio-gate.o</span><br><span class="line">  CC      drivers/clk/clk-conf.o</span><br><span class="line">  LD      drivers/clk/built-in.o</span><br><span class="line">  CC      drivers/clocksource/clksrc-of.o</span><br><span class="line">  CC      drivers/clocksource/mmio.o</span><br><span class="line">  CC      drivers/clocksource/arm_arch_timer.o</span><br><span class="line">  CC      drivers/clocksource/arm_global_timer.o</span><br><span class="line">  CC      drivers/clocksource/dummy_timer.o</span><br><span class="line">  LD      drivers/clocksource/built-in.o</span><br><span class="line">  CC      drivers/connector/cn_queue.o</span><br><span class="line">  CC      drivers/connector/connector.o</span><br><span class="line">  LD      drivers/connector/cn.o</span><br><span class="line">  CC      drivers/connector/cn_proc.o</span><br><span class="line">  LD      drivers/connector/built-in.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq.o</span><br><span class="line">  CC      drivers/cpufreq/freq_table.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq_opp.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq_stats.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq_performance.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq_powersave.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq_userspace.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq_conservative.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq_interactive.o</span><br><span class="line">  CC      drivers/cpufreq/cpufreq_governor.o</span><br><span class="line">  CC      drivers/cpufreq/imx6q-cpufreq.o</span><br><span class="line">  CC      drivers/cpufreq/imx7-cpufreq.o</span><br><span class="line">  LD      drivers/cpufreq/built-in.o</span><br><span class="line">  CC      drivers/cpuidle/cpuidle.o</span><br><span class="line">  CC      drivers/cpuidle/driver.o</span><br><span class="line">  CC      drivers/cpuidle/governor.o</span><br><span class="line">  CC      drivers/cpuidle/sysfs.o</span><br><span class="line">  CC      drivers/cpuidle/governors/ladder.o</span><br><span class="line">  CC      drivers/cpuidle/governors/menu.o</span><br><span class="line">  LD      drivers/cpuidle/governors/built-in.o</span><br><span class="line">  LD      drivers/cpuidle/built-in.o</span><br><span class="line">  CC      drivers/crypto/caam/ctrl.o</span><br><span class="line">  LD      drivers/crypto/caam/caam.o</span><br><span class="line">  CC      drivers/crypto/caam/jr.o</span><br><span class="line">  CC      drivers/crypto/caam/key_gen.o</span><br><span class="line">  CC      drivers/crypto/caam/error.o</span><br><span class="line">  LD      drivers/crypto/caam/caam_jr.o</span><br><span class="line">  CC      drivers/crypto/caam/caamalg.o</span><br><span class="line">  CC      drivers/crypto/caam/caamhash.o</span><br><span class="line">  CC      drivers/crypto/caam/caamrng.o</span><br><span class="line">  CC      drivers/crypto/caam/sm_store.o</span><br><span class="line">  CC      drivers/crypto/caam/sm_test.o</span><br><span class="line">  CC      drivers/crypto/caam/secvio.o</span><br><span class="line">  LD      drivers/crypto/caam/built-in.o</span><br><span class="line">  CC      drivers/crypto/mxs-dcp.o</span><br><span class="line">  LD      drivers/crypto/built-in.o</span><br><span class="line">  CC      drivers/dma/dmaengine.o</span><br><span class="line">  CC      drivers/dma/virt-dma.o</span><br><span class="line">  CC      drivers/dma/of-dma.o</span><br><span class="line">  CC      drivers/dma/ipu/ipu_irq.o</span><br><span class="line">  CC      drivers/dma/ipu/ipu_idmac.o</span><br><span class="line">  LD      drivers/dma/ipu/built-in.o</span><br><span class="line">  CC      drivers/dma/pxp/pxp_dma_v2.o</span><br><span class="line">  CC      drivers/dma/pxp/pxp_dma_v3.o</span><br><span class="line">  CC      drivers/dma/pxp/pxp_device.o</span><br><span class="line">  LD      drivers/dma/pxp/built-in.o</span><br><span class="line">  LD      drivers/dma/xilinx/built-in.o</span><br><span class="line">  CC      drivers/dma/imx-sdma.o</span><br><span class="line">  CC      drivers/dma/mxs-dma.o</span><br><span class="line">  LD      drivers/dma/built-in.o</span><br><span class="line">  CC [M]  drivers/dma/dmatest.o</span><br><span class="line">  CC      drivers/dma-buf/dma-buf.o</span><br><span class="line">  CC      drivers/dma-buf/fence.o</span><br><span class="line">  CC      drivers/dma-buf/reservation.o</span><br><span class="line">  CC      drivers/dma-buf/seqno-fence.o</span><br><span class="line">  LD      drivers/dma-buf/built-in.o</span><br><span class="line">  LD      drivers/firewire/built-in.o</span><br><span class="line">  LD      drivers/firmware/built-in.o</span><br><span class="line">  CC      drivers/gpio/devres.o</span><br><span class="line">  CC      drivers/gpio/gpiolib.o</span><br><span class="line">  CC      drivers/gpio/gpiolib-legacy.o</span><br><span class="line">  CC      drivers/gpio/gpiolib-of.o</span><br><span class="line">  CC      drivers/gpio/gpiolib-sysfs.o</span><br><span class="line">  CC      drivers/gpio/gpio-generic.o</span><br><span class="line">  CC      drivers/gpio/gpio-74x164.o</span><br><span class="line">  CC      drivers/gpio/gpio-max732x.o</span><br><span class="line">  CC      drivers/gpio/gpio-mxc.o</span><br><span class="line">  CC      drivers/gpio/gpio-pca953x.o</span><br><span class="line">  CC      drivers/gpio/gpio-vf610.o</span><br><span class="line">  LD      drivers/gpio/built-in.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_auth.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_bufs.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_cache.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_context.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_dma.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_fops.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_gem.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_ioctl.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_irq.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_lock.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_memory.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_drv.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_vm.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_agpsupport.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_scatter.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_pci.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_platform.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_sysfs.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_hashtab.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_mm.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_crtc.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_modes.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_edid.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_info.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_debugfs.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_encoder_slave.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_trace_points.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_global.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_prime.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_rect.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_vma_manager.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_flip_work.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_modeset_lock.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_atomic.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_bridge.o</span><br><span class="line">  CC      drivers/gpu/drm/drm_of.o</span><br><span class="line">  LD      drivers/gpu/drm/drm.o</span><br><span class="line">  LD      drivers/gpu/drm/bridge/built-in.o</span><br><span class="line">  LD      drivers/gpu/drm/i2c/built-in.o</span><br><span class="line">  LD      drivers/gpu/drm/panel/built-in.o</span><br><span class="line">  CC      drivers/gpu/drm/vivante/vivante_drv.o</span><br><span class="line">  LD      drivers/gpu/drm/vivante/vivante.o</span><br><span class="line">  LD      drivers/gpu/drm/vivante/built-in.o</span><br><span class="line">  LD      drivers/gpu/drm/built-in.o</span><br><span class="line">  LD      drivers/gpu/vga/built-in.o</span><br><span class="line">  LD      drivers/gpu/built-in.o</span><br><span class="line">  CC      drivers/hid/hid-core.o</span><br><span class="line">  CC      drivers/hid/hid-input.o</span><br><span class="line">  CC      drivers/hid/hid-debug.o</span><br><span class="line">  LD      drivers/hid/hid.o</span><br><span class="line">  CC      drivers/hid/hid-generic.o</span><br><span class="line">  CC      drivers/hid/usbhid/hid-core.o</span><br><span class="line">  CC      drivers/hid/usbhid/hid-quirks.o</span><br><span class="line">  LD      drivers/hid/usbhid/usbhid.o</span><br><span class="line">  LD      drivers/hid/usbhid/built-in.o</span><br><span class="line">  LD      drivers/hid/built-in.o</span><br><span class="line">  LD      drivers/hsi/clients/built-in.o</span><br><span class="line">  LD      drivers/hsi/controllers/built-in.o</span><br><span class="line">  LD      drivers/hsi/built-in.o</span><br><span class="line">  CC      drivers/hwmon/hwmon.o</span><br><span class="line">  CC      drivers/hwmon/max17135-hwmon.o</span><br><span class="line">  CC      drivers/hwmon/mag3110.o</span><br><span class="line">  CC      drivers/hwmon/mxc_mma8451.o</span><br><span class="line">  LD      drivers/hwmon/built-in.o</span><br><span class="line">  CC      drivers/i2c/i2c-boardinfo.o</span><br><span class="line">  CC      drivers/i2c/i2c-core.o</span><br><span class="line">  CC      drivers/i2c/i2c-dev.o</span><br><span class="line">  CC      drivers/i2c/i2c-mux.o</span><br><span class="line">  CC      drivers/i2c/algos/i2c-algo-bit.o</span><br><span class="line">  LD      drivers/i2c/algos/built-in.o</span><br><span class="line">  CC [M]  drivers/i2c/algos/i2c-algo-pcf.o</span><br><span class="line">  CC [M]  drivers/i2c/algos/i2c-algo-pca.o</span><br><span class="line">  CC      drivers/i2c/busses/i2c-imx.o</span><br><span class="line">  LD      drivers/i2c/busses/built-in.o</span><br><span class="line">  LD      drivers/i2c/muxes/built-in.o</span><br><span class="line">  LD      drivers/i2c/built-in.o</span><br><span class="line">  LD      drivers/idle/built-in.o</span><br><span class="line">  CC      drivers/iio/industrialio-core.o</span><br><span class="line">  CC      drivers/iio/industrialio-event.o</span><br><span class="line">  CC      drivers/iio/inkern.o</span><br><span class="line">  LD      drivers/iio/industrialio.o</span><br><span class="line">  LD      drivers/iio/accel/built-in.o</span><br><span class="line">  CC      drivers/iio/adc/imx7d_adc.o</span><br><span class="line">  CC      drivers/iio/adc/vf610_adc.o</span><br><span class="line">  LD      drivers/iio/adc/built-in.o</span><br><span class="line">  LD      drivers/iio/amplifiers/built-in.o</span><br><span class="line">  LD      drivers/iio/common/hid-sensors/built-in.o</span><br><span class="line">  LD      drivers/iio/common/ssp_sensors/built-in.o</span><br><span class="line">  LD      drivers/iio/common/st_sensors/built-in.o</span><br><span class="line">  LD      drivers/iio/common/built-in.o</span><br><span class="line">  LD      drivers/iio/dac/built-in.o</span><br><span class="line">  LD      drivers/iio/frequency/built-in.o</span><br><span class="line">  LD      drivers/iio/gyro/built-in.o</span><br><span class="line">  LD      drivers/iio/humidity/built-in.o</span><br><span class="line">  LD      drivers/iio/imu/inv_mpu6050/built-in.o</span><br><span class="line">  LD      drivers/iio/imu/built-in.o</span><br><span class="line">  LD      drivers/iio/light/built-in.o</span><br><span class="line">  LD      drivers/iio/magnetometer/built-in.o</span><br><span class="line">  LD      drivers/iio/orientation/built-in.o</span><br><span class="line">  LD      drivers/iio/pressure/built-in.o</span><br><span class="line">  LD      drivers/iio/proximity/built-in.o</span><br><span class="line">  LD      drivers/iio/temperature/built-in.o</span><br><span class="line">  LD      drivers/iio/trigger/built-in.o</span><br><span class="line">  LD      drivers/iio/built-in.o</span><br><span class="line">  CC      drivers/input/input.o</span><br><span class="line">  CC      drivers/input/input-compat.o</span><br><span class="line">  CC      drivers/input/input-mt.o</span><br><span class="line">  CC      drivers/input/ff-core.o</span><br><span class="line">  LD      drivers/input/input-core.o</span><br><span class="line">  CC      drivers/input/input-polldev.o</span><br><span class="line">  CC      drivers/input/matrix-keymap.o</span><br><span class="line">  CC      drivers/input/mousedev.o</span><br><span class="line">  CC      drivers/input/evdev.o</span><br><span class="line">  CC      drivers/input/keyboard/atkbd.o</span><br><span class="line">  CC      drivers/input/keyboard/gpio_keys.o</span><br><span class="line">  CC      drivers/input/keyboard/imx_keypad.o</span><br><span class="line">  CC      drivers/input/keyboard/snvs_pwrkey.o</span><br><span class="line">  LD      drivers/input/keyboard/built-in.o</span><br><span class="line">  CC      drivers/input/misc/mma8450.o</span><br><span class="line">  CC      drivers/input/misc/mpl3115.o</span><br><span class="line">  CC      drivers/input/misc/fxls8471.o</span><br><span class="line">  CC      drivers/input/misc/fxls8471_i2c.o</span><br><span class="line">  CC      drivers/input/misc/isl29023.o</span><br><span class="line">  LD      drivers/input/misc/built-in.o</span><br><span class="line">  LD      drivers/input/mouse/built-in.o</span><br><span class="line">  CC [M]  drivers/input/mouse/psmouse-base.o</span><br><span class="line">  CC [M]  drivers/input/mouse/synaptics.o</span><br><span class="line">  CC [M]  drivers/input/mouse/focaltech.o</span><br><span class="line">  CC [M]  drivers/input/mouse/alps.o</span><br><span class="line">  CC [M]  drivers/input/mouse/elantech.o</span><br><span class="line">  CC [M]  drivers/input/mouse/logips2pp.o</span><br><span class="line">  CC [M]  drivers/input/mouse/trackpoint.o</span><br><span class="line">  CC [M]  drivers/input/mouse/cypress_ps2.o</span><br><span class="line">  LD [M]  drivers/input/mouse/psmouse.o</span><br><span class="line">  CC      drivers/input/touchscreen/of_touchscreen.o</span><br><span class="line">  CC      drivers/input/touchscreen/ads7846.o</span><br><span class="line">  CC      drivers/input/touchscreen/edt-ft5x06.o</span><br><span class="line">  CC      drivers/input/touchscreen/elan_ts.o</span><br><span class="line">  CC      drivers/input/touchscreen/egalax_ts.o</span><br><span class="line">  CC      drivers/input/touchscreen/gt9xx.o</span><br><span class="line">  CC      drivers/input/touchscreen/imx6ul_tsc.o</span><br><span class="line">  CC      drivers/input/touchscreen/max11801_ts.o</span><br><span class="line">  CC      drivers/input/touchscreen/mc13783_ts.o</span><br><span class="line">  CC      drivers/input/touchscreen/stmpe-ts.o</span><br><span class="line">  CC      drivers/input/touchscreen/tsc2007.o</span><br><span class="line">  CC      drivers/input/touchscreen/vtl/vtl_ts.o</span><br><span class="line">  LD      drivers/input/touchscreen/vtl/built-in.o</span><br><span class="line">  LD      drivers/input/touchscreen/built-in.o</span><br><span class="line">  LD      drivers/input/built-in.o</span><br><span class="line">  CC [M]  drivers/input/evbug.o</span><br><span class="line">  CC      drivers/input/serio/serio.o</span><br><span class="line">  CC      drivers/input/serio/libps2.o</span><br><span class="line">  LD      drivers/input/serio/built-in.o</span><br><span class="line">  CC [M]  drivers/input/serio/serport.o</span><br><span class="line">  CC      drivers/irqchip/irqchip.o</span><br><span class="line">  CC      drivers/irqchip/irq-gic.o</span><br><span class="line">  CC      drivers/irqchip/irq-gic-common.o</span><br><span class="line">  CC      drivers/irqchip/irq-vf610-mscm-ir.o</span><br><span class="line">  LD      drivers/irqchip/built-in.o</span><br><span class="line">  CC      drivers/leds/led-core.o</span><br><span class="line">  CC      drivers/leds/led-class.o</span><br><span class="line">  CC      drivers/leds/led-triggers.o</span><br><span class="line">  CC      drivers/leds/leds-gpio.o</span><br><span class="line">  CC      drivers/leds/trigger/ledtrig-timer.o</span><br><span class="line">  CC      drivers/leds/trigger/ledtrig-oneshot.o</span><br><span class="line">  CC      drivers/leds/trigger/ledtrig-heartbeat.o</span><br><span class="line">  CC      drivers/leds/trigger/ledtrig-backlight.o</span><br><span class="line">  CC      drivers/leds/trigger/ledtrig-gpio.o</span><br><span class="line">  LD      drivers/leds/trigger/built-in.o</span><br><span class="line">  LD      drivers/leds/built-in.o</span><br><span class="line">  LD      drivers/lguest/built-in.o</span><br><span class="line">  LD      drivers/macintosh/built-in.o</span><br><span class="line">  LD      drivers/media/common/b2c2/built-in.o</span><br><span class="line">  LD      drivers/media/common/saa7146/built-in.o</span><br><span class="line">  LD      drivers/media/common/siano/built-in.o</span><br><span class="line">  LD      drivers/media/common/built-in.o</span><br><span class="line">  LD      drivers/media/firewire/built-in.o</span><br><span class="line">  LD      drivers/media/i2c/soc_camera/built-in.o</span><br><span class="line">  CC [M]  drivers/media/i2c/soc_camera/ov2640.o</span><br><span class="line">  CC [M]  drivers/media/i2c/soc_camera/ov772x.o</span><br><span class="line">  CC      drivers/media/i2c/ir-kbd-i2c.o</span><br><span class="line">  LD      drivers/media/i2c/built-in.o</span><br><span class="line">  LD      drivers/media/mmc/siano/built-in.o</span><br><span class="line">  LD      drivers/media/mmc/built-in.o</span><br><span class="line">  LD      drivers/media/pci/b2c2/built-in.o</span><br><span class="line">  LD      drivers/media/pci/ddbridge/built-in.o</span><br><span class="line">  LD      drivers/media/pci/dm1105/built-in.o</span><br><span class="line">  LD      drivers/media/pci/mantis/built-in.o</span><br><span class="line">  LD      drivers/media/pci/ngene/built-in.o</span><br><span class="line">  LD      drivers/media/pci/pluto2/built-in.o</span><br><span class="line">  LD      drivers/media/pci/pt1/built-in.o</span><br><span class="line">  LD      drivers/media/pci/pt3/built-in.o</span><br><span class="line">  LD      drivers/media/pci/saa7146/built-in.o</span><br><span class="line">  LD      drivers/media/pci/smipcie/built-in.o</span><br><span class="line">  LD      drivers/media/pci/ttpci/built-in.o</span><br><span class="line">  LD      drivers/media/pci/built-in.o</span><br><span class="line">  CC      drivers/media/platform/coda/coda-common.o</span><br><span class="line">  CC      drivers/media/platform/coda/coda-bit.o</span><br><span class="line">  CC      drivers/media/platform/coda/coda-h264.o</span><br><span class="line">  CC      drivers/media/platform/coda/coda-jpeg.o</span><br><span class="line">  LD      drivers/media/platform/coda/coda.o</span><br><span class="line">  LD      drivers/media/platform/coda/built-in.o</span><br><span class="line">  LD      drivers/media/platform/mxc/capture/built-in.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/mxc_v4l2_capture.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/ipu_fg_overlay_sdc.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/ipu_bg_overlay_sdc.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/ipu_prp_enc.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/ipu_still.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/ipu_csi_enc.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/ov5640.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ov5640_camera_int.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/ov5642.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ov5642_camera.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/ov5640_mipi.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ov5640_camera_mipi_int.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/adv7180.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/adv7180_tvin.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/capture/v4l2-int-device.o</span><br><span class="line">  CC      drivers/media/platform/mxc/output/mxc_vout.o</span><br><span class="line">  CC      drivers/media/platform/mxc/output/mxc_pxp_v4l2.o</span><br><span class="line">  LD      drivers/media/platform/mxc/output/built-in.o</span><br><span class="line">  LD      drivers/media/platform/mxc/subdev/built-in.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/subdev/mx6s_capture.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/subdev/mxc_vadc.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/subdev/mxc_mipi_csi.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/subdev/ov5640.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/ov5640_camera.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/subdev/ov5640_mipi.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/ov5640_camera_mipi.o</span><br><span class="line">  CC [M]  drivers/media/platform/mxc/subdev/ov5647_mipi.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/ov5647_camera_mipi.o</span><br><span class="line">  LD      drivers/media/platform/omap/built-in.o</span><br><span class="line">  CC      drivers/media/platform/soc_camera/soc_camera.o</span><br><span class="line">  CC      drivers/media/platform/soc_camera/soc_mediabus.o</span><br><span class="line">  CC      drivers/media/platform/soc_camera/mx3_camera.o</span><br><span class="line">  LD      drivers/media/platform/soc_camera/built-in.o</span><br><span class="line">  LD      drivers/media/platform/built-in.o</span><br><span class="line">  CC      drivers/media/radio/radio-si476x.o</span><br><span class="line">  LD      drivers/media/radio/built-in.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-adstech-dvb-t-pci.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-alink-dtu-m.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-anysee.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-apac-viewcomp.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-asus-pc39.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-asus-ps3-100.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-ati-tv-wonder-hd-600.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-ati-x10.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-avermedia-a16d.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-avermedia.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-avermedia-cardbus.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-avermedia-dvbt.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-avermedia-m135a.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-avermedia-m733a-rm-k6.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-avermedia-rm-ks.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-avertv-303.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-azurewave-ad-tu700.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-behold.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-behold-columbus.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-budget-ci-old.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-cinergy-1400.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-cinergy.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-delock-61959.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-dib0700-nec.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-dib0700-rc5.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-digitalnow-tinytwin.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-digittrade.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-dm1105-nec.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-dntv-live-dvb-t.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-dntv-live-dvbt-pro.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-dvbsky.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-em-terratec.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-encore-enltv2.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-encore-enltv.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-encore-enltv-fm53.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-evga-indtube.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-eztv.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-flydvb.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-flyvideo.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-fusionhdtv-mce.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-gadmei-rm008z.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-genius-tvgo-a11mce.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-gotview7135.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-imon-mce.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-imon-pad.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-iodata-bctv7e.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-it913x-v1.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-it913x-v2.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-kaiomy.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-kworld-315u.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-kworld-pc150u.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-kworld-plus-tv-analog.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-leadtek-y04g0051.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-lirc.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-lme2510.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-manli.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-medion-x10.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-medion-x10-digitainer.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-medion-x10-or2x.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-msi-digivox-ii.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-msi-digivox-iii.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-msi-tvanywhere.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-msi-tvanywhere-plus.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-nebula.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-nec-terratec-cinergy-xs.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-norwood.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-npgtech.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pctv-sedna.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pinnacle-color.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pinnacle-grey.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pinnacle-pctv-hd.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pixelview.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pixelview-mk12.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pixelview-002t.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pixelview-new.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-powercolor-real-angel.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-proteus-2309.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-purpletv.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-pv951.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-hauppauge.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-rc6-mce.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-real-audio-220-32-keys.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-reddo.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-snapstream-firefly.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-streamzap.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-tbs-nec.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-technisat-usb2.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-terratec-cinergy-xs.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-terratec-slim.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-terratec-slim-2.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-tevii-nec.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-tivo.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-total-media-in-hand.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-total-media-in-hand-02.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-trekstor.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-tt-1500.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-twinhan1027.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-videomate-m1f.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-videomate-s350.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-videomate-tv-pvr.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-winfast.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-winfast-usbii-deluxe.o</span><br><span class="line">  CC      drivers/media/rc/keymaps/rc-su3000.o</span><br><span class="line">  LD      drivers/media/rc/keymaps/built-in.o</span><br><span class="line">  CC      drivers/media/rc/rc-main.o</span><br><span class="line">  CC      drivers/media/rc/rc-ir-raw.o</span><br><span class="line">  LD      drivers/media/rc/rc-core.o</span><br><span class="line">  CC      drivers/media/rc/ir-nec-decoder.o</span><br><span class="line">  CC      drivers/media/rc/ir-rc5-decoder.o</span><br><span class="line">  CC      drivers/media/rc/ir-rc6-decoder.o</span><br><span class="line">  CC      drivers/media/rc/ir-jvc-decoder.o</span><br><span class="line">  CC      drivers/media/rc/ir-sony-decoder.o</span><br><span class="line">  CC      drivers/media/rc/ir-sanyo-decoder.o</span><br><span class="line">  CC      drivers/media/rc/ir-sharp-decoder.o</span><br><span class="line">  CC      drivers/media/rc/ir-mce_kbd-decoder.o</span><br><span class="line">  CC      drivers/media/rc/ir-xmp-decoder.o</span><br><span class="line">  CC      drivers/media/rc/gpio-ir-recv.o</span><br><span class="line">  LD      drivers/media/rc/built-in.o</span><br><span class="line">  CC      drivers/media/tuners/tuner-xc2028.o</span><br><span class="line">  CC      drivers/media/tuners/tuner-simple.o</span><br><span class="line">  CC      drivers/media/tuners/tuner-types.o</span><br><span class="line">  CC      drivers/media/tuners/mt20xx.o</span><br><span class="line">  CC      drivers/media/tuners/tda8290.o</span><br><span class="line">  CC      drivers/media/tuners/tea5767.o</span><br><span class="line">  CC      drivers/media/tuners/tea5761.o</span><br><span class="line">  CC      drivers/media/tuners/tda9887.o</span><br><span class="line">  CC      drivers/media/tuners/tda827x.o</span><br><span class="line">  CC      drivers/media/tuners/tda18271-maps.o</span><br><span class="line">  CC      drivers/media/tuners/tda18271-common.o</span><br><span class="line">  CC      drivers/media/tuners/tda18271-fe.o</span><br><span class="line">  LD      drivers/media/tuners/tda18271.o</span><br><span class="line">  CC      drivers/media/tuners/xc5000.o</span><br><span class="line">  CC      drivers/media/tuners/xc4000.o</span><br><span class="line">  CC      drivers/media/tuners/mc44s803.o</span><br><span class="line">  LD      drivers/media/tuners/built-in.o</span><br><span class="line">  LD      drivers/media/usb/b2c2/built-in.o</span><br><span class="line">  LD      drivers/media/usb/dvb-usb/built-in.o</span><br><span class="line">  LD      drivers/media/usb/dvb-usb-v2/built-in.o</span><br><span class="line">  LD      drivers/media/usb/gspca/built-in.o</span><br><span class="line">  CC [M]  drivers/media/usb/gspca/gspca.o</span><br><span class="line">  CC [M]  drivers/media/usb/gspca/autogain_functions.o</span><br><span class="line">  LD [M]  drivers/media/usb/gspca/gspca_main.o</span><br><span class="line">  LD      drivers/media/usb/s2255/built-in.o</span><br><span class="line">  LD      drivers/media/usb/siano/built-in.o</span><br><span class="line">  LD      drivers/media/usb/stkwebcam/built-in.o</span><br><span class="line">  LD      drivers/media/usb/ttusb-budget/built-in.o</span><br><span class="line">  LD      drivers/media/usb/ttusb-dec/built-in.o</span><br><span class="line">  LD      drivers/media/usb/uvc/built-in.o</span><br><span class="line">  CC [M]  drivers/media/usb/uvc/uvc_driver.o</span><br><span class="line">  CC [M]  drivers/media/usb/uvc/uvc_queue.o</span><br><span class="line">  CC [M]  drivers/media/usb/uvc/uvc_v4l2.o</span><br><span class="line">  CC [M]  drivers/media/usb/uvc/uvc_video.o</span><br><span class="line">  CC [M]  drivers/media/usb/uvc/uvc_ctrl.o</span><br><span class="line">  CC [M]  drivers/media/usb/uvc/uvc_status.o</span><br><span class="line">  CC [M]  drivers/media/usb/uvc/uvc_isight.o</span><br><span class="line">  CC [M]  drivers/media/usb/uvc/uvc_debugfs.o</span><br><span class="line">  LD [M]  drivers/media/usb/uvc/uvcvideo.o</span><br><span class="line">  LD      drivers/media/usb/zr364xx/built-in.o</span><br><span class="line">  LD      drivers/media/usb/built-in.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-dev.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-ioctl.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-device.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-fh.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-event.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-ctrls.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-subdev.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-clk.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-async.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-of.o</span><br><span class="line">  LD      drivers/media/v4l2-core/videodev.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-common.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-dv-timings.o</span><br><span class="line">  CC      drivers/media/v4l2-core/v4l2-mem2mem.o</span><br><span class="line">  CC      drivers/media/v4l2-core/videobuf-core.o</span><br><span class="line">  CC      drivers/media/v4l2-core/videobuf-dma-contig.o</span><br><span class="line">  CC      drivers/media/v4l2-core/videobuf2-core.o</span><br><span class="line">  CC      drivers/media/v4l2-core/videobuf2-memops.o</span><br><span class="line">  CC      drivers/media/v4l2-core/videobuf2-vmalloc.o</span><br><span class="line">  CC      drivers/media/v4l2-core/videobuf2-dma-contig.o</span><br><span class="line">  LD      drivers/media/v4l2-core/built-in.o</span><br><span class="line">  LD      drivers/media/built-in.o</span><br><span class="line">  CC      drivers/mfd/stmpe.o</span><br><span class="line">  CC      drivers/mfd/stmpe-i2c.o</span><br><span class="line">  CC      drivers/mfd/wm8994-core.o</span><br><span class="line">  CC      drivers/mfd/wm8994-irq.o</span><br><span class="line">  CC      drivers/mfd/wm8994-regmap.o</span><br><span class="line">  CC      drivers/mfd/mc13xxx-core.o</span><br><span class="line">  CC      drivers/mfd/mc13xxx-spi.o</span><br><span class="line">  CC      drivers/mfd/mc13xxx-i2c.o</span><br><span class="line">  CC      drivers/mfd/mfd-core.o</span><br><span class="line">  CC      drivers/mfd/da9052-irq.o</span><br><span class="line">  CC      drivers/mfd/da9052-core.o</span><br><span class="line">  CC      drivers/mfd/da9052-i2c.o</span><br><span class="line">  CC      drivers/mfd/max17135-core.o</span><br><span class="line">  CC      drivers/mfd/si476x-cmd.o</span><br><span class="line">  CC      drivers/mfd/si476x-prop.o</span><br><span class="line">  CC      drivers/mfd/si476x-i2c.o</span><br><span class="line">  LD      drivers/mfd/si476x-core.o</span><br><span class="line">  CC      drivers/mfd/syscon.o</span><br><span class="line">  CC      drivers/mfd/mxc-hdmi-core.o</span><br><span class="line">  LD      drivers/mfd/built-in.o</span><br><span class="line">  CC      drivers/misc/fxos8700.o</span><br><span class="line">  CC      drivers/misc/fxas2100x.o</span><br><span class="line">  LD      drivers/misc/carma/built-in.o</span><br><span class="line">  LD      drivers/misc/cb710/built-in.o</span><br><span class="line">  CC      drivers/misc/eeprom/at24.o</span><br><span class="line">  CC      drivers/misc/eeprom/at25.o</span><br><span class="line">  LD      drivers/misc/eeprom/built-in.o</span><br><span class="line">  LD      drivers/misc/lis3lv02d/built-in.o</span><br><span class="line">  LD      drivers/misc/mic/built-in.o</span><br><span class="line">  LD      drivers/misc/ti-st/built-in.o</span><br><span class="line">  CC      drivers/misc/sram.o</span><br><span class="line">  LD      drivers/misc/built-in.o</span><br><span class="line">  CC      drivers/mmc/card/block.o</span><br><span class="line">  CC      drivers/mmc/card/queue.o</span><br><span class="line">  LD      drivers/mmc/card/mmc_block.o</span><br><span class="line">  LD      drivers/mmc/card/built-in.o</span><br><span class="line">  CC      drivers/mmc/core/core.o</span><br><span class="line">  CC      drivers/mmc/core/bus.o</span><br><span class="line">  CC      drivers/mmc/core/host.o</span><br><span class="line">  CC      drivers/mmc/core/mmc.o</span><br><span class="line">  CC      drivers/mmc/core/mmc_ops.o</span><br><span class="line">  CC      drivers/mmc/core/sd.o</span><br><span class="line">  CC      drivers/mmc/core/sd_ops.o</span><br><span class="line">  CC      drivers/mmc/core/sdio.o</span><br><span class="line">  CC      drivers/mmc/core/sdio_ops.o</span><br><span class="line">  CC      drivers/mmc/core/sdio_bus.o</span><br><span class="line">  CC      drivers/mmc/core/sdio_cis.o</span><br><span class="line">  CC      drivers/mmc/core/sdio_io.o</span><br><span class="line">  CC      drivers/mmc/core/sdio_irq.o</span><br><span class="line">  CC      drivers/mmc/core/quirks.o</span><br><span class="line">  CC      drivers/mmc/core/slot-gpio.o</span><br><span class="line">  CC      drivers/mmc/core/pwrseq.o</span><br><span class="line">  CC      drivers/mmc/core/pwrseq_simple.o</span><br><span class="line">  CC      drivers/mmc/core/pwrseq_emmc.o</span><br><span class="line">  CC      drivers/mmc/core/debugfs.o</span><br><span class="line">  LD      drivers/mmc/core/mmc_core.o</span><br><span class="line">  LD      drivers/mmc/core/built-in.o</span><br><span class="line">  CC      drivers/mmc/host/sdhci.o</span><br><span class="line">  CC      drivers/mmc/host/sdhci-pltfm.o</span><br><span class="line">  CC      drivers/mmc/host/sdhci-esdhc-imx.o</span><br><span class="line">  LD      drivers/mmc/host/built-in.o</span><br><span class="line">  LD      drivers/mmc/built-in.o</span><br><span class="line">  CC      drivers/mtd/mtdcore.o</span><br><span class="line">  CC      drivers/mtd/mtdsuper.o</span><br><span class="line">  CC      drivers/mtd/mtdconcat.o</span><br><span class="line">  CC      drivers/mtd/mtdpart.o</span><br><span class="line">  CC      drivers/mtd/mtdchar.o</span><br><span class="line">  LD      drivers/mtd/mtd.o</span><br><span class="line">  CC      drivers/mtd/ofpart.o</span><br><span class="line">  CC      drivers/mtd/cmdlinepart.o</span><br><span class="line">  CC      drivers/mtd/mtd_blkdevs.o</span><br><span class="line">  CC      drivers/mtd/mtdblock.o</span><br><span class="line">  CC      drivers/mtd/chips/chipreg.o</span><br><span class="line">  CC      drivers/mtd/chips/cfi_probe.o</span><br><span class="line">  CC      drivers/mtd/chips/cfi_util.o</span><br><span class="line">  CC      drivers/mtd/chips/cfi_cmdset_0020.o</span><br><span class="line">  CC      drivers/mtd/chips/cfi_cmdset_0002.o</span><br><span class="line">  CC      drivers/mtd/chips/cfi_cmdset_0001.o</span><br><span class="line">  CC      drivers/mtd/chips/gen_probe.o</span><br><span class="line">  CC      drivers/mtd/chips/jedec_probe.o</span><br><span class="line">  LD      drivers/mtd/chips/built-in.o</span><br><span class="line">  CC      drivers/mtd/devices/mtd_dataflash.o</span><br><span class="line">  CC      drivers/mtd/devices/m25p80.o</span><br><span class="line">  CC      drivers/mtd/devices/sst25l.o</span><br><span class="line">  LD      drivers/mtd/devices/built-in.o</span><br><span class="line">  LD      drivers/mtd/lpddr/built-in.o</span><br><span class="line">  CC      drivers/mtd/maps/physmap_of.o</span><br><span class="line">  LD      drivers/mtd/maps/built-in.o</span><br><span class="line">  CC      drivers/mtd/nand/nand_base.o</span><br><span class="line">  CC      drivers/mtd/nand/nand_bbt.o</span><br><span class="line">  CC      drivers/mtd/nand/nand_timings.o</span><br><span class="line">  LD      drivers/mtd/nand/nand.o</span><br><span class="line">  CC      drivers/mtd/nand/nand_ecc.o</span><br><span class="line">  CC      drivers/mtd/nand/nand_ids.o</span><br><span class="line">  CC      drivers/mtd/nand/mxc_nand.o</span><br><span class="line">  CC      drivers/mtd/nand/gpmi-nand/gpmi-nand.o</span><br><span class="line">  CC      drivers/mtd/nand/gpmi-nand/gpmi-lib.o</span><br><span class="line">  LD      drivers/mtd/nand/gpmi-nand/gpmi_nand.o</span><br><span class="line">  LD      drivers/mtd/nand/gpmi-nand/built-in.o</span><br><span class="line">  LD      drivers/mtd/nand/built-in.o</span><br><span class="line">  LD      drivers/mtd/onenand/built-in.o</span><br><span class="line">  CC      drivers/mtd/spi-nor/spi-nor.o</span><br><span class="line">  CC      drivers/mtd/spi-nor/fsl-quadspi.o</span><br><span class="line">  LD      drivers/mtd/spi-nor/built-in.o</span><br><span class="line">  LD      drivers/mtd/tests/built-in.o</span><br><span class="line">  CC      drivers/mtd/ubi/vtbl.o</span><br><span class="line">  CC      drivers/mtd/ubi/vmt.o</span><br><span class="line">  CC      drivers/mtd/ubi/upd.o</span><br><span class="line">  CC      drivers/mtd/ubi/build.o</span><br><span class="line">  CC      drivers/mtd/ubi/cdev.o</span><br><span class="line">  CC      drivers/mtd/ubi/kapi.o</span><br><span class="line">  CC      drivers/mtd/ubi/eba.o</span><br><span class="line">  CC      drivers/mtd/ubi/io.o</span><br><span class="line">  CC      drivers/mtd/ubi/wl.o</span><br><span class="line">  CC      drivers/mtd/ubi/attach.o</span><br><span class="line">  CC      drivers/mtd/ubi/misc.o</span><br><span class="line">  CC      drivers/mtd/ubi/debug.o</span><br><span class="line">  LD      drivers/mtd/ubi/ubi.o</span><br><span class="line">  LD      drivers/mtd/ubi/built-in.o</span><br><span class="line">  LD      drivers/mtd/built-in.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_device.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_linux.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_math.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_os.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_debugfs.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_allocator.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/gc_hal_kernel_probe.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/platform/freescale/gc_hal_kernel_platform_imx6q14.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_db.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_debug.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_event.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_heap.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_video_memory.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_power.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_context.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_hardware.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/arch/gc_hal_kernel_recorder.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_vg.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_command_vg.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_interrupt_vg.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/gc_hal_kernel_mmu_vg.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_command_vg.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/kernel/archvg/gc_hal_kernel_hardware_vg.o</span><br><span class="line">  CC      drivers/mxc/gpu-viv/hal/os/linux/kernel/allocator/freescale/gc_hal_kernel_allocator_cma.o</span><br><span class="line">  LD      drivers/mxc/gpu-viv/galcore.o</span><br><span class="line">  LD      drivers/mxc/gpu-viv/built-in.o</span><br><span class="line">  CC      drivers/mxc/hdmi-cec/mxc_hdmi-cec.o</span><br><span class="line">  LD      drivers/mxc/hdmi-cec/built-in.o</span><br><span class="line">  CC      drivers/mxc/ipu3/ipu_common.o</span><br><span class="line">  CC      drivers/mxc/ipu3/ipu_ic.o</span><br><span class="line">  CC      drivers/mxc/ipu3/ipu_disp.o</span><br><span class="line">  CC      drivers/mxc/ipu3/ipu_capture.o</span><br><span class="line">  CC      drivers/mxc/ipu3/ipu_device.o</span><br><span class="line">  CC      drivers/mxc/ipu3/ipu_calc_stripes_sizes.o</span><br><span class="line">  CC      drivers/mxc/ipu3/vdoa.o</span><br><span class="line">  CC      drivers/mxc/ipu3/ipu_pixel_clk.o</span><br><span class="line">  LD      drivers/mxc/ipu3/mxc_ipu.o</span><br><span class="line">  CC      drivers/mxc/ipu3/prg.o</span><br><span class="line">  CC      drivers/mxc/ipu3/pre.o</span><br><span class="line">  LD      drivers/mxc/ipu3/built-in.o</span><br><span class="line">  CC      drivers/mxc/mipi/mxc_mipi_csi2.o</span><br><span class="line">  LD      drivers/mxc/mipi/built-in.o</span><br><span class="line">  CC      drivers/mxc/mlb/mxc_mlb.o</span><br><span class="line">  LD      drivers/mxc/mlb/built-in.o</span><br><span class="line">  CC      drivers/mxc/sim/imx_sim.o</span><br><span class="line">  LD      drivers/mxc/sim/built-in.o</span><br><span class="line">  CC      drivers/mxc/vpu/mxc_vpu.o</span><br><span class="line">  LD      drivers/mxc/vpu/built-in.o</span><br><span class="line">  LD      drivers/mxc/built-in.o</span><br><span class="line">  CC      drivers/net/mii.o</span><br><span class="line">  CC      drivers/net/Space.o</span><br><span class="line">  CC      drivers/net/loopback.o</span><br><span class="line">  CC      drivers/net/can/dev.o</span><br><span class="line">  LD      drivers/net/can/can-dev.o</span><br><span class="line">  CC      drivers/net/can/m_can/m_can.o</span><br><span class="line">  LD      drivers/net/can/m_can/built-in.o</span><br><span class="line">  LD      drivers/net/can/softing/built-in.o</span><br><span class="line">  LD      drivers/net/can/spi/built-in.o</span><br><span class="line">  LD      drivers/net/can/usb/built-in.o</span><br><span class="line">  CC      drivers/net/can/flexcan.o</span><br><span class="line">  LD      drivers/net/can/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/arc/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/cadence/built-in.o</span><br><span class="line">  CC      drivers/net/ethernet/cirrus/cs89x0.o</span><br><span class="line">  LD      drivers/net/ethernet/cirrus/built-in.o</span><br><span class="line">  CC      drivers/net/ethernet/freescale/fec_main.o</span><br><span class="line">  CC      drivers/net/ethernet/freescale/fec_ptp.o</span><br><span class="line">  LD      drivers/net/ethernet/freescale/fec.o</span><br><span class="line">  LD      drivers/net/ethernet/freescale/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/hisilicon/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/qualcomm/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/rocker/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/samsung/built-in.o</span><br><span class="line">  CC      drivers/net/ethernet/smsc/smc91x.o</span><br><span class="line">  CC      drivers/net/ethernet/smsc/smc911x.o</span><br><span class="line">  CC      drivers/net/ethernet/smsc/smsc911x.o</span><br><span class="line">  LD      drivers/net/ethernet/smsc/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/via/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/wiznet/built-in.o</span><br><span class="line">  LD      drivers/net/ethernet/built-in.o</span><br><span class="line">  CC      drivers/net/phy/phy.o</span><br><span class="line">  CC      drivers/net/phy/phy_device.o</span><br><span class="line">  CC      drivers/net/phy/mdio_bus.o</span><br><span class="line">  LD      drivers/net/phy/libphy.o</span><br><span class="line">  CC      drivers/net/phy/smsc.o</span><br><span class="line">  CC      drivers/net/phy/micrel.o</span><br><span class="line">  LD      drivers/net/phy/built-in.o</span><br><span class="line">  CC      drivers/net/ppp/ppp_generic.o</span><br><span class="line">  CC      drivers/net/ppp/ppp_async.o</span><br><span class="line">  CC      drivers/net/ppp/bsd_comp.o</span><br><span class="line">  CC      drivers/net/ppp/ppp_deflate.o</span><br><span class="line">  CC      drivers/net/ppp/ppp_mppe.o</span><br><span class="line">  CC      drivers/net/ppp/ppp_synctty.o</span><br><span class="line">  CC      drivers/net/ppp/pppox.o</span><br><span class="line">  CC      drivers/net/ppp/pppoe.o</span><br><span class="line">  LD      drivers/net/ppp/built-in.o</span><br><span class="line">  CC      drivers/net/slip/slhc.o</span><br><span class="line">  LD      drivers/net/slip/built-in.o</span><br><span class="line">  CC      drivers/net/usb/asix_devices.o</span><br><span class="line">  CC      drivers/net/usb/asix_common.o</span><br><span class="line">  CC      drivers/net/usb/ax88172a.o</span><br><span class="line">  LD      drivers/net/usb/asix.o</span><br><span class="line">  CC      drivers/net/usb/ax88179_178a.o</span><br><span class="line">  CC      drivers/net/usb/cdc_ether.o</span><br><span class="line">  CC      drivers/net/usb/net1080.o</span><br><span class="line">  CC      drivers/net/usb/cdc_subset.o</span><br><span class="line">  CC      drivers/net/usb/zaurus.o</span><br><span class="line">  CC      drivers/net/usb/usbnet.o</span><br><span class="line">  CC      drivers/net/usb/cdc_ncm.o</span><br><span class="line">  LD      drivers/net/usb/built-in.o</span><br><span class="line">  CC [M]  drivers/net/usb/pegasus.o</span><br><span class="line">  CC [M]  drivers/net/usb/rtl8150.o</span><br><span class="line">  CC [M]  drivers/net/usb/r8152.o</span><br><span class="line">  CC [M]  drivers/net/usb/cdc_eem.o</span><br><span class="line">  CC [M]  drivers/net/usb/GobiUSBNet.o</span><br><span class="line">  CC [M]  drivers/net/usb/QMIDevice.o</span><br><span class="line">  CC [M]  drivers/net/usb/QMI.o</span><br><span class="line">  LD [M]  drivers/net/usb/GobiNet.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_pno.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_common.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_ip.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_custom_gpio.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_linux.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_linux_sched.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_cfg80211.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_linux_wq.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/aiutils.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/bcmevent.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/bcmutils.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/bcmwifi_channels.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/hndpmu.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/linux_osl.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/sbutils.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/siutils.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/wl_android.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/wl_cfg80211.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/wl_cfgp2p.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/wl_cfg_btcoex.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/wldev_common.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/wl_linux_mon.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_linux_platdev.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/wl_cfgvendor.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/bcmsdh.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/bcmsdh_linux.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_cdc.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_wlfc.o</span><br><span class="line">  CC      drivers/net/wireless/bcmdhd/dhd_sdio.o</span><br><span class="line">  LD      drivers/net/wireless/bcmdhd/bcmdhd.o</span><br><span class="line">  LD      drivers/net/wireless/bcmdhd/built-in.o</span><br><span class="line">  LD      drivers/net/wireless/rtl8192cu/built-in.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_cmd.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_security.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_debug.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_io.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_ioctl_query.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_ioctl_set.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_ieee80211.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_mlme.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_mlme_ext.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_wlan_util.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_pwrctrl.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_rf.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_recv.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_sta_mgt.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_ap.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_xmit.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_p2p.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_tdls.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_br_ext.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_iol.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/rtw_sreset.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/core/efuse/rtw_efuse.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/hal_intf.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/hal_com.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/dm.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_hal_init.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_dm.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_cmd.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_halinit.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_led.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_sreset.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/rtl8192c_xmit.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/osdep_service.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/os_intfs.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/usb_intf.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/usb_ops_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/ioctl_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/xmit_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/mlme_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/recv_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/ioctl_cfg80211.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtl8192cu/os_dep/linux/rtw_android.o</span><br><span class="line">  LD [M]  drivers/net/wireless/rtl8192cu/8192cu.o</span><br><span class="line">  LD      drivers/net/wireless/rtlwifi/built-in.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/base.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/cam.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/core.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/debug.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/efuse.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/ps.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rc.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/regd.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/stats.o</span><br><span class="line">  LD [M]  drivers/net/wireless/rtlwifi/rtlwifi.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/usb.o</span><br><span class="line">  LD [M]  drivers/net/wireless/rtlwifi/rtl_usb.o</span><br><span class="line">  LD      drivers/net/wireless/rtlwifi/rtl8188EUS/built-in.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_cmd.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_security.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_debug.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_io.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_ioctl_query.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_ioctl_set.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_ieee80211.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_mlme.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_mlme_ext.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_wlan_util.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_vht.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_pwrctrl.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_rf.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_recv.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_sta_mgt.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_ap.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_xmit.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_p2p.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_tdls.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_br_ext.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_iol.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_sreset.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_btcoex.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_beamforming.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_odm.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/efuse/rtw_efuse.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/osdep_service.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/os_intfs.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/usb_intf.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/usb_ops_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/ioctl_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/xmit_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/mlme_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/recv_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/ioctl_cfg80211.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/wifi_regd.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/rtw_android.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/os_dep/linux/rtw_proc.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/hal_intf.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/hal_com.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/hal_com_phycfg.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/hal_phy.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/hal_btcoex.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/hal_hci/hal_usb.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/led/hal_usb_led.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/HalPwrSeqCmd.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/Hal8188EPwrSeq.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_xmit.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_sreset.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_hal_init.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_phycfg.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_rf6052.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_dm.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_rxdesc.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_cmd.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/usb/usb_halinit.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/usb/rtl8188eu_led.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/usb/rtl8188eu_xmit.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/usb/rtl8188eu_recv.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/usb/usb_ops_linux.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/rtl8188e/rtl8188e_mp.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/odm_debug.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/odm_AntDiv.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/odm_interface.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/odm_HWConfig.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/odm.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/HalPhyRf.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/PhyDM_Adaptivity.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/rtl8188e/odm_RegConfig8188E.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/rtl8188e/Hal8188ERateAdaptive.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/hal/OUTSRC/rtl8188e/odm_RTL8188E.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/platform/platform_ops.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_mp.o</span><br><span class="line">  CC [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/core/rtw_mp_ioctl.o</span><br><span class="line">  LD [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/8188eu.o</span><br><span class="line">  LD      drivers/net/wireless/built-in.o</span><br><span class="line">  CC [M]  drivers/net/wireless/zd1201.o</span><br><span class="line">  LD      drivers/net/built-in.o</span><br><span class="line">  LD      drivers/nfc/built-in.o</span><br><span class="line">  CC      drivers/of/base.o</span><br><span class="line">  CC      drivers/of/device.o</span><br><span class="line">  CC      drivers/of/platform.o</span><br><span class="line">  CC      drivers/of/fdt.o</span><br><span class="line">  CC      drivers/of/fdt_address.o</span><br><span class="line">  CC      drivers/of/address.o</span><br><span class="line">  CC      drivers/of/irq.o</span><br><span class="line">  CC      drivers/of/of_net.o</span><br><span class="line">  CC      drivers/of/of_mdio.o</span><br><span class="line">  CC      drivers/of/of_mtd.o</span><br><span class="line">  CC      drivers/of/of_reserved_mem.o</span><br><span class="line">  LD      drivers/of/built-in.o</span><br><span class="line">  CC      drivers/pinctrl/core.o</span><br><span class="line">  CC      drivers/pinctrl/pinctrl-utils.o</span><br><span class="line">  CC      drivers/pinctrl/pinmux.o</span><br><span class="line">  CC      drivers/pinctrl/pinconf.o</span><br><span class="line">  CC      drivers/pinctrl/devicetree.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx50.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx53.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx6q.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx6dl.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx6sl.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx6sx.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx6ul.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx6sll.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-imx7d.o</span><br><span class="line">  CC      drivers/pinctrl/freescale/pinctrl-vf610.o</span><br><span class="line">  LD      drivers/pinctrl/freescale/built-in.o</span><br><span class="line">  LD      drivers/pinctrl/nomadik/built-in.o</span><br><span class="line">  LD      drivers/pinctrl/built-in.o</span><br><span class="line">  LD      drivers/platform/built-in.o</span><br><span class="line">  CC      drivers/power/power_supply_core.o</span><br><span class="line">  CC      drivers/power/power_supply_sysfs.o</span><br><span class="line">  CC      drivers/power/power_supply_leds.o</span><br><span class="line">  LD      drivers/power/power_supply.o</span><br><span class="line">  CC      drivers/power/sabresd_battery.o</span><br><span class="line">  CC      drivers/power/reset/syscon-poweroff.o</span><br><span class="line">  LD      drivers/power/reset/built-in.o</span><br><span class="line">  LD      drivers/power/built-in.o</span><br><span class="line">  CC      drivers/pps/pps.o</span><br><span class="line">  CC      drivers/pps/kapi.o</span><br><span class="line">  CC      drivers/pps/sysfs.o</span><br><span class="line">  LD      drivers/pps/pps_core.o</span><br><span class="line">  LD      drivers/pps/clients/built-in.o</span><br><span class="line">  LD      drivers/pps/generators/built-in.o</span><br><span class="line">  LD      drivers/pps/built-in.o</span><br><span class="line">  CC      drivers/ptp/ptp_clock.o</span><br><span class="line">  CC      drivers/ptp/ptp_chardev.o</span><br><span class="line">  CC      drivers/ptp/ptp_sysfs.o</span><br><span class="line">  LD      drivers/ptp/ptp.o</span><br><span class="line">  LD      drivers/ptp/built-in.o</span><br><span class="line">  CC      drivers/pwm/core.o</span><br><span class="line">  CC      drivers/pwm/sysfs.o</span><br><span class="line">  CC      drivers/pwm/pwm-imx.o</span><br><span class="line">  LD      drivers/pwm/built-in.o</span><br><span class="line">  CC      drivers/regulator/core.o</span><br><span class="line">  CC      drivers/regulator/dummy.o</span><br><span class="line">  CC      drivers/regulator/fixed-helper.o</span><br><span class="line">  CC      drivers/regulator/helpers.o</span><br><span class="line">  CC      drivers/regulator/devres.o</span><br><span class="line">  CC      drivers/regulator/of_regulator.o</span><br><span class="line">  CC      drivers/regulator/fixed.o</span><br><span class="line">  CC      drivers/regulator/anatop-regulator.o</span><br><span class="line">  CC      drivers/regulator/da9052-regulator.o</span><br><span class="line">  CC      drivers/regulator/gpio-regulator.o</span><br><span class="line">  CC      drivers/regulator/max17135-regulator.o</span><br><span class="line">  CC      drivers/regulator/mc13783-regulator.o</span><br><span class="line">  CC      drivers/regulator/mc13892-regulator.o</span><br><span class="line">  CC      drivers/regulator/mc13xxx-regulator-core.o</span><br><span class="line">  CC      drivers/regulator/pfuze100-regulator.o</span><br><span class="line">  LD      drivers/regulator/built-in.o</span><br><span class="line">  CC      drivers/reset/core.o</span><br><span class="line">  CC      drivers/reset/gpio-reset.o</span><br><span class="line">  LD      drivers/reset/built-in.o</span><br><span class="line">  CC      drivers/rpmsg/virtio_rpmsg_bus.o</span><br><span class="line">  LD      drivers/rpmsg/built-in.o</span><br><span class="line">  CC [M]  drivers/rpmsg/imx_rpmsg_pingpong.o</span><br><span class="line">  CC [M]  drivers/rpmsg/imx_rpmsg_tty.o</span><br><span class="line">  CC      drivers/rtc/rtc-lib.o</span><br><span class="line">  CC      drivers/rtc/hctosys.o</span><br><span class="line">  CC      drivers/rtc/systohc.o</span><br><span class="line">  CC      drivers/rtc/class.o</span><br><span class="line">  CC      drivers/rtc/interface.o</span><br><span class="line">  CC      drivers/rtc/rtc-dev.o</span><br><span class="line">  CC      drivers/rtc/rtc-proc.o</span><br><span class="line">  CC      drivers/rtc/rtc-sysfs.o</span><br><span class="line">  LD      drivers/rtc/rtc-core.o</span><br><span class="line">  CC      drivers/rtc/rtc-mxc.o</span><br><span class="line">  CC      drivers/rtc/rtc-mc13xxx.o</span><br><span class="line">  CC      drivers/rtc/rtc-snvs.o</span><br><span class="line">  LD      drivers/rtc/built-in.o</span><br><span class="line">  CC      drivers/scsi/scsi.o</span><br><span class="line">  CC      drivers/scsi/hosts.o</span><br><span class="line">  CC      drivers/scsi/scsi_ioctl.o</span><br><span class="line">  CC      drivers/scsi/scsicam.o</span><br><span class="line">  CC      drivers/scsi/scsi_error.o</span><br><span class="line">  CC      drivers/scsi/scsi_lib.o</span><br><span class="line">  CC      drivers/scsi/constants.o</span><br><span class="line">  CC      drivers/scsi/scsi_lib_dma.o</span><br><span class="line">  CC      drivers/scsi/scsi_scan.o</span><br><span class="line">  CC      drivers/scsi/scsi_sysfs.o</span><br><span class="line">  CC      drivers/scsi/scsi_devinfo.o</span><br><span class="line">  CC      drivers/scsi/scsi_sysctl.o</span><br><span class="line">  CC      drivers/scsi/scsi_trace.o</span><br><span class="line">  CC      drivers/scsi/scsi_logging.o</span><br><span class="line">  CC      drivers/scsi/scsi_pm.o</span><br><span class="line">  LD      drivers/scsi/scsi_mod.o</span><br><span class="line">  LD      drivers/scsi/arm/built-in.o</span><br><span class="line">  CC      drivers/scsi/sd.o</span><br><span class="line">  LD      drivers/scsi/sd_mod.o</span><br><span class="line">  LD      drivers/scsi/built-in.o</span><br><span class="line">  LD      drivers/soc/built-in.o</span><br><span class="line">  CC      drivers/spi/spi.o</span><br><span class="line">  CC      drivers/spi/spidev.o</span><br><span class="line">  CC      drivers/spi/spi-bitbang.o</span><br><span class="line">  CC      drivers/spi/spi-gpio.o</span><br><span class="line">  CC      drivers/spi/spi-imx.o</span><br><span class="line">  LD      drivers/spi/built-in.o</span><br><span class="line">  CC      drivers/staging/staging.o</span><br><span class="line">  LD      drivers/staging/iio/accel/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/adc/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/addac/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/cdc/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/frequency/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/gyro/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/impedance-analyzer/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/light/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/magnetometer/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/meter/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/resolver/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/trigger/built-in.o</span><br><span class="line">  LD      drivers/staging/iio/built-in.o</span><br><span class="line">  LD      drivers/staging/media/built-in.o</span><br><span class="line">  LD      drivers/staging/built-in.o</span><br><span class="line">  CC      drivers/thermal/thermal_core.o</span><br><span class="line">  CC      drivers/thermal/thermal_hwmon.o</span><br><span class="line">  CC      drivers/thermal/of-thermal.o</span><br><span class="line">  CC      drivers/thermal/step_wise.o</span><br><span class="line">  CC      drivers/thermal/cpu_cooling.o</span><br><span class="line">  LD      drivers/thermal/thermal_sys.o</span><br><span class="line">  LD      drivers/thermal/samsung/built-in.o</span><br><span class="line">  CC      drivers/thermal/imx_thermal.o</span><br><span class="line">  CC      drivers/thermal/device_cooling.o</span><br><span class="line">  LD      drivers/thermal/built-in.o</span><br><span class="line">  CC      drivers/tty/tty_io.o</span><br><span class="line">  CC      drivers/tty/n_tty.o</span><br><span class="line">  CC      drivers/tty/tty_ioctl.o</span><br><span class="line">  CC      drivers/tty/tty_ldisc.o</span><br><span class="line">  CC      drivers/tty/tty_buffer.o</span><br><span class="line">  CC      drivers/tty/tty_port.o</span><br><span class="line">  CC      drivers/tty/tty_mutex.o</span><br><span class="line">  CC      drivers/tty/tty_ldsem.o</span><br><span class="line">  CC      drivers/tty/pty.o</span><br><span class="line">  CC      drivers/tty/sysrq.o</span><br><span class="line">  LD      drivers/tty/ipwireless/built-in.o</span><br><span class="line">  CC      drivers/tty/serial/serial_core.o</span><br><span class="line">  CC      drivers/tty/serial/imx.o</span><br><span class="line">  CC      drivers/tty/serial/fsl_lpuart.o</span><br><span class="line">  LD      drivers/tty/serial/built-in.o</span><br><span class="line">  CC      drivers/tty/vt/vt_ioctl.o</span><br><span class="line">  CC      drivers/tty/vt/vc_screen.o</span><br><span class="line">  CC      drivers/tty/vt/selection.o</span><br><span class="line">  CC      drivers/tty/vt/keyboard.o</span><br><span class="line">  CC      drivers/tty/vt/consolemap.o</span><br><span class="line">  CONMK   drivers/tty/vt/consolemap_deftbl.c</span><br><span class="line">  CC      drivers/tty/vt/consolemap_deftbl.o</span><br><span class="line">  CC      drivers/tty/vt/vt.o</span><br><span class="line">  SHIPPED drivers/tty/vt/defkeymap.c</span><br><span class="line">  CC      drivers/tty/vt/defkeymap.o</span><br><span class="line">  LD      drivers/tty/vt/built-in.o</span><br><span class="line">  LD      drivers/tty/built-in.o</span><br><span class="line">  CC      drivers/usb/chipidea/core.o</span><br><span class="line">  CC      drivers/usb/chipidea/otg.o</span><br><span class="line">  CC      drivers/usb/chipidea/debug.o</span><br><span class="line">  CC      drivers/usb/chipidea/udc.o</span><br><span class="line">  CC      drivers/usb/chipidea/host.o</span><br><span class="line">  CC      drivers/usb/chipidea/otg_fsm.o</span><br><span class="line">  LD      drivers/usb/chipidea/ci_hdrc.o</span><br><span class="line">  CC      drivers/usb/chipidea/ci_hdrc_usb2.o</span><br><span class="line">  CC      drivers/usb/chipidea/ci_hdrc_msm.o</span><br><span class="line">  CC      drivers/usb/chipidea/ci_hdrc_zevio.o</span><br><span class="line">  CC      drivers/usb/chipidea/usbmisc_imx.o</span><br><span class="line">  CC      drivers/usb/chipidea/ci_hdrc_imx.o</span><br><span class="line">  LD      drivers/usb/chipidea/built-in.o</span><br><span class="line">  LD      drivers/usb/class/built-in.o</span><br><span class="line">  CC [M]  drivers/usb/class/cdc-acm.o</span><br><span class="line">  CC      drivers/usb/common/common.o</span><br><span class="line">  LD      drivers/usb/common/usb-common.o</span><br><span class="line">  CC      drivers/usb/common/usb-otg-fsm.o</span><br><span class="line">  LD      drivers/usb/common/built-in.o</span><br><span class="line">  CC      drivers/usb/core/usb.o</span><br><span class="line">  CC      drivers/usb/core/hub.o</span><br><span class="line">  CC      drivers/usb/core/hcd.o</span><br><span class="line">  CC      drivers/usb/core/urb.o</span><br><span class="line">  CC      drivers/usb/core/message.o</span><br><span class="line">  CC      drivers/usb/core/driver.o</span><br><span class="line">  CC      drivers/usb/core/config.o</span><br><span class="line">  CC      drivers/usb/core/file.o</span><br><span class="line">  CC      drivers/usb/core/buffer.o</span><br><span class="line">  CC      drivers/usb/core/sysfs.o</span><br><span class="line">  CC      drivers/usb/core/endpoint.o</span><br><span class="line">  CC      drivers/usb/core/devio.o</span><br><span class="line">  CC      drivers/usb/core/notify.o</span><br><span class="line">  CC      drivers/usb/core/generic.o</span><br><span class="line">  CC      drivers/usb/core/quirks.o</span><br><span class="line">  CC      drivers/usb/core/devices.o</span><br><span class="line">  CC      drivers/usb/core/port.o</span><br><span class="line">  LD      drivers/usb/core/usbcore.o</span><br><span class="line">  LD      drivers/usb/core/built-in.o</span><br><span class="line">  LD      drivers/usb/gadget/function/built-in.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_acm.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_acm.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_loopback.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_sourcesink.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_ss_lb.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/u_serial.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_serial.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_serial.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_obex.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_obex.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/u_ether.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_ncm.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_ncm.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_ecm.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_ecm.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_eem.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_eem.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_subset.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_ecm_subset.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_rndis.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/rndis.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_rndis.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_mass_storage.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/storage_common.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_mass_storage.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/function/f_fs.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_fs.o</span><br><span class="line">  LD      drivers/usb/gadget/legacy/built-in.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/legacy/zero.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_zero.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/legacy/ether.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_ether.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/legacy/inode.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/gadgetfs.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/legacy/mass_storage.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_mass_storage.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/legacy/serial.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_serial.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/legacy/ncm.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_ncm.o</span><br><span class="line">  CC      drivers/usb/gadget/udc/udc-core.o</span><br><span class="line">  LD      drivers/usb/gadget/udc/built-in.o</span><br><span class="line">  LD      drivers/usb/gadget/built-in.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/usbstring.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/config.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/epautoconf.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/composite.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/functions.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/configfs.o</span><br><span class="line">  CC [M]  drivers/usb/gadget/u_f.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/libcomposite.o</span><br><span class="line">  CC      drivers/usb/host/ehci-hcd.o</span><br><span class="line">  CC      drivers/usb/host/ehci-mxc.o</span><br><span class="line">  LD      drivers/usb/host/built-in.o</span><br><span class="line">  CC      drivers/usb/misc/ehset.o</span><br><span class="line">  LD      drivers/usb/misc/built-in.o</span><br><span class="line">  CC      drivers/usb/phy/phy.o</span><br><span class="line">  CC      drivers/usb/phy/of.o</span><br><span class="line">  CC      drivers/usb/phy/phy-generic.o</span><br><span class="line">  CC      drivers/usb/phy/phy-mxs-usb.o</span><br><span class="line">  LD      drivers/usb/phy/built-in.o</span><br><span class="line">  LD      drivers/usb/serial/built-in.o</span><br><span class="line">  CC [M]  drivers/usb/serial/usb-serial.o</span><br><span class="line">  CC [M]  drivers/usb/serial/generic.o</span><br><span class="line">  CC [M]  drivers/usb/serial/bus.o</span><br><span class="line">  LD [M]  drivers/usb/serial/usbserial.o</span><br><span class="line">  CC [M]  drivers/usb/serial/ch341.o</span><br><span class="line">  CC [M]  drivers/usb/serial/cp210x.o</span><br><span class="line">  CC [M]  drivers/usb/serial/ftdi_sio.o</span><br><span class="line">  CC [M]  drivers/usb/serial/option.o</span><br><span class="line">  CC [M]  drivers/usb/serial/usb_wwan.o</span><br><span class="line">  CC      drivers/usb/storage/scsiglue.o</span><br><span class="line">  CC      drivers/usb/storage/protocol.o</span><br><span class="line">  CC      drivers/usb/storage/transport.o</span><br><span class="line">  CC      drivers/usb/storage/usb.o</span><br><span class="line">  CC      drivers/usb/storage/initializers.o</span><br><span class="line">  CC      drivers/usb/storage/sierra_ms.o</span><br><span class="line">  CC      drivers/usb/storage/option_ms.o</span><br><span class="line">  CC      drivers/usb/storage/usual-tables.o</span><br><span class="line">  LD      drivers/usb/storage/usb-storage.o</span><br><span class="line">  LD      drivers/usb/storage/built-in.o</span><br><span class="line">  LD      drivers/usb/built-in.o</span><br><span class="line">  CC      drivers/video/hdmi.o</span><br><span class="line">  CC      drivers/video/backlight/lcd.o</span><br><span class="line">  CC      drivers/video/backlight/l4f00242t03.o</span><br><span class="line">  CC      drivers/video/backlight/platform_lcd.o</span><br><span class="line">  CC      drivers/video/backlight/backlight.o</span><br><span class="line">  CC      drivers/video/backlight/generic_bl.o</span><br><span class="line">  CC      drivers/video/backlight/pwm_bl.o</span><br><span class="line">  LD      drivers/video/backlight/built-in.o</span><br><span class="line">  CC      drivers/video/console/dummycon.o</span><br><span class="line">  CC      drivers/video/console/fbcon.o</span><br><span class="line">  CC      drivers/video/console/bitblit.o</span><br><span class="line">  CC      drivers/video/console/softcursor.o</span><br><span class="line">  LD      drivers/video/console/built-in.o</span><br><span class="line">  CC      drivers/video/fbdev/core/fb_notify.o</span><br><span class="line">  CC      drivers/video/fbdev/core/fb_cmdline.o</span><br><span class="line">  CC      drivers/video/fbdev/core/fbmem.o</span><br><span class="line">  CC      drivers/video/fbdev/core/fbmon.o</span><br><span class="line">  CC      drivers/video/fbdev/core/fbcmap.o</span><br><span class="line">  CC      drivers/video/fbdev/core/fbsysfs.o</span><br><span class="line">  CC      drivers/video/fbdev/core/modedb.o</span><br><span class="line">  CC      drivers/video/fbdev/core/fbcvt.o</span><br><span class="line">  LD      drivers/video/fbdev/core/fb.o</span><br><span class="line">  CC      drivers/video/fbdev/core/cfbfillrect.o</span><br><span class="line">  CC      drivers/video/fbdev/core/cfbcopyarea.o</span><br><span class="line">  CC      drivers/video/fbdev/core/cfbimgblt.o</span><br><span class="line">  CC      drivers/video/fbdev/core/fb_defio.o</span><br><span class="line">  LD      drivers/video/fbdev/core/built-in.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mipi_dsi.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mipi_dsi_samsung.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxcfb_hx8369_wvga.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxcfb_otm8018b_wvga.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/ldb.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxc_hdmi.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxc_edid.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxc_dispdrv.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxc_lcdif.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxc_ipuv3_fb.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxc_epdc_fb.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxc_epdc_v2_fb.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxsfb_sii902x.o</span><br><span class="line">  CC      drivers/video/fbdev/mxc/hannstar_cabc.o</span><br><span class="line">  LD      drivers/video/fbdev/mxc/built-in.o</span><br><span class="line">  CC [M]  drivers/video/fbdev/mxc/mxc_dcic.o</span><br><span class="line">  LD      drivers/video/fbdev/omap2/displays-new/built-in.o</span><br><span class="line">  LD      drivers/video/fbdev/omap2/dss/built-in.o</span><br><span class="line">  LD      drivers/video/fbdev/omap2/built-in.o</span><br><span class="line">  CC      drivers/video/fbdev/mx3fb.o</span><br><span class="line">  CC      drivers/video/fbdev/mxsfb.o</span><br><span class="line">  LD      drivers/video/fbdev/built-in.o</span><br><span class="line">  CC      drivers/video/logo/logo.o</span><br><span class="line">  LOGO    drivers/video/logo/logo_linux_mono.c</span><br><span class="line">  CC      drivers/video/logo/logo_linux_mono.o</span><br><span class="line">  LOGO    drivers/video/logo/logo_linux_vga16.c</span><br><span class="line">  CC      drivers/video/logo/logo_linux_vga16.o</span><br><span class="line">  LOGO    drivers/video/logo/logo_linux_clut224.c</span><br><span class="line">  CC      drivers/video/logo/logo_linux_clut224.o</span><br><span class="line">  LD      drivers/video/logo/built-in.o</span><br><span class="line">  LOGO    drivers/video/logo/logo_superh_mono.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_superh_vga16.c</span><br><span class="line">  LOGO    drivers/video/logo/clut_vga16.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_blackfin_vga16.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_spe_clut224.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_mac_clut224.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_superh_clut224.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_sun_clut224.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_parisc_clut224.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_blackfin_clut224.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_dec_clut224.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_m32r_clut224.c</span><br><span class="line">  LOGO    drivers/video/logo/logo_sgi_clut224.c</span><br><span class="line">  CC      drivers/video/display_timing.o</span><br><span class="line">  CC      drivers/video/videomode.o</span><br><span class="line">  CC      drivers/video/of_display_timing.o</span><br><span class="line">  CC      drivers/video/of_videomode.o</span><br><span class="line">  LD      drivers/video/built-in.o</span><br><span class="line">  CC      drivers/virtio/virtio.o</span><br><span class="line">  CC      drivers/virtio/virtio_ring.o</span><br><span class="line">  LD      drivers/virtio/built-in.o</span><br><span class="line">  CC      drivers/watchdog/watchdog_core.o</span><br><span class="line">  CC      drivers/watchdog/watchdog_dev.o</span><br><span class="line">  LD      drivers/watchdog/watchdog.o</span><br><span class="line">  CC      drivers/watchdog/imx2_wdt.o</span><br><span class="line">  LD      drivers/watchdog/built-in.o</span><br><span class="line">  LD      drivers/built-in.o</span><br><span class="line">  CC      sound/sound_core.o</span><br><span class="line">  LD      sound/soundcore.o</span><br><span class="line">  LD      sound/arm/built-in.o</span><br><span class="line">  LD      sound/atmel/built-in.o</span><br><span class="line">  CC      sound/core/sound.o</span><br><span class="line">  CC      sound/core/init.o</span><br><span class="line">  CC      sound/core/memory.o</span><br><span class="line">  CC      sound/core/info.o</span><br><span class="line">  CC      sound/core/control.o</span><br><span class="line">  CC      sound/core/misc.o</span><br><span class="line">  CC      sound/core/device.o</span><br><span class="line">  CC      sound/core/ctljack.o</span><br><span class="line">  CC      sound/core/jack.o</span><br><span class="line">  LD      sound/core/snd.o</span><br><span class="line">  CC      sound/core/timer.o</span><br><span class="line">  LD      sound/core/snd-timer.o</span><br><span class="line">  CC      sound/core/pcm.o</span><br><span class="line">  CC      sound/core/pcm_native.o</span><br><span class="line">  CC      sound/core/pcm_lib.o</span><br><span class="line">  CC      sound/core/pcm_timer.o</span><br><span class="line">  CC      sound/core/pcm_misc.o</span><br><span class="line">  CC      sound/core/pcm_memory.o</span><br><span class="line">  CC      sound/core/memalloc.o</span><br><span class="line">  LD      sound/core/snd-pcm.o</span><br><span class="line">  CC      sound/core/pcm_dmaengine.o</span><br><span class="line">  LD      sound/core/snd-pcm-dmaengine.o</span><br><span class="line">  CC      sound/core/compress_offload.o</span><br><span class="line">  LD      sound/core/snd-compress.o</span><br><span class="line">  LD      sound/core/built-in.o</span><br><span class="line">  CC [M]  sound/core/hwdep.o</span><br><span class="line">  LD [M]  sound/core/snd-hwdep.o</span><br><span class="line">  CC [M]  sound/core/rawmidi.o</span><br><span class="line">  LD [M]  sound/core/snd-rawmidi.o</span><br><span class="line">  LD      sound/drivers/mpu401/built-in.o</span><br><span class="line">  LD      sound/drivers/opl3/built-in.o</span><br><span class="line">  LD      sound/drivers/opl4/built-in.o</span><br><span class="line">  LD      sound/drivers/pcsp/built-in.o</span><br><span class="line">  LD      sound/drivers/vx/built-in.o</span><br><span class="line">  LD      sound/drivers/built-in.o</span><br><span class="line">  LD      sound/firewire/built-in.o</span><br><span class="line">  LD      sound/hda/built-in.o</span><br><span class="line">  LD      sound/i2c/other/built-in.o</span><br><span class="line">  LD      sound/i2c/built-in.o</span><br><span class="line">  LD      sound/isa/ad1816a/built-in.o</span><br><span class="line">  LD      sound/isa/ad1848/built-in.o</span><br><span class="line">  LD      sound/isa/cs423x/built-in.o</span><br><span class="line">  LD      sound/isa/es1688/built-in.o</span><br><span class="line">  LD      sound/isa/galaxy/built-in.o</span><br><span class="line">  LD      sound/isa/gus/built-in.o</span><br><span class="line">  LD      sound/isa/msnd/built-in.o</span><br><span class="line">  LD      sound/isa/opti9xx/built-in.o</span><br><span class="line">  LD      sound/isa/sb/built-in.o</span><br><span class="line">  LD      sound/isa/wavefront/built-in.o</span><br><span class="line">  LD      sound/isa/wss/built-in.o</span><br><span class="line">  LD      sound/isa/built-in.o</span><br><span class="line">  LD      sound/mips/built-in.o</span><br><span class="line">  LD      sound/parisc/built-in.o</span><br><span class="line">  LD      sound/pci/ac97/built-in.o</span><br><span class="line">  LD      sound/pci/ali5451/built-in.o</span><br><span class="line">  LD      sound/pci/asihpi/built-in.o</span><br><span class="line">  LD      sound/pci/au88x0/built-in.o</span><br><span class="line">  LD      sound/pci/aw2/built-in.o</span><br><span class="line">  LD      sound/pci/ca0106/built-in.o</span><br><span class="line">  LD      sound/pci/cs46xx/built-in.o</span><br><span class="line">  LD      sound/pci/cs5535audio/built-in.o</span><br><span class="line">  LD      sound/pci/ctxfi/built-in.o</span><br><span class="line">  LD      sound/pci/echoaudio/built-in.o</span><br><span class="line">  LD      sound/pci/emu10k1/built-in.o</span><br><span class="line">  LD      sound/pci/hda/built-in.o</span><br><span class="line">  LD      sound/pci/ice1712/built-in.o</span><br><span class="line">  LD      sound/pci/korg1212/built-in.o</span><br><span class="line">  LD      sound/pci/lola/built-in.o</span><br><span class="line">  LD      sound/pci/lx6464es/built-in.o</span><br><span class="line">  LD      sound/pci/mixart/built-in.o</span><br><span class="line">  LD      sound/pci/nm256/built-in.o</span><br><span class="line">  LD      sound/pci/oxygen/built-in.o</span><br><span class="line">  LD      sound/pci/pcxhr/built-in.o</span><br><span class="line">  LD      sound/pci/riptide/built-in.o</span><br><span class="line">  LD      sound/pci/rme9652/built-in.o</span><br><span class="line">  LD      sound/pci/trident/built-in.o</span><br><span class="line">  LD      sound/pci/vx222/built-in.o</span><br><span class="line">  LD      sound/pci/ymfpci/built-in.o</span><br><span class="line">  LD      sound/pci/built-in.o</span><br><span class="line">  LD      sound/pcmcia/pdaudiocf/built-in.o</span><br><span class="line">  LD      sound/pcmcia/vx/built-in.o</span><br><span class="line">  LD      sound/pcmcia/built-in.o</span><br><span class="line">  LD      sound/ppc/built-in.o</span><br><span class="line">  LD      sound/sh/built-in.o</span><br><span class="line">  CC      sound/soc/soc-core.o</span><br><span class="line">  CC      sound/soc/soc-dapm.o</span><br><span class="line">  CC      sound/soc/soc-jack.o</span><br><span class="line">  CC      sound/soc/soc-cache.o</span><br><span class="line">  CC      sound/soc/soc-utils.o</span><br><span class="line">  CC      sound/soc/soc-pcm.o</span><br><span class="line">  CC      sound/soc/soc-compress.o</span><br><span class="line">  CC      sound/soc/soc-io.o</span><br><span class="line">  CC      sound/soc/soc-devres.o</span><br><span class="line">  CC      sound/soc/soc-ops.o</span><br><span class="line">  CC      sound/soc/soc-generic-dmaengine-pcm.o</span><br><span class="line">  LD      sound/soc/snd-soc-core.o</span><br><span class="line">  LD      sound/soc/adi/built-in.o</span><br><span class="line">  LD      sound/soc/atmel/built-in.o</span><br><span class="line">  LD      sound/soc/au1x/built-in.o</span><br><span class="line">  LD      sound/soc/bcm/built-in.o</span><br><span class="line">  LD      sound/soc/blackfin/built-in.o</span><br><span class="line">  LD      sound/soc/cirrus/built-in.o</span><br><span class="line">  CC      sound/soc/codecs/cs42xx8.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-cs42xx8.o</span><br><span class="line">  CC      sound/soc/codecs/cs42xx8-i2c.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-cs42xx8-i2c.o</span><br><span class="line">  CC      sound/soc/codecs/fsl_mqs.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-fsl-mqs.o</span><br><span class="line">  CC      sound/soc/codecs/mc13783.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-mc13783.o</span><br><span class="line">  CC      sound/soc/codecs/hdmi.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-hdmi-codec.o</span><br><span class="line">  CC      sound/soc/codecs/sgtl5000.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-sgtl5000.o</span><br><span class="line">  CC      sound/soc/codecs/si476x.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-si476x.o</span><br><span class="line">  CC      sound/soc/codecs/tlv320aic23.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-tlv320aic23.o</span><br><span class="line">  CC      sound/soc/codecs/tlv320aic23-i2c.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-tlv320aic23-i2c.o</span><br><span class="line">  CC      sound/soc/codecs/wm8960.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-wm8960.o</span><br><span class="line">  CC      sound/soc/codecs/wm8962.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-wm8962.o</span><br><span class="line">  CC      sound/soc/codecs/wm8994.o</span><br><span class="line">  CC      sound/soc/codecs/wm8958-dsp2.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-wm8994.o</span><br><span class="line">  CC      sound/soc/codecs/wm_hubs.o</span><br><span class="line">  LD      sound/soc/codecs/snd-soc-wm-hubs.o</span><br><span class="line">  LD      sound/soc/codecs/built-in.o</span><br><span class="line">  LD      sound/soc/davinci/built-in.o</span><br><span class="line">  LD      sound/soc/dwc/built-in.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_asrc.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_asrc_dma.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-fsl-asrc.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_sai.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-fsl-sai.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_ssi.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_ssi_dbg.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-fsl-ssi.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_spdif.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-fsl-spdif.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_esai.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-fsl-esai.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_utils.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-fsl-utils.o</span><br><span class="line">  CC      sound/soc/fsl/fsl_hdmi.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-fsl-hdmi.o</span><br><span class="line">  CC      sound/soc/fsl/imx-ssi.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-ssi.o</span><br><span class="line">  CC      sound/soc/fsl/imx-audmux.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-audmux.o</span><br><span class="line">  CC      sound/soc/fsl/imx-pcm-fiq.o</span><br><span class="line">  CC      sound/soc/fsl/imx-pcm-dma.o</span><br><span class="line">  CC      sound/soc/fsl/imx-hdmi-dma.o</span><br><span class="line">  AS      sound/soc/fsl/hdmi_pcm.o</span><br><span class="line">  CC      sound/soc/fsl/eukrea-tlv320.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-eukrea-tlv320.o</span><br><span class="line">  CC      sound/soc/fsl/imx-cs42888.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-cs42888.o</span><br><span class="line">  CC      sound/soc/fsl/imx-sgtl5000.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-sgtl5000.o</span><br><span class="line">  CC      sound/soc/fsl/imx-wm8958.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-wm8958.o</span><br><span class="line">  CC      sound/soc/fsl/imx-wm8960.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-wm8960.o</span><br><span class="line">  CC      sound/soc/fsl/imx-wm8962.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-wm8962.o</span><br><span class="line">  CC      sound/soc/fsl/imx-sii902x.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-sii902x.o</span><br><span class="line">  CC      sound/soc/fsl/imx-spdif.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-spdif.o</span><br><span class="line">  CC      sound/soc/fsl/imx-mc13783.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-mc13783.o</span><br><span class="line">  CC      sound/soc/fsl/imx-mqs.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-mqs.o</span><br><span class="line">  CC      sound/soc/fsl/imx-si476x.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-si476x.o</span><br><span class="line">  CC      sound/soc/fsl/imx-hdmi.o</span><br><span class="line">  LD      sound/soc/fsl/snd-soc-imx-hdmi.o</span><br><span class="line">  LD      sound/soc/fsl/built-in.o</span><br><span class="line">  LD      sound/soc/generic/built-in.o</span><br><span class="line">  LD      sound/soc/intel/built-in.o</span><br><span class="line">  LD      sound/soc/jz4740/built-in.o</span><br><span class="line">  LD      sound/soc/kirkwood/built-in.o</span><br><span class="line">  LD      sound/soc/mxs/built-in.o</span><br><span class="line">  LD      sound/soc/nuc900/built-in.o</span><br><span class="line">  LD      sound/soc/omap/built-in.o</span><br><span class="line">  LD      sound/soc/pxa/built-in.o</span><br><span class="line">  LD      sound/soc/qcom/built-in.o</span><br><span class="line">  LD      sound/soc/rockchip/built-in.o</span><br><span class="line">  LD      sound/soc/samsung/built-in.o</span><br><span class="line">  LD      sound/soc/sh/built-in.o</span><br><span class="line">  LD      sound/soc/sirf/built-in.o</span><br><span class="line">  LD      sound/soc/spear/built-in.o</span><br><span class="line">  LD      sound/soc/tegra/built-in.o</span><br><span class="line">  LD      sound/soc/txx9/built-in.o</span><br><span class="line">  LD      sound/soc/ux500/built-in.o</span><br><span class="line">  LD      sound/soc/xtensa/built-in.o</span><br><span class="line">  LD      sound/soc/built-in.o</span><br><span class="line">  LD      sound/sparc/built-in.o</span><br><span class="line">  LD      sound/spi/built-in.o</span><br><span class="line">  LD      sound/synth/built-in.o</span><br><span class="line">  LD      sound/usb/6fire/built-in.o</span><br><span class="line">  LD      sound/usb/bcd2000/built-in.o</span><br><span class="line">  LD      sound/usb/caiaq/built-in.o</span><br><span class="line">  LD      sound/usb/hiface/built-in.o</span><br><span class="line">  LD      sound/usb/misc/built-in.o</span><br><span class="line">  LD      sound/usb/usx2y/built-in.o</span><br><span class="line">  LD      sound/usb/built-in.o</span><br><span class="line">  CC [M]  sound/usb/card.o</span><br><span class="line">  CC [M]  sound/usb/clock.o</span><br><span class="line">  CC [M]  sound/usb/endpoint.o</span><br><span class="line">  CC [M]  sound/usb/format.o</span><br><span class="line">  CC [M]  sound/usb/helper.o</span><br><span class="line">  CC [M]  sound/usb/mixer.o</span><br><span class="line">  CC [M]  sound/usb/mixer_quirks.o</span><br><span class="line">  CC [M]  sound/usb/mixer_scarlett.o</span><br><span class="line">  CC [M]  sound/usb/pcm.o</span><br><span class="line">  CC [M]  sound/usb/proc.o</span><br><span class="line">  CC [M]  sound/usb/quirks.o</span><br><span class="line">  CC [M]  sound/usb/stream.o</span><br><span class="line">  LD [M]  sound/usb/snd-usb-audio.o</span><br><span class="line">  CC [M]  sound/usb/midi.o</span><br><span class="line">  LD [M]  sound/usb/snd-usbmidi-lib.o</span><br><span class="line">  CC      sound/last.o</span><br><span class="line">  LD      sound/built-in.o</span><br><span class="line">  MK_FW   firmware/imx/sdma/sdma-imx6q.bin.gen.S</span><br><span class="line">  IHEX    firmware/imx/sdma/sdma-imx6q.bin</span><br><span class="line">  AS      firmware/imx/sdma/sdma-imx6q.bin.gen.o</span><br><span class="line">  MK_FW   firmware/imx/sdma/sdma-imx7d.bin.gen.S</span><br><span class="line">  IHEX    firmware/imx/sdma/sdma-imx7d.bin</span><br><span class="line">  AS      firmware/imx/sdma/sdma-imx7d.bin.gen.o</span><br><span class="line">  LD      firmware/built-in.o</span><br><span class="line">  CC      net/socket.o</span><br><span class="line">  CC      net/802/p8022.o</span><br><span class="line">  CC      net/802/psnap.o</span><br><span class="line">  CC      net/802/stp.o</span><br><span class="line">  LD      net/802/built-in.o</span><br><span class="line">  CC      net/8021q/vlan_core.o</span><br><span class="line">  CC      net/8021q/vlan.o</span><br><span class="line">  CC      net/8021q/vlan_dev.o</span><br><span class="line">  CC      net/8021q/vlan_netlink.o</span><br><span class="line">  CC      net/8021q/vlanproc.o</span><br><span class="line">  LD      net/8021q/8021q.o</span><br><span class="line">  LD      net/8021q/built-in.o</span><br><span class="line">  CC      net/bluetooth/af_bluetooth.o</span><br><span class="line">  CC      net/bluetooth/hci_core.o</span><br><span class="line">  CC      net/bluetooth/hci_conn.o</span><br><span class="line">  CC      net/bluetooth/hci_event.o</span><br><span class="line">  CC      net/bluetooth/mgmt.o</span><br><span class="line">  CC      net/bluetooth/hci_sock.o</span><br><span class="line">  CC      net/bluetooth/hci_sysfs.o</span><br><span class="line">  CC      net/bluetooth/l2cap_core.o</span><br><span class="line">  CC      net/bluetooth/l2cap_sock.o</span><br><span class="line">  CC      net/bluetooth/smp.o</span><br><span class="line">  CC      net/bluetooth/sco.o</span><br><span class="line">  CC      net/bluetooth/lib.o</span><br><span class="line">  CC      net/bluetooth/a2mp.o</span><br><span class="line">  CC      net/bluetooth/amp.o</span><br><span class="line">  CC      net/bluetooth/ecc.o</span><br><span class="line">  CC      net/bluetooth/hci_request.o</span><br><span class="line">  CC      net/bluetooth/mgmt_util.o</span><br><span class="line">  CC      net/bluetooth/hci_debugfs.o</span><br><span class="line">  LD      net/bluetooth/bluetooth.o</span><br><span class="line">  CC      net/bluetooth/bnep/core.o</span><br><span class="line">  CC      net/bluetooth/bnep/sock.o</span><br><span class="line">  CC      net/bluetooth/bnep/netdev.o</span><br><span class="line">  LD      net/bluetooth/bnep/bnep.o</span><br><span class="line">  LD      net/bluetooth/bnep/built-in.o</span><br><span class="line">  CC      net/bluetooth/hidp/core.o</span><br><span class="line">  CC      net/bluetooth/hidp/sock.o</span><br><span class="line">  LD      net/bluetooth/hidp/hidp.o</span><br><span class="line">  LD      net/bluetooth/hidp/built-in.o</span><br><span class="line">  CC      net/bluetooth/rfcomm/core.o</span><br><span class="line">  CC      net/bluetooth/rfcomm/sock.o</span><br><span class="line">  CC      net/bluetooth/rfcomm/tty.o</span><br><span class="line">  LD      net/bluetooth/rfcomm/rfcomm.o</span><br><span class="line">  LD      net/bluetooth/rfcomm/built-in.o</span><br><span class="line">  LD      net/bluetooth/built-in.o</span><br><span class="line">  CC      net/bridge/br.o</span><br><span class="line">  CC      net/bridge/br_device.o</span><br><span class="line">  CC      net/bridge/br_fdb.o</span><br><span class="line">  CC      net/bridge/br_forward.o</span><br><span class="line">  CC      net/bridge/br_if.o</span><br><span class="line">  CC      net/bridge/br_input.o</span><br><span class="line">  CC      net/bridge/br_ioctl.o</span><br><span class="line">  CC      net/bridge/br_stp.o</span><br><span class="line">  CC      net/bridge/br_stp_bpdu.o</span><br><span class="line">  CC      net/bridge/br_stp_if.o</span><br><span class="line">  CC      net/bridge/br_stp_timer.o</span><br><span class="line">  CC      net/bridge/br_netlink.o</span><br><span class="line">  CC      net/bridge/br_sysfs_if.o</span><br><span class="line">  CC      net/bridge/br_sysfs_br.o</span><br><span class="line">  CC      net/bridge/br_multicast.o</span><br><span class="line">  CC      net/bridge/br_mdb.o</span><br><span class="line">  LD      net/bridge/bridge.o</span><br><span class="line">  LD      net/bridge/built-in.o</span><br><span class="line">  CC      net/can/af_can.o</span><br><span class="line">  CC      net/can/proc.o</span><br><span class="line">  LD      net/can/can.o</span><br><span class="line">  CC      net/can/raw.o</span><br><span class="line">  LD      net/can/can-raw.o</span><br><span class="line">  CC      net/can/bcm.o</span><br><span class="line">  LD      net/can/can-bcm.o</span><br><span class="line">  CC      net/can/gw.o</span><br><span class="line">  LD      net/can/can-gw.o</span><br><span class="line">  LD      net/can/built-in.o</span><br><span class="line">  CC      net/core/sock.o</span><br><span class="line">  CC      net/core/request_sock.o</span><br><span class="line">  CC      net/core/skbuff.o</span><br><span class="line">  CC      net/core/datagram.o</span><br><span class="line">  CC      net/core/stream.o</span><br><span class="line">  CC      net/core/scm.o</span><br><span class="line">  CC      net/core/gen_stats.o</span><br><span class="line">  CC      net/core/gen_estimator.o</span><br><span class="line">  CC      net/core/net_namespace.o</span><br><span class="line">  CC      net/core/secure_seq.o</span><br><span class="line">  CC      net/core/flow_dissector.o</span><br><span class="line">  CC      net/core/sysctl_net_core.o</span><br><span class="line">  CC      net/core/dev.o</span><br><span class="line">  CC      net/core/ethtool.o</span><br><span class="line">  CC      net/core/dev_addr_lists.o</span><br><span class="line">  CC      net/core/dst.o</span><br><span class="line">  CC      net/core/netevent.o</span><br><span class="line">  CC      net/core/neighbour.o</span><br><span class="line">  CC      net/core/rtnetlink.o</span><br><span class="line">  CC      net/core/utils.o</span><br><span class="line">  CC      net/core/link_watch.o</span><br><span class="line">  CC      net/core/filter.o</span><br><span class="line">  CC      net/core/sock_diag.o</span><br><span class="line">  CC      net/core/dev_ioctl.o</span><br><span class="line">  CC      net/core/tso.o</span><br><span class="line">  CC      net/core/flow.o</span><br><span class="line">  CC      net/core/net-sysfs.o</span><br><span class="line">  CC      net/core/net-procfs.o</span><br><span class="line">  CC      net/core/ptp_classifier.o</span><br><span class="line">  LD      net/core/built-in.o</span><br><span class="line">  CC      net/dns_resolver/dns_key.o</span><br><span class="line">  CC      net/dns_resolver/dns_query.o</span><br><span class="line">  LD      net/dns_resolver/dns_resolver.o</span><br><span class="line">  LD      net/dns_resolver/built-in.o</span><br><span class="line">  CC      net/ethernet/eth.o</span><br><span class="line">  LD      net/ethernet/built-in.o</span><br><span class="line">  CC      net/ipv4/route.o</span><br><span class="line">  CC      net/ipv4/inetpeer.o</span><br><span class="line">  CC      net/ipv4/protocol.o</span><br><span class="line">  CC      net/ipv4/ip_input.o</span><br><span class="line">  CC      net/ipv4/ip_fragment.o</span><br><span class="line">  CC      net/ipv4/ip_forward.o</span><br><span class="line">  CC      net/ipv4/ip_options.o</span><br><span class="line">  CC      net/ipv4/ip_output.o</span><br><span class="line">  CC      net/ipv4/ip_sockglue.o</span><br><span class="line">  CC      net/ipv4/inet_hashtables.o</span><br><span class="line">  CC      net/ipv4/inet_timewait_sock.o</span><br><span class="line">  CC      net/ipv4/inet_connection_sock.o</span><br><span class="line">  CC      net/ipv4/tcp.o</span><br><span class="line">  CC      net/ipv4/tcp_input.o</span><br><span class="line">  CC      net/ipv4/tcp_output.o</span><br><span class="line">  CC      net/ipv4/tcp_timer.o</span><br><span class="line">  CC      net/ipv4/tcp_ipv4.o</span><br><span class="line">  CC      net/ipv4/tcp_minisocks.o</span><br><span class="line">  CC      net/ipv4/tcp_cong.o</span><br><span class="line">  CC      net/ipv4/tcp_metrics.o</span><br><span class="line">  CC      net/ipv4/tcp_fastopen.o</span><br><span class="line">  CC      net/ipv4/tcp_offload.o</span><br><span class="line">  CC      net/ipv4/datagram.o</span><br><span class="line">  CC      net/ipv4/raw.o</span><br><span class="line">  CC      net/ipv4/udp.o</span><br><span class="line">  CC      net/ipv4/udplite.o</span><br><span class="line">  CC      net/ipv4/udp_offload.o</span><br><span class="line">  CC      net/ipv4/arp.o</span><br><span class="line">  CC      net/ipv4/icmp.o</span><br><span class="line">  CC      net/ipv4/devinet.o</span><br><span class="line">  CC      net/ipv4/af_inet.o</span><br><span class="line">  CC      net/ipv4/igmp.o</span><br><span class="line">  CC      net/ipv4/fib_frontend.o</span><br><span class="line">  CC      net/ipv4/fib_semantics.o</span><br><span class="line">  CC      net/ipv4/fib_trie.o</span><br><span class="line">  CC      net/ipv4/inet_fragment.o</span><br><span class="line">  CC      net/ipv4/ping.o</span><br><span class="line">  CC      net/ipv4/ip_tunnel_core.o</span><br><span class="line">  CC      net/ipv4/gre_offload.o</span><br><span class="line">  CC      net/ipv4/ip_tunnel.o</span><br><span class="line">  CC      net/ipv4/sysctl_net_ipv4.o</span><br><span class="line">  CC      net/ipv4/proc.o</span><br><span class="line">  CC      net/ipv4/tunnel4.o</span><br><span class="line">  CC      net/ipv4/ipconfig.o</span><br><span class="line">  CC      net/ipv4/inet_diag.o</span><br><span class="line">  CC      net/ipv4/tcp_diag.o</span><br><span class="line">  CC      net/ipv4/tcp_cubic.o</span><br><span class="line">  CC      net/ipv4/xfrm4_policy.o</span><br><span class="line">  CC      net/ipv4/xfrm4_state.o</span><br><span class="line">  CC      net/ipv4/xfrm4_input.o</span><br><span class="line">  CC      net/ipv4/xfrm4_output.o</span><br><span class="line">  CC      net/ipv4/xfrm4_protocol.o</span><br><span class="line">  LD      net/ipv4/built-in.o</span><br><span class="line">  CC      net/ipv6/af_inet6.o</span><br><span class="line">  CC      net/ipv6/anycast.o</span><br><span class="line">  CC      net/ipv6/ip6_output.o</span><br><span class="line">  CC      net/ipv6/ip6_input.o</span><br><span class="line">  CC      net/ipv6/addrconf.o</span><br><span class="line">  CC      net/ipv6/addrlabel.o</span><br><span class="line">  CC      net/ipv6/route.o</span><br><span class="line">  CC      net/ipv6/ip6_fib.o</span><br><span class="line">  CC      net/ipv6/ipv6_sockglue.o</span><br><span class="line">  CC      net/ipv6/ndisc.o</span><br><span class="line">  CC      net/ipv6/udp.o</span><br><span class="line">  CC      net/ipv6/udplite.o</span><br><span class="line">  CC      net/ipv6/raw.o</span><br><span class="line">  CC      net/ipv6/icmp.o</span><br><span class="line">  CC      net/ipv6/mcast.o</span><br><span class="line">  CC      net/ipv6/reassembly.o</span><br><span class="line">  CC      net/ipv6/tcp_ipv6.o</span><br><span class="line">  CC      net/ipv6/ping.o</span><br><span class="line">  CC      net/ipv6/exthdrs.o</span><br><span class="line">  CC      net/ipv6/datagram.o</span><br><span class="line">  CC      net/ipv6/ip6_flowlabel.o</span><br><span class="line">  CC      net/ipv6/inet6_connection_sock.o</span><br><span class="line">  CC      net/ipv6/sysctl_net_ipv6.o</span><br><span class="line">  CC      net/ipv6/xfrm6_policy.o</span><br><span class="line">  CC      net/ipv6/xfrm6_state.o</span><br><span class="line">  CC      net/ipv6/xfrm6_input.o</span><br><span class="line">  CC      net/ipv6/xfrm6_output.o</span><br><span class="line">  CC      net/ipv6/xfrm6_protocol.o</span><br><span class="line">  CC      net/ipv6/proc.o</span><br><span class="line">  LD      net/ipv6/ipv6.o</span><br><span class="line">  CC      net/ipv6/xfrm6_mode_transport.o</span><br><span class="line">  CC      net/ipv6/xfrm6_mode_tunnel.o</span><br><span class="line">  CC      net/ipv6/xfrm6_mode_beet.o</span><br><span class="line">  CC      net/ipv6/sit.o</span><br><span class="line">  CC      net/ipv6/addrconf_core.o</span><br><span class="line">  CC      net/ipv6/exthdrs_core.o</span><br><span class="line">  CC      net/ipv6/ip6_checksum.o</span><br><span class="line">  CC      net/ipv6/ip6_icmp.o</span><br><span class="line">  CC      net/ipv6/output_core.o</span><br><span class="line">  CC      net/ipv6/protocol.o</span><br><span class="line">  CC      net/ipv6/ip6_offload.o</span><br><span class="line">  CC      net/ipv6/tcpv6_offload.o</span><br><span class="line">  CC      net/ipv6/udp_offload.o</span><br><span class="line">  CC      net/ipv6/exthdrs_offload.o</span><br><span class="line">  CC      net/ipv6/inet6_hashtables.o</span><br><span class="line">  LD      net/ipv6/built-in.o</span><br><span class="line">  CC      net/llc/llc_core.o</span><br><span class="line">  CC      net/llc/llc_input.o</span><br><span class="line">  CC      net/llc/llc_output.o</span><br><span class="line">  LD      net/llc/llc.o</span><br><span class="line">  CC      net/llc/llc_if.o</span><br><span class="line">  CC      net/llc/llc_c_ev.o</span><br><span class="line">  CC      net/llc/llc_c_ac.o</span><br><span class="line">  CC      net/llc/llc_conn.o</span><br><span class="line">  CC      net/llc/llc_c_st.o</span><br><span class="line">  CC      net/llc/llc_pdu.o</span><br><span class="line">  CC      net/llc/llc_sap.o</span><br><span class="line">  CC      net/llc/llc_s_ac.o</span><br><span class="line">  CC      net/llc/llc_s_ev.o</span><br><span class="line">  CC      net/llc/llc_s_st.o</span><br><span class="line">  CC      net/llc/af_llc.o</span><br><span class="line">  CC      net/llc/llc_station.o</span><br><span class="line">  CC      net/llc/llc_proc.o</span><br><span class="line">  CC      net/llc/sysctl_net_llc.o</span><br><span class="line">  LD      net/llc/llc2.o</span><br><span class="line">  LD      net/llc/built-in.o</span><br><span class="line">  CC      net/mac80211/main.o</span><br><span class="line">  CC      net/mac80211/status.o</span><br><span class="line">  CC      net/mac80211/sta_info.o</span><br><span class="line">  CC      net/mac80211/wep.o</span><br><span class="line">  CC      net/mac80211/wpa.o</span><br><span class="line">  CC      net/mac80211/scan.o</span><br><span class="line">  CC      net/mac80211/offchannel.o</span><br><span class="line">  CC      net/mac80211/ht.o</span><br><span class="line">  CC      net/mac80211/agg-tx.o</span><br><span class="line">  CC      net/mac80211/agg-rx.o</span><br><span class="line">  CC      net/mac80211/vht.o</span><br><span class="line">  CC      net/mac80211/ibss.o</span><br><span class="line">  CC      net/mac80211/iface.o</span><br><span class="line">  CC      net/mac80211/rate.o</span><br><span class="line">  CC      net/mac80211/michael.o</span><br><span class="line">  CC      net/mac80211/tkip.o</span><br><span class="line">  CC      net/mac80211/aes_ccm.o</span><br><span class="line">  CC      net/mac80211/aes_gcm.o</span><br><span class="line">  CC      net/mac80211/aes_cmac.o</span><br><span class="line">  CC      net/mac80211/aes_gmac.o</span><br><span class="line">  CC      net/mac80211/cfg.o</span><br><span class="line">  CC      net/mac80211/ethtool.o</span><br><span class="line">  CC      net/mac80211/rx.o</span><br><span class="line">  CC      net/mac80211/spectmgmt.o</span><br><span class="line">  CC      net/mac80211/tx.o</span><br><span class="line">  CC      net/mac80211/key.o</span><br><span class="line">  CC      net/mac80211/util.o</span><br><span class="line">  CC      net/mac80211/wme.o</span><br><span class="line">  CC      net/mac80211/event.o</span><br><span class="line">  CC      net/mac80211/chan.o</span><br><span class="line">  CC      net/mac80211/trace.o</span><br><span class="line">  CC      net/mac80211/mlme.o</span><br><span class="line">  CC      net/mac80211/tdls.o</span><br><span class="line">  CC      net/mac80211/ocb.o</span><br><span class="line">  CC      net/mac80211/pm.o</span><br><span class="line">  CC      net/mac80211/rc80211_minstrel.o</span><br><span class="line">  CC      net/mac80211/rc80211_minstrel_ht.o</span><br><span class="line">  LD      net/mac80211/mac80211.o</span><br><span class="line">  LD      net/mac80211/built-in.o</span><br><span class="line">  CC      net/netlink/af_netlink.o</span><br><span class="line">  CC      net/netlink/genetlink.o</span><br><span class="line">  LD      net/netlink/built-in.o</span><br><span class="line">  CC      net/packet/af_packet.o</span><br><span class="line">  LD      net/packet/built-in.o</span><br><span class="line">  CC      net/rfkill/core.o</span><br><span class="line">  CC      net/rfkill/input.o</span><br><span class="line">  LD      net/rfkill/rfkill.o</span><br><span class="line">  LD      net/rfkill/built-in.o</span><br><span class="line">  CC      net/sched/sch_generic.o</span><br><span class="line">  CC      net/sched/sch_mq.o</span><br><span class="line">  LD      net/sched/built-in.o</span><br><span class="line">  CC      net/sunrpc/clnt.o</span><br><span class="line">  CC      net/sunrpc/xprt.o</span><br><span class="line">  CC      net/sunrpc/socklib.o</span><br><span class="line">  CC      net/sunrpc/xprtsock.o</span><br><span class="line">  CC      net/sunrpc/sched.o</span><br><span class="line">  CC      net/sunrpc/auth.o</span><br><span class="line">  CC      net/sunrpc/auth_null.o</span><br><span class="line">  CC      net/sunrpc/auth_unix.o</span><br><span class="line">  CC      net/sunrpc/auth_generic.o</span><br><span class="line">  CC      net/sunrpc/svc.o</span><br><span class="line">  CC      net/sunrpc/svcsock.o</span><br><span class="line">  CC      net/sunrpc/svcauth.o</span><br><span class="line">  CC      net/sunrpc/svcauth_unix.o</span><br><span class="line">  CC      net/sunrpc/addr.o</span><br><span class="line">  CC      net/sunrpc/rpcb_clnt.o</span><br><span class="line">  CC      net/sunrpc/timer.o</span><br><span class="line">  CC      net/sunrpc/xdr.o</span><br><span class="line">  CC      net/sunrpc/sunrpc_syms.o</span><br><span class="line">  CC      net/sunrpc/cache.o</span><br><span class="line">  CC      net/sunrpc/rpc_pipe.o</span><br><span class="line">  CC      net/sunrpc/svc_xprt.o</span><br><span class="line">  CC      net/sunrpc/stats.o</span><br><span class="line">  CC      net/sunrpc/sysctl.o</span><br><span class="line">  LD      net/sunrpc/sunrpc.o</span><br><span class="line">  CC      net/sunrpc/auth_gss/auth_gss.o</span><br><span class="line">  CC      net/sunrpc/auth_gss/gss_generic_token.o</span><br><span class="line">  CC      net/sunrpc/auth_gss/gss_mech_switch.o</span><br><span class="line">  CC      net/sunrpc/auth_gss/svcauth_gss.o</span><br><span class="line">  CC      net/sunrpc/auth_gss/gss_rpc_upcall.o</span><br><span class="line">  CC      net/sunrpc/auth_gss/gss_rpc_xdr.o</span><br><span class="line">  LD      net/sunrpc/auth_gss/auth_rpcgss.o</span><br><span class="line">  LD      net/sunrpc/auth_gss/built-in.o</span><br><span class="line">  LD      net/sunrpc/xprtrdma/built-in.o</span><br><span class="line">  LD      net/sunrpc/built-in.o</span><br><span class="line">  CC      net/unix/af_unix.o</span><br><span class="line">  CC      net/unix/garbage.o</span><br><span class="line">  CC      net/unix/sysctl_net_unix.o</span><br><span class="line">  LD      net/unix/unix.o</span><br><span class="line">  LD      net/unix/built-in.o</span><br><span class="line">  CC      net/wireless/core.o</span><br><span class="line">  CC      net/wireless/sysfs.o</span><br><span class="line">  CC      net/wireless/radiotap.o</span><br><span class="line">  CC      net/wireless/util.o</span><br><span class="line">  CC      net/wireless/reg.o</span><br><span class="line">  CC      net/wireless/scan.o</span><br><span class="line">  CC      net/wireless/nl80211.o</span><br><span class="line">  CC      net/wireless/mlme.o</span><br><span class="line">  CC      net/wireless/ibss.o</span><br><span class="line">  CC      net/wireless/sme.o</span><br><span class="line">  CC      net/wireless/chan.o</span><br><span class="line">  CC      net/wireless/ethtool.o</span><br><span class="line">  CC      net/wireless/mesh.o</span><br><span class="line">  CC      net/wireless/ap.o</span><br><span class="line">  CC      net/wireless/trace.o</span><br><span class="line">  CC      net/wireless/ocb.o</span><br><span class="line">  CC      net/wireless/wext-compat.o</span><br><span class="line">  CC      net/wireless/wext-sme.o</span><br><span class="line">  LD      net/wireless/cfg80211.o</span><br><span class="line">  CC      net/wireless/wext-core.o</span><br><span class="line">  CC      net/wireless/wext-proc.o</span><br><span class="line">  CC      net/wireless/wext-priv.o</span><br><span class="line">  LD      net/wireless/built-in.o</span><br><span class="line">  CC      net/xfrm/xfrm_policy.o</span><br><span class="line">  CC      net/xfrm/xfrm_state.o</span><br><span class="line">  CC      net/xfrm/xfrm_hash.o</span><br><span class="line">  CC      net/xfrm/xfrm_input.o</span><br><span class="line">  CC      net/xfrm/xfrm_output.o</span><br><span class="line">  CC      net/xfrm/xfrm_sysctl.o</span><br><span class="line">  CC      net/xfrm/xfrm_replay.o</span><br><span class="line">  LD      net/xfrm/built-in.o</span><br><span class="line">  CC      net/sysctl_net.o</span><br><span class="line">  LD      net/built-in.o</span><br><span class="line">  LD      arch/arm/lib/built-in.o</span><br><span class="line">  AS      arch/arm/lib/ashldi3.o</span><br><span class="line">  AS      arch/arm/lib/ashrdi3.o</span><br><span class="line">  AS      arch/arm/lib/backtrace.o</span><br><span class="line">  AS      arch/arm/lib/bswapsdi2.o</span><br><span class="line">  AS      arch/arm/lib/call_with_stack.o</span><br><span class="line">  AS      arch/arm/lib/changebit.o</span><br><span class="line">  AS      arch/arm/lib/clear_user.o</span><br><span class="line">  AS      arch/arm/lib/clearbit.o</span><br><span class="line">  AS      arch/arm/lib/copy_from_user.o</span><br><span class="line">  AS      arch/arm/lib/copy_page.o</span><br><span class="line">  AS      arch/arm/lib/copy_to_user.o</span><br><span class="line">  AS      arch/arm/lib/csumipv6.o</span><br><span class="line">  AS      arch/arm/lib/csumpartial.o</span><br><span class="line">  AS      arch/arm/lib/csumpartialcopy.o</span><br><span class="line">  AS      arch/arm/lib/csumpartialcopyuser.o</span><br><span class="line">  AS      arch/arm/lib/delay-loop.o</span><br><span class="line">  CC      arch/arm/lib/delay.o</span><br><span class="line">  AS      arch/arm/lib/div64.o</span><br><span class="line">  AS      arch/arm/lib/findbit.o</span><br><span class="line">  AS      arch/arm/lib/getuser.o</span><br><span class="line">  AS      arch/arm/lib/io-readsb.o</span><br><span class="line">  AS      arch/arm/lib/io-readsl.o</span><br><span class="line">  AS      arch/arm/lib/io-readsw-armv4.o</span><br><span class="line">  AS      arch/arm/lib/io-writesb.o</span><br><span class="line">  AS      arch/arm/lib/io-writesl.o</span><br><span class="line">  AS      arch/arm/lib/io-writesw-armv4.o</span><br><span class="line">  AS      arch/arm/lib/lib1funcs.o</span><br><span class="line">  AS      arch/arm/lib/lshrdi3.o</span><br><span class="line">  AS      arch/arm/lib/memchr.o</span><br><span class="line">  AS      arch/arm/lib/memcpy.o</span><br><span class="line">  AS      arch/arm/lib/memmove.o</span><br><span class="line">  AS      arch/arm/lib/memset.o</span><br><span class="line">  AS      arch/arm/lib/memzero.o</span><br><span class="line">  AS      arch/arm/lib/muldi3.o</span><br><span class="line">  AS      arch/arm/lib/putuser.o</span><br><span class="line">  AS      arch/arm/lib/setbit.o</span><br><span class="line">  AS      arch/arm/lib/strchr.o</span><br><span class="line">  AS      arch/arm/lib/strrchr.o</span><br><span class="line">  AS      arch/arm/lib/testchangebit.o</span><br><span class="line">  AS      arch/arm/lib/testclearbit.o</span><br><span class="line">  AS      arch/arm/lib/testsetbit.o</span><br><span class="line">  AS      arch/arm/lib/ucmpdi2.o</span><br><span class="line">  AR      arch/arm/lib/lib.a</span><br><span class="line">  CC      lib/lockref.o</span><br><span class="line">  CC      lib/bcd.o</span><br><span class="line">  CC      lib/div64.o</span><br><span class="line">  CC      lib/sort.o</span><br><span class="line">  CC      lib/parser.o</span><br><span class="line">  CC      lib/halfmd4.o</span><br><span class="line">  CC      lib/debug_locks.o</span><br><span class="line">  CC      lib/random32.o</span><br><span class="line">  CC      lib/bust_spinlocks.o</span><br><span class="line">  CC      lib/kasprintf.o</span><br><span class="line">  CC      lib/bitmap.o</span><br><span class="line">  CC      lib/scatterlist.o</span><br><span class="line">  CC      lib/gcd.o</span><br><span class="line">  CC      lib/lcm.o</span><br><span class="line">  CC      lib/list_sort.o</span><br><span class="line">  CC      lib/uuid.o</span><br><span class="line">  CC      lib/flex_array.o</span><br><span class="line">  CC      lib/iov_iter.o</span><br><span class="line">  CC      lib/clz_ctz.o</span><br><span class="line">  CC      lib/bsearch.o</span><br><span class="line">  CC      lib/find_bit.o</span><br><span class="line">  CC      lib/llist.o</span><br><span class="line">  CC      lib/memweight.o</span><br><span class="line">  CC      lib/kfifo.o</span><br><span class="line">  CC      lib/percpu-refcount.o</span><br><span class="line">  CC      lib/percpu_ida.o</span><br><span class="line">  CC      lib/rhashtable.o</span><br><span class="line">  CC      lib/reciprocal_div.o</span><br><span class="line">  CC      lib/string_helpers.o</span><br><span class="line">  CC      lib/hexdump.o</span><br><span class="line">  CC      lib/kstrtox.o</span><br><span class="line">  CC      lib/pci_iomap.o</span><br><span class="line">  CC      lib/iomap_copy.o</span><br><span class="line">  CC      lib/devres.o</span><br><span class="line">  CC      lib/hweight.o</span><br><span class="line">  CC      lib/assoc_array.o</span><br><span class="line">  CC      lib/smp_processor_id.o</span><br><span class="line">  CC      lib/bitrev.o</span><br><span class="line">  CC      lib/rational.o</span><br><span class="line">  CC      lib/crc-ccitt.o</span><br><span class="line">  CC      lib/crc16.o</span><br><span class="line">  CC      lib/crc-t10dif.o</span><br><span class="line">  HOSTCC  lib/gen_crc32table</span><br><span class="line">  GEN     lib/crc32table.h</span><br><span class="line">  CC      lib/crc32.o</span><br><span class="line">  CC      lib/genalloc.o</span><br><span class="line">  CC      lib/fonts/fonts.o</span><br><span class="line">  CC      lib/fonts/font_8x8.o</span><br><span class="line">  CC      lib/fonts/font_8x16.o</span><br><span class="line">  LD      lib/fonts/font.o</span><br><span class="line">  LD      lib/fonts/built-in.o</span><br><span class="line">  CC      lib/lz4/lz4_decompress.o</span><br><span class="line">  LD      lib/lz4/built-in.o</span><br><span class="line">  CC      lib/lzo/lzo1x_compress.o</span><br><span class="line">  LD      lib/lzo/lzo_compress.o</span><br><span class="line">  CC      lib/lzo/lzo1x_decompress_safe.o</span><br><span class="line">  LD      lib/lzo/lzo_decompress.o</span><br><span class="line">  LD      lib/lzo/built-in.o</span><br><span class="line">  CC      lib/xz/xz_dec_syms.o</span><br><span class="line">  CC      lib/xz/xz_dec_stream.o</span><br><span class="line">  CC      lib/xz/xz_dec_lzma2.o</span><br><span class="line">  CC      lib/xz/xz_dec_bcj.o</span><br><span class="line">  LD      lib/xz/xz_dec.o</span><br><span class="line">  LD      lib/xz/built-in.o</span><br><span class="line">  CC      lib/zlib_deflate/deflate.o</span><br><span class="line">  CC      lib/zlib_deflate/deftree.o</span><br><span class="line">  CC      lib/zlib_deflate/deflate_syms.o</span><br><span class="line">  LD      lib/zlib_deflate/zlib_deflate.o</span><br><span class="line">  LD      lib/zlib_deflate/built-in.o</span><br><span class="line">  CC      lib/zlib_inflate/inffast.o</span><br><span class="line">  CC      lib/zlib_inflate/inflate.o</span><br><span class="line">  CC      lib/zlib_inflate/infutil.o</span><br><span class="line">  CC      lib/zlib_inflate/inftrees.o</span><br><span class="line">  CC      lib/zlib_inflate/inflate_syms.o</span><br><span class="line">  LD      lib/zlib_inflate/zlib_inflate.o</span><br><span class="line">  LD      lib/zlib_inflate/built-in.o</span><br><span class="line">  CC      lib/percpu_counter.o</span><br><span class="line">  CC      lib/swiotlb.o</span><br><span class="line">  CC      lib/iommu-helper.o</span><br><span class="line">  CC      lib/iommu-common.o</span><br><span class="line">  CC      lib/syscall.o</span><br><span class="line">  CC      lib/nlattr.o</span><br><span class="line">  CC      lib/average.o</span><br><span class="line">  CC      lib/cpu_rmap.o</span><br><span class="line">  CC      lib/dynamic_queue_limits.o</span><br><span class="line">  CC      lib/glob.o</span><br><span class="line">  CC      lib/strncpy_from_user.o</span><br><span class="line">  CC      lib/strnlen_user.o</span><br><span class="line">  CC      lib/net_utils.o</span><br><span class="line">  CC      lib/stmp_device.o</span><br><span class="line">  GEN     lib/oid_registry_data.c</span><br><span class="line">  CC      lib/oid_registry.o</span><br><span class="line">  LD      lib/built-in.o</span><br><span class="line">  CC      lib/argv_split.o</span><br><span class="line">  CC      lib/bug.o</span><br><span class="line">  CC      lib/cmdline.o</span><br><span class="line">  CC      lib/cpumask.o</span><br><span class="line">  CC      lib/ctype.o</span><br><span class="line">  CC      lib/dec_and_lock.o</span><br><span class="line">  CC      lib/decompress.o</span><br><span class="line">  CC      lib/decompress_bunzip2.o</span><br><span class="line">  CC      lib/decompress_inflate.o</span><br><span class="line">  CC      lib/decompress_unlz4.o</span><br><span class="line">  CC      lib/decompress_unlzma.o</span><br><span class="line">  CC      lib/decompress_unlzo.o</span><br><span class="line">  CC      lib/decompress_unxz.o</span><br><span class="line">  CC      lib/dump_stack.o</span><br><span class="line">  CC      lib/earlycpio.o</span><br><span class="line">  CC      lib/extable.o</span><br><span class="line">  CC      lib/fdt.o</span><br><span class="line">  CC      lib/fdt_empty_tree.o</span><br><span class="line">  CC      lib/fdt_ro.o</span><br><span class="line">  CC      lib/fdt_rw.o</span><br><span class="line">  CC      lib/fdt_strerror.o</span><br><span class="line">  CC      lib/fdt_sw.o</span><br><span class="line">  CC      lib/fdt_wip.o</span><br><span class="line">  CC      lib/flex_proportions.o</span><br><span class="line">  CC      lib/idr.o</span><br><span class="line">  CC      lib/int_sqrt.o</span><br><span class="line">  CC      lib/ioremap.o</span><br><span class="line">  CC      lib/irq_regs.o</span><br><span class="line">  CC      lib/is_single_threaded.o</span><br><span class="line">  CC      lib/klist.o</span><br><span class="line">  CC      lib/kobject.o</span><br><span class="line">  CC      lib/kobject_uevent.o</span><br><span class="line">  CC      lib/md5.o</span><br><span class="line">  CC      lib/plist.o</span><br><span class="line">  CC      lib/proportions.o</span><br><span class="line">  CC      lib/radix-tree.o</span><br><span class="line">  CC      lib/ratelimit.o</span><br><span class="line">  CC      lib/rbtree.o</span><br><span class="line">  CC      lib/seq_buf.o</span><br><span class="line">  CC      lib/sha1.o</span><br><span class="line">  CC      lib/show_mem.o</span><br><span class="line">  CC      lib/string.o</span><br><span class="line">  CC      lib/timerqueue.o</span><br><span class="line">  CC      lib/vsprintf.o</span><br><span class="line">  AR      lib/lib.a</span><br><span class="line">  CC [M]  lib/crc-itu-t.o</span><br><span class="line">  CC [M]  lib/crc7.o</span><br><span class="line">  CC [M]  lib/libcrc32c.o</span><br><span class="line">  LINK    vmlinux</span><br><span class="line">  LD      vmlinux.o</span><br><span class="line">  MODPOST vmlinux.o</span><br><span class="line">  GEN     .version</span><br><span class="line">  CHK     include/generated/compile.h</span><br><span class="line">  UPD     include/generated/compile.h</span><br><span class="line">  CC      init/version.o</span><br><span class="line">  LD      init/built-in.o</span><br><span class="line">  KSYM    .tmp_kallsyms1.o</span><br><span class="line">  KSYM    .tmp_kallsyms2.o</span><br><span class="line">  LD      vmlinux</span><br><span class="line">  SORTEX  vmlinux</span><br><span class="line">  SYSMAP  System.map</span><br><span class="line">  OBJCOPY arch/arm/boot/Image</span><br><span class="line">  Kernel: arch/arm/boot/Image is ready</span><br><span class="line">  LDS     arch/arm/boot/compressed/vmlinux.lds</span><br><span class="line">  AS      arch/arm/boot/compressed/head.o</span><br><span class="line">  LZO     arch/arm/boot/compressed/piggy.lzo</span><br><span class="line">  AS      arch/arm/boot/compressed/piggy.lzo.o</span><br><span class="line">  CC      arch/arm/boot/compressed/misc.o</span><br><span class="line">  CC      arch/arm/boot/compressed/decompress.o</span><br><span class="line">  CC      arch/arm/boot/compressed/string.o</span><br><span class="line">  SHIPPED arch/arm/boot/compressed/hyp-stub.S</span><br><span class="line">  AS      arch/arm/boot/compressed/hyp-stub.o</span><br><span class="line">  SHIPPED arch/arm/boot/compressed/lib1funcs.S</span><br><span class="line">  AS      arch/arm/boot/compressed/lib1funcs.o</span><br><span class="line">  SHIPPED arch/arm/boot/compressed/ashldi3.S</span><br><span class="line">  AS      arch/arm/boot/compressed/ashldi3.o</span><br><span class="line">  SHIPPED arch/arm/boot/compressed/bswapsdi2.S</span><br><span class="line">  AS      arch/arm/boot/compressed/bswapsdi2.o</span><br><span class="line">  LD      arch/arm/boot/compressed/vmlinux</span><br><span class="line">  OBJCOPY arch/arm/boot/zImage</span><br><span class="line">  Kernel: arch/arm/boot/zImage is ready</span><br><span class="line">  DTC     arch/arm/boot/dts/imx50-evk.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-ard.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-m53evk.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-mba53.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-qsb.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-qsrb.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-smd.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-tx53-x03x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-tx53-x13x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx53-voipac-bsb.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-aristainetos_4.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-aristainetos_7.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-cubox-i.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-dfi-fs700-m60.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-gw51xx.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-gw52xx.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-gw53xx.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-gw54xx.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-gw552x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-hummingboard.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-nitrogen6x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-phytec-pbab01.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-rex-basic.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-riotboard.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabreauto.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabreauto-ecspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabreauto-enetirq.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabreauto-flexcan1.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabreauto-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabrelite.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabresd.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabresd-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabresd-hdcp.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabresd-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-tx6dl-comtft.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-tx6u-801x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-tx6u-811x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-udoo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-sabresd-enetirq.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-wandboard.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dl-wandboard-revb1.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-arm2-hsic.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-pop-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-cm-fx6.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-cubox-i.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-dfi-fs700-m60.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-dmo-edmqmx6.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-gk802.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-gw51xx.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-gw52xx.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-gw53xx.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-gw5400-a.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-gw54xx.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-gw552x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-hummingboard.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-nitrogen6x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-phytec-pbab01.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-rex-pro.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabreauto.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabreauto-ecspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabreauto-enetirq.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabreauto-flexcan1.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabreauto-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabreauto.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabreauto-ecspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabreauto-flexcan1.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabreauto-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabresd.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabresd-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabresd-hdcp.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabresd-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6qp-sabresd-ldo-pcie-cert.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabrelite.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabresd.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabresd-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabresd-hdcp.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabresd-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sabresd-enetirq.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-sbc6x.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-tbs2910.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-tx6q-1010.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-tx6q-1010-comtft.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-tx6q-1020.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-tx6q-1020-comtft.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-tx6q-1110.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-udoo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-wandboard.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6q-wandboard-revb1.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev2-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev2-interleave-android-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev2-wifi-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev2-hdcp-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-evb-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-evb-interleave-android-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-evb-btwifi-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-evb-enetirq-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-evb-hdcp-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev3-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev3-hdcp-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6dqscm-1gb-qwks-rev3-btwifi-fix-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sl-evk.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sl-evk-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sl-evk-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sl-evk-csi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sl-evk-uart.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sl-warp.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-14x14-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sabreauto.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sabreauto-m4.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-reva.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-reva-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-emmc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-lcdif1.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-m4.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-mqs.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-sdb-sai.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-19x19-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-19x19-arm2-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-19x19-arm2-csi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sx-19x19-arm2-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sxscm-1gb-evb-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sxscm-1gb-evb-lcdif1-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sxscm-1gb-evb-m4-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sxscm-1gb-evb-mqs-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sxscm-1gb-evb-sai-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sxscm-1gb-evb-btwifi-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sxscm-epop-evb-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sxscm-epop-evb-m4-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-emmc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-flexcan2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-mqs.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-spdif.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-ddr3-arm2-wm8958.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-evk.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-evk-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-evk-csi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-evk-emmc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-evk-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-evk-usb-certi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-14x14-lpddr2-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-9x9-evk.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-9x9-evk-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-9x9-evk-csi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ul-9x9-evk-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-adc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-cs42888.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-ecspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-emmc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-epdc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-flexcan2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-lcdif.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-qspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-qspi-all.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-tsc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-uart2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-usb.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-ddr3-arm2-wm8958.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-evk.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-evk-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-evk-emmc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-evk-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-emmc-10.1-1280x800-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-emmc-7-1024x600-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-emmc-7-800x480-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-emmc-4.3-800x480-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-emmc-4.3-480x272-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-emmc-vga.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-emmc-hdmi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-nand-10.1-1280x800-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-nand-7-1024x600-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-nand-7-800x480-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-nand-4.3-800x480-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-nand-4.3-480x272-c.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-nand-vga.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-nand-hdmi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-alientek-emmc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-alientek-nand.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-14x14-evk-usb-certi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-9x9-evk.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-9x9-evk-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6ull-9x9-evk-ldo.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sll-lpddr2-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sll-lpddr3-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sll-lpddr3-arm2-csi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sll-lpddr3-arm2-ecspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sll-lpddr3-arm2-spdif.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sll-evk.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sll-evk-reva.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx6sll-evk-btwifi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-m4.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-ddr3-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-ecspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-enet2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-flexcan.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-mipi_dsi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-qspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-sai.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-mqs.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-12x12-lpddr3-arm2-pcie.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-19x19-lpddr2-arm2.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-epdc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-m4.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-qspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-mipi-dsi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-reva.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-reva-epdc.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-reva-gpmi-weim.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-reva-hdmi-audio.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-reva-m4.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-reva-qspi.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-reva-touch.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/imx7d-sdb-reva-wm8960.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/vf500-colibri-eval-v3.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/vf610-colibri-eval-v3.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/vf610-cosmic.dtb</span><br><span class="line">  DTC     arch/arm/boot/dts/vf610-twr.dtb</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 82 modules</span><br><span class="line">  CC      crypto/tcrypt.mod.o</span><br><span class="line">  LD [M]  crypto/tcrypt.ko</span><br><span class="line">  CC      drivers/bluetooth/rtk_btusb.mod.o</span><br><span class="line">  LD [M]  drivers/bluetooth/rtk_btusb.ko</span><br><span class="line">  CC      drivers/dma/dmatest.mod.o</span><br><span class="line">  LD [M]  drivers/dma/dmatest.ko</span><br><span class="line">  CC      drivers/i2c/algos/i2c-algo-pca.mod.o</span><br><span class="line">  LD [M]  drivers/i2c/algos/i2c-algo-pca.ko</span><br><span class="line">  CC      drivers/i2c/algos/i2c-algo-pcf.mod.o</span><br><span class="line">  LD [M]  drivers/i2c/algos/i2c-algo-pcf.ko</span><br><span class="line">  CC      drivers/input/evbug.mod.o</span><br><span class="line">  LD [M]  drivers/input/evbug.ko</span><br><span class="line">  CC      drivers/input/mouse/psmouse.mod.o</span><br><span class="line">  LD [M]  drivers/input/mouse/psmouse.ko</span><br><span class="line">  CC      drivers/input/serio/serport.mod.o</span><br><span class="line">  LD [M]  drivers/input/serio/serport.ko</span><br><span class="line">  CC      drivers/media/i2c/soc_camera/ov2640.mod.o</span><br><span class="line">  LD [M]  drivers/media/i2c/soc_camera/ov2640.ko</span><br><span class="line">  CC      drivers/media/i2c/soc_camera/ov772x.mod.o</span><br><span class="line">  LD [M]  drivers/media/i2c/soc_camera/ov772x.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/adv7180_tvin.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/adv7180_tvin.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/ipu_bg_overlay_sdc.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ipu_bg_overlay_sdc.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/ipu_csi_enc.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ipu_csi_enc.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/ipu_fg_overlay_sdc.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ipu_fg_overlay_sdc.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/ipu_prp_enc.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ipu_prp_enc.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/ipu_still.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ipu_still.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/mxc_v4l2_capture.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/mxc_v4l2_capture.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/ov5640_camera_int.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ov5640_camera_int.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/ov5640_camera_mipi_int.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ov5640_camera_mipi_int.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/ov5642_camera.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/ov5642_camera.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/capture/v4l2-int-device.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/capture/v4l2-int-device.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/subdev/mx6s_capture.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/mx6s_capture.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/subdev/mxc_mipi_csi.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/mxc_mipi_csi.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/subdev/mxc_vadc.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/mxc_vadc.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/subdev/ov5640_camera.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/ov5640_camera.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/subdev/ov5640_camera_mipi.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/ov5640_camera_mipi.ko</span><br><span class="line">  CC      drivers/media/platform/mxc/subdev/ov5647_camera_mipi.mod.o</span><br><span class="line">  LD [M]  drivers/media/platform/mxc/subdev/ov5647_camera_mipi.ko</span><br><span class="line">  CC      drivers/media/usb/gspca/gspca_main.mod.o</span><br><span class="line">  LD [M]  drivers/media/usb/gspca/gspca_main.ko</span><br><span class="line">  CC      drivers/media/usb/uvc/uvcvideo.mod.o</span><br><span class="line">  LD [M]  drivers/media/usb/uvc/uvcvideo.ko</span><br><span class="line">  CC      drivers/net/usb/GobiNet.mod.o</span><br><span class="line">  LD [M]  drivers/net/usb/GobiNet.ko</span><br><span class="line">  CC      drivers/net/usb/cdc_eem.mod.o</span><br><span class="line">  LD [M]  drivers/net/usb/cdc_eem.ko</span><br><span class="line">  CC      drivers/net/usb/pegasus.mod.o</span><br><span class="line">  LD [M]  drivers/net/usb/pegasus.ko</span><br><span class="line">  CC      drivers/net/usb/r8152.mod.o</span><br><span class="line">  LD [M]  drivers/net/usb/r8152.ko</span><br><span class="line">  CC      drivers/net/usb/rtl8150.mod.o</span><br><span class="line">  LD [M]  drivers/net/usb/rtl8150.ko</span><br><span class="line">  CC      drivers/net/wireless/rtl8192cu/8192cu.mod.o</span><br><span class="line">  LD [M]  drivers/net/wireless/rtl8192cu/8192cu.ko</span><br><span class="line">  CC      drivers/net/wireless/rtlwifi/rtl8188EUS/8188eu.mod.o</span><br><span class="line">  LD [M]  drivers/net/wireless/rtlwifi/rtl8188EUS/8188eu.ko</span><br><span class="line">  CC      drivers/net/wireless/rtlwifi/rtl_usb.mod.o</span><br><span class="line">  LD [M]  drivers/net/wireless/rtlwifi/rtl_usb.ko</span><br><span class="line">  CC      drivers/net/wireless/rtlwifi/rtlwifi.mod.o</span><br><span class="line">  LD [M]  drivers/net/wireless/rtlwifi/rtlwifi.ko</span><br><span class="line">  CC      drivers/net/wireless/zd1201.mod.o</span><br><span class="line">  LD [M]  drivers/net/wireless/zd1201.ko</span><br><span class="line">  CC      drivers/rpmsg/imx_rpmsg_pingpong.mod.o</span><br><span class="line">  LD [M]  drivers/rpmsg/imx_rpmsg_pingpong.ko</span><br><span class="line">  CC      drivers/rpmsg/imx_rpmsg_tty.mod.o</span><br><span class="line">  LD [M]  drivers/rpmsg/imx_rpmsg_tty.ko</span><br><span class="line">  CC      drivers/usb/class/cdc-acm.mod.o</span><br><span class="line">  LD [M]  drivers/usb/class/cdc-acm.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/u_ether.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/u_ether.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/u_serial.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/u_serial.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_acm.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_acm.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_ecm.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_ecm.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_ecm_subset.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_ecm_subset.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_eem.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_eem.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_fs.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_fs.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_mass_storage.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_mass_storage.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_ncm.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_ncm.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_obex.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_obex.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_rndis.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_rndis.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_serial.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_serial.ko</span><br><span class="line">  CC      drivers/usb/gadget/function/usb_f_ss_lb.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/function/usb_f_ss_lb.ko</span><br><span class="line">  CC      drivers/usb/gadget/legacy/g_ether.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_ether.ko</span><br><span class="line">  CC      drivers/usb/gadget/legacy/g_mass_storage.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_mass_storage.ko</span><br><span class="line">  CC      drivers/usb/gadget/legacy/g_ncm.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_ncm.ko</span><br><span class="line">  CC      drivers/usb/gadget/legacy/g_serial.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_serial.ko</span><br><span class="line">  CC      drivers/usb/gadget/legacy/g_zero.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/g_zero.ko</span><br><span class="line">  CC      drivers/usb/gadget/legacy/gadgetfs.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/legacy/gadgetfs.ko</span><br><span class="line">  CC      drivers/usb/gadget/libcomposite.mod.o</span><br><span class="line">  LD [M]  drivers/usb/gadget/libcomposite.ko</span><br><span class="line">  CC      drivers/usb/serial/ch341.mod.o</span><br><span class="line">  LD [M]  drivers/usb/serial/ch341.ko</span><br><span class="line">  CC      drivers/usb/serial/cp210x.mod.o</span><br><span class="line">  LD [M]  drivers/usb/serial/cp210x.ko</span><br><span class="line">  CC      drivers/usb/serial/ftdi_sio.mod.o</span><br><span class="line">  LD [M]  drivers/usb/serial/ftdi_sio.ko</span><br><span class="line">  CC      drivers/usb/serial/option.mod.o</span><br><span class="line">  LD [M]  drivers/usb/serial/option.ko</span><br><span class="line">  CC      drivers/usb/serial/usb_wwan.mod.o</span><br><span class="line">  LD [M]  drivers/usb/serial/usb_wwan.ko</span><br><span class="line">  CC      drivers/usb/serial/usbserial.mod.o</span><br><span class="line">  LD [M]  drivers/usb/serial/usbserial.ko</span><br><span class="line">  CC      drivers/video/fbdev/mxc/mxc_dcic.mod.o</span><br><span class="line">  LD [M]  drivers/video/fbdev/mxc/mxc_dcic.ko</span><br><span class="line">  CC      fs/binfmt_misc.mod.o</span><br><span class="line">  LD [M]  fs/binfmt_misc.ko</span><br><span class="line">  CC      fs/configfs/configfs.mod.o</span><br><span class="line">  LD [M]  fs/configfs/configfs.ko</span><br><span class="line">  CC      fs/fat/msdos.mod.o</span><br><span class="line">  LD [M]  fs/fat/msdos.ko</span><br><span class="line">  CC      fs/isofs/isofs.mod.o</span><br><span class="line">  LD [M]  fs/isofs/isofs.ko</span><br><span class="line">  CC      fs/nls/nls_iso8859-15.mod.o</span><br><span class="line">  LD [M]  fs/nls/nls_iso8859-15.ko</span><br><span class="line">  CC      fs/udf/udf.mod.o</span><br><span class="line">  LD [M]  fs/udf/udf.ko</span><br><span class="line">  CC      lib/crc-itu-t.mod.o</span><br><span class="line">  LD [M]  lib/crc-itu-t.ko</span><br><span class="line">  CC      lib/crc7.mod.o</span><br><span class="line">  LD [M]  lib/crc7.ko</span><br><span class="line">  CC      lib/libcrc32c.mod.o</span><br><span class="line">  LD [M]  lib/libcrc32c.ko</span><br><span class="line">  CC      sound/core/snd-hwdep.mod.o</span><br><span class="line">  LD [M]  sound/core/snd-hwdep.ko</span><br><span class="line">  CC      sound/core/snd-rawmidi.mod.o</span><br><span class="line">  LD [M]  sound/core/snd-rawmidi.ko</span><br><span class="line">  CC      sound/usb/snd-usb-audio.mod.o</span><br><span class="line">  LD [M]  sound/usb/snd-usb-audio.ko</span><br><span class="line">  CC      sound/usb/snd-usbmidi-lib.mod.o</span><br><span class="line">  LD [M]  sound/usb/snd-usbmidi-lib.ko</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="2-kernel-yuan-ma-mu-lu-jie-gou-fen-xi">2 kernel源码目录结构分析</span><a href="#2-kernel-yuan-ma-mu-lu-jie-gou-fen-xi" class="header-anchor">#</a></h1><p>linux内核源码编译后目录结构如下:<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/5.png" alt="image"></p>
<table>
<thead>
<tr>
<th>架构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>架构相关目录</td>
</tr>
<tr>
<td>block</td>
<td>块设备相关目录</td>
</tr>
<tr>
<td>crypto</td>
<td>加密相关目录</td>
</tr>
<tr>
<td>Documentation</td>
<td>文档相关目录</td>
</tr>
<tr>
<td>drivers</td>
<td>驱动相关目录</td>
</tr>
<tr>
<td>firmeare</td>
<td>固件相关目录</td>
</tr>
<tr>
<td>fs</td>
<td>文件系统相关目录</td>
</tr>
<tr>
<td>include</td>
<td>头文件相关目录</td>
</tr>
<tr>
<td>init</td>
<td>初始化相关目录</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信相关目录</td>
</tr>
<tr>
<td>kernel</td>
<td>内核相关目录</td>
</tr>
<tr>
<td>lib</td>
<td>库相关目录</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理相关目录</td>
</tr>
<tr>
<td>net</td>
<td>网络相关目录</td>
</tr>
<tr>
<td>samples</td>
<td>例程相关目录</td>
</tr>
<tr>
<td>scripts</td>
<td>脚本相关目录</td>
</tr>
<tr>
<td>security</td>
<td>安全相关目录</td>
</tr>
<tr>
<td>sound</td>
<td>音频处理相关目录</td>
</tr>
<tr>
<td>tools</td>
<td>工具相关目录</td>
</tr>
<tr>
<td>usr</td>
<td>与 initramfs 相关的目录，用于生成initramfs</td>
</tr>
<tr>
<td>virt</td>
<td>提供虚拟机技术(KVM)</td>
</tr>
<tr>
<td>.gitignore</td>
<td>git 工具相关文件</td>
</tr>
<tr>
<td>.mailmap</td>
<td>邮件列表</td>
</tr>
<tr>
<td>COPYING</td>
<td>版权声明</td>
</tr>
<tr>
<td>CREDITS</td>
<td>Linux 贡献者</td>
</tr>
<tr>
<td>Kbuild</td>
<td>Makefile 会读取此文件</td>
</tr>
<tr>
<td>Kconfig</td>
<td>图形化配置界面的配置文件</td>
</tr>
<tr>
<td>MAINTAINERS</td>
<td>维护者名单</td>
</tr>
<tr>
<td>Makefile</td>
<td>Linux 顶层 Makefile</td>
</tr>
</tbody></table>
<p>编译产生的文件如下：</p>
<table>
<thead>
<tr>
<th>架构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.config</td>
<td>Linux 最终使用的配置文件</td>
</tr>
<tr>
<td>.version</td>
<td>好像和版本有关</td>
</tr>
<tr>
<td>.vmlinux.cmd</td>
<td>cmd 文件，用于链接生成 vmlinux</td>
</tr>
<tr>
<td>Module.xx、modules.xx</td>
<td>一系列文件，和模块有关</td>
</tr>
<tr>
<td>System.map</td>
<td>符号表</td>
</tr>
<tr>
<td>vmlinux</td>
<td>编译出来的、未压缩的 ELF 格式Linux 文件</td>
</tr>
<tr>
<td>vmlinux.o</td>
<td>编译出来的 vmlinux.o 文件</td>
</tr>
</tbody></table>
<h2><span id="2-1-arch-mu-lu">2.1 arch 目录</span><a href="#2-1-arch-mu-lu" class="header-anchor">#</a></h2><p>和架构有关的目录，比如 arm、arm64、avr32、x86 等等架构。每种架构都对应一个目录，在这些目录中又有很多子目录，比如 boot、common、configs 等等，以 arch&#x2F;arm 为例:<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/6.png" alt="image"><br>这些子目录用于控制系统引导、系统调用、动态调频、主频设置等。</p>
<h2><span id="2-1-1-arch-x2f-arm-x2f-configs">2.1.1 arch&#x2F;arm&#x2F;configs</span><a href="#2-1-1-arch-x2f-arm-x2f-configs" class="header-anchor">#</a></h2><p>arch&#x2F;arm&#x2F;configs 目录是不同平台的默认配置文件：xxx_defconfig:<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/7.png" alt="image"><br>I.MX6U-ALPHA 开发板的默认配置文件：arch&#x2F;arm&#x2F;configs&#x2F;imx_v7_defconfig</p>
<h2><span id="2-1-2-arch-x2f-arm-x2f-boot-x2f-dts">2.1.2 arch&#x2F;arm&#x2F;boot&#x2F;dts</span><a href="#2-1-2-arch-x2f-arm-x2f-boot-x2f-dts" class="header-anchor">#</a></h2><p>arch&#x2F;arm&#x2F;boot&#x2F;dts 目录里面是对应开发平台的设备树文件， I.MX6U-ALPHA 开发板对应的设备树文件如下：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/8.png" alt="image"></p>
<h2><span id="2-1-3-arch-x2f-arm-x2f-boot">2.1.3 arch&#x2F;arm&#x2F;boot</span><a href="#2-1-3-arch-x2f-arm-x2f-boot" class="header-anchor">#</a></h2><p>会保存编译出来的 Image 和 zImage 镜像文件，而 zImage 就是我们要用的 linux 镜像文件。</p>
<h2><span id="2-1-4-arch-x2f-arm-x2f-mach-xxx">2.1.4 arch&#x2F;arm&#x2F;mach-xxx</span><a href="#2-1-4-arch-x2f-arm-x2f-mach-xxx" class="header-anchor">#</a></h2><p>相应平台的驱动和初始化文件，比如 mach-imx 目录里面就是 I.MX 系列 CPU 的驱动和初始化文件。</p>
<h2><span id="2-2-block-mu-lu">2.2 block 目录</span><a href="#2-2-block-mu-lu" class="header-anchor">#</a></h2><p>块设备目录，像 SD 卡、EMMC、NAND、硬盘等存储设备就属于块设备，block 目录中存放着管理块设备的相关文件。</p>
<h2><span id="2-3-crypto-mu-lu">2.3 crypto 目录</span><a href="#2-3-crypto-mu-lu" class="header-anchor">#</a></h2><p>存放加密算法，比如常见的 crc、crc32、md4、md5、hash 等加密算法。</p>
<h2><span id="2-4-documentation-mu-lu">2.4 Documentation 目录</span><a href="#2-4-documentation-mu-lu" class="header-anchor">#</a></h2><h2><span id="2-5-drivers-mu-lu">2.5 drivers 目录</span><a href="#2-5-drivers-mu-lu" class="header-anchor">#</a></h2><p>驱动目录文件，此目录根据驱动类型的不同，分门别类进行整理，比如 drivers&#x2F;i2c 就是 I2C相关驱动目录，drivers&#x2F;gpio 就是 GPIO 相关的驱动目录。</p>
<h2><span id="2-6-firmware-mu-lu">2.6 firmware 目录</span><a href="#2-6-firmware-mu-lu" class="header-anchor">#</a></h2><p>此目录用于存放固件。</p>
<h2><span id="2-7-fs-mu-lu">2.7 fs 目录</span><a href="#2-7-fs-mu-lu" class="header-anchor">#</a></h2><p>存放文件系统，比如 fs&#x2F;ext2、fs&#x2F;ext4、fs&#x2F;f2fs 等，分别是 ext2、ext4 和 f2fs 等文件系统。</p>
<h2><span id="2-8-init-mu-lu">2.8 init 目录</span><a href="#2-8-init-mu-lu" class="header-anchor">#</a></h2><p>此目录存放 Linux 内核启动的时候初始化代码。</p>
<h2><span id="2-9-ipc-mu-lu">2.9 ipc 目录</span><a href="#2-9-ipc-mu-lu" class="header-anchor">#</a></h2><p>IPC 为进程间通信，ipc 目录是进程间通信的具体实现代码。</p>
<h1><span id="3-vscode-gong-cheng-chuang-jian">3 VSCode 工程创建</span><a href="#3-vscode-gong-cheng-chuang-jian" class="header-anchor">#</a></h1><p>分析 Linux 的顶层 Makefile 之前，先创建 VSCode 工程，新建文件.vscode&#x2F;settings.json：</p>
<details>
<summary>.vscode/settings.json</summary>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;search.exclude&quot;: &#123;</span><br><span class="line">		&quot;**/node_modules&quot;: true,</span><br><span class="line">		&quot;**/bower_components&quot;: true,</span><br><span class="line">		&quot;**/*.o&quot;:true,</span><br><span class="line">		&quot;**/*.su&quot;:true,</span><br><span class="line">		&quot;**/*.cmd&quot;:true,</span><br><span class="line">		&quot;Documentation&quot;:true,</span><br><span class="line"></span><br><span class="line">		/* 屏蔽不用的架构相关的文件 */</span><br><span class="line">		&quot;arch/alpha&quot;:true,</span><br><span class="line">		&quot;arch/arc&quot;:true,</span><br><span class="line">		&quot;arch/arm64&quot;:true,</span><br><span class="line">		&quot;arch/avr32&quot;:true,</span><br><span class="line">		&quot;arch/[b-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/plat*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-[a-h]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-[n-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-i[n-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-m[e-v]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-k*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-l*&quot;:true,</span><br><span class="line"></span><br><span class="line">		/* 屏蔽排除不用的配置文件 */</span><br><span class="line">		&quot;arch/arm/configs/[a-h]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/[j-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/imo*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/in*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/io*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/ix*&quot;:true,</span><br><span class="line"></span><br><span class="line">		/* 屏蔽掉不用的 DTB 文件 */</span><br><span class="line">		&quot;arch/arm/boot/dts/[a-h]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/[k-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/in*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx1*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx7*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx2*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx3*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx5*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6d*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6q*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6s*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6ul-*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6ull-9x9*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6ull-14x14-ddr*&quot;:true, </span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	&quot;files.exclude&quot;: &#123;</span><br><span class="line">		&quot;**/.git&quot;: true,</span><br><span class="line">		&quot;**/.svn&quot;: true,</span><br><span class="line">		&quot;**/.hg&quot;: true,</span><br><span class="line">		&quot;**/CVS&quot;: true,</span><br><span class="line">		&quot;**/.DS_Store&quot;: true, </span><br><span class="line">		&quot;**/*.o&quot;:true,</span><br><span class="line">		&quot;**/*.su&quot;:true,</span><br><span class="line">		&quot;**/*.cmd&quot;:true,</span><br><span class="line">		&quot;Documentation&quot;:true,</span><br><span class="line"></span><br><span class="line">		/* 屏蔽不用的架构相关的文件 */</span><br><span class="line">		&quot;arch/alpha&quot;:true,</span><br><span class="line">		&quot;arch/arc&quot;:true,</span><br><span class="line">		&quot;arch/arm64&quot;:true,</span><br><span class="line">		&quot;arch/avr32&quot;:true,</span><br><span class="line">		&quot;arch/[b-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/plat*&quot;:true, </span><br><span class="line">		&quot;arch/arm/mach-[a-h]*&quot;:true, </span><br><span class="line">		&quot;arch/arm/mach-[n-z]*&quot;:true, </span><br><span class="line">		&quot;arch/arm/mach-i[n-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-m[e-v]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-k*&quot;:true,</span><br><span class="line">		&quot;arch/arm/mach-l*&quot;:true,</span><br><span class="line"></span><br><span class="line">		/* 屏蔽排除不用的配置文件 */</span><br><span class="line">		&quot;arch/arm/configs/[a-h]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/[j-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/imo*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/in*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/io*&quot;:true,</span><br><span class="line">		&quot;arch/arm/configs/ix*&quot;:true,</span><br><span class="line"></span><br><span class="line">		/* 屏蔽掉不用的 DTB 文件 */</span><br><span class="line">		&quot;arch/arm/boot/dts/[a-h]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/[k-z]*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/in*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx1*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx7*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx2*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx3*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx5*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6d*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6q*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6s*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6ul-*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6ull-9x9*&quot;:true,</span><br><span class="line">		&quot;arch/arm/boot/dts/imx6ull-14x14-ddr*&quot;:true,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>方便排除一些不必要的文件和搜索路径，方便加速搜索速率。</p>
<h1><span id="4-linux-ding-ceng-makefile-fen-xi">4 linux顶层 Makefile分析</span><a href="#4-linux-ding-ceng-makefile-fen-xi" class="header-anchor">#</a></h1><p>Linux 的顶层 Makefile 和 uboot 的顶层 Makefile 非常相似。<br><a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a><br><a href="https://www.cnblogs.com/fuzidage/p/17901135.html" title="uboot顶层makefile-2编译过程">uboot顶层makefile-2编译过程</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/">uboot-编译过程Make分析 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="4-1-ban-ben-hao">4.1 版本号</span><a href="#4-1-ban-ben-hao" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> VERSION = <span class="number">4</span></span><br><span class="line"><span class="number">2</span> PATCHLEVEL = <span class="number">1</span></span><br><span class="line"><span class="number">3</span> SUBLEVEL = <span class="number">15</span></span><br><span class="line"><span class="number">4</span> EXTRAVERSION =</span><br></pre></td></tr></table></figure>
<h2><span id="4-2-makeflags-bian-liang">4.2 MAKEFLAGS 变量</span><a href="#4-2-makeflags-bian-liang" class="header-anchor">#</a></h2><p><code>16 MAKEFLAGS += -rR --include-dir=$(CURDIR)</code></p>
<h2><span id="4-3-ming-ling-shu-chu-xiang-xi-cheng-du">4.3 命令输出详细程度</span><a href="#4-3-ming-ling-shu-chu-xiang-xi-cheng-du" class="header-anchor">#</a></h2><p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/9.png" alt="image"><br>和uboot完全一样。make -s设置成静默输出，将会silent_输出,不打印任何提示信息。如下：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/10.png" alt="image"></p>
<h2><span id="4-4-she-zhi-bian-yi-jie-guo-shu-chu-mu-lu">4.4 设置编译结果输出目录</span><a href="#4-4-she-zhi-bian-yi-jie-guo-shu-chu-mu-lu" class="header-anchor">#</a></h2><p>和uboot完全一样。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="4-5-dai-ma-jian-cha">4.5 代码检查</span><a href="#4-5-dai-ma-jian-cha" class="header-anchor">#</a></h2><p>和uboot完全一样。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="4-6-zi-mo-kuai-bian-yi">4.6 子模块编译</span><a href="#4-6-zi-mo-kuai-bian-yi" class="header-anchor">#</a></h2><p>和uboot完全一样。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="4-7-she-zhi-mu-biao-jia-gou-he-jiao-cha-bian-yi-qi">4.7 设置目标架构和交叉编译器</span><a href="#4-7-she-zhi-mu-biao-jia-gou-he-jiao-cha-bian-yi-qi" class="header-anchor">#</a></h2><p>和uboot完全一样。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="4-8-diao-yong-scripts-x2f-kbuild-include">4.8 调用 scripts&#x2F;Kbuild.include</span><a href="#4-8-diao-yong-scripts-x2f-kbuild-include" class="header-anchor">#</a></h2><p>和uboot完全一样。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="4-9-tou-wen-jian-lu-jing-bian-liang">4.9 头文件路径变量</span><a href="#4-9-tou-wen-jian-lu-jing-bian-liang" class="header-anchor">#</a></h2><p>顶层 Makefile 定义了两个变量保存头文件路径：<code>USERINCLUDE </code>和 <code>LINUXINCLUDE</code>：<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/11.png" alt="image"><br>其中<code>srctree=.</code>，<code>hdr-arch=arm</code>，<code>KBUILD_SRC </code>为空，因此，将 <code>USERINCLUDE </code>和<code>LINUXINCLUDE </code>展<br>开以后为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">USERINCLUDE := \</span><br><span class="line">	-I./arch/arm/<span class="keyword">include</span>/uapi \</span><br><span class="line">	-Iarch/arm/<span class="keyword">include</span>/generated/uapi \</span><br><span class="line">	-I./<span class="keyword">include</span>/uapi \</span><br><span class="line">	-Iinclude/generated/uapi \</span><br><span class="line">	 <span class="keyword">-include</span> ./<span class="keyword">include</span>/linux/kconfig.h</span><br><span class="line">LINUXINCLUDE := \</span><br><span class="line">	-I./arch/arm/<span class="keyword">include</span> \</span><br><span class="line">	-Iarch/arm/<span class="keyword">include</span>/generated/uapi \</span><br><span class="line">	-Iarch/arm/<span class="keyword">include</span>/generated \</span><br><span class="line">	-Iinclude \</span><br><span class="line">	-I./arch/arm/<span class="keyword">include</span>/uapi \</span><br><span class="line">	-Iarch/arm/<span class="keyword">include</span>/generated/uapi \</span><br><span class="line">	-I./<span class="keyword">include</span>/uapi \</span><br><span class="line">	-Iinclude/generated/uapi \</span><br><span class="line">	<span class="keyword">-include</span> ./<span class="keyword">include</span>/linux/kconfig.h</span><br></pre></td></tr></table></figure>
<h2><span id="4-10-he-xin-bian-liang-dao-chu">4.10 核心变量导出</span><a href="#4-10-he-xin-bian-liang-dao-chu" class="header-anchor">#</a></h2><p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/12.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION</span><br><span class="line"><span class="keyword">export</span> ARCH SRCARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC</span><br><span class="line"><span class="keyword">export</span> CPP AR NM STRIP OBJCOPY OBJDUMP</span><br><span class="line"><span class="keyword">export</span> MAKE AWK GENKSYMS INSTALLKERNEL PERL PYTHON UTS_MACHINE</span><br><span class="line"><span class="keyword">export</span> HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS</span><br><span class="line"><span class="keyword">export</span> KBUILD_CFLAGS CFLAGS_KERNEL CFLAGS_MODULE CFLAGS_GCOV CFLAGS_KASAN</span><br><span class="line"><span class="keyword">export</span> KBUILD_AFLAGS AFLAGS_KERNEL AFLAGS_MODULE</span><br><span class="line"><span class="keyword">export</span> KBUILD_AFLAGS_MODULE KBUILD_CFLAGS_MODULE KBUILD_LDFLAGS_MODULE</span><br><span class="line"><span class="keyword">export</span> KBUILD_AFLAGS_KERNEL KBUILD_CFLAGS_KERNEL</span><br><span class="line"><span class="keyword">export</span> KBUILD_ARFLAGS</span><br></pre></td></tr></table></figure>
<h1><span id="5-linux-nei-he-defconfig-guo-cheng">5 linux内核defconfig过程</span><a href="#5-linux-nei-he-defconfig-guo-cheng" class="header-anchor">#</a></h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_v7_defconfig</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-pei-zhi-bian-liang">5.1 配置变量</span><a href="#5-1-pei-zhi-bian-liang" class="header-anchor">#</a></h2><p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/13.png" alt="image"><br>同uboot一样，<a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a>  <a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a>得到:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">config-targets= 1</span><br><span class="line">mixed-targets= 0</span><br><span class="line">dot-config= 1</span><br></pre></td></tr></table></figure>

<h2><span id="5-2-zhi-xing-3-ge-yi-lai">5.2 执行3个依赖</span><a href="#5-2-zhi-xing-3-ge-yi-lai" class="header-anchor">#</a></h2><p>继续看顶层<code>makefile</code>, 同uboot一样，<a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a>，<a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/">uboot-编译过程Make分析 | Hexo (fuzidage.github.io)</a>  三个依赖为<code>scripts_basic</code>，<code>outputmakefile</code>，<code>FORCE</code>。<br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/14.png" alt="image"></p>
<p>build 定义在文件 <code>scripts/Kbuild.include </code>中，值为：<br><code>build := -f $(srctree)/scripts/Makefile.build obj</code><br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/15.png" alt="image"></p>
<h3><span id="5-2-1-scripts-basic">5.2.1 scripts_basic</span><a href="#5-2-1-scripts-basic" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">scripts_basic:</span></span><br><span class="line">	<span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/basic</span><br><span class="line">	<span class="variable">$(Q)</span>rm -f .tmp_quiet_recordmcount</span><br></pre></td></tr></table></figure>
<p>scripts_basic展开后:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">scripts_basic:</span></span><br><span class="line">	@make -f ./scripts/Makefile.build obj=scripts/basic <span class="comment">#也可以没有@，视配置而定</span></span><br><span class="line">	@rm -f . tmp_quiet_recordmcount</span><br></pre></td></tr></table></figure>
<p>从<code>scripts/Makefile.build</code>开始编译默认目标<code>_build</code>。scripts_basic就是利用<code>scripts/Makefile.build</code>去找到<code>_build</code>目标，然后去scripts&#x2F;basic目录编译出<code>fixdep</code>。</p>
<h4><span id="5-2-1-1-scripts-x2f-makefile-build-fen-xi">5.2.1.1 scripts&#x2F;Makefile.build分析</span><a href="#5-2-1-1-scripts-x2f-makefile-build-fen-xi" class="header-anchor">#</a></h4><p>scripts&#x2F;Makefile.build分析详见<a href="https://www.cnblogs.com/fuzidage/p/17859528.html" title="Uboot顶层Makefile解析-1. defconfig过程分析">Uboot顶层Makefile解析-1. defconfig过程分析</a>  第12.3.1.1。</p>
<p>即<a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/#12-3-1-1-scripts-makefile-build">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a><br>最后展开：<br><code>kbuild-dir=./scripts/basic</code><br><code>kbuild-file= ./scripts/basic/Makefile</code><br>继续分析<code> scripts/Makefile.build</code>, 命令<code>“@make -f ./scripts/Makefile.build obj=scripts/basic”</code>没有指定目标，所以会使用到默认目标<code>__build</code><br><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/16.png" alt="image"><br>在顶层 Makefile 中，<code>KBUILD_BUILTIN</code> 为 1，<code>KBUILD_MODULES</code> 为空，因此展开后目标<code>__build </code>为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">__build:$(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) <span class="variable">$(always)</span></span></span><br><span class="line">	@:</span><br></pre></td></tr></table></figure>
<p>打印出依赖：<br><code>builtin-target =</code><br><code>lib-target =</code><br><code>extra-y =</code><br><code>subdir-ym =</code><br><code>always = scripts/basic/fixdep scripts/basic/bin2c</code><br>只有 always 有效，因此__build 最终为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">__build: scripts/basic/fixdep scripts/basic/bin2c</span></span><br><span class="line">	@:</span><br></pre></td></tr></table></figure>

<p>综上所述，scripts_basic 目标的作用就是编译出 scripts&#x2F;basic&#x2F;fixdep 和 scripts&#x2F;basic&#x2F;bin2c 这两个软件。</p>
<h3><span id="5-2-2-outputmakefile">5.2.2 outputmakefile：</span><a href="#5-2-2-outputmakefile" class="header-anchor">#</a></h3><p>由于KBUILD_SRC为空，不执行。否则会为源码路径创建source这个符号链接，执行mkmakefile。</p>
<h3><span id="5-2-3-force">5.2.3 FORCE：</span><a href="#5-2-3-force" class="header-anchor">#</a></h3><p>Makefile最底下定了FORCE目标，可以看到什么都不执行。</p>
<h2><span id="5-3-chan-sheng-config">5.3 产生.config</span><a href="#5-3-chan-sheng-config" class="header-anchor">#</a></h2><p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/17.png" alt="image"><br>回到顶层Makefile的%config 处,三个依赖执行完后继续执行，展开：<br><code>make -f ./scripts/Makefile.build obj=scripts/kconfig imx_v7_defconfig</code></p>
<h3><span id="5-3-1-ji-xu-scripts-x2f-makefile-build-fen-xi">5.3.1 继续scripts&#x2F;Makefile.build分析</span><a href="#5-3-1-ji-xu-scripts-x2f-makefile-build-fen-xi" class="header-anchor">#</a></h3><p>前面整理了scripts&#x2F;Makefile.build用到的变量include内容：<br><code>src= scripts/kconfig</code><br><code>kbuild-dir = ./scripts/kconfig</code><br><code>kbuild-file = ./scripts/kconfig/Makefile</code><br><code>include ./scripts/kconfig/Makefile</code><br>可以看出，scripts&#x2F;Makefile.build会读取 scripts&#x2F;kconfig&#x2F;Makefile 中的内容:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">113 %_defconfig: <span class="variable">$(obj)</span>/conf</span><br><span class="line">114 <span class="variable">$(Q)</span><span class="variable">$&lt;</span> <span class="variable">$(silent)</span> --defconfig=arch/<span class="variable">$(SRCARCH)</span>/configs/<span class="variable">$@</span> <span class="variable">$(Kconfig)</span></span><br></pre></td></tr></table></figure>

<p>目标%_defconfig 与 xxx_defconfig 匹配，所以会执行这条规则，将其展开就是:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%_defconfig: scripts/kconfig/conf</span></span><br><span class="line">	@ scripts/kconfig/conf --defconfig=arch/arm/configs/%_defconfig Kconfig</span><br></pre></td></tr></table></figure>
<p><code>%_defconfig</code>依赖scripts&#x2F;kconfig&#x2F;conf，所以会编译scripts&#x2F;kconfig&#x2F;conf.c生成conf 这个软件。此软件就会将<code>%_defconfig </code>中的配置输出到<code>.config </code>文件中，最终生成 Linux kernel 根目录下的<code>.config </code>文件。</p>
<p><img src="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/18.png" alt="image"></p>
<h1><span id="6-nei-he-bian-yi-xuan-xiang">6 内核编译选项</span><a href="#6-nei-he-bian-yi-xuan-xiang" class="header-anchor">#</a></h1><h2><span id="6-1-ccflags-y-asflags-y-he-ldflags-y">6.1 ccflags-y asflags-y和ldflags-y</span><a href="#6-1-ccflags-y-asflags-y-he-ldflags-y" class="header-anchor">#</a></h2><p>编译、汇编、链接时的参数.<br>所有的<code>ccflags-y</code> <code>asflags-y</code>和<code>ldflags-y</code>这三个变量只对有定义的Makefile中使用，简而言之，这些flag在Makefile树中不会有继承效果，Makefile之间相互独立。</p>
<h2><span id="6-2-subdir-ccflags-y-subdir-asflags-y">6.2 subdir-ccflags-y, subdir-asflags-y</span><a href="#6-2-subdir-ccflags-y-subdir-asflags-y" class="header-anchor">#</a></h2><p>添加了<code>subdir-</code>前缀，意味着这两个编译选项对本目录和所有的子目录都有效。</p>
<h2><span id="6-3-cflags-mod-xxx">6.3 CFLAGS_MOD_XXX</span><a href="#6-3-cflags-mod-xxx" class="header-anchor">#</a></h2><p>使用<code>CFLAGS_</code>或者<code>AFLAGS_</code>前缀描述的模块可以为模块的编译单独提供参数:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CFLAGS_foo.o = -DAUTOCONF <span class="comment">#在编译foo.o时，添加了-DAUTOCONF编译选项</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机-异常中断</title>
    <url>/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</a><ul>
<li><a href="#1-1-cpu-mo-shi">1.1 CPU模式</a></li>
<li><a href="#1-2-gong-zuo-state">1.2 工作State</a></li>
<li><a href="#1-3-arm-ji-cun-qi">1.3 ARM寄存器</a><ul>
<li><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</a></li>
<li><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</a></li>
</ul>
</li>
<li><a href="#1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</a></li>
</ul>
</li>
<li><a href="#2-yi-chang-chu-li-liu-cheng">2 异常处理流程</a><ul>
<li><a href="#2-1-zhong-duan-qian">2.1 中断前</a><ul>
<li><a href="#2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</a></li>
</ul>
</li>
<li><a href="#2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</a><ul>
<li><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</a></li>
</ul>
</li>
<li><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</a></li>
</ul>
</li>
<li><a href="#3-zhong-duan-shi-li">3 中断实例</a><ul>
<li><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</a><ul>
<li><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</a></li>
<li><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</a></li>
<li><a href="#3-1-3-shi-li-gai-jin">3.1.3 示例改进</a><ul>
<li><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</a></li>
<li><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</a></li>
<li><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-2-swi-ruan-zhong-duan">3.2 swi-软中断</a><ul>
<li><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</a><ul>
<li><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</a><ul>
<li><a href="#3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</a></li>
<li><a href="#3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</a><ul>
<li><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</a></li>
<li><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</a></li>
<li><a href="#3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</a></li>
<li><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</a><ul>
<li><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</a><ul>
<li><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</a><ul>
<li><a href="#3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</a></li>
<li><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</a><ul>
<li><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</a></li>
<li><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</a></li>
</ul>
</li>
<li><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</a><ul>
<li><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</a></li>
<li><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</a><ul>
<li><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</a></li>
<li><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</span><a href="#1-yi-chang-zhong-duan-yin-ru" class="header-anchor">#</a></h1><p>在arm架构的处理器中，cpu有7中工作模式，2中工作状态。</p>
<h2><span id="1-1-cpu-mo-shi">1.1 CPU模式</span><a href="#1-1-cpu-mo-shi" class="header-anchor">#</a></h2><pre><code>7种Mode: 除了usr/sys，其他5种都是异常模式。我们知道中断属于异常的2中，中断有irq,fiq。
</code></pre>
<table>
<thead>
<tr>
<th>usr</th>
<th>sys</th>
<th>undefined(und)</th>
<th>Supervisor(svc)</th>
<th>Abort(abt)</th>
<th>irq</th>
<th>fiq</th>
</tr>
</thead>
<tbody><tr>
<td>用户模式</td>
<td>系统模式</td>
<td>未定义指令异常模</td>
<td>svc管理模式</td>
<td>终止模式（1.指令预取终止(读写某条错误的指令导致终止运行)；2.数据访问终止(读写某个非法地址程序终止)）</td>
<td>irq中断</td>
<td>快中断</td>
</tr>
</tbody></table>
<p>除了usr模式，其他6中为特权模式。 CPU无法从usr模式直接进入特权模式。不能直接进入特权模式，那么<strong>怎么进入特权模式</strong>呢？</p>
<p>可以通过<strong>设置CPSR</strong>进入其他模式。</p>
<h2><span id="1-2-gong-zuo-state">1.2 工作State</span><a href="#1-2-gong-zuo-state" class="header-anchor">#</a></h2><pre><code>ARM state
Thumb state(几乎用不上)
</code></pre>
<h2><span id="1-3-arm-ji-cun-qi">1.3 ARM寄存器</span><a href="#1-3-arm-ji-cun-qi" class="header-anchor">#</a></h2><pre><code>(1)通用寄存器:
(2)备份寄存器(banked register):
    CPSR:当前程序状态寄存器(Current Program Status Register) 反映程序处在那种状态
    SPSR:CPSR的备份寄存器 (Saved Program Status Register)  用来保存&quot;被中断前的CPSR&quot;
</code></pre>
<p>下图是我们arm状态下的通用寄存器和程序状态寄存器<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/1.png"></p>
<p><strong>R13是SP（栈指针）</strong><br><strong>R14是LR</strong>（link register），程序跳转或者发成异常时的返回地址<br><strong>R15是PC</strong>（程序计数器）</p>
<p>假设cpu执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov R0, R8</span><br><span class="line">mov R0,R8_fiq</span><br></pre></td></tr></table></figure>

<p>在usr&#x2F;System 模式下访问的R8, 但是在FIQ模式下，访问R8是访问FIQ模式专属的R8寄存器，不是同一个物理上的寄存器。<br>在5种异常模式中每个模式都有自己专属的R13 R14寄存器，R13用作SP(栈)， R14(LR)是用来保存发生异常时的指令地址。</p>
<p>为什么快中断(FIQ)有那么多专属寄存器?<br>这些寄存器称为备份寄存器，我们先看下<strong>中断处理流程</strong>：</p>
<pre><code>1 保存现场(保存被中断模式的寄存器)---(比如程序正在sys/usr模式下运行，当发生中断时，需要把R0-R14这些寄存器全部保存下来)
2 异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）
3 恢复现场(恢复被中断时保存下来的寄存器R0-R14)
</code></pre>
<p>但如果是快中断，那么我就不需要保存系统&#x2F;用户模式下的R8 ~ R12这几个寄存器，因为在FIQ模式下有自己专属的R8 ~ R12寄存器，省略保存寄存器的时间，加快处理速度，所以它才称得上快中断。</p>
<h3><span id="1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</span><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>在异常中断中PSR寄存器会使用的很频繁，PSR寄存器的格式如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/2.png"></p>
<p>我们再来看看下表，反映的是PSR的 M[4:0]与arm工作模式的关系：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/3.png"></p>
<p>我们可以按照上图的对应关系设置CPSR，让其进入与之对应的模式。</p>
<h3><span id="1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</span><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi" class="header-anchor">#</a></h3><h2><span id="1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</span><a href="#1-4-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p><strong>异常向量</strong>：不同的异常有不同的入口函数，那么这个异常入口函数的地址就是存放在该异常向量的位置。从该异常向量读取到的数据就是异常入口函数的地址。<br><strong>异常向量表</strong>：就是由异常向量组成的集合。</p>
<p>下图是从uboot源代码中截取的smdk2410 的异常向量表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start:	b       reset</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br></pre></td></tr></table></figure>

<p>异常向量表对应的地址如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/4.png"></p>
<h1><span id="2-yi-chang-chu-li-liu-cheng">2 异常处理流程</span><a href="#2-yi-chang-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>CPU是如何进入到中断模式，执行中断服务程序的？</p>
<h2><span id="2-1-zhong-duan-qian">2.1 中断前</span><a href="#2-1-zhong-duan-qian" class="header-anchor">#</a></h2><p>下图是中断未触发前的程序执行过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/5.png"></p>
<h3><span id="2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</span><a href="#2-1-1-chu-shi-hua-zhong-duan" class="header-anchor">#</a></h3><pre><code>1，设置中断源（使中断能够产生，让CPU知道是哪个中断）
2，设置中断控制器（设置中断屏蔽，中断优先级）
3，设置中断总开关CPSR (使能中断)
</code></pre>
<h2><span id="2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</span><a href="#2-2-zhong-duan-chan-sheng-hou" class="header-anchor">#</a></h2><p>举个栗子：按键按下，产生按键irq。</p>
<h3><span id="2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</span><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h3><p>cpu强制跳转到异常向量表上对应的_irq异常向量（0x18）去读取指令（这个是CPU强制执行的，不需要我们去控制）。</p>
<p>具体的进入中断向量和中断返回流程见下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/6.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">进入：</span><br><span class="line">	 (<span class="number">1</span>) LR_异常=PC + offset（具体多少看下图）</span><br><span class="line">	（<span class="number">2</span>）SPSR_异常=被中断前的程序模式CPSR</span><br><span class="line">	 (<span class="number">3</span>) CPSR被设置成对应的异常模式</span><br><span class="line">	（<span class="number">4</span>）跳转到对应的异常向量去执行</span><br><span class="line">退出（返回）：进入和退出就是一个逆过程</span><br><span class="line">	（<span class="number">1</span>）PC= LR_异常 -offset</span><br><span class="line">	（<span class="number">2</span>）被中断前的程序模式CPSR = SPSR_异常</span><br><span class="line">	（<span class="number">3</span>）中断结束，清中断</span><br></pre></td></tr></table></figure>

<p>进入异常和返回异常时pc和lr的关系如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/7.png"></p>
<p>从图中我们发现进入不同异常，offset的值也是有差异的。</p>
<h2><span id="2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</span><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h2><pre><code>1.当跳转到irq异常向量(0x18)后，发现该处是一条跳转指令“ldr pc, _irq”,
那么会通过ldr绝对跳转指令跳到到真正的中断处理函数_irq去执行。
2.那么在_irq的函数中我们需要按照之前说的**中断处理流程**去执行：
    （1）保存现场
    （2）异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）
    （3）恢复现场
</code></pre>
<p>流程图总结下中断产生后的详细处理过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/8.png"></p>
<h1><span id="3-zhong-duan-shi-li">3 中断实例</span><a href="#3-zhong-duan-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</span><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang" class="header-anchor">#</a></h2><p>先来看下当cpu解析到什么样的指令才会触发未定义指令异常呢？</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/9.png"></p>
<p>从上面的arm指令格式中可知，只要指令码属于划线的格式，就属于未定义指令异常。</p>
<h3><span id="3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</span><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can" class="header-anchor">#</a></h3><p>我们知道汇编给C语言函数传参是通过r0，r1，…通过堆栈的方式去传递的参数，比如r0&#x3D;1, r1&#x3D;2;那么在被调用的c函数中argv0就是r0, argv1就是r1…,那么我们如果通过汇编给C函数传递字符串呢？</p>
<p>声明und_string为一个字符串:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>ldr r1, =und_string</code>，这样r1中就保存了und_string的地址。<br>这样调用我们的c函数就可以把und_string传入进去。</p>
<h3><span id="3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</span><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	sdram</span></span><br><span class="line"><span class="comment">	设置SP</span></span><br><span class="line"><span class="comment">	重定位*/</span></span><br><span class="line">	...</span><br><span class="line">	bl print1</span><br><span class="line">und_code:</span><br><span class="line">	.word <span class="number">0xdeadc0de</span>; <span class="comment">/*定义一条未定义指令*/</span></span><br><span class="line">	<span class="comment">/*故意以一个数据的方式引入一条未定义指令，当cpu执行到这里，读取0xdeadc0de指令码的时候，</span></span><br><span class="line"><span class="comment">	发现无法识别这条指令，就发生未定义指令异常，就跳转到0x4的中断向量去执行*/</span></span><br><span class="line">	</span><br><span class="line">	bl print2</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>


<p>在未定义指令异常前后加上打印print1, print2，<strong>如果出现未定义指令异常后，就会跳到0x4的地方去读取指令，print2也就没法执行</strong>。</p>
<p>当跳转到0x4的中断向量后，发现此处是一条跳转指令<code>bl do_und</code>, 我们再到未定义指令异常的服务程序do_und中打印出und_string这个字符串的内容。<br>现在开始写指令异常的服务程序do_und，实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_und:</span><br><span class="line">	<span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理und异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure>

<p>下面来分析一下这个未定义指令异常服务程序:</p>
<ol>
<li><p>进入未定义指令异常服务do_und之前硬件自动完成的事情如下：</p>
<ol>
<li>lr_und保存有被中断模式中的下一条即将执行的指令的地址</li>
<li>SPSR_und保存有被中断模式的CPSR</li>
<li>CPSR中的M4-M0被设置为11011, 进入到und模式</li>
<li>跳到0x4的地方执行程序 （bl do_und）</li>
</ol>
</li>
<li><p>进入指令异常服务程序do_und后，我们需要保存现场，处理und异常,恢复现场，<strong>注意：由于发生了cpu模式切换，如果要用到栈，那么先要设置对应模式的栈。</strong>由于栈的地址是向下生长的，这里我就用sdram的末位地址作为栈指针，把sp_und&#x3D;0x34000000。</p>
</li>
<li><p>在und异常服务程序中有可能会用到栈, 所以先保存现场，通过<code>stmdb sp!, &#123;r0-r12, lr&#125;</code>语句把栈中的值备份到r0-r12和lr，然后恢复现场的时候通过<code>ldmia sp!, &#123;r0-r12, pc&#125;^</code>，详见上面的注释。</p>
</li>
<li><p>我们看到保存现场后，我们把cpsr的值放到r0, 把und_string放到r1, 然后用bl printException调用c函数，这样我们的c函数printException就能收到汇编传过来的参数，一个是cpsr模式（r0），一个是und_string汇编传过来的字符串(r1)。我们用C函数实现printException：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printException</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpsr, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Exception! cpsr = &quot;</span>);</span><br><span class="line">	printHex(cpsr);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(str);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	</span><br><span class="line">	b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line"></span><br><span class="line">do_und:</span><br><span class="line">	<span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment">	 * 1. lr_und保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment">	 * 2. SPSR_und保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment">	 * 3. CPSR中的M4-M0被设置为11011, 进入到und模式</span></span><br><span class="line"><span class="comment">	 * 4. 跳到0x4的地方执行程序 （bl do_und）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理und异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">	<span class="comment">/* sdram */</span>	</span><br><span class="line">	bl copy2sdram</span><br><span class="line">	bl clean_bss</span><br><span class="line"></span><br><span class="line">	bl uart0_init</span><br><span class="line"></span><br><span class="line">	bl print1</span><br><span class="line">	<span class="comment">/* 故意加入一条未定义指令 */</span></span><br><span class="line">und_code:</span><br><span class="line">	.word <span class="number">0xdeadc0de</span>  <span class="comment">/* 未定义指令 */</span></span><br><span class="line">	bl print2</span><br><span class="line"></span><br><span class="line">	<span class="comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong>如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/10.png"></p>
<p>打印出print1中的字符串‘abc’后，紧接着打印printException函数中的结果，cpsr&#x3D;0x600000db,那么对应的M[4:0]&#x3D;11011， 对应下图为und模式。然后从und异常返回，恢复原来的模式继续执行。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/11.png"></p>
<h3><span id="3-1-3-shi-li-gai-jin">3.1.3 示例改进</span><a href="#3-1-3-shi-li-gai-jin" class="header-anchor">#</a></h3><h4><span id="3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</span><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi" class="header-anchor">#</a></h4><p>我们将上面的代码的und_string字符串修改一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>编译烧录再次运行，发现没有任何打印输出，这是为什么呢？我明明只是把und_string字符串改了一下呀。</p>
<p>查看反汇编：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/12.png"></p>
<p>我们发现reset的地址是0x30000032，竟然不是4字节对齐的，我们知道arm指令集是以4字节为基本单位的，那么这里没有对齐，肯定无法解析指令。那么我们手工改进代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br></pre></td></tr></table></figure>

<font color="red" size="2.5">
.align 4
</font>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/13.png"></p>
<p>我们再来看看反汇编，发现reset的地址是30000040，是以4字节对齐的，再次烧录运行，发现能够正常输出print1, 能够进入未定义指令异常。</p>
<h4><span id="3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</span><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang" class="header-anchor">#</a></h4><p>如果我们程序非常大，中断向量入口代码的地址可能会大于sram的容量4k，比如do_und和do_swi，那么这个时候就需要用绝对跳转。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">    b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br></pre></td></tr></table></figure>

<p>将上面的相对跳转换成如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  </span><br><span class="line">	ldr pc, und_addr </span><br><span class="line">    ldr pc, swi_addr</span><br><span class="line">    ...</span><br><span class="line">    ... </span><br><span class="line">und_addr:</span><br><span class="line">	.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">    .word do_swi</span><br></pre></td></tr></table></figure>

<p>这样我们的do_und， do_swi就可放在4k之外的地方, 放到sdram。</p>
<h4><span id="3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</span><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing" class="header-anchor">#</a></h4><p>我们现在不断增加的程序代码量，那么有可能在 <code>ldr pc, =main</code> 这条指令执行之前程序就已经超过4k。那么我们当从nand启动的时候，还没执行到ldr pc, &#x3D;main这句来，就无法取指令执行了。nor同理超过2M也就无法取指令执行了。 所以我们干脆重定位完代码后就直接跳转到sdram上去执行,代码简要概述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位*/</span></span><br><span class="line">ldr pc, =sdram</span><br><span class="line">sdram：</span><br><span class="line">   ...</span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<p>我们再来分析下整个程序执行过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/14.jpg"></p>
<pre><code>1.一上电，cpu从0地址执行，执行b reset（进行初始化硬件）
2.重定位程序
3.跳转到sdram去继续执行
4.执行到 deadc0de,发生未定义指令异常
5.跳转到异常向量表的0x4地址去执行
6.跳转到sdram上执行异常处理函数（do_und）
7.异常返回，继续执行
</code></pre>
<h2><span id="3-2-swi-ruan-zhong-duan">3.2 swi-软中断</span><a href="#3-2-swi-ruan-zhong-duan" class="header-anchor">#</a></h2><p>arm有7中工作模式，除了usr模式，其他6种都是特权模式。</p>
<p>我们知道usr模式无法修改CPSR直接进入其他特权模式，但linux应用程序一般运行在usr模式，既然usr模式权限非常低，是无法直接访问硬件寄存器的，那么它是如何访问硬件的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux应用程序是通过系统调用，从而进入内核态，运行驱动程序来访问的硬件，那么系统调用又是如何实现的呢，就是通过软中断swi指令来进入svc模式，进入到svc模式后当然就能访问硬件啦。</span><br></pre></td></tr></table></figure>

<p>所以我们的应用程序在usr模式想访问硬件，必须切换模式:</p>
<p>有以下两种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 发生异常或中断(被动的)</span><br><span class="line"><span class="number">2.</span> swi + 某个值(主动的)</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</span><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi" class="header-anchor">#</a></h3><p>s3c2440 一上电会跳到0地址（reset复位）执行代码，此时CPU处于svc模式，2440异常向量表如下图所示:<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/15.png"></p>
<p>为了验证usr模式能够主动的通过swi软中断指令来进入svc模式, 我们先将模式切换到usr模式，那么这个时候就不能访问硬件了，也不能直接修改cpsr直接进入其他模式。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/16.png"></p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/17.png"></p>
<p>从上图我们设置CPSR让M4-M0处在10000，这样就进入了usr模式。修改start.s如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  </span><br><span class="line">		ldr pc, und_addr </span><br><span class="line">		ldr pc, swi_addr</span><br><span class="line">		...</span><br><span class="line">	und_addr:</span><br><span class="line">		.word do_und</span><br><span class="line">	swi_addr:</span><br><span class="line">		.word do_swi</span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位</span></span><br><span class="line"><span class="comment">	bl uart0_init</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*先进入usr模式*/</span></span><br><span class="line">	mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line">	<span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">	msr cpsr, r0	 <span class="comment">/* 写入cpsr */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">	swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>那么当执行到swi 0x123，就会触发SWI异常, 进入0x8的向量去执行，调用do_swi，我们参考do_und实现我们的软中断服务程序do_swi。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_swi:</span><br><span class="line">	<span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment">	 * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment">	 * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment">	 * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment">	 * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理swi异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">		b reset  </span><br><span class="line">		ldr pc, und_addr </span><br><span class="line">		ldr pc, swi_addr</span><br><span class="line">		...</span><br><span class="line">	und_addr:</span><br><span class="line">		.word do_und</span><br><span class="line">	swi_addr:</span><br><span class="line">		.word do_swi</span><br><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">bl printException</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line"></span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位</span></span><br><span class="line"><span class="comment">	bl uart0_init</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*先进入usr模式*/</span></span><br><span class="line">	mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line">	<span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">	msr cpsr, r0	 <span class="comment">/* 写入cpsr */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">	swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>do_swi中调用printException，打印出了软中断异常的字符串和CPSR对应的svc模式。</p>
<h4><span id="3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</span><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao" class="header-anchor">#</a></h4><p>我们要读出swi 0x123指令，我们知道当执行完swi 0x123指令以后，会发生swi异常，那么lr_svc &#x3D; PC + offset。从下图看出offset是4：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/18.png"></p>
<p>修改中断服务函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;</span><br></pre></td></tr></table></figure>

<p>我们要把lr拿出来保存,因为bl printException会破坏lr，那么把lr保存在哪个个寄存器比较好呢？</p>
<p>我们知道当调用<code>bl printException</code>可能会修改某些寄存器，但是又会恢复这些寄存器，那么得知道它会保护哪些些寄存器。<br>来看下ATPCS规则：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/19.png" alt="img"></p>
<p>在子程序中,使用R4~R11来保存局部变量,子程序进入时必须保存这些寄存器的值,在返回前必须恢复这些寄存器的值。所以对于 r4 ~ r11在C函数里会保存这几个寄存器，执行完C函数再把它释放掉并且恢复原来的值。我们把lr 保存在r4寄存器里，r4寄存器不会被C语言破坏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov r4, lr</span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string</span><br><span class="line">bl printException</span><br></pre></td></tr></table></figure>

<p>当执行完<code>swi 0x123</code>指令后，会发生swi异常，swi异常模式里的lr寄存器会保存下一条指令的地址（即’ldr pc, &#x3D;main’），我们把lr寄存器的地址减去4就是<code>swi 0x123</code>这条指令的地址。</p>
<p>把r4的寄存器赋给r0让后打印我们得写出打印函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    mov r0, r4</span><br><span class="line"></span><br><span class="line">    sub r0, r4, #<span class="number">4</span>	<span class="comment">//得到swi指令的地址</span></span><br><span class="line">    bl printSWIVal</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>在uart.c添加printSWIVal打印函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printSWIVal</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSWI)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;SWI val = &quot;</span>);</span><br><span class="line">	printHEx(*pSWI &amp; ~<span class="number">0xff000000</span>); <span class="comment">//高8位忽略掉  </span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</span><a href="#3-3-irq-wai-bu-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</span><a href="#3-3-1-yin-ru-wai-bu-zhong-duan" class="header-anchor">#</a></h3><p>我们想实现一个按键点灯程序，我们知道有以下两种方案：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>轮询方案:轮询检测按键的电平状态，当检测到被按下后，对应的gpio会拉低，点亮对应的led;(略)</span><br><span class="line"><span class="number">2.</span>中断方案:将按键配置成外部中断源，当有按键按下，触发中断，在中断服务程序（isr）中去完成点灯。</span><br></pre></td></tr></table></figure>

<p>我们用按键作为外部中断源，我们把按键对应的gpio配置成中断引脚，当按键按下，相应的gpio产生了电平跳变，就会触发外部中断。</p>
<h3><span id="3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</span><a href="#3-3-2-wai-bu-zhong-duan-shi-li" class="header-anchor">#</a></h3><p>我们想达到按下按键灯亮, 松开按键灯灭这种效果（配成双边沿触发，按下的时候产生下降沿中断，进行点亮，松开产生上升沿中断，进行熄灭）。当然也可做成按一下点亮，再按一下熄灭的效果（设成单边沿触发，每来一次中断，对led电平进行一次取反）。<br>原理图如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/20.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/21.png"></p>
<p>从按键的原理图中得知，当按键没有按下时，接上拉电阻，按键为高电平状态。当按键按下时，电位被拉低，按键处于低电平状态。s2-s5分别对应GPF0，GPF2，GPG3，GPG11; D10-D12这3盏led所对应的gpio分别是GPF4，GPF5，GPF6。</p>
<p>那么我们让s2,s3,s4分别控制D10,D11,D12；s5对D10-D12同时控制（按下s5同时点亮3个led）。</p>
<h4><span id="3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</span><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan" class="header-anchor">#</a></h4><p>配置D10-D12的gpio为输出模式，s2-s4的gpio为外部中断模式。</p>
<p>打开芯片手册找到第九章 IO ports，找到对应的gpio控制寄存器，将对应的gpio配置成中断模式。</p>
<ol>
<li>配置GPF GPIO为中断引脚：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/22.png"><br>同理GPG的寄存器类似。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">4</span>));	<span class="comment">//先把eint0和eint2这两个引脚清零</span></span><br><span class="line">GPFCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">4</span>));   <span class="comment">//S2,S3被配置为中断引脚</span></span><br><span class="line"></span><br><span class="line">GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">22</span>));</span><br><span class="line">GPGCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">22</span>));   <span class="comment">//S4,S5被配置为中断引脚</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置中断触发方式:</li>
</ol>
<p>当电平从高变低时，此时表示按键按下，当电平由低变高，表示松开按键。不妨设置中断方式为双边沿触发，按下按键，触发下降沿中断，中断服务程序就可以去点亮led，反之，松开触发上升沿中断，就可以去熄灭led。<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/23.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/24.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/25.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTINT0 |= (<span class="number">7</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">7</span>&lt;&lt;<span class="number">8</span>);     <span class="comment">/* S2,S3 */</span></span><br><span class="line">EXTINT1 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S4 */</span></span><br><span class="line">EXTINT2 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S5 */</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置外部中断屏蔽寄存器EINTMASK：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/26.png"></li>
</ol>
<p>从上图我们知道外部中断0-3是直接连接到中断控制器，而外部中断4-7、外部中断8-23还要经过EINTMASK,那么我们需要配置EINTMASK来打开中断的通道：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/27.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EINTMASK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">19</span>));    <span class="comment">//打开外部中断通道</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>外部中断挂起寄存器EINTPEND:</li>
</ol>
<p>当一个外部中断（EINT4-EINT23）发生后，那么相应的位会被置1, 所以中断结束后需要清除对应位。这个寄存器可以用来区分外部中断4-23的哪一个中断源。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/28.png"></p>
<h4><span id="3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</span><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi" class="header-anchor">#</a></h4><p>我们先来看下中断控制器的总框图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/29.png"></p>
<p><strong>1. 首先是SRCPND:用来表示哪个中断源发出了中断请求。</strong></p>
<p>先看下中断源:<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/30.png"></p>
<p>从上图我们发现外部中断有24个外部中断，除了外部中断EINT，还有定时器中断，ADC中断，UART中断等…。</p>
<p>我们来认识下SRCPND寄存器：（用来表示哪个（哪些）中断源已产生中断请求，中断结束后要清中断）<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/31.png"></p>
<p>从上图中我们发现EINT4-7共用1bit，EINT8-23共用1bit，那么肯定有其他寄存器来区分它们，那就是EINTPEND寄存器（后面5会讲）。</p>
<p><strong>2. 然后到达INTMSK：（中断屏蔽寄存器）</strong></p>
<p>我们需要把INTMSK寄存器配置成非屏蔽状态，默认是中断源时屏蔽的，见下图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/32.png"></p>
<p><strong>3.INTMOD（中断模式，是fiq还是irq）</strong><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/33.png"></p>
<p><strong>4.Priroty:</strong></p>
<p><strong>5.INTPND:</strong><br>INTPND 用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p>
<p>中断发生后，SRCPND中会有bit置1，可能好几个（因为同时可能发生几个中断），这些中断会由优先级仲裁器选出一个最紧迫的，然后把INTPND中相应位置1。所以只有INTPND置1，CPU才会处理。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/34.png"></p>
<p>我们知道有可能同时出现多个中断请求，那么INTPND就挑选出当前优先级最高的、正在发生的中断。</p>
<p>当产生irq后，要去分辨是哪个中断源，根据不同的中断源去中断服务程序isr中做不同的事情，那么如何得知当前产生的中断是哪一个外部中断源产生的呢？那么就可以访问这个INTPND寄存器。</p>
<p>可是我们要去手工去解析INTPND里面的位，才能知道是哪个中断源产生了中断请求。那么有没有什么比较快捷的方式自动帮我们解析INTPND呢，直接返回中断号给我们？</p>
<p>当然有啦，有一个INTOFFSET寄存器的值就是代表哪个中断请求产生了，如果INTOFFSET&#x3D;0表示EINT0产生了中断请求，INTOFFSET&#x3D;2表示EINT2产生了中断请求。具体见下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/35.png"></p>
<p>我们从上图看到ENIT4-7共用一个offset， EINT8-23也共用一个offset，那么要通过访问EINTPEND寄存器来区分它们。</p>
<p>中断控制器设置代码入下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化中断控制器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1是屏蔽我们需要清零，外部中断0 外部中断2 外部中8_23里面还有外部中断11到19</span></span><br><span class="line">    INTMSK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>)); </span><br><span class="line">    <span class="comment">//INTMOD默认是irq，可以不设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</span><a href="#3-3-3-3-zhong-duan-zong-kai-guan" class="header-anchor">#</a></h4><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/36.png"></p>
<p>CPSR有I位，是irq的总开关，我们需要把CPSR寄存器 bit7给清零，这是中断的总开关，如果bit7设置为1，CPU无法响应任何中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 把bit7这一位清零 */</span></span><br><span class="line">bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">msr cpsr, r0</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</span><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>到这里中断前的初始化工作知识点就已经讲完了，当然要提前准备好led初始化工作（就是将led对应的gpio配置成输出模式，这个不讲解）。</p>
<p>那么中断产生后，我们之前讲过，会跳转到0x18异常向量，执行跳转指令<code>ldr pc, =_irq</code>，和之前的swi异常，und异常框架一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	</span><br><span class="line">	ldr pc, und_addr <span class="comment">/* vector 4 : und（绝对跳转） */</span></span><br><span class="line">	ldr pc, swi_addr <span class="comment">/* vector 8 : swi */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x0c : prefetch aboot */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x10 : data abort */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x14 : reserved */</span></span><br><span class="line">	ldr pc, irq_addr <span class="comment">/* vector 0x18 : irq */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x1c : fiq */</span></span><br><span class="line"></span><br><span class="line">und_addr:</span><br><span class="line">	.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">	.word do_swi</span><br><span class="line">irq_addr:</span><br><span class="line">	.word do_irq</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/*初始化时钟*/</span></span><br><span class="line">	<span class="comment">/*初始化sdram,设置栈*/</span></span><br><span class="line">	<span class="comment">/*代码重定位,清bss*/</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 把bit7这一位清零(打开中断总开关) */</span></span><br><span class="line">	bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">	msr cpsr, r0</span><br><span class="line"></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>1.我们在start.s中用汇编代码设置cpsr的I位，开启中断开关；</p>
<p>2.在main函数中初始化中断源key_eint_init，初始化中断控制器interrupt_init；</p>
<p>3.然后继续执行main主函数。</p>
<p>4.当中断产生，触发irq异常，进入0x18异常向量，执行do_irq。</p>
<p>do_irq实现如下（和do_und, do_swi类似）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_irq:</span><br><span class="line">	<span class="comment">/* 执行到这里之前: */</span></span><br><span class="line">	<span class="comment">/* 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址 */</span></span><br><span class="line">	<span class="comment">/* 2. SPSR_irq保存有被中断模式的CPSR */</span></span><br><span class="line">	<span class="comment">/* 3. CPSR中的M4-M0被设置为10010, 进入到irq模式 */</span></span><br><span class="line">	<span class="comment">/* 4. 跳到0x18的地方执行程序 */</span> </span><br><span class="line">	<span class="comment">/* sp_irq未设置, 先设置它 */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33d00000</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr-4是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	sub lr, lr, #<span class="number">4</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line">		</span><br><span class="line">	<span class="comment">/* 处理irq异常 */</span></span><br><span class="line">	bl handle_irq_c</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr_irq的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure>


<p>handle_irq_c函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">key_eint_irq</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val = EINTPEND;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val1 = GPFDAT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val2 = GPGDAT;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (irq == <span class="number">0</span>) <span class="comment">/* eint0 : s2 控制 D12 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) <span class="comment">/* s2 --&gt; gpf6 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 松开 */</span></span><br><span class="line">			GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 按下 */</span></span><br><span class="line">			GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">2</span>) <span class="comment">/* eint2 : s3 控制 D11 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) <span class="comment">/* s3 --&gt; gpf5 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 松开 */</span></span><br><span class="line">			GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 按下 */</span></span><br><span class="line">			GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">5</span>) <span class="comment">/* eint8_23, eint11--s4 控制 D10, eint19---s5 控制所有LED */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>)) <span class="comment">/* eint11 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) <span class="comment">/* s4 --&gt; gpf4 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 松开 */</span></span><br><span class="line">				GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 按下 */</span></span><br><span class="line">				GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">19</span>)) <span class="comment">/* eint19 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 松开 */</span></span><br><span class="line">				<span class="comment">/* 熄灭所有LED */</span></span><br><span class="line">				GPFDAT |= ((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 按下: 点亮所有LED */</span></span><br><span class="line">				GPFDAT &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	EINTPEND = val; 	<span class="comment">/* 清中断 : 源头*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*INTOFFSET中哪一位被设置成1，就表示哪一个 中断源*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 分辨中断源 */</span></span><br><span class="line">	<span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">	SRCPND = (<span class="number">1</span>&lt;&lt;bit);<span class="comment">/*清EINT0，EINT2，EINT5*/</span></span><br><span class="line">	INTPND = (<span class="number">1</span>&lt;&lt;bit);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</span><a href="#3-4-irq-ding-shi-qi-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</span><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi" class="header-anchor">#</a></h3><p>s3c2440共有2种定时器：</p>
<pre><code>1.Watchdog看门狗定时器
2.PWM脉冲可调制定时器
</code></pre>
<p>下面详细介绍2种定时器的原理，来了解定时器是如何产生定时器中断的。</p>
<h4><span id="3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</span><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>Watchdog定时器的原理很简单，寄存器很少，框图如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/37.png"></p>
<ol>
<li>定时器，定时器那肯定是需要用到时钟的，从框图中可以看到Watchdog定时器采用的时钟源是PCLK，从<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中也可以体现出来，接的是APB总线。</li>
<li>然后到达一个8 bit的分频器，可以通过配置WTCON[15:8]来设置分频器的预设值。</li>
<li>再设置WTCON[4:3]来设置除数因子来进一步分频。<br>所以最终的Watchdog定时器的时钟周期<code>t_watchdog = 1/[ PCLK / (Prescaler value + 1) / Division_factor ]</code></li>
<li>到达WTCNT：看门狗递减寄存器。WTCNT里的数据就开始在输入时钟频率下递减。WTCNT的值由WTDAT寄存器提供。</li>
<li>WTDAT：WTDAT寄存器用于指定计数器的初始值，也就是它的超时时间，<strong>系统上电之后硬件自动的将0x8000的初始值载入到WTCNT里，在发生了第一次超时操作时，WTDAT的值才会载入到WTCNT寄存器</strong>。</li>
</ol>
<p>当WTCNT的值减到0时，就会触发看门狗定时器中断，进而产生复位。中断框图中可以看到可以设置WTCON[2]来设置是否产生中断信号，可以设置WTCON[0]来设置是否产生复位信号。</p>
<h5><span id="3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</span><a href="#3-4-1-1-1-wtcon-ji-cun-qi" class="header-anchor">#</a></h5><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/38.png"></p>
<h5><span id="3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</span><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi" class="header-anchor">#</a></h5><p> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/39.png"></p>
<h3><span id="3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</span><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li" class="header-anchor">#</a></h3><h4><span id="3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</span><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>在之前的章节中，我们在start.s启动代码中首先做的就是关闭看门狗，把WTCON[5]&#x3D;0，也就是把Watchdog timer给disable。那么Watchdog Timer就不再工作了，这样做是为了防止在启动代码进行硬件初始化的时候出现超时，发出复位信号又去重启硬件，这样就陷入了不断重启过程中。因为s3c2440芯片默认WTCON[5]是1，也就是Watchdog Timer默认是处于使能状态。</p>
<p>从<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中配置了PCLK&#x3D;50M Hz, 那么让WTDAT取默认值0x8000，那么根据公式算出从开机到触发复位重启的时间：</p>
<p><code>t=WTDAT*( 1/[ PCLK / (Prescaler value + 1) / Division_factor ])</code>。</p>
<p>根据WTCON寄存器配置Prescaler value&#x3D;255，配置Division_factor&#x3D;128，这样最终定时器分得的频率更低，那么减数器递减的更慢，也就代表从开机到触发复位重启的时间:</p>
<p><code>T=0x8000 * (1/[50*10^6/(255+1)/128]) = 21474836.48us = 21s</code>。</p>
<p>之前的start.s中把看门狗已经关闭了，那么我们在跳转到main函数中调用wtd_timer_init函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//使能定时器，开启reset复位</span></span><br><span class="line">	WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看测试结果：<br>果然初始化wtd_timer_init后，过21s后板子重启了，说明我们watchdog定时器功能已经OK了。</p>
<p>现在修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//使能定时器，开启watchdog定时器中断</span></span><br><span class="line">	WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">	WTDAT = <span class="number">0x4000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到我们现在定时器的初值被修改成了0x4000, 相对于默认值少了一半，那么触发wtd_timer中断的时间应该减半，也就是约等于10s。</p>
<h4><span id="3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</span><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>那么需要写一个wtd_timer的中断服务程序，同样需要先在do_irq中去保护现场、调用handle_irq_c、恢复现场。查看INTOFFSET寄存器：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/40.png"></p>
<p>得知：<br>handle_irq_c代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        这里还需区分子中断源</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看芯片手册查找“INT_WDT_AC97”如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/41.png"></p>
<p>从上图可以看到SRCPND和SUBSRCPND的映射关系。<br>SUBSRCPND寄存器如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/42.png"></p>
<p>我们可以读取SUBSRCPND来区分到底是哪一个子中断源产生了中断，当SUBSRCPND中哪一位被置1，表示对应的中断源发生了中断。</p>
<p>前面做完wtd_timer_init，还要进行中断控制器的初始化，查看INTMSK寄存器如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/43.png"></p>
<p>查看INTSUBMSK寄存器如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/44.png"></p>
<p>在interrupt_init中添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">9</span>);<span class="comment">//不屏蔽INT_WDT_AC97</span></span><br><span class="line">INTSUBMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);<span class="comment">//不屏蔽INT_AC97</span></span><br></pre></td></tr></table></figure>

<p>修改handle_irq_c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bit == <span class="number">9</span>)<span class="comment">//INTOFFSET==9</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SUBSRCPND &amp; <span class="number">1</span>&lt;&lt;<span class="number">14</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;watchdog timer interrupt occured.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3><span id="3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</span><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi" class="header-anchor">#</a></h3><p>PWM（Pulse Width Modulation），字面上是脉冲可调制的意思，就是可以调节占空比。</p>
<p>s3c2440有5个定时器，其中定时器0、1、2和3具有脉宽调制（PWM）功能。定时器4是一个无输出引脚的内部定时器。</p>
<p>先认识下s3c2440的pwm timer的框架：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/45.jpg"></p>
<pre><code>1.时钟源为PCLK
2.pclk经过8 bit的预分频系数（Prescaler），和4 bit的时钟除数因子（clock divider）,进行分频
3.经过MUX选择器选择用哪个定时器（5选1）
4.设置TCMPB0和TCNTB0和TCONn寄存器
</code></pre>
<h4><span id="3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</span><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>pwm定时器的逻辑控制单元结构如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/46.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> TCMPBn和TCNTBn寄存器中的值分别加载到TCMPn和TCNTn寄存器</span><br><span class="line"><span class="number">2</span> 每来一个clk(时钟)这个TCNTn减去<span class="number">1</span></span><br><span class="line"><span class="number">3</span> 当TCNTn == TCMPn时，可以产生中断，pwm输出引脚反转</span><br><span class="line"><span class="number">4</span> TCNTn继续减<span class="number">1</span>，当TCNTn == <span class="number">0</span>时，又产生一次中断，pwm引脚再次反转</span><br><span class="line"><span class="number">5</span> 重复<span class="number">1</span><span class="number">-4</span>过程</span><br></pre></td></tr></table></figure>

<p>设置TCNTBn寄存器来设置加载初值，设置后TCNTn中的值就会按照时钟周期递减。<br>设置TCMPBn寄存器来设置占空比，从而控制高低电平持续时间的比例。</p>
<h4><span id="3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</span><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian" class="header-anchor">#</a></h4><p>要开始一个PWM定时器功能的步骤如下：(假设使用的是timer0)</p>
<h5><span id="3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</span><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi" class="header-anchor">#</a></h5><p>定义一个pwm_timer_init()函数。</p>
<ol>
<li><p>设置时钟：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/47.png"><br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/48.png"></p>
<p> 分别设置定时器0的预分频器值(prescaler)和时钟分频值(clock divider)，从而控制TCNT0减数器的频率。</p>
</li>
</ol>
<p>根据公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwm Timer clk = PCLK / &#123;(预分频数)prescaler value+<span class="number">1</span>&#125; / &#123;divider value(<span class="number">5.1</span>MUX值)&#125; </span><br></pre></td></tr></table></figure>
<p>PCLK是50M，设置prescaler value&#x3D;99， divider value&#x3D;16,所以pwm Timer clk&#x3D; 50000000&#x2F;(99+1)&#x2F;16 &#x3D; 31250 Hz</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCFG0 = <span class="number">99</span>; </span><br><span class="line">TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">TCFG1 |= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置初值：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置比较缓存寄存器TCMPB0和计数缓存寄存器TCNTB0的初始值*/</span></span><br><span class="line">TCNTB0 = <span class="number">31250</span> &lt;&lt; <span class="number">1</span>;  <span class="comment">/* 2s中断一次 */</span></span><br><span class="line">TCMPB0 = <span class="number">31250</span> &gt;&gt; <span class="number">1</span>;  <span class="comment">/* 设置占空比*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>开启定时器0的手动更新TCNTB0&amp;TCMPB0功能(设置TCON的第1位)：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/49.png"></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开始需要手工更新,这样才能将TCNTB0&amp;TCMPB0同步到TCNT0&amp;TCMP0</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开启定时器0的自动加载：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开启自动加载要先清除手动更新</span></span><br><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动定时器0(设置TCON的第0位)；</li>
</ol>
<p>	</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>初始化中断控制器:</li>
</ol>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/50.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/51.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">interrupt_init()&#123;</span><br><span class="line">	...</span><br><span class="line">	INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);  <span class="comment">/* enable timer0 int */</span>		</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完这些初始化工作，就可以产生定时器中断了,同样我们需要在handle_irq_c函数中区分中断源：</p>
<h5><span id="3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</span><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h5><p>我们可以通过查看TCNTO0寄存器来查看当前TCNT的值。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/52.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>) <span class="comment">//INT_WDT_AC97</span></span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">10</span>) <span class="comment">//timer0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;timer0 interrupt occured.\n&quot;</span>);</span><br><span class="line">		print_hex(TCNTO0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</span><a href="#3-5-irq-de-you-hua-gai-jin" class="header-anchor">#</a></h2><p>我们对比irq外部中断， irq定时器中断，发现每增加一个中断源，又要去修改中断控制器的初始化interrupt_init()和handle_irq_c(),要在handle_irq_c()中去添加分支去执行不同的中断服务。</p>
<p>那么我们现在不去改变interrupt文件，在timer.c、key_eint.c中去注册自己的中断服务程序即可，这里我们使用<strong>函数指针数组</strong>，建立一个中断号和中断服务程序的映射关系。这样就可以根据中断号来执行对应的中断服务程序，即在handle_irq_c()中去回调不同类型的中断源注册下来的函数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义函数指针数组 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUM	32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*irq_func)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">irq_func irq_array[IRQ_NUM];</span><br></pre></td></tr></table></figure>

<p>然后实现一个register_irq(…)如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">register_irq</span> <span class="params">(<span class="type">int</span> irq, irq_func fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	irq_array[irq] = fp;</span><br><span class="line">	INTMASK &amp;= ~(<span class="number">1</span> &lt;&lt; irq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handle_irq_c()修改实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 分辨中断源 */</span></span><br><span class="line">	<span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">	irq_array[bit](bit); <span class="comment">//根据中断号回调不同的中断处理函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 清中断 */</span></span><br><span class="line">	SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">	INTPND = (<span class="number">1</span>&lt;&lt;bit);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子我们的irq中断就被统一管理了起来，只要在其他各中断模块初始化的时候调用register_irq(…)注册即可。</p>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>中断体系</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-LDC</title>
    <url>/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-lcd-ying-jian-yuan-li">1 LCD硬件原理</a><ul>
<li><a href="#1-1-lcd-xiang-su-sao-miao">1.1 LCD像素扫描</a></li>
<li><a href="#1-2-lcd-ying-jian-yuan-li-tu">1.2 LCD硬件原理图</a><ul>
<li><a href="#1-2-1-rgb-lcd-mo-shi">1.2.1 RGB LCD模式</a></li>
<li><a href="#1-2-2-lcd-shi-xu-fen-xi">1.2.2 LCD时序分析</a><ul>
<li><a href="#1-2-2-1-xing-shi-xu">1.2.2.1 行时序</a></li>
<li><a href="#1-2-2-2-zheng-shi-xu">1.2.2.2 帧时序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-2-framebuffer-he-bpp-gai-nian">1.2 FrameBuffer和BPP概念</a></li>
<li><a href="#1-3-lcd-chong-lei">1.3 LCD种类</a></li>
<li><a href="#1-4-lcd-fang-wen-kuang-jia">1.4 LCD访问框架</a></li>
</ul>
</li>
<li><a href="#2-lcd-kong-zhi-qi">2 LCD控制器</a><ul>
<li><a href="#2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu">2.1 s3c2440 LCD控制器框图</a></li>
<li><a href="#2-2-ji-cun-qi-jie-shao">2.2 寄存器介绍</a><ul>
<li><a href="#2-2-1-shu-ju-cun-chu-ge-shi">2.2.1 数据存储格式</a><ul>
<li><a href="#2-2-1-1-bswp-hwswp-ji-cun-qi">2.2.1.1 BSWP&#x2F;HWSWP寄存器</a><ul>
<li><a href="#2-2-2-1-1-24bpp">2.2.2.1.1 24BPP</a></li>
<li><a href="#2-2-2-1-2-16bpp">2.2.2.1.2 16BPP</a></li>
<li><a href="#2-2-2-1-3-8bpp">2.2.2.1.3 8BPP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-2-diao-se-ban-ji-cun-qi">2.2.2 调色板寄存器</a><ul>
<li><a href="#2-2-2-1-diao-se-ban-ge-shi">2.2.2.1 调色板格式</a></li>
</ul>
</li>
<li><a href="#2-2-3-lcd-kong-zhi-ji-cun-qi-1">2.2.3 LCD控制寄存器1</a></li>
<li><a href="#2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu">2.2.4 LCD控制寄存器2(垂直方向参数)</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu">2.2.5 LCD控制寄存器3(水平方向参数)</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-4">2.2.5 LCD控制寄存器4</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-5">2.2.5 LCD控制寄存器5</a></li>
<li><a href="#2-2-6-lcdsaddr1-ji-cun-qi">2.2.6 LCDSADDR1寄存器</a></li>
<li><a href="#2-2-7-lcdsaddr2-ji-cun-qi">2.2.7 LCDSADDR2寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-lcd-luo-ji-bian-cheng">3 LCD裸机编程</a><ul>
<li><a href="#3-1-ruan-jian-kuang-jia">3.1 软件框架</a></li>
<li><a href="#3-2-shu-ju-jie-gou-ding-yi">3.2 数据结构定义</a><ul>
<li><a href="#3-2-1-lcd-she-bei-jie-gou-ti">3.2.1 LCD设备结构体</a></li>
</ul>
</li>
<li><a href="#3-3-cao-zuo-fang-fa-ding-yi">3.3 操作方法定义</a><ul>
<li><a href="#3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c">3.3.1 LCD操作方法-lcd_controller.c</a></li>
<li><a href="#3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c">3.3.2 具体型号LCD管理-ldc.c</a></li>
</ul>
</li>
<li><a href="#3-4-lcd-chu-shi-hua">3.4 LCD初始化</a><ul>
<li><a href="#3-4-1-chu-shi-hua-lcd-kong-zhi-qi">3.4.1 初始化lcd控制器</a><ul>
<li><a href="#3-4-1-1-chu-shi-hua-yin-jiao">3.4.1.1 初始化引脚</a><ul>
<li><a href="#3-4-1-1-1-bei-guang-yin-jiao">3.4.1.1.1 背光引脚</a></li>
<li><a href="#3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao">3.4.1.1.2 控制引脚和数据引脚</a></li>
<li><a href="#3-4-1-1-3-pwren-yin-jiao">3.4.1.1.3 PWREN引脚</a></li>
</ul>
</li>
<li><a href="#3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi">3.4.1.2 初始化LCD控制寄存器、地址寄存器</a></li>
<li><a href="#3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao">3.4.1.3 使能、禁用背光引脚</a></li>
</ul>
</li>
<li><a href="#3-4-2-chu-shi-hua-lcd-she-bei">3.4.2 初始化lcd设备</a></li>
</ul>
</li>
<li><a href="#3-5-shi-xian-xian-shi-gong-neng">3.5 实现显示功能</a><ul>
<li><a href="#3-5-1-lcd-xian-shi-man-ping-hong-se">3.5.1 LCD显示满屏红色</a><ul>
<li><a href="#3-5-1-1-chu-shi-hua-lcd">3.5.1.1 初始化LCD</a></li>
<li><a href="#3-5-1-2-shi-neng-lcd">3.5.1.2 使能LCD</a></li>
<li><a href="#3-5-1-3-huo-qu-lcd-can-shu">3.5.1.3 获取LCD参数</a></li>
<li><a href="#3-5-1-4-wang-framebuffer-zhong-xie-shu-ju">3.5.1.4 往framebuffer中写数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu">3.6 实现绘制点线圆函数</a><ul>
<li><a href="#3-6-1-hua-dian">3.6.1 画点</a></li>
<li><a href="#3-6-2-32bppto16bpp-han-shu">3.6.2 32bppto16bpp函数</a></li>
<li><a href="#3-6-3-hua-xian-hua-yuan">3.6.3 画线画圆</a></li>
<li><a href="#3-6-4-ce-shi">3.6.4 测试</a></li>
</ul>
</li>
<li><a href="#3-7-zi-fu-ku-yi-zhi">3.7 字符库移植</a><ul>
<li><a href="#3-7-1-xian-shi-zi-fu-chuan">3.7.1 显示字符串</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-lcd-ying-jian-yuan-li">1 LCD硬件原理</span><a href="#1-lcd-ying-jian-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-lcd-xiang-su-sao-miao">1.1 LCD像素扫描</span><a href="#1-1-lcd-xiang-su-sao-miao" class="header-anchor">#</a></h2><p>里面的每个点就是一个像素点。</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/1.jpg"></p>
<p>它里面有一个电子枪，一边移动，一边发出各种颜色的光。用动态图表示如下：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/2.jpg"></p>
<ol>
<li><p>电子枪是如何移动的？</p>
<pre><code> 有一条CLK时钟线与LCD相连，每发出一次CLK(高低电平)，电子枪就移动一个像素。
</code></pre>
</li>
<li><p>颜色如何确定？</p>
<pre><code> 由连接LCD的三组线RGB三原色混合而成：R(Red)、G(Green)、B(Blue)确定。
</code></pre>
</li>
<li><p>电子枪如何得知应跳到下一行？</p>
<pre><code> 有一条HSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到下一行，该信号叫做行同步信号。
</code></pre>
</li>
<li><p>电子枪如何得知应跳到原点？</p>
<pre><code> 有一条VSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到原点，该信号叫做帧同步信号。
</code></pre>
</li>
<li><p>RGB线上的数据从何而来？</p>
<pre><code> 内存里面划分一块显存(FrameBuffer)，里面存放了要显示的数据，LCD控制器从里面将数据读出来，通过RGB三组线传给电子枪，电子枪再依次打到显示屏上。
</code></pre>
</li>
<li><p>前面的信号由谁发给LCD？</p>
<pre><code> 有S3C2440里面的LCD控制器来控制发出信号。
</code></pre>
</li>
</ol>
<h2><span id="1-2-lcd-ying-jian-yuan-li-tu">1.2 LCD硬件原理图</span><a href="#1-2-lcd-ying-jian-yuan-li-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/3.png"></p>
<p>①是时钟信号，每来一个CLK，电子枪就移动一个像素；</p>
<p>②是用来传输颜色数据；</p>
<p>③是垂直方向同步信号，FRAME(帧)；</p>
<p>④是水平方向同步信号，LINE(行)；</p>
<p>⑤LED+、LED-背光灯电源。</p>
<p>⑥TSYP、TSXP、TSYM、TSXM是触摸屏信号，暂时不用。</p>
<p>⑦VM接DE是数据使能</p>
<h3><span id="1-2-1-rgb-lcd-mo-shi">1.2.1 RGB LCD模式</span><a href="#1-2-1-rgb-lcd-mo-shi" class="header-anchor">#</a></h3><p>HV模式: HS与VS来控制刷新。比如对于分辨率为1024x600RGB的LCD，LCD控制器发出HS信号后，就会发出1024个DCLK，在每个DCLK上传输像素数据；当发出600个HS信号后，就会发出一个VS信号<br>DE模式：DE信号来控制刷新，比如对于分辨率为1024x600RGB的LCD，LCD控制器发出DE信号后，就要发出1024个DCLK，在每个DCLK上传输像素数据；当发出600个DE信号，刷新完一帧数据</p>
<h3><span id="1-2-2-lcd-shi-xu-fen-xi">1.2.2 LCD时序分析</span><a href="#1-2-2-lcd-shi-xu-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/4.png" alt="image"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/5.png"></p>
<p>①从一行最开始的像素开始分析，如上图标号①，DE信号开始有效，电子枪每次在CLK下降沿时从数据线Dn0-Dn7上得到数据（Dn0-Dn7上的数据来源于FrameBuffer，后面会讲），然后发射到显示屏上，然后移动到下一个位置。从<em>1 st pixel</em>到<em>last pixel</em>，就这样从一行的最左边，一直移动到一行的最右边，完成了一行的显示，假设一行有x个pixel。可以看到每发送一个pixel，需要1个时钟周期（1&#x2F;tc）。</p>
<p>②当打完一行的最后一个数据后，会收到Hsync行同步信号，那么电子枪会跳到下一行，如上图标号②，根据时序图，一个Hsync周期，也就是一行数据刷新时间th, 可以大致分为五部分组成：thp、thb、1&#x2F;tc、thd、thf。<br>    thp:称为脉冲宽度，这个时间不能太短，太短电子枪可能识别不到。<br>    thb:电子枪正确识别到thp后，会从最右端移动最左端，这个移动的时间就是thb，称之为移动时间。<br>    thd：表示显示一行数据的时间<br>    thf：表示显示完最右像素，再过多久Hsync才来。</p>
<p>③同理，当电子枪移动到最后一行时，就会发送一个Vsync垂直同步信号，让电子枪移动回最上边。如上图标号③，根据时序图，一个Vsync周期，也就是一帧数据刷新时间tv, 可以大致分为：tvp、tvb、tvd、tvf。<br>    tvp:Vsync信号的脉冲宽度<br>    tvb：电子枪从最后一行移动到第一行的移动时间<br>    tvf：表示显示完最后一行像素，再过多久Vsync才来。</p>
<p> 假设一共有y行，那么LCD的分辨率就是x*y。</p>
<p>下面是LCD显示配置示意图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/6.png"></p>
<p>从左往右看，可以看到Total width &#x3D; HSYNC width + HBP + Active width + HFP。当发出一个HSYNC信号后，电子枪就会从最右边花费HBP时长移动到最左边，等到了最右边后，等待HFP时长后下一轮HSYNC信号才会发出。因此，HBP和HFP分别决定了左边和右边的黑框。</p>
<pre><code> HSYNC是行同步信号的脉冲宽度（低电平有效）
 HBP表示屏幕左边黑框的宽度（电子枪要花多久才能从最右边移动到最左边）行后肩
 Active width表示有效数据宽度
 HFP表示屏幕右边黑框的宽度（再过多久HSYNC才会发出）行前肩
</code></pre>
<p>同理从上往下看，Total height &#x3D; Vsync width + VBP + Active width + VFP。当发出一个VSYNC信号后，电子枪就会从最下边花费VBP时长移动到最上边，等到了最下边后，等待VFP时长后下一轮VSYNC信号才会发出。因此，VBP和VFP分别决定了上边和下边的黑框。 中间灰色区域才是有效显示区域。</p>
<pre><code>VSYNC是帧同步信号的脉冲宽度（低电平有效）
VBP表示屏幕上边黑框的宽度（电子枪要花多久才能从最后一行移动到最上面一行）帧后肩
Active height表示有效数据高度
VFP表示屏幕下边黑框的宽度(再过多久VSYNC才会发出) 帧前肩
</code></pre>
<p>总结：</p>
<h4><span id="1-2-2-1-xing-shi-xu">1.2.2.1 行时序</span><a href="#1-2-2-1-xing-shi-xu" class="header-anchor">#</a></h4><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/7.png" alt="image"></p>
<pre><code>HSPW：有些地方也叫做 thp，是 HSYNC 信号宽度，也就是 HSYNC 信号持续时间。HSYNC信号不是一个脉冲，而是需要持续一段时间才是有效的，单位为 CLK。
HOZVAL：有些地方叫做 thd，显示一行数据所需的时间，假如屏幕分辨率为 1024*600，那么 HOZVAL 就是 1024，单位为 CLK。
</code></pre>
<h4><span id="1-2-2-2-zheng-shi-xu">1.2.2.2 帧时序</span><a href="#1-2-2-2-zheng-shi-xu" class="header-anchor">#</a></h4><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/8.png" alt="image"></p>
<pre><code>VSPW：有些地方也叫做 tvp，是 VSYNC 信号宽度，也就是 VSYNC 信号持续时间，单位为 1 行的时间
LINE：有些地方叫做 tvd，显示一帧有效数据所需的时间，假如屏幕分辨率为 1024*600，那么 LINE 就是 600 行的时间。
</code></pre>
<h2><span id="1-2-framebuffer-he-bpp-gai-nian">1.2 FrameBuffer和BPP概念</span><a href="#1-2-framebuffer-he-bpp-gai-nian" class="header-anchor">#</a></h2><p>FrameBuffer是在内存中的一段区域，这段区域专门用来存放颜色数据的。如下图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/9.png"></p>
<p>BPP(Bits Per Pixels)表示每个像素占据多少位。 前面的LCD引脚功能图里，有R0-R7、G0-G7、B0-B7，那么每个像素是占据3<em>8&#x3D;24位的，*<em>所以硬件上LCD的BPP是确定的.</em></em></p>
<p>那么在FrameBuffer中，每个像素在FrameBuffer中，占据多少位BPP(Bits Per Pixels)？</p>
<p>虽然LCD上的引脚是固定的，但我们使用的时候，可以根据实际情况进行取舍，查看我们的硬件原理图，发现我们的LCD硬件上只有R1-R5、G0-G5、B1-B5与SOC相连，5+6+5&#x3D;16BPP，所以每个像素就只占据16位数据。等效连接图如下：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/10.png"></p>
<h2><span id="1-3-lcd-chong-lei">1.3 LCD种类</span><a href="#1-3-lcd-chong-lei" class="header-anchor">#</a></h2><p>S3C2440芯片手册介绍了LCD控制器支持TFT和STN两种LCD，我们常用的都是TFT材质的，本开发板采用的就是一款TFT材质的LCD.</p>
<h2><span id="1-4-lcd-fang-wen-kuang-jia">1.4 LCD访问框架</span><a href="#1-4-lcd-fang-wen-kuang-jia" class="header-anchor">#</a></h2><p>如下图，LCD控制器从SDRAM中的FrameBuffer区域取出颜色数据，发送给电子枪，电子枪按照特定的时钟周期将颜色数据显示在LCD上。<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/11.png"></p>
<h1><span id="2-lcd-kong-zhi-qi">2 LCD控制器</span><a href="#2-lcd-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu">2.1 s3c2440 LCD控制器框图</span><a href="#2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/12.png"></p>
<p>S3C2440 LCD控制器用于传输视频数据并且生成必要的控制信号，如VFRAME，VLINE，VCLK，VM等。除了控制信号，S3C2440还有视频数据端口，即VD [23：0]。通过设置REGBANK(寄存器组)，LCDCDMA会自动(无需CPU参与)把内存上FrameBuffer里的数据，通过VIDPRCS发送到引脚VD[23:0]数据总线上，再配合VIDEOMUX引脚的控制信号，正确的显示出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">REGBANK：具有<span class="number">17</span>个可编程寄存器组和<span class="number">256</span>x16调色板存储器，用于配置LCD控制器。 </span><br><span class="line">TIMEGEN：产生控制信号，例如 VSYNC、HSYNC、VCLK等信号</span><br><span class="line">LCDCDMA：可以自动从FrameBuff中把数据copy出来。</span><br><span class="line">VIDPRCS：从LCDCDMA接收视频数据，将数据输出到VD[<span class="number">23</span>:<span class="number">0</span>]数据总线上。</span><br></pre></td></tr></table></figure>

<p>总结LCD控制器主要功能如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 取：从内存(FrameBuffer)取出某个像素的数据（之后需要把FrameBuffer地址、BPP、分辨率告诉LCD控制器）</span><br><span class="line"><span class="number">2.</span> 发：配合其它信号把FrameBuffer中的数据发给LCD；（那么需要设置LCD控制器时序、设置引脚极性）</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-ji-cun-qi-jie-shao">2.2 寄存器介绍</span><a href="#2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h2><h3><span id="2-2-1-shu-ju-cun-chu-ge-shi">2.2.1 数据存储格式</span><a href="#2-2-1-shu-ju-cun-chu-ge-shi" class="header-anchor">#</a></h3><p>可以配置寄存器的BSWP、HWSWP来设置Framebuff中的像素存储格式。</p>
<h4><span id="2-2-1-1-bswp-x2f-hwswp-ji-cun-qi">2.2.1.1 BSWP&#x2F;HWSWP寄存器</span><a href="#2-2-1-1-bswp-x2f-hwswp-ji-cun-qi" class="header-anchor">#</a></h4><h5><span id="2-2-2-1-1-24bpp">2.2.2.1.1 24BPP</span><a href="#2-2-2-1-1-24bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/13.png"></p>
<p>从图中可以看到24bpp的像素，在lcd控制器的VD[7:0]表示BLUE， VD[15:8]表示GREEN，VD[23:16]表示RED。在内存中的FrameBuffer中每一个像素占据4个字节，当BPP24BL&#x3D;0时，低24位为颜色数据，当BPP24BL&#x3D;1时，高24位为颜色数据。</p>
<h5><span id="2-2-2-1-2-16bpp">2.2.2.1.2 16BPP</span><a href="#2-2-2-1-2-16bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/14.png"></p>
<p>也可以看到16bpp的像素，在内存中的FrameBuffer中每一个像素占据2个字节，HWSWP用来设置像素数据的存放方式。</p>
<p>再看下LCD控制器的VD引脚输出情况，可以看到16bpp时分5:6:5和5：5：5：i两种数据格式。当5：6：5模式时，VD[7:3]表示BLUE， VD[15:10]表示Green数据，VD[23:19]表示RED。当5：5:5：i模式时，VD[7:3]表示BLUE， VD[15:11]表示Green，VD[23:19]表示RED。其中i表示透明度。</p>
<h5><span id="2-2-2-1-3-8bpp">2.2.2.1.3 8BPP</span><a href="#2-2-2-1-3-8bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/15.png"></p>
<h3><span id="2-2-2-diao-se-ban-ji-cun-qi">2.2.2 调色板寄存器</span><a href="#2-2-2-diao-se-ban-ji-cun-qi" class="header-anchor">#</a></h3><p>我们外接的LCD硬件上只有R1-R5、G0-G5、B1-B5与SOC相连，5+6+5&#x3D;16BPP，所以LCD上每个像素就只占据16位数据。那么当我们的Frame buffer中是8BPP颜色数据时，是如何把颜色数据填充到LCD上的呢？</p>
<p><code>用调色板</code></p>
<p>S3C2440A 中的 TFT LCD 控制器支持 1、2、4 或 8bpp调色显示（伪彩色）和16、24bpp无调色显示（真彩色）。S3C2440A 可以支持 256 色调色板给各种色彩映射的选择，以提供灵活操作给用户。</p>
<p>假如是16BPP的数据，LCD控制器从FB取出16bit数据，显示到LCD上，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/16.png"></p>
<p>那么当8BPP的数据时，就需要用到调色板，调色板里存放了256个16bit的数据，FB(frame buffer)只存放每个像素的索引，根据索引去调色板找到对应的数据传给LCD控制器，比如从FB中的第0个元素拿到调色板中的第0个16bit数据，再通过电子枪显示出来，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/17.png"></p>
<p>调色板支持 5:6:5（R:G:B）格式和 5:5:5:I（R:G:B:I）格式。当用户使用5:5:5:I格式时，I表示强度，也就是透明度。I是用作每个RGB 数据的共用 LSB 位，因此 5:5:5:I与R(5+I):G(5+I):B(5+I)格式相同。</p>
<h4><span id="2-2-2-1-diao-se-ban-ge-shi">2.2.2.1 调色板格式</span><a href="#2-2-2-1-diao-se-ban-ge-shi" class="header-anchor">#</a></h4><p>0x4D000400为调色板起始地址:</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/18.png"></p>
<h3><span id="2-2-3-lcd-kong-zhi-ji-cun-qi-1">2.2.3 LCD控制寄存器1</span><a href="#2-2-3-lcd-kong-zhi-ji-cun-qi-1" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/19.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">27</span>:<span class="number">18</span>]为只读数据位，不需要设置；</span><br><span class="line">[<span class="number">17</span>:<span class="number">8</span>]设置CLKVAL(像素时钟频率)，我们使用的是TFT屏，因此采用的公式是VCLK = HCLK / [(CLKVAL+<span class="number">1</span>) x <span class="number">2</span>]，其中HCLK为<span class="number">100</span>M。LCD手册里面Clock cycle的要求范围为<span class="number">5</span><span class="number">-12</span>MHz即可，那么取VCLK=<span class="number">9</span>，根据公式<span class="number">9</span>=<span class="number">100</span>/[(CLKVAL+<span class="number">1</span>)x2],算出CLKVAL≈<span class="number">4.5</span>=<span class="number">5</span>，设置CLKVAL=<span class="number">5</span>。</span><br><span class="line">[<span class="number">7</span>]不用管，默认即可；</span><br><span class="line">[<span class="number">6</span>:<span class="number">5</span>]TFT lcd配置为<span class="number">0b11</span>；</span><br><span class="line">[<span class="number">4</span>:<span class="number">1</span>]设置bpp模式，用户可选</span><br><span class="line">[<span class="number">0</span>]LCD输出使能，先暂时关闭不输出；</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu">2.2.4 LCD控制寄存器2(垂直方向参数)</span><a href="#2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/20.png"></p>
<p>s3c2440 LCD控制器时序图如下：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/21.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">31</span>:<span class="number">24</span>] : VBPD = tvb - <span class="number">1</span> （表示显示完最后一行像素，再过多久Vsync才来，表示上边黑框）</span><br><span class="line">[<span class="number">23</span>:<span class="number">14</span>] : LINEVAL = 每帧有多少行 - <span class="number">1</span> </span><br><span class="line">[<span class="number">13</span>:<span class="number">6</span>]  : VFPD = tvf - <span class="number">1</span>（下边黑框）</span><br><span class="line">[<span class="number">5</span>:<span class="number">0</span>]  : VSPW = tvp - <span class="number">1</span> （Vsync信号的脉冲宽度）</span><br></pre></td></tr></table></figure>



<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu">2.2.5 LCD控制寄存器3(水平方向参数)</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/22.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">25</span>:<span class="number">19</span>] : HBPD = thb - <span class="number">1</span>（左边黑框）</span><br><span class="line">[<span class="number">18</span>:<span class="number">8</span>]  : HOZVAL = 每行有多少列 - <span class="number">1</span></span><br><span class="line">[<span class="number">7</span>:<span class="number">0</span>]  : HFPD = thf - <span class="number">1</span> （右边黑框）</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-4">2.2.5 LCD控制寄存器4</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-4" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/23.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>:<span class="number">0</span>]: HSPW = thp - <span class="number">1</span> (Hsync信号的脉冲宽度)</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-5">2.2.5 LCD控制寄存器5</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-5" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/24.png"></p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/25.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">12</span>] : BPP24BL（表示<span class="number">24b</span>pp的数据是大端还是小端）</span><br><span class="line">[<span class="number">11</span>] : FRM565 （数据存放格式）</span><br><span class="line">[<span class="number">10</span>] : INVVCLK（时钟是否反转极性，当配置成<span class="number">0</span>时数据在时钟下降沿被锁存）</span><br><span class="line">[<span class="number">9</span>]  : HSYNC是否反转</span><br><span class="line">[<span class="number">8</span>]  : VSYNC是否反转</span><br><span class="line">[<span class="number">7</span>]  : INVVD, rgb是否反转</span><br><span class="line">[<span class="number">6</span>]  : INVVDEN</span><br><span class="line">[<span class="number">5</span>]  : INVPWREN</span><br><span class="line">[<span class="number">4</span>]  : INVLEND</span><br><span class="line">[<span class="number">3</span>]  : PWREN(LCD_PWREN output signal enable/disable)</span><br><span class="line">[<span class="number">2</span>]  : ENLEND</span><br><span class="line">[<span class="number">1</span>]  : BSWP</span><br><span class="line">[<span class="number">0</span>]  : HWSWP</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-6-lcdsaddr1-ji-cun-qi">2.2.6 LCDSADDR1寄存器</span><a href="#2-2-6-lcdsaddr1-ji-cun-qi" class="header-anchor">#</a></h3><p>frame buffer的起始地址寄存器：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/26.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">29</span>:<span class="number">21</span>] : LCDBANK, A[<span class="number">30</span>:<span class="number">22</span>] of fb</span><br><span class="line">[<span class="number">20</span>:<span class="number">0</span>]  : LCDBASEU, A[<span class="number">21</span>:<span class="number">1</span>] of fb</span><br><span class="line">即[<span class="number">29</span>:<span class="number">0</span>]表示Frame buffer的起始地址的[<span class="number">30</span>:<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-7-lcdsaddr2-ji-cun-qi">2.2.7 LCDSADDR2寄存器</span><a href="#2-2-7-lcdsaddr2-ji-cun-qi" class="header-anchor">#</a></h3><p>frame buffer的结束地址寄存器：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/27.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">20</span>:<span class="number">0</span>] : LCDBASEL，A[<span class="number">21</span>:<span class="number">1</span>] of end addr,即framebuffer的结束地址。</span><br></pre></td></tr></table></figure>

<h1><span id="3-lcd-luo-ji-bian-cheng">3 LCD裸机编程</span><a href="#3-lcd-luo-ji-bian-cheng" class="header-anchor">#</a></h1><h2><span id="3-1-ruan-jian-kuang-jia">3.1 软件框架</span><a href="#3-1-ruan-jian-kuang-jia" class="header-anchor">#</a></h2><p>为了让程序更加好扩展，体现出<strong>高内聚、低耦合</strong>的特点，能够兼容各种不同型号的lcd，假如有两款尺寸大小的lcd，如何快速的在两个lcd上切换？</p>
<p>首先我们抽象出lcd_3.5.c和lcd_4.3.c的共同点，比如都有初始化函数init(),我们可以新建一个lcd.c，然后定义一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_opr</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户不接触lcd_3.5.c和lcd_4.3.c，只需要在lcd.c里通过指针访问对应的结构体的函数，也就调用了不同init():</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/28.jpg" alt="img"></p>
<p>我们的目的是在LCD显示屏上画线、画圆(geomentry.c)和写字(font.c)其核心是画点(farmebuffer.c)，这些都属于纯软件。此外还需要一个lcd_test.c测试程序提供操作菜单，调用画线、画圆和写字操作。</p>
<p>往下操作的是LCD相关的内容，不同的LCD，其配置的参数也会不一样，通过lcd_3.5.c或lcd_4.3.c来设置属性参数。</p>
<p>根据LCD的特性，来设置LCD控制器，首先编写lcd_controller.c，它向上要接收不同LCD的参数，向下要使用这些参数设置对应具体的某一款LCD控制器。</p>
<p>对于我们开发板，就是s3c2440_lcd_controller.c，假如希望在其它开发板上也实现LCD显示，只需添加相应的代码文件即可。文件自上而下的框架如下：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/29.jpg"></p>
<h2><span id="3-2-shu-ju-jie-gou-ding-yi">3.2 数据结构定义</span><a href="#3-2-shu-ju-jie-gou-ding-yi" class="header-anchor">#</a></h2><h3><span id="3-2-1-lcd-she-bei-jie-gou-ti">3.2.1 LCD设备结构体</span><a href="#3-2-1-lcd-she-bei-jie-gou-ti" class="header-anchor">#</a></h3><p>我们知道LCD的参数属性有：引脚的极性、时序、数据的格式bpp、分辨率等，使用面向对象的思维方式，将这些封装成结构体放在lcd.h中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	NORMAL = <span class="number">0</span>,</span><br><span class="line">	INVERT = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NORMAL : 正常极性</span></span><br><span class="line"><span class="comment"> * INVERT : 反转极性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pins_polarity</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> vclk;  <span class="comment">/* normal: 在下降沿获取数据 */</span></span><br><span class="line">	<span class="type">int</span> rgb;   <span class="comment">/* normal: 高电平表示1 */</span></span><br><span class="line">	<span class="type">int</span> hsync; <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">	<span class="type">int</span> vsync; <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">&#125; pins_polarity, *p_pins_polarity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">time_sequence</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 垂直方向 */</span></span><br><span class="line">	<span class="type">int</span> tvp; <span class="comment">/* vysnc脉冲宽度 */</span></span><br><span class="line">	<span class="type">int</span> tvb; <span class="comment">/* 上边黑框, Vertical Back porch */</span></span><br><span class="line">	<span class="type">int</span> tvf; <span class="comment">/* 下边黑框, Vertical Front porch */</span></span><br><span class="line">	<span class="comment">/* 水平方向 */</span></span><br><span class="line">	<span class="type">int</span> thp; <span class="comment">/* hsync脉冲宽度 */</span></span><br><span class="line">	<span class="type">int</span> thb; <span class="comment">/* 左边黑框, Horizontal Back porch */</span></span><br><span class="line">	<span class="type">int</span> thf; <span class="comment">/* 右边黑框, Horizontal Front porch */</span></span><br><span class="line">	<span class="type">int</span> vclk;</span><br><span class="line">&#125; time_sequence, *p_time_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_params</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 引脚极性 */</span></span><br><span class="line">	pins_polarity pins_pol;</span><br><span class="line">	<span class="comment">/* 时序 */</span></span><br><span class="line">	time_sequence time_seq;</span><br><span class="line">	<span class="comment">/* 分辨率, bpp */</span></span><br><span class="line">	<span class="type">int</span> xres;</span><br><span class="line">	<span class="type">int</span> yres;</span><br><span class="line">	<span class="type">int</span> bpp;</span><br><span class="line">	<span class="comment">/* framebuffer的地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line">&#125; lcd_params, *p_lcd_params;</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-cao-zuo-fang-fa-ding-yi">3.3 操作方法定义</span><a href="#3-3-cao-zuo-fang-fa-ding-yi" class="header-anchor">#</a></h2><h3><span id="3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c">3.3.1  LCD操作方法-lcd_controller.c</span><a href="#3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c" class="header-anchor">#</a></h3><p>我们知道在c++中是面向对象编程的，那么一个对象就有它的属性和方法，LCD属性我们上面已经定义好了，那么方法我们可以定义一个lcd_controller.c用来控制管理LCD，定义个一个lcd_controller.h, struct lcd_controller结构体放置lcd对象的一些成员函数，即对象的方法，或者称之为对象的行为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> (*init)(p_lcd_params plcdparams);</span><br><span class="line">    <span class="type">void</span> (*enable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*disable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*init_palette)(<span class="type">void</span>);</span><br><span class="line">&#125; lcd_controller, *p_lcd_controller;</span><br></pre></td></tr></table></figure>
<p>那么lcd_controller.c相当于一个管理者，会去选择具体型号的LCD对象去执行具体的成员函数，比如管理s3c2440_lcd_controller.c，它向上接受传入的LCD参数，向下传给具体的LCD控制器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">    <span class="comment">/* 调用2440的LCD控制器的初始化函数，lcd_controller是一个被选中的对象，即s3c2440_lcd_controller*/</span></span><br><span class="line">    lcd_controller.init(plcdparams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在s3c2440_lcd_controller.c再构造一个具体的lcd对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> <span class="title">s3c2440_lcd_controller</span> =</span> &#123;</span><br><span class="line">	.name    = xxx,</span><br><span class="line">	.init    = xxx,</span><br><span class="line">	.enalbe  = xxx,</span><br><span class="line">	.disable = xxx,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lcd_controller.c代码框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd_controller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CONTROLLER_NUM 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> p_lcd_controller p_array_lcd_controller[LCD_CONTROLLER_NUM];</span><br><span class="line"><span class="type">static</span> p_lcd_controller g_p_lcd_controller_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_lcd_controller</span><span class="params">(p_lcd_controller plcdcon)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p_array_lcd_controller[i]) &#123;</span><br><span class="line">			p_array_lcd_controller[i] = plcdcon;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_lcd_controller</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p_array_lcd_controller[i] &amp;&amp; !<span class="built_in">strcmp</span>(p_array_lcd_controller[i]-&gt;name, name)) &#123;</span><br><span class="line">			g_p_lcd_controller_selected = p_array_lcd_controller[i];</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向上: 接收不同LCD的参数</span></span><br><span class="line"><span class="comment"> * 向下: 使用这些参数设置对应的LCD控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">	<span class="comment">/* 调用所选择的LCD控制器的初始化函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected) &#123;</span><br><span class="line">		g_p_lcd_controller_selected-&gt;init(plcdparams);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected)</span><br><span class="line">		g_p_lcd_controller_selected-&gt;enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected)</span><br><span class="line">		g_p_lcd_controller_selected-&gt;disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面详细分析lcd_controller.c框架的含义以及作用：</p>
<ol>
<li>开始定义了一个p_array_lcd_controller数组和g_p_lcd_controller_selected，p_array_lcd_controller数组表示lcd控制器的集合，g_p_lcd_controller_selected表示被选中的那一个lcd_controller;</li>
<li>当我们初始化时要先调用register_lcd_controller，select_lcd_controller选中具体的lcd_controller；</li>
<li>然后才能调用lcd_controller_init初始化具体的lcd_controller，去控制具体型号的lcd。</li>
</ol>
<p>同理，也通过lcd.c去管理lcd_4.3.c,思路如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a. 有一个数组存放各类lcd的参数；</span><br><span class="line">b. 有一个register_lcd给下面的lcd程序来设置数组；</span><br><span class="line">c. 有一个select_lcd，供上层选择某款LCD；</span><br></pre></td></tr></table></figure>
<h3><span id="3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c">3.3.2 具体型号LCD管理-ldc.c</span><a href="#3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c" class="header-anchor">#</a></h3><p>参考前面的lcd_controller.c编辑lcd.c如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_NUM 10</span></span><br><span class="line"><span class="type">static</span> p_lcd_params p_array_lcd[LCD_NUM];</span><br><span class="line"><span class="type">static</span> p_lcd_params g_p_lcd_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_lcd</span><span class="params">(p_lcd_params plcd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p_array_lcd[i]) &#123;</span><br><span class="line">			p_array_lcd[i] = plcd;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_lcd</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p_array_lcd[i] &amp;&amp; !<span class="built_in">strcmp</span>(p_array_lcd[i]-&gt;name, name)) &#123;</span><br><span class="line">			g_p_lcd_selected = p_array_lcd[i];</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_lcd_params</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_base, <span class="type">int</span> *xres, <span class="type">int</span> *yres, <span class="type">int</span> *bpp)</span> &#123;</span><br><span class="line">	*fb_base = g_p_lcd_selected-&gt;fb_base;</span><br><span class="line">	*xres = g_p_lcd_selected-&gt;xres;</span><br><span class="line">	*yres = g_p_lcd_selected-&gt;yres;</span><br><span class="line">	*bpp = g_p_lcd_selected-&gt;bpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-lcd-chu-shi-hua">3.4 LCD初始化</span><a href="#3-4-lcd-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="3-4-1-chu-shi-hua-lcd-kong-zhi-qi">3.4.1 初始化lcd控制器</span><a href="#3-4-1-chu-shi-hua-lcd-kong-zhi-qi" class="header-anchor">#</a></h3><h4><span id="3-4-1-1-chu-shi-hua-yin-jiao">3.4.1.1 初始化引脚</span><a href="#3-4-1-1-chu-shi-hua-yin-jiao" class="header-anchor">#</a></h4><h5><span id="3-4-1-1-1-bei-guang-yin-jiao">3.4.1.1.1 背光引脚</span><a href="#3-4-1-1-1-bei-guang-yin-jiao" class="header-anchor">#</a></h5><p>我们配置LCD的背光引脚成输出模式：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/30.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPBCON &amp;= ~<span class="number">0x3</span>;</span><br><span class="line">GPBCON |= <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao">3.4.1.1.2 控制引脚和数据引脚</span><a href="#3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao" class="header-anchor">#</a></h5><p>然后再配置LCD的控制引脚和数据引脚，LCD控制引脚和数据引脚分别复用了GPC和GPD，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/31.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/32.png"></p>
<p>设置GPC, GPD均为0xaaaa,aaaa。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* LCD专用引脚 */</span></span><br><span class="line">GPCCON = <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">GPDCON = <span class="number">0xaaaaaaaa</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="3-4-1-1-3-pwren-yin-jiao">3.4.1.1.3 PWREN引脚</span><a href="#3-4-1-1-3-pwren-yin-jiao" class="header-anchor">#</a></h5><p>设置GPG4成PWREN引脚</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/33.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/34.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPGCON |= (<span class="number">3</span>&lt;&lt;<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi">3.4.1.2 初始化LCD控制寄存器、地址寄存器</span><a href="#3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p>前面介绍了LCDCON1，LCDCON2，LCDCON3…LCDSADDR1等寄存器，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">	<span class="comment">/* [17:8]: CLKVAL, vclk = HCLK / [(CLKVAL+1) x 2]</span></span><br><span class="line"><span class="comment">	 *                   如：9   = 100M /[(CLKVAL+1) x 2], 所以CLKVAL = 4.5 = 5</span></span><br><span class="line"><span class="comment">	 *                 CLKVAL = 100/vclk/2-1</span></span><br><span class="line"><span class="comment">	 * [6:5]: 0b11, tft lcd</span></span><br><span class="line"><span class="comment">	 * [4:1]: bpp mode</span></span><br><span class="line"><span class="comment">	 * [0]  : LCD video output and the logic enable/disable</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> clkval = (<span class="type">double</span>)HCLK/plcdparams-&gt;time_seq.vclk/<span class="number">2</span><span class="number">-1</span>+<span class="number">0.5</span>;</span><br><span class="line">	<span class="type">int</span> bppmode = plcdparams-&gt;bpp == <span class="number">8</span>  ? <span class="number">0xb</span> :\</span><br><span class="line">				  plcdparams-&gt;bpp == <span class="number">16</span> ? <span class="number">0xc</span> :\</span><br><span class="line">				  <span class="number">0xd</span>;  <span class="comment">/* 0xd: 24bpp */</span></span><br><span class="line">	LCDCON1 = (clkval&lt;&lt;<span class="number">8</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">5</span>) | (bppmode&lt;&lt;<span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* [31:24] : VBPD    = tvb - 1</span></span><br><span class="line"><span class="comment">	 * [23:14] : LINEVAL = line - 1</span></span><br><span class="line"><span class="comment">	 * [13:6]  : VFPD    = tvf - 1</span></span><br><span class="line"><span class="comment">	 * [5:0]   : VSPW    = tvp - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON2 = 	((plcdparams-&gt;time_seq.tvb - <span class="number">1</span>)&lt;&lt;<span class="number">24</span>) | \</span><br><span class="line">	            ((plcdparams-&gt;yres - <span class="number">1</span>)&lt;&lt;<span class="number">14</span>)         | \</span><br><span class="line">				((plcdparams-&gt;time_seq.tvf - <span class="number">1</span>)&lt;&lt;<span class="number">6</span>)  | \</span><br><span class="line">				((plcdparams-&gt;time_seq.tvp - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* [25:19] : HBPD	 = thb - 1</span></span><br><span class="line"><span class="comment">	 * [18:8]  : HOZVAL  = 列 - 1</span></span><br><span class="line"><span class="comment">	 * [7:0]   : HFPD	 = thf - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON3 =	((plcdparams-&gt;time_seq.thb - <span class="number">1</span>)&lt;&lt;<span class="number">19</span>) | \</span><br><span class="line">				((plcdparams-&gt;xres - <span class="number">1</span>)&lt;&lt;<span class="number">8</span>)		      | \</span><br><span class="line">				((plcdparams-&gt;time_seq.thf - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * [7:0]   : HSPW	 = thp - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON4 =	((plcdparams-&gt;time_seq.thp - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用来设置引脚极性, 设置16bpp, 设置内存中象素存放的格式</span></span><br><span class="line"><span class="comment">     * [12] : BPP24BL</span></span><br><span class="line"><span class="comment">	 * [11] : FRM565, 1-565</span></span><br><span class="line"><span class="comment">	 * [10] : INVVCLK, 0 = The video data is fetched at VCLK falling edge</span></span><br><span class="line"><span class="comment">	 * [9]  : HSYNC是否反转</span></span><br><span class="line"><span class="comment">	 * [8]  : VSYNC是否反转</span></span><br><span class="line"><span class="comment">	 * [7]  : INVVD, rgb是否反转</span></span><br><span class="line"><span class="comment">	 * [6]  : INVVDEN</span></span><br><span class="line"><span class="comment">	 * [5]  : INVPWREN</span></span><br><span class="line"><span class="comment">	 * [4]  : INVLEND</span></span><br><span class="line"><span class="comment">	 * [3]  : PWREN, LCD_PWREN output signal enable/disable</span></span><br><span class="line"><span class="comment">	 * [2]  : ENLEND</span></span><br><span class="line"><span class="comment">	 * [1]  : BSWP</span></span><br><span class="line"><span class="comment">	 * [0]  : HWSWP</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	pixelplace = plcdparams-&gt;bpp == <span class="number">24</span> ? (<span class="number">0</span>) : |\</span><br><span class="line">	             plcdparams-&gt;bpp == <span class="number">16</span> ? (<span class="number">1</span>) : |\</span><br><span class="line">	             (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);  <span class="comment">/* 8bpp */</span></span><br><span class="line">	LCDCON5 = (plcdparams-&gt;pins_pol.vclk&lt;&lt;<span class="number">10</span>) |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.rgb&lt;&lt;<span class="number">7</span>)   |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.hsync&lt;&lt;<span class="number">9</span>) |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.vsync&lt;&lt;<span class="number">8</span>) |\</span><br><span class="line"> 			  (plcdparams-&gt;pins_pol.de&lt;&lt;<span class="number">6</span>)    |\</span><br><span class="line">			  (plcdparams-&gt;pins_pol.pwren&lt;&lt;<span class="number">5</span>) |\</span><br><span class="line">			  (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | pixelplace;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* framebuffer地址 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * [29:21] : LCDBANK, A[30:22] of fb</span></span><br><span class="line"><span class="comment">	 * [20:0]  : LCDBASEU, A[21:1] of fb</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = plcdparams-&gt;fb_base &amp; ~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">	LCDSADDR1 = (addr &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * [20:0] : LCDBASEL, A[21:1] of end addr</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = plcdparams-&gt;fb_base + plcdparams-&gt;xres*plcdparams-&gt;yres*plcdparams-&gt;bpp/<span class="number">8</span>;</span><br><span class="line">	addr &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	addr &amp;= <span class="number">0x1fffff</span>;</span><br><span class="line">	LCDSADDR2 = addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao">3.4.1.3 使能、禁用背光引脚</span><a href="#3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao" class="header-anchor">#</a></h4><p>根据背光电路背光引脚是GPB0，那么配置GPBDAT[0]置1，使能背光引脚，设置LCDCON5和<br>LCDCON1使能power enable和LCD输出，反之。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_enalbe</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 背光引脚 : GPB0 */</span></span><br><span class="line">	GPBDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* pwren    : 给LCD提供AVDD  */</span></span><br><span class="line">	LCDCON5 |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span></span><br><span class="line">	LCDCON1 |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 背光引脚 : GPB0 */</span></span><br><span class="line">	GPBDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* pwren	: 给LCD提供AVDD  */</span></span><br><span class="line">	LCDCON5 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span></span><br><span class="line">	LCDCON1 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的s3c2440的lcd控制器初始化就编写完了，那么用户只要调用s3c2440_lcd_controller_init去设置LCD的属性即可。下面开始介绍如何设置LCD属性，让LCD控制器能够适应具体型号的LCD。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> <span class="title">s3c2440_lcd_controller</span> =</span> &#123;</span><br><span class="line">	.name    = <span class="string">&quot;s3c2440&quot;</span>,</span><br><span class="line">	.init    = s3c2440_lcd_controller_init,</span><br><span class="line">	.enable  = s3c2440_lcd_controller_enalbe,</span><br><span class="line">	.disable = s3c2440_lcd_controller_disable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="3-4-2-chu-shi-hua-lcd-she-bei">3.4.2 初始化lcd设备</span><a href="#3-4-2-chu-shi-hua-lcd-she-bei" class="header-anchor">#</a></h3><p>参考AT043TN24 LCD数据手册上的参数性能，见下表：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/35.png"></p>
<p>配置lcd_params属性如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_FB_BASE 0x33c00000</span></span><br><span class="line">lcd_params lcd_4_3_params = &#123;</span><br><span class="line">	.name = <span class="string">&quot;lcd_4.3&quot;</span></span><br><span class="line">	.pins_polarity = &#123;</span><br><span class="line">		.de    = NORMAL,	<span class="comment">/* normal: 高电平时可以传输数据 */</span></span><br><span class="line">		.vclk  = NORMAL,	<span class="comment">/* normal: 在下降沿获取数据 */</span></span><br><span class="line">		.rgb   = NORMAL,	<span class="comment">/* normal: 高电平表示1 */</span></span><br><span class="line">		.hsync = INVERT,    <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">		.vsync = INVERT, 	<span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">	&#125;,</span><br><span class="line">	.time_sequence = &#123;</span><br><span class="line">		<span class="comment">/* 垂直方向 */</span></span><br><span class="line">		.tvp=	<span class="number">10</span>, <span class="comment">/* vysnc脉冲宽度 */</span></span><br><span class="line">		.tvb=	<span class="number">2</span>,  <span class="comment">/* 上边黑框, Vertical Back porch */</span></span><br><span class="line">		.tvf=	<span class="number">2</span>,  <span class="comment">/* 下边黑框, Vertical Front porch */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 水平方向 */</span></span><br><span class="line">		.thp=	<span class="number">41</span>, <span class="comment">/* hsync脉冲宽度 */</span></span><br><span class="line">		.thb=	<span class="number">2</span>,  <span class="comment">/* 左边黑框, Horizontal Back porch */</span></span><br><span class="line">		.thf=	<span class="number">2</span>,  <span class="comment">/* 右边黑框, Horizontal Front porch */</span></span><br><span class="line"></span><br><span class="line">		.vclk=	<span class="number">9</span>,  <span class="comment">/* MHz */</span></span><br><span class="line">	&#125;,</span><br><span class="line">	.xres = <span class="number">480</span>,</span><br><span class="line">	.yres = <span class="number">272</span>,</span><br><span class="line">	.bpp  = <span class="number">16</span>,</span><br><span class="line">	.fb_base = LCD_FB_BASE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.de表示数据输出使能引脚，高电平有效，所以配置成NORMAL；</span><br><span class="line">.pwren表示LCD_PWREN引脚，高电平有效；</span><br><span class="line">.vclk表示LCD的时钟，从手册的LCD时序图中可以看到下降沿有效，所以配置NORMAL；</span><br><span class="line">.rgb表示颜色数据的引脚极性，高电平表示<span class="number">1</span>，配置成NORMAL；</span><br><span class="line">.hsync表示行同步信号，normal表示高脉冲，参考手册发现该信号低脉冲有效，所以配置成INVERT；</span><br></pre></td></tr></table></figure>

<p>什么是高低脉冲？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">高脉冲：即从逻辑<span class="number">0</span>变化bai到逻辑du1再变化到逻辑<span class="number">0</span>，如此便是一个高脉zhi冲。在单片机中定义高脉冲就是让某个I/O先输出逻辑<span class="number">0</span>，接着保持一定的时间（延时），再输出逻辑<span class="number">1</span>，同样保持一定的时间（延时），最后再转变输出为逻辑<span class="number">0</span>+延时。</span><br><span class="line">低脉冲：反之</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.vsync表示帧同步信号，同.hsync；</span><br><span class="line">.time_sequence时序设置参考上表配置。我们看到thf + thp + thb = <span class="number">2</span> + <span class="number">41</span> +<span class="number">2</span> = <span class="number">45</span> clk &gt; <span class="number">44</span> clk，满足上面的注意事项；</span><br><span class="line">.xres .yres表示分辨率</span><br><span class="line">.bpp表示像素点颜色模式</span><br><span class="line">.fb_base指定frame buffer的基地址</span><br></pre></td></tr></table></figure>

<p>那么最终LCD初始化函数封装如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 注册LCD,把具体的LCD属性配置下去 */</span></span><br><span class="line">	register_lcd(&amp;lcd_4_3_params);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册LCD控制器 */</span></span><br><span class="line">	register_lcd_controller(&amp;s3c2440_lcd_controller);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 选择某款LCD */</span></span><br><span class="line">	select_lcd(<span class="string">&quot;lcd_4.3&quot;</span>);</span><br><span class="line">	<span class="comment">/* 选择某款LCD控制器 */</span></span><br><span class="line">	select_lcd_controller(<span class="string">&quot;s3c2440&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用LCD的参数, 初始化LCD控制器 */</span></span><br><span class="line">	lcd_controller_init(g_p_lcd_selected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：我们可以看到，调用的函数都是一些通用型框架型接口，具体的实现本质还得根据硬件本身的特性来配置寄存器来驱动硬件工作。</p>
<h2><span id="3-5-shi-xian-xian-shi-gong-neng">3.5 实现显示功能</span><a href="#3-5-shi-xian-xian-shi-gong-neng" class="header-anchor">#</a></h2><h3><span id="3-5-1-lcd-xian-shi-man-ping-hong-se">3.5.1 LCD显示满屏红色</span><a href="#3-5-1-lcd-xian-shi-man-ping-hong-se" class="header-anchor">#</a></h3><p>想要在LCD上显示出数据，所需步骤如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a. 初始化LCD</span><br><span class="line">b. 使能LCD</span><br><span class="line">c. 获取LCD参数: fb_base, xres, yres, bpp</span><br><span class="line">d. 往framebuffer中写数据</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-1-chu-shi-hua-lcd">3.5.1.1 初始化LCD</span><a href="#3-5-1-1-chu-shi-hua-lcd" class="header-anchor">#</a></h4><p>前面已详细实现。</p>
<h4><span id="3-5-1-2-shi-neng-lcd">3.5.1.2 使能LCD</span><a href="#3-5-1-2-shi-neng-lcd" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_enable</span><span class="params">()</span> &#123;</span><br><span class="line">	lcd_controller_enalbe(); <span class="comment">//会间接调用s3c2440_lcd_controller_enalbe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-3-huo-qu-lcd-can-shu">3.5.1.3 获取LCD参数</span><a href="#3-5-1-3-huo-qu-lcd-can-shu" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_lcd_params</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_base, <span class="type">int</span> *xres, <span class="type">int</span> *yres, <span class="type">int</span> *bpp)</span> &#123;</span><br><span class="line">	*fb_base = g_p_lcd_selected-&gt;fb_base;</span><br><span class="line">	*xres = g_p_lcd_selected-&gt;xres;</span><br><span class="line">	*yres = g_p_lcd_selected-&gt;yres;</span><br><span class="line">	*bpp = g_p_lcd_selected-&gt;bpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-4-wang-framebuffer-zhong-xie-shu-ju">3.5.1.4 往framebuffer中写数据</span><a href="#3-5-1-4-wang-framebuffer-zhong-xie-shu-ju" class="header-anchor">#</a></h4><p>假设我们初始化配置了BPP&#x3D;16，那么如何让全屏显示红色？</p>
<p>就需要从framebuffer基地址开始的整个屏幕的像素点都填充红色值。 对于16BPP，RGB&#x3D;565，想显示红色，即[15:11]全为1表示红色，[10:5]全为0表示无绿色，[4:0]全为0表示无蓝色，0b1111100000000000&#x3D;0xF800。<br>以基地址为起点，分别以xres和yres为边界，依次填充颜色。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = (<span class="type">unsigned</span> <span class="type">short</span> *)fb_base;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; xres; x++)</span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; yres; y++)</span><br><span class="line">		*p++ = <span class="number">0xf800</span>;</span><br></pre></td></tr></table></figure>
<p>假设我们初始化配置了BPP&#x3D;24 或者BPP &#x3D;32，那么如何让全屏显示红色？</p>
<p>其实无论是24bpp还是32bpp，在frame buffer中每个像素点都占4 bytes，对于24BPP or 32 bpp，即RGB:888，每个颜色占8位，一共占据24位。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = (<span class="type">unsigned</span> <span class="type">int</span> *)fb_base;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; xres; x++)</span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; yres; y++)</span><br><span class="line">		*p++ = <span class="number">0xff0000</span>;</span><br></pre></td></tr></table></figure>
<p>当Frame buffer中填满颜色数据时，LCD控制器会参照我们之前的配置将数据填充到LCD显示器上。那前面的24BPP、32BPP是怎样在 只能接收16BPP(硬件上只有16根数据线)的LCD上显示的呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">这是因为在使用<span class="number">24B</span>PP时，发出的<span class="number">8</span>条红色，<span class="number">8</span>条绿色，<span class="number">8</span>条蓝色数据，只用了高<span class="number">5</span>条红色，高<span class="number">6</span>条绿色，高<span class="number">5</span>条蓝色与LCD相连。（前面LCD硬件原理的FrameBuffer和BPP概念有讲）</span><br></pre></td></tr></table></figure>

<h2><span id="3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu">3.6 实现绘制点线圆函数</span><a href="#3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu" class="header-anchor">#</a></h2><h3><span id="3-6-1-hua-dian">3.6.1 画点</span><a href="#3-6-1-hua-dian" class="header-anchor">#</a></h3><p>无论是何种图形，都是基于点来构成的，因此我们需要先实现画点，其他的都是上层的一些数据处理了，像各种图形、甚至色彩鲜艳的图片无非都是一些由点构造出的数据而已。</p>
<p>我们在在farmebuffer.c实现画点，在geomentry.c实现画线、画圆等几何图形，font.c实现画字。</p>
<p>那么一个像素点要显示到lcd上，我们要知道它的位置坐标，然后还要知道它的颜色值，假设该像素点的坐标为（x,y）,那么该像素的地址为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（x,y）= fb_base + (xres*(bpp/<span class="number">8</span>))*y +x*bpp/<span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>那么所以在画点前需要先获取lcd参数：fb_base、xres、yres、bpp;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_get_lcd_params</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	get_lcd_params(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后画点函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>  *pc;  <span class="comment">/* 8bpp */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *pw;  <span class="comment">/* 16bpp */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>   *pdw; <span class="comment">/* 32bpp */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pixel_base = fb_base + (xres * bpp / <span class="number">8</span>) * y + x * bpp / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (bpp) &#123; <span class="comment">//根据像素不同bpp格式，在Frame buffer中存放方式不一样，但对用户来说，不关心颜色格式，通通当做32位色颜色处理，所以这里需要做格式转换</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			pc = (<span class="type">unsigned</span> <span class="type">char</span> *) pixel_base;</span><br><span class="line">			*pc = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">			pw = (<span class="type">unsigned</span> <span class="type">short</span> *) pixel_base;</span><br><span class="line">			*pw = convert32bppto16bpp(color);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">			pdw = (<span class="type">unsigned</span> <span class="type">int</span> *) pixel_base;</span><br><span class="line">			*pdw = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户传入的颜色数据一般都是32bit的，即格式为：0x00RRGGBB。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于<span class="number">8</span>PP，通过的是调色板索引实现的，这个后续再讲解，直接*pc = color即可（这样只取了高<span class="number">8</span>位，低精度的数据就丢了）。</span><br><span class="line">对于<span class="number">16</span>PP，那么需要进行颜色转换后再存放进frame buffer。</span><br><span class="line">对于<span class="number">32</span>PP，大小刚好对应，直接*pc = color即可。</span><br></pre></td></tr></table></figure>

<h3><span id="3-6-2-32bppto16bpp-han-shu">3.6.2 32bppto16bpp函数</span><a href="#3-6-2-32bppto16bpp-han-shu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先分别取出RGB，再相应的清除低位数据，实现将RGB888变为RGB565</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">convert32bppto16bpp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rgb)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r = (rgb &gt;&gt; <span class="number">16</span>)&amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="type">int</span> g = (rgb &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="type">int</span> b = rgb &amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="comment">/* rgb565 */</span></span><br><span class="line">	r = r &gt;&gt; <span class="number">3</span>;<span class="comment">//取低5位</span></span><br><span class="line">	g = g &gt;&gt; <span class="number">2</span>;<span class="comment">//取低6位</span></span><br><span class="line">	b = b &gt;&gt; <span class="number">3</span>;<span class="comment">//取低5位</span></span><br><span class="line">	<span class="keyword">return</span> ((r&lt;&lt;<span class="number">11</span>) | (g&lt;&lt;<span class="number">5</span>) | (b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-6-3-hua-xian-hua-yuan">3.6.3 画线画圆</span><a href="#3-6-3-hua-xian-hua-yuan" class="header-anchor">#</a></h3><p>画圆画线的具体原理不是本主题的重点，这些属于研究算法的范畴了，比如这里就有现成的算法可以用，如这篇博客：<a href="https://blog.csdn.net/p1126500468/article/details/50428613">https://blog.csdn.net/p1126500468/article/details/50428613</a>，里面有画圆画线的函数实现，直接使用就可以了，套用画点的”轮子”就可以了。</p>
<h3><span id="3-6-4-ce-shi">3.6.4 测试</span><a href="#3-6-4-ce-shi" class="header-anchor">#</a></h3><p>新建一个geometry.c，复制博客中代码，替换里面的描点显示函数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 画线 */</span></span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, xres - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xff0000</span>); <span class="comment">//(0,0) 到（xres - 1, 0）两点间的线</span></span><br><span class="line">draw_line(xres - <span class="number">1</span>, <span class="number">0</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xffff00</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, yres - <span class="number">1</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xff00aa</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, yres - <span class="number">1</span>, <span class="number">0xff00ef</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xff4500</span>);</span><br><span class="line">draw_line(xres - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, yres - <span class="number">1</span>, <span class="number">0xff0780</span>);</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 画圆 */</span></span><br><span class="line">draw_circle(xres/<span class="number">2</span>, yres/<span class="number">2</span>, yres/<span class="number">4</span>, <span class="number">0xff00</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/36.jpg"></p>
<h2><span id="3-7-zi-fu-ku-yi-zhi">3.7 字符库移植</span><a href="#3-7-zi-fu-ku-yi-zhi" class="header-anchor">#</a></h2><p>字符也是由点构成的，一个个点组成的点阵，其实本质上要显示文字就是把字库移植到对应的自己型号相匹配的board上，字库中的每一个字符都是一些点按照对应格式组合成的集合。</p>
<p>从linux内核源码中随便挑选一个字库文件，比如linux-4.18.16&#x2F;lib&#x2F;fonts这个目录下就有对应的很多字库文件。在这里我挑选font_8x16.c，如下图：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/37.png"></p>
<p>其中8x16表示每个字符所占的像素点的大小，表示每个字符占的大小为长*宽&#x3D;8*16个像素点。</p>
<p>我们来看下一个字符’A’是如何显示的？从font_8x16.c我们找到字符’A’的数据，如下图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/38.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/39.png"><br>那么我们如何让font_8x16.c这个字库的数据显示到lcd上呢？font_8x16.c见附件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a. 根据要显示的字符的ascii码作为索引，在fontdata_8x16中得到点阵数据</span></span><br><span class="line"><span class="comment">b. 根据点阵来设置对应象素的颜色</span></span><br><span class="line"><span class="comment">c. 根据点阵的某位决定是否描颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_print_char</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> c, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="comment">/* 根据c的ascii码作为索引在fontdata_8x16中得到点阵数据（fontdata_8x16是字库的数据集合）*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *dots = &amp;fontdata_8x16[c * <span class="number">16</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">	<span class="type">int</span> bit;</span><br><span class="line">	<span class="comment">/* 根据点阵来设置对应象素的颜色 */</span></span><br><span class="line">	<span class="keyword">for</span> (j = y; j &lt; y+<span class="number">16</span>; j++) &#123;</span><br><span class="line">		data = *dots++;</span><br><span class="line">		bit = <span class="number">7</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = x; i &lt; x+<span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="comment">/* 根据点阵的某位决定是否描颜色 */</span></span><br><span class="line">			<span class="keyword">if</span> (data &amp; (<span class="number">1</span>&lt;&lt;bit))</span><br><span class="line">				fb_put_pixel(i, j, color);</span><br><span class="line">			bit--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在font_8x16.c里面，每个字符占据16字节，因此想要根据ascii码找到对应的点阵数据，需要对应的乘16，再取地址，得到该字符的首地址。</p>
<p>在显示之前，还需要获取LCD参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> fontdata_8x16[];</span><br><span class="line"><span class="comment">/* 获得LCD参数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">font_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	get_lcd_params(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-7-1-xian-shi-zi-fu-chuan">3.7.1 显示字符串</span><a href="#3-7-1-xian-shi-zi-fu-chuan" class="header-anchor">#</a></h3><p>如果想显示字符串，那就在每显示完一个字符后，x轴加8即可，同时考虑是否超出屏幕显示范围进行换行处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &quot;abc\n\r123&quot; */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_print_string</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>* str, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    	<span class="keyword">while</span> (str[i]) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (str[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            			y = y+<span class="number">16</span>;</span><br><span class="line">        		<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            			x = <span class="number">0</span>;</span><br><span class="line">        		<span class="keyword">else</span> &#123;</span><br><span class="line">            			fb_print_char(x, y, str[i], color);</span><br><span class="line">            			x = x+<span class="number">8</span>;</span><br><span class="line">            			<span class="keyword">if</span> (x &gt;= xres) &#123;</span><br><span class="line">                				x = <span class="number">0</span>;</span><br><span class="line">                				y = y+<span class="number">16</span>;</span><br><span class="line">            			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        		i++;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-I2C</title>
    <url>/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-i2c-yuan-li">1 I2C原理</a><ul>
<li><a href="#1-1-ying-jian-dian-lu">1.1 硬件电路</a></li>
<li><a href="#1-2-i2c-xie-yi">1.2 i2c协议</a><ul>
<li><a href="#1-2-1-s-p-xin-hao">1.2.1 S&#x2F;P信号</a></li>
<li><a href="#1-2-2-ack-xin-hao">1.2.2 ACK信号</a></li>
<li><a href="#1-2-3-data-ge-shi">1.2.3 DATA格式</a></li>
<li><a href="#1-2-4-shu-ju-you-xiao-xing">1.2.4 数据有效性</a></li>
</ul>
</li>
<li><a href="#1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li">1.3 一次完整的I2C数据传输举例</a></li>
<li><a href="#1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li">1.4 一条SDA上实现双向传输的原理</a></li>
<li><a href="#1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai">1.5 SCL被从设备拉低表示busy状态</a></li>
</ul>
</li>
<li><a href="#2-i2c-kong-zhi-qi">2 I2C控制器</a><ul>
<li><a href="#2-1-i2c-zhu-cong-she-bei-guan-xi">2.1 I2c主从设备关系</a></li>
<li><a href="#2-2-s3c2440-i2c-kong-zhi-qi">2.2 s3c2440 I2C控制器</a><ul>
<li><a href="#2-2-1-kong-zhi-qi-kuang-tu">2.2.1 控制器框图</a></li>
<li><a href="#2-2-2-ji-cun-qi-jie-shao">2.2.2 寄存器介绍</a><ul>
<li><a href="#2-2-2-1-iiccon-shi-zhong-pei-zhi">2.2.2.1 IICCON-时钟配置</a></li>
<li><a href="#2-2-2-2-iicstat-mo-shi-pei-zhi">2.2.2.2 IICSTAT-模式配置</a></li>
<li><a href="#2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi">2.2.2.3 IICADD-从机地址配置</a></li>
<li><a href="#2-2-2-4-iicds-shu-ju-ji-cun-qi">2.2.2.4 IICDS-数据寄存器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-i2c-du-xie-cao-zuo-liu-cheng">3 I2C读写操作流程</a><ul>
<li><a href="#3-1-i2c-cao-zuo-mo-shi">3.1 I2C操作模式</a><ul>
<li><a href="#3-1-1-zhu-fa-master-transmitter-mode">3.1.1 主发Master&#x2F;Transmitter Mode</a></li>
<li><a href="#3-1-2-zhu-shou-master-receiver-mode">3.1.2 主收Master&#x2F;Receiver Mode</a></li>
<li><a href="#3-1-3-cong-fa-slave-transmitter-mode">3.1.3 从发Slave&#x2F;Transmitter Mode</a></li>
<li><a href="#3-1-4-cong-shou-slave-receiver-mode">3.1.4 从收Slave&#x2F;Receiver Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-i2c-cheng-xu-shi-li">4 I2C程序示例</a><ul>
<li><a href="#4-1-i2c-cong-she-bei-jie-shao">4.1 I2C从设备介绍</a><ul>
<li><a href="#4-1-1-at24cxx-eeprom">4.1.1 AT24CXX EEPROM</a></li>
</ul>
</li>
<li><a href="#4-2-cheng-xu-kuang-jia">4.2 程序框架</a><ul>
<li><a href="#4-2-1-i2c-msg-jie-gou-ti">4.2.1 i2c_msg结构体</a></li>
<li><a href="#4-2-2-i2c-test-c">4.2.2 i2c_test.c</a></li>
<li><a href="#4-2-3-at24cxx-c">4.2.3 at24cxx.c</a></li>
<li><a href="#4-2-4-i2c-controller-h">4.2.4 i2c_controller.h</a></li>
<li><a href="#4-2-5-i2c-controller-c">4.2.5 i2c_controller.c</a></li>
<li><a href="#4-2-6-s3c2440-i2c-controller-c">4.2.6 s3c2440_i2c_controller.c</a></li>
</ul>
</li>
<li><a href="#4-3-cheng-xu-kuang-jia-zong-jie">4.3 程序框架总结</a></li>
<li><a href="#4-4-i2c-zhong-duan-fu-wu-cheng-xu">4.4 I2C中断服务程序</a><ul>
<li><a href="#4-4-1-xie-cao-zuo">4.4.1 写操作</a></li>
<li><a href="#4-4-2-du-cao-zuo">4.4.2 读操作</a></li>
</ul>
</li>
<li><a href="#4-5-ce-shi">4.5 测试</a><ul>
<li><a href="#4-5-1-i2c-test-c">4.5.1 i2c_test.c</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-i2c-yuan-li">1 I2C原理</span><a href="#1-i2c-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-ying-jian-dian-lu">1.1 硬件电路</span><a href="#1-1-ying-jian-dian-lu" class="header-anchor">#</a></h2><p>I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/1.png" alt="img"></p>
<p>SDA（串行数据线）和SCL（串行时钟线）都是双向I&#x2F;O线，需通过上拉电阻接电源VCC．当总线空闲时．两根线都是高电平。</p>
<p>I2C 总线标准模式下速度可以达到 100Kb&#x2F;S，快速模式下可以达到 400Kb&#x2F;S。SDA 和 SCL 这两根线必须要接一个上拉电阻，一般是 4.7K。</p>
<h2><span id="1-2-i2c-xie-yi">1.2 i2c协议</span><a href="#1-2-i2c-xie-yi" class="header-anchor">#</a></h2><p>传输过程如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/2.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 主控发送start讯号(S)</span><br><span class="line"><span class="number">2.</span> 主控发送从设备地址(slave dev addr)</span><br><span class="line"><span class="number">3.</span> 主控发送方向（W/R）</span><br><span class="line"><span class="number">4.</span> 从设备应答（ack）</span><br><span class="line"><span class="number">5.</span> 主控（or从设备）发送数据(data)</span><br><span class="line"><span class="number">6.</span> 从设备（or主控）应答(ack)</span><br><span class="line">...</span><br><span class="line"><span class="number">7.</span> 主控发送停止信号(P)</span><br></pre></td></tr></table></figure>

<p>s3c2440 一次i2c读写过程:</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/3.png" alt="img"></p>
<h3><span id="1-2-1-s-x2f-p-xin-hao">1.2.1 S&#x2F;P信号</span><a href="#1-2-1-s-x2f-p-xin-hao" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/4.png" alt="img"></p>
<p>start信号：SCL是高电平，SDA被主控拉低。<br>stop信号：SCL是高电平，SDA被主控拉高。</p>
<p>示波器测量出start信号:<br><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/5.png" alt="img"></p>
<p>示波器测量出stop信号:<br><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/6.png" alt="img"></p>
<h3><span id="1-2-2-ack-xin-hao">1.2.2 ACK信号</span><a href="#1-2-2-ack-xin-hao" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/7.png" alt="img"></p>
<p>第9个时钟周期，SDA被拉低表示ack讯号。</p>
<h3><span id="1-2-3-data-ge-shi">1.2.3 DATA格式</span><a href="#1-2-3-data-ge-shi" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/8.png" alt="img"></p>
<p>用 9个clk传输8bit数据（7bit 从设备地址 + 1bit方向 ），MSB高位先出。第9个clk是ack讯号。</p>
<h3><span id="1-2-4-shu-ju-you-xiao-xing">1.2.4 数据有效性</span><a href="#1-2-4-shu-ju-you-xiao-xing" class="header-anchor">#</a></h3><p>SDA 线上的数据必须在<strong>SCL高电平周期保持稳定，在 SCL 低电平时才能允许改变</strong>。</p>
<h2><span id="1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li">1.3 一次完整的I2C数据传输举例</span><a href="#1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/9.jpg" alt="img"></p>
<ol>
<li>主控发送了S信号；</li>
<li>发送地址0x34，包含读写位；</li>
<li>发送数据0x30, 0x00, 0x01共3个字节数据；</li>
<li>最后SDA被拉高发送P信号。</li>
</ol>
<p>这里我是用了带I2C解码的示波器，能将I2C协议解码出来方便调试者阅读分析。</p>
<h2><span id="1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li">1.4 一条SDA上实现双向传输的原理</span><a href="#1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li" class="header-anchor">#</a></h2><p>电路设计内部结构使用<strong>开极电路</strong>。如下图：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/10.png" alt="img"></p>
<p><strong>条件</strong>：</p>
<ol>
<li><p>主设备发送时，从设备不发送（通过SCL控制即可，比如让前8个clk主控发送数据到SDA,让第9个clk从设备发送数据到SDA）</p>
</li>
<li><p>主设备发送数据时，从设备的“发送引脚”不能影响SDA数据。反之，从设备发送数据时，主设备的”发送引脚”不能影响到SDA数据。那么如何做到？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDA内部电路用三极管，开集电路,原理如下图：</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/11.png" alt="img"></p>
<p>从上图知道：</p>
<ol>
<li><p>当A,B都为低电平时，三极管不导通，SDA的电平取决于外部电路，这里SDA有上拉电阻，所以对应高电平；</p>
</li>
<li><p>当主控拉高A时，三极管导通，此时SDA接地，电平被拉低</p>
</li>
<li><p>同理，当从设备拉高B时，三极管导通，此时SDA接地，电平被拉低</p>
</li>
</ol>
</li>
</ol>
<p>那么电平真值表如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/12.png" alt="img"></p>
<p>所以，要实现双向传输：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果要master-&gt; slave进行数据传输，那么让主控驱动三极管，拉低SDA。</span><br><span class="line">如果要slave-&gt; master进行数据传输，那么让从设备驱动三极管，拉低SDA。</span><br><span class="line">否则，都不驱动三极管，SDA一直输出高电平，处于idle状态。</span><br></pre></td></tr></table></figure>

<p>从下面的例子可以看看数据是怎么传的（实现双向传输）。</p>
<p>举例：主设备发送（8bit）给从设备:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">前 <span class="number">8</span> 个 clk</span><br><span class="line">	◼ 从设备不要影响 SDA，从设备不驱动三极管</span><br><span class="line">	◼ 主设备决定数据，主设备要发送 <span class="number">1</span> 时不驱动三极管，要发送 <span class="number">0</span> 时驱动三极管</span><br><span class="line">第 <span class="number">9</span> 个 clk，由从设备决定数据</span><br><span class="line">	◼ 主设备不驱动三极管</span><br><span class="line">	◼ 从设备决定数据，要发出回应信号的话，就驱动三极管让 SDA 变为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>从这里也可以知道 ACK 信号是低电平从上面的例子，就可以知道怎样在一条线上实现双向传输，这就是 SDA 上要使用上拉电阻的原因。</p>
<p>为何 SCL 也要使用上拉电阻？在第 9 个时钟之后，如果有某一方需要更多的时间来处理数据，它可以一直驱动三极管把 SCL 拉低。</p>
<p>当 SCL 为低电平时候，大家都不应该使用 IIC 总线，只有当 SCL 从低电平变为高电平的时候，IIC 总线才能被使用。当它就绪后，就可以不再驱动三极管，这是上拉电阻把 SCL 变为高电平，其他设备就可以继续使用 I2C 总线了。</p>
<h2><span id="1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai">1.5 SCL被从设备拉低表示busy状态</span><a href="#1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/13.png" alt="img"></p>
<p>在<strong>第9个clk 后i2c会产生中断，此时SCL被拉低，表示busy状态</strong>，表示谁都不允许再使用i2c, 然后等到中断处理结束了，也就是处于idle状态了，此时会释放出SCL，那么主控可以继续发送SCL讯号表示可以继续进行i2c通信了。</p>
<h1><span id="2-i2c-kong-zhi-qi">2 I2C控制器</span><a href="#2-i2c-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-i2c-zhu-cong-she-bei-guan-xi">2.1 I2c主从设备关系</span><a href="#2-1-i2c-zhu-cong-she-bei-guan-xi" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/14.png" alt="img"></p>
<p>对于写操作，主控作为transmitter,从设备作为receiver。<br>对于读操作，主控作为receiver， 从设备作为transmitter。</p>
<h2><span id="2-2-s3c2440-i2c-kong-zhi-qi">2.2 s3c2440 I2C控制器</span><a href="#2-2-s3c2440-i2c-kong-zhi-qi" class="header-anchor">#</a></h2><h3><span id="2-2-1-kong-zhi-qi-kuang-tu">2.2.1 控制器框图</span><a href="#2-2-1-kong-zhi-qi-kuang-tu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/15.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pclk = <span class="number">50</span>Mhz, 经过prescaler分频，可以得到SCL。</span><br><span class="line"></span><br><span class="line">IICSTAT: 发出S（start）信号或者P(stop)信号。</span><br><span class="line"></span><br><span class="line">Data Bus可以把数据写入IICDS寄存器，然后会自动产生SCL，并且会将<span class="number">8</span>位数据从SDA同步给slave dev，</span><br><span class="line"></span><br><span class="line">在数据发送出去后，在第<span class="number">9</span>个SCL时钟，会受到slave dev的ack应答，可以通过查询IICSTAT来判断是否有ACK回应。</span><br><span class="line"></span><br><span class="line">当slave dev回应ACK后，那么又可以继续发送数据，继续写入据到IICDS。</span><br><span class="line"></span><br><span class="line">当主控想结束，设置IICSTAT发出P信号。</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-2-ji-cun-qi-jie-shao">2.2.2 寄存器介绍</span><a href="#2-2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h3><h4><span id="2-2-2-1-iiccon-shi-zhong-pei-zhi">2.2.2.1 IICCON-时钟配置</span><a href="#2-2-2-1-iiccon-shi-zhong-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/16.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Bit[<span class="number">7</span>]: 对于发送模式，不需要配置ack信号，ack是接收者发送回来的应答。对于接受模式，设置成<span class="number">1</span>，让它在第<span class="number">9</span>个CLK发出ack讯号（拉低sda）。</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">6</span>]:SCL时钟源，pclk分频即可</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">5</span>]:中断使能，使用i2c时要去enable</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">4</span>]:中断状态标识 表示中断有没有结束，当该bit读出来是<span class="number">1</span>时，SCL被拉低表示busy，也就是i2c中断还在处理中。当i2c中断处理结束后，可以将该bit 清<span class="number">0</span>，释放出SCL。</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">3</span>:<span class="number">0</span>]:i2c时钟分频系数配置，SCL时钟 = IICCLK/(IICCON[<span class="number">3</span>:<span class="number">0</span>]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-2-iicstat-mo-shi-pei-zhi">2.2.2.2 IICSTAT-模式配置</span><a href="#2-2-2-2-iicstat-mo-shi-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/17.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bit[<span class="number">7</span>:<span class="number">6</span>]:模式选择</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">5</span>]:当读的时候，<span class="number">0</span>表示not busy,<span class="number">1</span>表示busy, 当写的时候，<span class="number">0</span>表示写入STOP, <span class="number">1</span>表示写入START</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">4</span>] : 数据输出使能，<span class="number">0</span>：表示disable, <span class="number">1</span>表示enable</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">3</span>]:仲裁flag</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">0</span>]:表示i2c总线上的第<span class="number">9</span>个时钟周期有没有ack，<span class="number">1</span>表示有ack, <span class="number">0</span>表示无ack</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi">2.2.2.3 IICADD-从机地址配置</span><a href="#2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/18.png" alt="img"></p>
<h4><span id="2-2-2-4-iicds-shu-ju-ji-cun-qi">2.2.2.4 IICDS-数据寄存器</span><a href="#2-2-2-4-iicds-shu-ju-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/19.png" alt="img"></p>
<h1><span id="3-i2c-du-xie-cao-zuo-liu-cheng">3 I2C读写操作流程</span><a href="#3-i2c-du-xie-cao-zuo-liu-cheng" class="header-anchor">#</a></h1><p>The following steps must be executed before any IIC Tx&#x2F;Rx operations.</p>
<ol>
<li>Write own slave address on IICADD register, if needed.</li>
<li>Set IICCON register.<ol>
<li>Enable interrupt</li>
<li>Define SCL period</li>
</ol>
</li>
<li>Set IICSTAT to enable Serial Output</li>
</ol>
<p>在操作tx,rx前，要先执行以下几步骤：</p>
<ol>
<li>IICADD写入从设备地址</li>
<li>设置IICCON，设置时钟，使能中断</li>
<li>设置IICSTAT，使能传输</li>
</ol>
<h2><span id="3-1-i2c-cao-zuo-mo-shi">3.1 I2C操作模式</span><a href="#3-1-i2c-cao-zuo-mo-shi" class="header-anchor">#</a></h2><p>The S3C2440A IIC-bus interface has four operation modes:<br><strong>— Master transmitter mode</strong><br><strong>— Master receive mode</strong><br><strong>— Slave transmitter mode</strong><br><strong>— Slave receive mode</strong></p>
<h3><span id="3-1-1-zhu-fa-master-x2f-transmitter-mode">3.1.1 主发Master&#x2F;Transmitter Mode</span><a href="#3-1-1-zhu-fa-master-x2f-transmitter-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/20.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 配置成master tx <span class="title function_">mode</span><span class="params">(也就是IICSTAT[<span class="number">7</span>:<span class="number">6</span>]配置成<span class="number">11</span>)</span></span><br><span class="line">2. 把从设备地址写入IICDS，（第一次传输地址）</span><br><span class="line">3. IICSTAT写入0xF0（使能传输,发S信号，使能tx/rx）</span><br><span class="line">3. IICDS中配置的数据（从设备地址7bit + 读写位1bit）就被发送出去了（每传输完一个数据将产生一个中断）</span><br><span class="line">5. 判断第9个clk从设备是否有ack</span><br><span class="line">	5.1 如果从设备有ack,恢复i2c传输</span><br><span class="line">			IICDS = buf</span><br><span class="line">			Clear pending bit</span><br><span class="line">			数据被发送出去，继续i2c传输</span><br><span class="line">	<span class="number">5.2</span> 如果没有ack, stop，返回错误</span><br><span class="line">			IICSTAT = <span class="number">0xd0</span></span><br><span class="line">			Clear pending bit（IICCON[<span class="number">4</span>]）</span><br><span class="line">			Delay一会儿等待停止条件生效</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-2-zhu-shou-master-x2f-receiver-mode">3.1.2 主收Master&#x2F;Receiver Mode</span><a href="#3-1-2-zhu-shou-master-x2f-receiver-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/21.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 配置成master rx <span class="title function_">mode</span><span class="params">(也就是IICSTAT[<span class="number">7</span>:<span class="number">6</span>]配置成<span class="number">10</span>)</span></span><br><span class="line">2. 把从设备地址写入IICDS，（第一次传输地址）</span><br><span class="line">3. IICSTAT写入0xB0（使能传输）</span><br><span class="line">4. IICDS中配置的数据（从设备地址7bit + 读写位1bit）就被发送出去了（每传输完一个数据将产生一个中断）</span><br><span class="line">5. 判断第9个clk从设备是否有ack</span><br><span class="line">	5.1 如果从设备有ack,恢复i2c传输</span><br><span class="line">		Buf = IICDS</span><br><span class="line">		Clear pending bit</span><br><span class="line">		数据被接受到，继续i2c传输</span><br><span class="line">	<span class="number">5.2</span> 如果没有ack, stop，返回错误</span><br><span class="line">		IICSTAT = <span class="number">0x90</span></span><br><span class="line">		Clear pending bit</span><br><span class="line">		Delay一会儿</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-cong-fa-slave-x2f-transmitter-mode">3.1.3 从发Slave&#x2F;Transmitter Mode</span><a href="#3-1-3-cong-fa-slave-x2f-transmitter-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/22.png" alt="img"></p>
<h3><span id="3-1-4-cong-shou-slave-x2f-receiver-mode">3.1.4 从收Slave&#x2F;Receiver Mode</span><a href="#3-1-4-cong-shou-slave-x2f-receiver-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/23.png" alt="img"></p>
<h1><span id="4-i2c-cheng-xu-shi-li">4 I2C程序示例</span><a href="#4-i2c-cheng-xu-shi-li" class="header-anchor">#</a></h1><h2><span id="4-1-i2c-cong-she-bei-jie-shao">4.1 I2C从设备介绍</span><a href="#4-1-i2c-cong-she-bei-jie-shao" class="header-anchor">#</a></h2><p>IIC控制器只提供了传输数据的能力，至于数据有什么含义，IIC控制器并不知道，数据的含义有外部i2c从设备，我们需要阅读芯片手册，才知道IIC控制器应该发出怎样的数据。</p>
<h3><span id="4-1-1-at24cxx-eeprom">4.1.1  AT24CXX EEPROM</span><a href="#4-1-1-at24cxx-eeprom" class="header-anchor">#</a></h3><p>AT24Cxx系列EEPROM是由美国Mcrochip公司出品，1-512K位的支持I2C总线数据传送协议的串行CMOS E2PROM。I2c传输规则如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/24.png" alt="img"></p>
<h2><span id="4-2-cheng-xu-kuang-jia">4.2 程序框架</span><a href="#4-2-cheng-xu-kuang-jia" class="header-anchor">#</a></h2><p>我们的程序应该分为两层（IIC设备层，IIC控制器层），框架如下图所示：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/25.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最上层是i2c_test层，用来对i2c的功能进行测试和验证。</span><br><span class="line"></span><br><span class="line">第2层是i2c设备层，用来对具体某一型号的从设备进行i2c读写。</span><br><span class="line"></span><br><span class="line">第3层是通用i2c控制器层，用来提供对具体某一型号的i2c主控进行管理操作。</span><br><span class="line"></span><br><span class="line">最底层是i2c控制器具体的型号层。</span><br></pre></td></tr></table></figure>

<p>在通用i2c控制层，我们提供一个统一的接口i2c_transfer，不关使用哪个芯片，他最终都会调用i2c_transfer，来选择某一款I2C控制器，把数据发送出去，或者从I2c设备读到数据。这种层次分明的架构是作为软件开发人员必备的素养和技能。这里也是借鉴了linux内核I2C子系统的模型。</p>
<h3><span id="4-2-1-i2c-msg-jie-gou-ti">4.2.1 i2c_msg结构体</span><a href="#4-2-1-i2c-msg-jie-gou-ti" class="header-anchor">#</a></h3><p>我们借鉴Linux I2C子系统的数据结构定义。对于每一次传输的数据都可以用一个i2c_msg结构体来表示。但是，读某个地址的数据时，就要用两个i2c_msg结构体来描述它，因为一个i2c_msg结构体只能描述一个传输方向(读&#x2F;写)，我们读取ac24ccxx某个地址上的数据时，要先写出要读取的地址，然后来读取设备地址上的数据。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/26.png" alt="img"></p>
<h3><span id="4-2-2-i2c-test-c">4.2.2 i2c_test.c</span><a href="#4-2-2-i2c-test-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* 初始化: 选择I2C控制器 */</span></span><br><span class="line">        <span class="comment">/* 提供菜单供测试 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个菜单会调用到at24cxx.c里面的函数进行i2c外设读写。</p>
<h3><span id="4-2-3-at24cxx-c">4.2.3 at24cxx.c</span><a href="#4-2-3-at24cxx-c" class="header-anchor">#</a></h3><p>定义描述at24cxx外设，并且实现该外设的操作，里面会使用标准的接口i2c_transfer来启动I2C传输。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AT24CXX_ADDR 0x50</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">at24cxx_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        i2c_msg msg;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buf[<span class="number">0</span>] = addr++;</span><br><span class="line">                buf[<span class="number">1</span>] = data[i];</span><br><span class="line">                <span class="comment">/* 构造i2c_msg */</span></span><br><span class="line">                msg.addr  = AT24CXX_ADDR;</span><br><span class="line">                msg.flags = <span class="number">0</span>; <span class="comment">/* write */</span></span><br><span class="line">                msg.len   = <span class="number">2</span>;</span><br><span class="line">                msg.buf   = buf;</span><br><span class="line">                msg.err   = <span class="number">0</span>;</span><br><span class="line">                msg.cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">/* 调用i2c_transfer */</span></span><br><span class="line">                err = i2c_transfer(&amp;msg, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">at24cxx_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        i2c_msg msg[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="comment">/* 构造i2c_msg */</span></span><br><span class="line">        msg[<span class="number">0</span>].addr  = AT24CXX_ADDR;</span><br><span class="line">        msg[<span class="number">0</span>].flags  = <span class="number">0</span>; <span class="comment">/* write */</span></span><br><span class="line">        msg[<span class="number">0</span>].len   = <span class="number">1</span>;</span><br><span class="line">        msg[<span class="number">0</span>].buf   = &amp;addr;</span><br><span class="line">        msg[<span class="number">0</span>].err   = <span class="number">0</span>;</span><br><span class="line">        msg[<span class="number">0</span>].cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg[<span class="number">1</span>].addr  = AT24CXX_ADDR;</span><br><span class="line">        msg[<span class="number">1</span>].lags  = <span class="number">1</span>; <span class="comment">/* read */</span></span><br><span class="line">        msg[<span class="number">1</span>].len   = len;</span><br><span class="line">        msg[<span class="number">1</span>].buf   = data;</span><br><span class="line">        msg[<span class="number">1</span>].err   = <span class="number">0</span>;</span><br><span class="line">        msg[<span class="number">1</span>].cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/* 调用i2c_transfer */</span></span><br><span class="line">        err = i2c_transfer(&amp;msg, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-4-i2c-controller-h">4.2.4 i2c_controller.h</span><a href="#4-2-4-i2c-controller-h" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> addr;  <span class="comment">/* 7bits */</span></span><br><span class="line">        <span class="type">int</span> flags;  <span class="comment">/* 0 - write, 1 - read */</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> cnt_transferred;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">&#125;i2c_msg, *p_i2c_msg;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_controller</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*<span class="type">int</span>)(<span class="type">void</span>);</span><br><span class="line">        <span class="type">int</span> (*master_xfer)(i2c_msg msgs, <span class="type">int</span> num);</span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">&#125;i2c_controller, *p_i2c_controller;</span><br></pre></td></tr></table></figure>

<p>构造i2c_msg和i2c_controller结构。</p>
<h3><span id="4-2-5-i2c-controller-c">4.2.5 i2c_controller.c</span><a href="#4-2-5-i2c-controller-c" class="header-anchor">#</a></h3><p>实现通用i2c控制器管理，用来注册具体i2c控制器，调用具体控制器去做i2c通信。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CONTROLLER_NUM 10</span></span><br><span class="line"><span class="comment">/* 有一个i2c_controller数组用来存放各种不同芯片的操作结构体 */</span></span><br><span class="line"><span class="type">static</span> p_i2c_controller p_i2c_controllers[I2C_CONTROLLER_NUM];</span><br><span class="line"><span class="type">static</span> p_i2c_controller p_i2c_con_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_i2c_controller</span><span class="params">(p_i2c_controller *p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!p_i2c_controllers[i]) &#123;</span><br><span class="line">                        p_i2c_controllers[i] = p;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据名字来选择某款I2C控制器 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_i2c_controller</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (p_i2c_controllers[i] &amp;&amp; !<span class="built_in">strcmp</span>(name, p_i2c_controllers[i]-&gt;name))</span><br><span class="line">                &#123;</span><br><span class="line">                        p_i2c_con_selected = p_i2c_controllers[i];</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现 i2c_transfer 接口函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(i2c_msg msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p_i2c_con_selected-&gt;master_xfer(msgs, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 注册下面的I2C控制器 */</span></span><br><span class="line">	s3c2440_i2c_con_add();</span><br><span class="line">	<span class="comment">/* 选择某款I2C控制器 */</span></span><br><span class="line">	select_i2c_controller(<span class="string">&quot;s3c2440&quot;</span>);</span><br><span class="line">	<span class="comment">/* 调用它的init函数 */</span></span><br><span class="line">	p_i2c_con_selected-&gt;init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-6-s3c2440-i2c-controller-c">4.2.6 s3c2440_i2c_controller.c</span><a href="#4-2-6-s3c2440-i2c-controller-c" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_interrupt_func</span>(<span class="params"><span class="built_in">int</span> irq</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* 每传输完一个数据将产生一个中断 */</span></span><br><span class="line">        <span class="comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c2440_i2c_con_init</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* 配置引脚用于I2C*/</span></span><br><span class="line">        GPECON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">28</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line">        GPECON |= ((<span class="number">2</span>&lt;&lt;<span class="number">28</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置时钟 */</span></span><br><span class="line">        <span class="comment">/* [7] : IIC-bus acknowledge enable bit, 1-enable in rx mode</span></span><br><span class="line"><span class="comment">         * [6] : 时钟源, 0: IICCLK = fPCLK /16; 1: IICCLK = fPCLK /512</span></span><br><span class="line"><span class="comment">         * [5] : 1-enable interrupt</span></span><br><span class="line"><span class="comment">         * [4] : 读出为1时表示中断发生了, 写入0来清除并恢复I2C操作</span></span><br><span class="line"><span class="comment">         * [3:0] : Tx clock = IICCLK/(IICCON[3:0]+1).</span></span><br><span class="line"><span class="comment">         * Tx Clock = 100khz = 50Mhz/16/(IICCON[3:0]+1)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        IICCON = (<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">30</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">        register_irq(<span class="number">27</span>, i2c_interrupt_func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">do_master_tx</span>(<span class="params">p_i2c_msg msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        p_cur_msg = msg;</span><br><span class="line">        msg-&gt;cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg-&gt;err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置寄存器启动传输 */</span></span><br><span class="line">        <span class="comment">/* 1. 配置为 master tx mode */</span></span><br><span class="line">        IICCON |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* TX mode, 在ACK周期释放SDA */</span></span><br><span class="line">        IICSTAT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">/*IIC-bus data output enable/disable(1: Enable Rx/Tx)*/</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">/* 2. 把从设备地址写入IICDS */</span></span><br><span class="line">        IICDS = msg-&gt;addr&lt;&lt;<span class="number">1</span>;<span class="comment">//[slave addr [7:1], addr[0] is trans dir]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. IICSTAT = 0xf0 (启动传输), slave addr数据即被发送出去,当到达第9个clk,无论是否有ack, 将导致中断产生 */</span></span><br><span class="line">        IICSTAT = <span class="number">0xf0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后续的传输由中断驱动 */</span></span><br><span class="line">        <span class="comment">/* 循环等待中断处理完毕 */</span></span><br><span class="line">        <span class="keyword">while</span> (!msg-&gt;err &amp;&amp; msg-&gt;cnt_transferred != msg-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;err)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">do_master_rx</span>(<span class="params">p_i2c_msg msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        p_cur_msg = msg;</span><br><span class="line">        msg-&gt;cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg-&gt;err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置寄存器启动传输 */</span></span><br><span class="line">        <span class="comment">/* 1. 配置为 Master Rx mode */</span></span><br><span class="line">        IICCON |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* RX mode, 在ACK周期回应ACK */</span></span><br><span class="line">        IICSTAT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);  <span class="comment">/*IIC-bus data output enable/disable*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. 把从设备地址写入IICDS */</span></span><br><span class="line">        IICDS = (msg-&gt;addr&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. IICSTAT = 0xb0 , 从设备地址即被发送出去, 将导致中断产生 */</span></span><br><span class="line">        IICSTAT = <span class="number">0xb0</span>;</span><br><span class="line">        <span class="comment">/* 后续的传输由中断驱动 */</span></span><br><span class="line">        <span class="comment">/* 循环等待中断处理完毕 */</span></span><br><span class="line">        <span class="keyword">while</span> (!msg-&gt;err &amp;&amp; msg-&gt;cnt_transferred != msg-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;err)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">s3c2440_master_xfer</span>(<span class="params">p_i2c_msg msgs, <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        <span class="built_in">int</span> err;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)        </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgs[i].flags == <span class="number">0</span>)<span class="comment">/* write */</span></span><br><span class="line">                        err = do_master_tx(&amp;msgs[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        err = do_master_rx(&amp;msgs[i]);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c2440_i2c_con_add</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        register_i2c_controller(&amp;s3c2440_i2c_con);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> i2c_controller s3c2440_i2c_con = &#123;</span><br><span class="line">        .name = <span class="string">&quot;s3c2440&quot;</span>,</span><br><span class="line">        .<span class="keyword">init</span> = s3c2440_i2c_con_init,</span><br><span class="line">        .master_xfer = s3c2440_master_xfer,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>s3c2440_i2c_con_add函数：注册 s3c2440的i2c控制器， 当调用i2c_init就会对选中的这款控制器初始化，也就是调用s3c2440_i2c_con_init。</p>
<p>s3c2440_i2c_con_init函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>).IICCON = (<span class="number">0</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">30</span>&lt;&lt;<span class="number">0</span>); 设置IICCON控制寄存器。选择发送时钟，使能中断。设置ACK应答使能，bit[<span class="number">7</span>]。</span><br><span class="line"><span class="number">2</span>).register_irq(<span class="number">27</span>, i2c_interrupt_func)：注册中断处理函数，当发生I2C中断的时候就会调用i2c_interrupt_func中断处理函数。</span><br></pre></td></tr></table></figure>

<p>s3c2440_master_xfer函数：</p>
<p>当发起i2c传输时，调用i2c_transfer，进而调用s3c2440_master_xfer进行数据传输。写的话do_master_tx，读的话do_master_rx。</p>
<p>do_master_rx函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IICDS = (msg-&gt;addr&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)：把从设备地址写入IICDS，前<span class="number">7</span>位是从机地址，第<span class="number">8</span>位表示传输方向(<span class="number">0</span>表示写操作，<span class="number">1</span>表示读操作)。</span><br></pre></td></tr></table></figure>

<p>do_master_tx函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> IICDS = msg-&gt;addr&lt;&lt;<span class="number">1</span>: 把从机地址（高<span class="number">7</span>位，所以需要向右移一位）写入到IICDS寄存器中。</span><br><span class="line"><span class="number">2.</span> IICSTAT = <span class="number">0xf0</span>:设置IICSTAT寄存器，将s3c2440设为主机发送器，并发出S信号后，紧接着就发出从机地址。后续的传输工作将在中断服务程序中完成。</span><br></pre></td></tr></table></figure>

<h2><span id="4-3-cheng-xu-kuang-jia-zong-jie">4.3 程序框架总结</span><a href="#4-3-cheng-xu-kuang-jia-zong-jie" class="header-anchor">#</a></h2><p>对应程序框架的4层架构。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/27.png" alt="img"></p>
<h2><span id="4-4-i2c-zhong-duan-fu-wu-cheng-xu">4.4 I2C中断服务程序</span><a href="#4-4-i2c-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h2><p>Start信号之后，发出设备地址，在第9个时钟就会产生第一个中断，我们根据i2c的流程图来编写中断程序。每传输完一个数据将又产生一个中断，I2C操作的主体在<strong>中断服务程序</strong>，它可以分为两部分：写操作，读操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> p_i2c_msg p_cur_msg;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">isLastData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == p_cur_msg-&gt;len - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* 正要开始传输最后一个数据 */</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">resume_iic_with_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon = IICCON;</span><br><span class="line">        iiccon |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* 回应ACK */</span></span><br><span class="line">        iiccon &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">/* 恢复IIC操作 */</span></span><br><span class="line">        IICCON =  iiccon;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">resume_iic_without_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon = IICCON;</span><br><span class="line">        iiccon &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>)); <span class="comment">/* 不回应ACK, 恢复IIC操作 */</span></span><br><span class="line">        IICCON =  iiccon;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_interrupt_func</span><span class="params">(<span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iicstat = IICSTAT;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//printf(&quot;i2c_interrupt_func! flags = %d\n\r&quot;, p_cur_msg-&gt;flags);</span></span><br><span class="line"> </span><br><span class="line">        p_cur_msg-&gt;cnt_transferred++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 每传输完一个数据将产生一个中断 */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (p_cur_msg-&gt;flags == <span class="number">0</span>) &#123;<span class="comment">//write</span></span><br><span class="line">				<span class="comment">/* 对于第1个中断, 它是发送出设备地址后产生的</span></span><br><span class="line"><span class="comment">                 * 需要判断是否有ACK</span></span><br><span class="line"><span class="comment">                 * 有ACK : 设备存在</span></span><br><span class="line"><span class="comment">                 * 无ACK : 无设备, 出错, 直接结束传输</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="number">0</span>) &#123;  <span class="comment">/* 第1次中断 */</span></span><br><span class="line">                        <span class="keyword">if</span> (iicstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &#123;<span class="comment">/*iicstat [0] == 1表示no ack*/</span></span><br><span class="line">								<span class="comment">/* no ack */</span></span><br><span class="line">                                <span class="comment">/* 停止传输 */</span></span><br><span class="line">                                IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">                                IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//clear pending bit</span></span><br><span class="line">                                p_cur_msg-&gt;err = <span class="number">-1</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;tx err, no ack\n\r&quot;</span>);</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len) &#123;</span><br><span class="line">						<span class="comment">/* 对于其他中断, 要继续发送下一个数据</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">						IICDS = p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred];</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//clear pending bit</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">/* 停止传输 */</span></span><br><span class="line">						IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">						delay(<span class="number">1000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//read</span></span><br><span class="line">                <span class="comment">/* 对于第1个中断, 它是发送出设备地址后产生的</span></span><br><span class="line"><span class="comment">                 * 需要判断是否有ACK</span></span><br><span class="line"><span class="comment">                 * 有ACK : 设备存在, 恢复I2C传输, 这样在下一个中断才可以得到第1个数据</span></span><br><span class="line"><span class="comment">                 * 无ACK : 无设备, 出错, 直接结束传输</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="number">0</span>) &#123;<span class="comment">/* 第1次中断 */</span></span><br><span class="line">                        <span class="keyword">if</span> (iicstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &#123;<span class="comment">/* no ack */</span></span><br><span class="line">                                <span class="comment">/* 停止传输 */</span></span><br><span class="line">                                IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">                                IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//clear pending bit</span></span><br><span class="line">                                p_cur_msg-&gt;err = <span class="number">-1</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;rx err, no ack\n\r&quot;</span>);</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ack */</span></span><br><span class="line">                                <span class="comment">/* 如果是最后一个数据, 启动传输时要设置为不回应ACK */</span></span><br><span class="line">                                <span class="comment">/* 恢复I2C传输 */</span></span><br><span class="line">                                <span class="keyword">if</span> (isLastData())</span><br><span class="line">                                        resume_iic_without_ack();</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        resume_iic_with_ack();</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">				<span class="comment">/* 非第1个中断, 表示得到了一个新数据</span></span><br><span class="line"><span class="comment">				 * 从IICDS读出、保存</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len) &#123;</span><br><span class="line">						index = p_cur_msg-&gt;cnt_transferred - <span class="number">1</span>;</span><br><span class="line">						p_cur_msg-&gt;buf[index] = IICDS;</span><br><span class="line">		 </span><br><span class="line">						<span class="comment">/* 如果是最后一个数据, 启动传输时要设置为不回应ACK */</span></span><br><span class="line">						<span class="comment">/* 恢复I2C传输 */</span></span><br><span class="line">						<span class="keyword">if</span> (isLastData())</span><br><span class="line">								resume_iic_without_ack();</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">								resume_iic_with_ack();</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">/* 发出停止信号 */</span></span><br><span class="line">						IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">						delay(<span class="number">1000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-1-xie-cao-zuo">4.4.1 写操作</span><a href="#4-4-1-xie-cao-zuo" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. p_cur_msg-&gt;cnt_transferred初始值为-1(do_master_tx启动时设置)。</span><br><span class="line">2. p_cur_msg-&gt;cnt_transferred == 0表示是第一次传输数据完后产生的中断，即发送从设备地址产生的中断。</span><br><span class="line">3. iicstat &amp; (1&lt;&lt;0)表示主机没有接受到ACK信号(即发出的设备地址不存在)，需要停止传输。</span><br><span class="line">4. IICSTAT = 0xd0置IICSTAT寄存器的[5]写为0，产生P信号。但是由于这时IICCON[4]仍为1，P信号没有实际发出，当执行IICCON &amp;= ~(1&lt;&lt;4);清除IICCON[4]后，P信号才真正发出。</span><br><span class="line">5. 等待一段时间，确保P信号已经发送完毕。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">1).假如if (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len)条件成立，表示数据还没有发送完毕，需要继续发送数据。</span><br><span class="line">2).执行IICDS = p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred]把要发送的数据写入到IICDS寄存器中，经过执行IICCON &amp;= ~(1&lt;&lt;4);清除中断标志后后，紧接着就自动把数据发送出去了，这将触发下一个中断。</span><br><span class="line">3).如果条件不成立表示数据传输完毕，发出P信号，停止数据的传输。</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-2-du-cao-zuo">4.4.2 读操作</span><a href="#4-4-2-du-cao-zuo" class="header-anchor">#</a></h3><p>见注释。</p>
<h2><span id="4-5-ce-shi">4.5 测试</span><a href="#4-5-ce-shi" class="header-anchor">#</a></h2><h3><span id="4-5-1-i2c-test-c">4.5.1 i2c_test.c</span><a href="#4-5-1-i2c-test-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_at24cxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">    addr = get_uint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">256</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address &gt; 256, error!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">    gets(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line">    err = at24cxx_write(addr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at24cxx_write ret = %d\n\r&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read_at24cxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">    addr = get_uint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">256</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address &gt; 256, error!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得长度 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the length to read: &quot;</span>);</span><br><span class="line">    len = get_int();</span><br><span class="line"></span><br><span class="line">    err = at24cxx_read(addr, data, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at24cxx_read ret = %d\n\r&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line">    <span class="comment">/* 长度固定为64 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* 每行打印16个数据 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            <span class="comment">/* 先打印数值 */</span></span><br><span class="line">            c = data[cnt++];</span><br><span class="line">            str[j] = c;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 后打印字符 */</span></span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    i2c_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">/* 打印菜单, 供我们选择测试内容 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[w] Write at24cxx\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[r] Read at24cxx\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[q] quit\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Enter selection: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            c = getchar();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\n\r&quot;</span>, c);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/* 测试内容:</span></span><br><span class="line"><span class="comment">             * 3. 编写某个地址</span></span><br><span class="line"><span class="comment">             * 4. 读某个地址</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                    do_write_at24cxx();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">					do_read_at24cxx();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-SPI</title>
    <url>/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-spi-yuan-li">1 SPI原理</a><ul>
<li><a href="#1-1-spi-gai-nian">1.1 spi概念</a></li>
<li><a href="#1-2-ying-ti-kuang-jia">1.2 硬体框架</a></li>
<li><a href="#1-2-shu-ju-chuan-shu-shi-xu">1.2 数据传输时序</a></li>
<li><a href="#1-3-spi-xiang-guan-de-ming-ci-suo-xie">1.3 SPI相关的名词缩写</a></li>
<li><a href="#1-4-shi-zhong-ji-xing-xiang-wei-mo-shi">1.4 时钟极性相位模式</a></li>
</ul>
</li>
<li><a href="#2-spi-kong-zhi-qi-jie-gou">2 SPI控制器结构</a><ul>
<li><a href="#2-1-sspsr">2.1 SSPSR</a></li>
<li><a href="#2-2-sspbuf">2.2 SSPBUF</a></li>
<li><a href="#2-3-controller">2.3 Controller</a></li>
</ul>
</li>
<li><a href="#3-spi-luo-ji-shi-li">3 SPI裸机示例</a><ul>
<li><a href="#3-1-spi-oled-xian-shi-mian-ban-jie-shao">3.1 SPI-OLED显示面板介绍</a><ul>
<li><a href="#3-1-1-bing-xing-jie-kou-shi-xu">3.1.1 并行接口时序</a></li>
<li><a href="#3-1-2-spi-chuan-xing-jie-kou-shi-xu">3.1.2 SPI串行接口时序</a></li>
<li><a href="#3-1-3-power-on-sequence-shang-dian-xu-lie">3.1.3 power on sequence-上电序列</a></li>
<li><a href="#3-1-4-power-down-sequence-diao-dian-xu-lie">3.1.4 power down sequence-掉电序列</a></li>
<li><a href="#3-1-5-xiu-mian-huan-xing">3.1.5 休眠唤醒</a></li>
</ul>
</li>
<li><a href="#3-2-spi-oled-mian-ban-xian-shi-yuan-li">3.2 SPI-OLED面板显示原理</a><ul>
<li><a href="#3-2-1-fa-song-di-zhi">3.2.1 发送地址</a><ul>
<li><a href="#3-2-1-1-ye-page-di-zhi-mo-shi">3.2.1.1 页(page)地址模式</a><ul>
<li><a href="#3-2-1-1-1-she-zhi-page-addr">3.2.1.1.1 设置page addr</a></li>
<li><a href="#3-2-1-1-2-she-zhi-col-addr">3.2.1.1.2 设置col addr</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-2-2-fa-song-shu-ju">3.2.2 发送数据</a></li>
</ul>
</li>
<li><a href="#3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi">3.3 SPI-OLED驱动-GPIO模拟SPI方式</a><ul>
<li><a href="#3-3-1-ruan-jian-ceng-ci">3.3.1 软件层次</a></li>
<li><a href="#3-3-2-gpio-spi-c">3.3.2 gpio_spi.c</a><ul>
<li><a href="#3-3-2-1-spi-yin-jiao-chu-shi-hua">3.3.2.1 spi引脚初始化</a></li>
<li><a href="#3-3-2-2-xie-ming-ling">3.3.2.2 写命令</a><ul>
<li><a href="#3-3-2-2-1-spisendbyte">3.3.2.2.1 SPISendByte</a></li>
</ul>
</li>
<li><a href="#3-3-2-3-xie-shu-ju">3.3.2.3 写数据</a></li>
</ul>
</li>
<li><a href="#3-2-3-oled-c">3.2.3 oled.c</a><ul>
<li><a href="#3-2-3-1-chu-shi-hua-oled">3.2.3.1 初始化OLED</a></li>
<li><a href="#3-2-3-2-qu-dong-xian-shi-oled">3.2.3.2 驱动显示OLED</a></li>
</ul>
</li>
<li><a href="#3-3-4-wan-zheng-dai-ma">3.3.4 完整代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-spi-yuan-li">1 SPI原理</span><a href="#1-spi-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-spi-gai-nian">1.1 spi概念</span><a href="#1-1-spi-gai-nian" class="header-anchor">#</a></h2><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一种同步串行接口技术，是一种高速的，全双工，同步的通信总线。</p>
<p>特点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">高速、同步、全双工、非差分、总线式</span><br><span class="line">主从机通信模式</span><br></pre></td></tr></table></figure>

<p>优点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">支持全双工通信（SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出）</span><br><span class="line">数据传输速率快（I2c一般只能到100-400Khz, SPI高达上百Mhz）</span><br></pre></td></tr></table></figure>

<p>缺点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据可靠性上有一定的缺陷</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-ying-ti-kuang-jia">1.2 硬体框架</span><a href="#1-2-ying-ti-kuang-jia" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/1.png" alt="img"></p>
<p>SCK：提供时钟<br>DO:作为数据输出<br>DI:作为数据输入<br>CS0&#x2F;CS1:作为片选</p>
<p>同一时刻只能有一个SPI设备处于工作状态。因此cs选中谁，谁就和主控通信。</p>
<h2><span id="1-2-shu-ju-chuan-shu-shi-xu">1.2 数据传输时序</span><a href="#1-2-shu-ju-chuan-shu-shi-xu" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/2.png" alt="img"></p>
<p>这里是一款SPI flash在SCLK上升延采样数据（D7~D0）的示意图。设现在s3c2440传输一个0x56数据给SPI Flash，时序如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/3.png" alt="img"></p>
<p>CS0低选中SPI Flash，配置成模式0， 0x56的二进制就是0b0101 0110，因此在每个SCK时钟周期，DO输出对应的电平。会在<strong>每个时钟周期的上升沿采样DO上的电平</strong>。</p>
<h2><span id="1-3-spi-xiang-guan-de-ming-ci-suo-xie">1.3 SPI相关的名词缩写</span><a href="#1-3-spi-xiang-guan-de-ming-ci-suo-xie" class="header-anchor">#</a></h2><p><strong>KPOL</strong>： (Clock Polarity)（时钟）极性</p>
<p><strong>CKPHA</strong>： (Clock Phase)（时钟）相位</p>
<p><strong>SCK</strong>&#x3D;<strong>SCLK</strong>：SPI的时钟</p>
<p><strong>Leading edge</strong>：前一个边沿</p>
<p><strong>Trailing edge</strong>：后一个边沿</p>
<h2><span id="1-4-shi-zhong-ji-xing-xiang-wei-mo-shi">1.4 时钟极性相位模式</span><a href="#1-4-shi-zhong-ji-xing-xiang-wei-mo-shi" class="header-anchor">#</a></h2><p>CPOL:表示SPI CLK的初始电平（空闲状态时电平），0为低电平，1为高电平</p>
<p>CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿</p>
<p>两者组合成4种模式：</p>
<table>
<thead>
<tr>
<th>SPI模式</th>
<th>CPOL</th>
<th>CPHA</th>
<th>空闲状态时钟极性</th>
<th>采样&#x2F;移位时钟相位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>低电平</td>
<td>上升沿采样（锁存）下降沿移位</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>低电平</td>
<td>上升沿移位下降沿采样（锁存）</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>高电平</td>
<td>上升沿移位下降沿采样（锁存）</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
<td>高电平</td>
<td>上升沿采样（锁存）下降沿移位</td>
</tr>
</tbody></table>
<p>4个模式波形对比：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/4.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/5.png" alt="img"></p>
<p>常用的是<strong>模式0和模式3</strong>，因为它们都是在<strong>上升沿采样数据</strong>.当配置成模式3时，<strong>对于主设备，数据采样在时钟上升沿，数据传送在时钟下降沿****。</strong></p>
<p><strong>主设备SPI时钟和极性的配置应该由外设来决定；二者的配置应该保持一致，即主设备的SDO同从设备的SDO配置一致，主设备的SDI同从设备的SDI配置一致。即因为主从设备是在SCLK的控制下，同时发送和接收数据，并通过2个双向移位寄存器来交换数据 。</strong></p>
<p>举个例子，以 CPOL&#x3D;0，CPHA&#x3D;0，模式0为例：空闲CLK为低电平，相位为0，也就是上升延采集数据。由于SPI的全双工可以同时读写，发送MOSI数据为0xD2,接收MISO数据为0x66。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/6.png" alt="img"></p>
<h1><span id="2-spi-kong-zhi-qi-jie-gou">2 SPI控制器结构</span><a href="#2-spi-kong-zhi-qi-jie-gou" class="header-anchor">#</a></h1><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/7.png" alt="img"></p>
<h2><span id="2-1-sspsr">2.1 SSPSR</span><a href="#2-1-sspsr" class="header-anchor">#</a></h2><p>SSPSR：移位寄存器(Shift Register). 根据 SPI 时钟同步信号, 将SSPBUF中的数据一位一位移出去或者收进来。</p>
<h2><span id="2-2-sspbuf">2.2 SSPBUF</span><a href="#2-2-sspbuf" class="header-anchor">#</a></h2><p>Master 与 Slave 之间交换的数据其实都是移位寄存器从 SSPBUF 里面拷贝的。通过往 SSPBUF 对应的寄存器 (Tx-Data &#x2F; Rx-Data register) 里读写数据, 间接地操控 SPI 设备内部的 SSPBUF。</p>
<h2><span id="2-3-controller">2.3 Controller</span><a href="#2-3-controller" class="header-anchor">#</a></h2><p>用来发送控制信号的，像CS，SCK等控制信号。</p>
<h1><span id="3-spi-luo-ji-shi-li">3 SPI裸机示例</span><a href="#3-spi-luo-ji-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-spi-oled-xian-shi-mian-ban-jie-shao">3.1 SPI-OLED显示面板介绍</span><a href="#3-1-spi-oled-xian-shi-mian-ban-jie-shao" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/8.png" alt="img"></p>
<p><strong>QG-2864TMBEG01</strong>这款OLED为例，可见它支持Parallel&#x2F;i2c&#x2F;SPI这3种方式对它进行控制，这里仅对它进行SPI控制。它的product Specification见附件。</p>
<h3><span id="3-1-1-bing-xing-jie-kou-shi-xu">3.1.1 并行接口时序</span><a href="#3-1-1-bing-xing-jie-kou-shi-xu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/9.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/10.png" alt="img"></p>
<h3><span id="3-1-2-spi-chuan-xing-jie-kou-shi-xu">3.1.2 SPI串行接口时序</span><a href="#3-1-2-spi-chuan-xing-jie-kou-shi-xu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/11.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tr/Tf: 表示spi clk上升/下降延不能超过<span class="number">40</span>ns</span><br><span class="line">Tclkl/Tclkh: 表示spi clk低/高电平持续至少<span class="number">20</span>ns</span><br><span class="line">Tcycle: 表示spi clk一个时钟周期至少<span class="number">100</span>ns</span><br><span class="line">Tdsw/Tdhw: 表示spi data的建立/持续时间至少<span class="number">15</span>ms</span><br><span class="line">Tcss:片选建立时间至少<span class="number">20</span>ns</span><br><span class="line">Tcsh:片选持续时间至少<span class="number">10</span>ns</span><br><span class="line">Tas/Tah:地址建立/持续时间至少<span class="number">15</span>ns</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-power-on-sequence-shang-dian-xu-lie">3.1.3 power on sequence-上电序列</span><a href="#3-1-3-power-on-sequence-shang-dian-xu-lie" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/12.png" alt="img"></p>
<h3><span id="3-1-4-power-down-sequence-diao-dian-xu-lie">3.1.4 power down sequence-掉电序列</span><a href="#3-1-4-power-down-sequence-diao-dian-xu-lie" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/13.png" alt="img"></p>
<h3><span id="3-1-5-xiu-mian-huan-xing">3.1.5 休眠唤醒</span><a href="#3-1-5-xiu-mian-huan-xing" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/14.png" alt="img"></p>
<h2><span id="3-2-spi-oled-mian-ban-xian-shi-yuan-li">3.2 SPI-OLED面板显示原理</span><a href="#3-2-spi-oled-mian-ban-xian-shi-yuan-li" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/15.png" alt="img"></p>
<p><strong>QG-2864TMBEG01</strong>这款为例，OLED长有128个像素，宽有64个像素，共128*64&#x3D;8,192 像素。每个像素用1bit来表示，为1则亮，为0则灭。所以每一个字节数据Data表示8个像素，Data0~Data1023,如上图。 那要怎么在显存里面存放Data数据。</p>
<h3><span id="3-2-1-fa-song-di-zhi">3.2.1 发送地址</span><a href="#3-2-1-fa-song-di-zhi" class="header-anchor">#</a></h3><h4><span id="3-2-1-1-ye-page-di-zhi-mo-shi">3.2.1.1 页(page)地址模式</span><a href="#3-2-1-1-ye-page-di-zhi-mo-shi" class="header-anchor">#</a></h4><p>QG-2864TMBEG01 OLED主控有三种地址模式，我们常用的是页地址模式，发送0x20命令，再发送0x02命令，进入页地址模式，如下图：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/16.png" alt="img"></p>
<p>它把显存的64行分为8页，每页对应8行；选中某页后，再选择某列。因此共用页地址，也就是8行都共用同一个页地址，列地址独立，所以page0<del>page7，col0</del>col127。然后就可以往里面写数据了，每写一个数据，列地址就会加1，一直写到最右端的位置，页地址加1，会自动跳到最左端。通过命令来实现发送页地址和列地址，其中列地址分为两次发送，先发送低字节，再发送高字节。如下图，假设每个字符数据大小为8x16像素，假如第一个字符位置为(page,col)，相邻的右边就是(page,col+8)，写一个字符需要先发8字节，然后跳到下一页坐标就是(page+2,col)，发送8字节数据。一个字符需要2个page*8个col，由于一个像素占1个bit, 所以一个Data占1byte, 一个字符占16 byte。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/17.png" alt="img"></p>
<h5><span id="3-2-1-1-1-she-zhi-page-addr">3.2.1.1.1 设置page addr</span><a href="#3-2-1-1-1-she-zhi-page-addr" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/18.png" alt="img"></p>
<p>一共就8页，因此X2<del>X0，有3bit足够了。比如选中page0，则x2</del>x0 &#x3D; 000。</p>
<h5><span id="3-2-1-1-2-she-zhi-col-addr">3.2.1.1.2 设置col addr</span><a href="#3-2-1-1-2-she-zhi-col-addr" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/19.png" alt="img"></p>
<p>分两次发送， 先发送列地址低4位，再发送列地址高4位；</p>
<h3><span id="3-2-2-fa-song-shu-ju">3.2.2 发送数据</span><a href="#3-2-2-fa-song-shu-ju" class="header-anchor">#</a></h3><p>如何发送一个字符‘A’，显示到OLED。</p>
<ol>
<li>取得字模</li>
</ol>
<p>这里从网上找了一份8x16的字库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLEDFONT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLEDFONT_H      </span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> oled_asc2_8x16[<span class="number">95</span>][<span class="number">16</span>]= &#123;</span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">// 0</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//!1</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x06</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&quot;2</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">//#3</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0xFC</span>,<span class="number">0x08</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//$4</span></span><br><span class="line">    &#123;<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x1C</span>,<span class="number">0x03</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//%5</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x27</span>,<span class="number">0x21</span>,<span class="number">0x10</span>&#125;,<span class="comment">//&amp;6</span></span><br><span class="line">    &#123;<span class="number">0x10</span>,<span class="number">0x16</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&#x27;7</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">//(8</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x18</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//)9</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x0F</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">//*10</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x1F</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//+11</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xB0</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//,12</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>&#125;,<span class="comment">//-13</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//.14</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">///15</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//016</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//117</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x28</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//218</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x48</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//319</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x00</span>&#125;,<span class="comment">//420</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//521</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//622</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//723</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">//824</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x11</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//925</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//:26</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//;27</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&lt;28</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">//=29</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&gt;30</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x48</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x36</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//?31</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0xC8</span>,<span class="number">0x28</span>,<span class="number">0xE8</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x27</span>,<span class="number">0x24</span>,<span class="number">0x23</span>,<span class="number">0x14</span>,<span class="number">0x0B</span>,<span class="number">0x00</span>&#125;,<span class="comment">//@32</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x38</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3C</span>,<span class="number">0x23</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x27</span>,<span class="number">0x38</span>,<span class="number">0x20</span>&#125;,<span class="comment">//A33</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//B34</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;,<span class="comment">//C35</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//D36</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x23</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">//E37</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//F38</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x22</span>,<span class="number">0x1E</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">//G39</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//H40</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//I41</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//J42</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0xC0</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x01</span>,<span class="number">0x26</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//K43</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//L44</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//M45</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//N46</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//O47</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//P48</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x18</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x38</span>,<span class="number">0x50</span>,<span class="number">0x4F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Q49</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">//R50</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">//S51</span></span><br><span class="line">    &#123;<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//T52</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//U53</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x78</span>,<span class="number">0x88</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x38</span>,<span class="number">0x0E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//V54</span></span><br><span class="line">    &#123;<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x3C</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x3C</span>,<span class="number">0x03</span>,<span class="number">0x00</span>&#125;,<span class="comment">//W55</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x68</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x2C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">//X56</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0xC8</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Y57</span></span><br><span class="line">    &#123;<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x38</span>,<span class="number">0x26</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Z58</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">//[59</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x38</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>&#125;,<span class="comment">//\60</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//]61</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//^62</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>&#125;,<span class="comment">//_63</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//`64</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//a65</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//b66</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x00</span>&#125;,<span class="comment">//c67</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x88</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//d68</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x00</span>&#125;,<span class="comment">//e69</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//f70</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x6B</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x93</span>,<span class="number">0x60</span>,<span class="number">0x00</span>&#125;,<span class="comment">//g71</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//h72</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//i73</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//j74</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x02</span>,<span class="number">0x2D</span>,<span class="number">0x30</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//k75</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//l76</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>&#125;,<span class="comment">//m77</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//n78</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//o79</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xFF</span>,<span class="number">0xA1</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//p80</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xA0</span>,<span class="number">0xFF</span>,<span class="number">0x80</span>&#125;,<span class="comment">//q81</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//r82</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x00</span>&#125;,<span class="comment">//s83</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xE0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//t84</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//u85</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x0E</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//v86</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x0F</span>,<span class="number">0x30</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//w87</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x31</span>,<span class="number">0x2E</span>,<span class="number">0x0E</span>,<span class="number">0x31</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//x88</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x81</span>,<span class="number">0x8E</span>,<span class="number">0x70</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//y89</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//z90</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x7C</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>&#125;,<span class="comment">//&#123;91</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//|92</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x7C</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&#125;93</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//~94</span></span><br><span class="line">&#125;;     </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>发送页&#x2F;列地址</p>
</li>
<li><p>发送数据</p>
</li>
</ol>
<h2><span id="3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi">3.3 SPI-OLED驱动-GPIO模拟SPI方式</span><a href="#3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi" class="header-anchor">#</a></h2><h3><span id="3-3-1-ruan-jian-ceng-ci">3.3.1 软件层次</span><a href="#3-3-1-ruan-jian-ceng-ci" class="header-anchor">#</a></h3><p>操作OLED，通过三条线(SCK、DO、CS)与OLED相连，这里没有DI是因为s3c2440只会向OLED传数据而不用接收数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpio_spi.c来实现gpio模拟spi，负责spi通讯。对于OLED，有专门的指令和数据格式，要传输的数据内容。</span><br><span class="line">oled.c这一层来实现，负责组织数据。</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-2-gpio-spi-c">3.3.2 gpio_spi.c</span><a href="#3-3-2-gpio-spi-c" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/20.png" alt="img"></p>
<h4><span id="3-3-2-1-spi-yin-jiao-chu-shi-hua">3.3.2.1 spi引脚初始化</span><a href="#3-3-2-1-spi-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h4><p>上图J3为板子pin2pin到OLED的底座。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPF1作为OLED片选引脚，设置为输出；</span><br><span class="line">GPG4作为OLED的数据(Data)/命令(Command)选择引脚，设置为输出；</span><br><span class="line">GPG5作为SPI的MISO，设置为输入（实际用不到）；</span><br><span class="line">GPG6作为SPI的MOSI，设置为输出；</span><br><span class="line">GPG7作为SPI的时钟CLK，设置为输出；</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/21.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/22.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPIInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 初始化引脚 */</span></span><br><span class="line">    SPI_GPIO_Init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* GPF1 as OLED_CSn output */</span></span><br><span class="line">    GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);<span class="comment">//取消OLED_CSn片选，pull up</span></span><br><span class="line">   <span class="comment">/* GPG2 FLASH_CSn output</span></span><br><span class="line"><span class="comment">    * GPG4 OLED_DC   output</span></span><br><span class="line"><span class="comment">    * GPG5 SPIMISO   input</span></span><br><span class="line"><span class="comment">    * GPG6 SPIMOSI   output</span></span><br><span class="line"><span class="comment">    * GPG7 SPICLK    output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGCON |= ((<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//取消FLASH_CSn 片选，pull up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-2-xie-ming-ling">3.3.2.2 写命令</span><a href="#3-3-2-2-xie-ming-ling" class="header-anchor">#</a></h4><p>D&#x2F;C即数据(Data)&#x2F;命令(Command)选择引脚，它为高电平时，OLED即认为收到的是数据；它为低电平时，OLED即认为收到的是命令。先设置为命令模式，再片选OLED，再传输命令，再恢复成原来的模式和取消片选。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/23.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_DO</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_CLK</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">        SPI_Set_DO(val &amp; <span class="number">0x80</span>);<span class="comment">//MSB</span></span><br><span class="line">        SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">        val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_DC</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_CS</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">0</span>); <span class="comment">/* command */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line">    SPISendByte(cmd);</span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  gpio output default is pull up*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>拉低DC引脚表示要发送是命令；</p>
</li>
<li><p>片选</p>
</li>
<li><p>发送1byte数据</p>
</li>
</ol>
<h5><span id="3-3-2-2-1-spisendbyte">3.3.2.2.1 SPISendByte</span><a href="#3-3-2-2-1-spisendbyte" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/24.png" alt="img"><br>SPISendByte是把一个byte数据从高位往低位依次发送到DO。spi配置模式0， 主控先设置CLK为低，由于是MSB, 先传送高位，然后CLK为高，在CLK这个上升沿,DO的数据被锁存，OLED就读取了一位数据。接着左移一位，传输下一位。通过SPI_Set_CLK()和SPI_Set_DO()配置SCK和DO的时序，用gpio模拟出了spi。至此，SPI初始化和OLED初始化就基本完成了，接下来就是OLED显示部分。</p>
<p>这里gpio模拟spi传送时主控没有加延时控制SCK的频率，那是由于s3c2440本身cpu运行就很慢，这里不延时也是能满足该款外设的spi传输时序，如果cpu很快，那么需要控制spi时序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每隔一个SPI时钟，发送1位数据，MSB-高位先出</span></span><br><span class="line"><span class="comment">//这里的SPI时钟并没有指定周期，这就取决于指令执行的速率，指令执行越快，gpio模拟的SPI时钟越快,如下：     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">              SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">              SPI_Set_DO(val &amp; <span class="number">0x80</span>);<span class="comment">//MSB</span></span><br><span class="line">              SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">              val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>取消片选</li>
<li>DC拉高</li>
</ol>
<h4><span id="3-3-2-3-xie-shu-ju">3.3.2.3 写数据</span><a href="#3-3-2-3-xie-shu-ju" class="header-anchor">#</a></h4><p>与写命令同理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data)</span>&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/* data*/</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line">    SPISendByte(data);</span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-oled-c">3.2.3 oled.c</span><a href="#3-2-3-oled-c" class="header-anchor">#</a></h3><h4><span id="3-2-3-1-chu-shi-hua-oled">3.2.3.1 初始化OLED</span><a href="#3-2-3-1-chu-shi-hua-oled" class="header-anchor">#</a></h4><p>找到<strong>QG-2864TMBEG01</strong> 的power on sequence-上电时序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OLEDInit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 向OLED发命令以初始化 */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAE</span>); <span class="comment">/*display off*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>); <span class="comment">/*set lower column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span>); <span class="comment">/*set higher column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x40</span>); <span class="comment">/*set display start line*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span>); <span class="comment">/*set page address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x81</span>); <span class="comment">/*contract control*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x66</span>); <span class="comment">/*128*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA1</span>); <span class="comment">/*set segment remap*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA6</span>); <span class="comment">/*normal / reverse*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA8</span>); <span class="comment">/*multiplex ratio*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xC8</span>); <span class="comment">/*Com scan direction*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD3</span>); <span class="comment">/*set display offset*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD5</span>); <span class="comment">/*set osc division*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x80</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD9</span>); <span class="comment">/*set pre-charge period*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x1f</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xDA</span>); <span class="comment">/*set COM pins*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x12</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xdb</span>); <span class="comment">/*set vcomh*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x30</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x8d</span>); <span class="comment">/*set charge pump enable*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-3-2-qu-dong-xian-shi-oled">3.2.3.2 驱动显示OLED</span><a href="#3-2-3-2-qu-dong-xian-shi-oled" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPutChar</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 得到字模 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line">    <span class="comment">/* 发给OLED */</span></span><br><span class="line">    OLEDSetPos(page, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i]);</span><br><span class="line">    OLEDSetPos(page+<span class="number">1</span>, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i+<span class="number">8</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPrint</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i]) &#123;</span><br><span class="line">        OLEDPutChar(page, col, str[i]);</span><br><span class="line">        col += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">127</span>) &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            page += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDClear</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> page, i;</span><br><span class="line">    <span class="keyword">for</span> (page = <span class="number">0</span>; page &lt; <span class="number">8</span>; page ++) &#123;</span><br><span class="line">        OLEDSetPos(page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            OLEDWriteDat(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-4-wan-zheng-dai-ma">3.3.4 完整代码</span><a href="#3-3-4-wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************** gpio_spi.c ****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 用GPIO模拟SPI */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* GPF1 OLED_CSn output */</span></span><br><span class="line">    GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* GPG2 FLASH_CSn output</span></span><br><span class="line"><span class="comment">    * GPG4 OLED_DC   output</span></span><br><span class="line"><span class="comment">    * GPG5 SPIMISO   input</span></span><br><span class="line"><span class="comment">    * GPG6 SPIMOSI   output</span></span><br><span class="line"><span class="comment">    * GPG7 SPICLK    output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGCON |= ((<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_CLK</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_DO</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">        SPI_Set_DO(val &amp; <span class="number">0x80</span>);</span><br><span class="line">        SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">        val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">SPIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化引脚 */</span></span><br><span class="line">    SPI_GPIO_Init();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/******************* oled.c****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio_spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_DC</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_CS</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">0</span>); <span class="comment">/* command */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line"> </span><br><span class="line">    SPISendByte(cmd);</span><br><span class="line"> </span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/* data */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line"> </span><br><span class="line">    SPISendByte(dat);</span><br><span class="line"> </span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPageAddrMode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x20</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x02</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line"> </span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDClear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> page, i;</span><br><span class="line">    <span class="keyword">for</span> (page = <span class="number">0</span>; page &lt; <span class="number">8</span>; page ++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLEDSetPos(page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            OLEDWriteDat(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 向OLED发命令以初始化 */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAE</span>); <span class="comment">/*display off*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>); <span class="comment">/*set lower column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span>); <span class="comment">/*set higher column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x40</span>); <span class="comment">/*set display start line*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span>); <span class="comment">/*set page address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x81</span>); <span class="comment">/*contract control*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x66</span>); <span class="comment">/*128*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA1</span>); <span class="comment">/*set segment remap*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA6</span>); <span class="comment">/*normal / reverse*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA8</span>); <span class="comment">/*multiplex ratio*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xC8</span>); <span class="comment">/*Com scan direction*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD3</span>); <span class="comment">/*set display offset*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD5</span>); <span class="comment">/*set osc division*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x80</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD9</span>); <span class="comment">/*set pre-charge period*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x1f</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xDA</span>); <span class="comment">/*set COM pins*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x12</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xdb</span>); <span class="comment">/*set vcomh*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x30</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x8d</span>); <span class="comment">/*set charge pump enable*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x14</span>);</span><br><span class="line"> </span><br><span class="line">    OLEDSetPageAddrMode();</span><br><span class="line"> </span><br><span class="line">    OLEDClear();</span><br><span class="line">     </span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAF</span>); <span class="comment">/*display ON*/</span>   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPutChar</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 得到字模 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 发给OLED */</span></span><br><span class="line">    OLEDSetPos(page, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i]);</span><br><span class="line"> </span><br><span class="line">    OLEDSetPos(page+<span class="number">1</span>, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i+<span class="number">8</span>]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPrint</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        OLEDPutChar(page, col, str[i]);</span><br><span class="line">        col += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">127</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            page += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-UART体系</title>
    <url>/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-uart-ying-jian-jie-shao">1 uart硬件介绍</a></li>
<li><a href="#2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</a></li>
<li><a href="#3-uart-chuan-shu-yuan-li">3 UART传输原理</a><ul>
<li><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</a><ul>
<li><a href="#3-1-1-rs232">3.1.1 RS232</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-uart-kong-zhi-qi">4 UART控制器</a></li>
<li><a href="#5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</a><ul>
<li><a href="#5-1-chu-shi-hua-uart">5.1 初始化UART</a><ul>
<li><a href="#5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</a></li>
<li><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</a><ul>
<li><a href="#5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</a></li>
<li><a href="#5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</a></li>
<li><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-putchar-getchar">5.2 putchar&#x2F;getchar</a></li>
<li><a href="#5-3-puts">5.3 puts</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-uart-ying-jian-jie-shao">1 uart硬件介绍</span><a href="#1-uart-ying-jian-jie-shao" class="header-anchor">#</a></h1><p>UART的全称是Universal Asynchronous Receiver and Transmitter（异步收发器)。 uart主要用于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.打印调试</span><br><span class="line">2.数据传输</span><br></pre></td></tr></table></figure>
<p>串口通过三根线即可，发送、接收、地线。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/1.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pc的TxD -&gt; arm的RxD (UART write)</span><br><span class="line">arm的TxD -&gt; pc的RxD  (UART <span class="built_in">read</span>)</span><br></pre></td></tr></table></figure>
<h1><span id="2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</span><a href="#2-uart-de-can-shu-he-ge-shi" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">波特率：表示每秒传输多少bit，bits per second(bps).一般波特率都会有9600,19200,115200等选项。</span><br><span class="line">起始位: 先发出一个逻辑”0”的信号，表示传输数据的开始。</span><br><span class="line">数据位：可以是5~8位逻辑”0”或”1”。一般7位，刚好可以传输所有ASCII码。</span><br><span class="line">校验位：</span><br><span class="line">	奇校验：（校验位+数据位）使得“1”的位数为奇数</span><br><span class="line">	偶校验：（校验位+数据位）使得“1”的位数为偶数</span><br><span class="line">	举个栗子：</span><br><span class="line">	‘A’的ASCII值是0x41,二进制就是01000001,那么奇校验就在校验位写‘1’,偶校验就在校验位写‘0’	</span><br><span class="line">停止位：它是一个字符数据的结束标志。</span><br></pre></td></tr></table></figure>
<h1><span id="3-uart-chuan-shu-yuan-li">3 UART传输原理</span><a href="#3-uart-chuan-shu-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</span><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a" class="header-anchor">#</a></h2><p>‘A’的ASCII值是0x41#,二进制就是01000001，怎样把这8位数据发送给PC机呢？</p>
<pre><code>1.双方约定好波特率（每一位占据的时间）
2.规定传输协议
</code></pre>
<p>现在处于这种模式：arm的TxD -&gt; pc的RxD  (UART read)</p>
<pre><code>1.arm拉低uart总线1bit的时间（起始位）
2.arm根据数据位依次驱动TxD的电平，同时PC依次读取uart总线，数据到达PC的RxD引脚，pc依次获得数据位
</code></pre>
<p>为了能够进行远距离的传输数据，我们的PC是使用的RS-232逻辑电平，而arm开发板使用的TTL&#x2F;CMOS逻辑电平。这里先讲解下什么是TTL逻辑电平，什么是RS-232逻辑电平。</p>
<p>TTL&#x2F;CMOS逻辑电平：</p>
<pre><code>0（低电平0-0.7v）表示逻辑&#39;0&#39;
1（高电平2-5v）  表示逻辑&#39;1&#39;
</code></pre>
<p>RS-232逻辑电平：</p>
<pre><code>(+3V ~ +12V) 表示逻辑&#39;0&#39;
(-12V ~ -3V) 表示逻辑&#39;1&#39;
</code></pre>
<p>TTL逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/2.jpg"><br>RS232逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/3.jpg"></p>
<p>那么在起始信号开始后开始计时，arm每隔一个时钟往TxD放1bit数据，同时pc也从RxD get 1bit数据.</p>
<pre><code>    arm				pc
TxD=data[0:]，    data[0:]=RxD
TxD=data[1:]，    data[1:]=RxD
...	
TxD=data[7:]，    data[7:]=RxD
</code></pre>
<h3><span id="3-1-1-rs232">3.1.1 RS232</span><a href="#3-1-1-rs232" class="header-anchor">#</a></h3><p>我们知道RS232的逻辑’0’和逻辑’1’相差较大，比TTL&#x2F;CMOS差距大，那么逻辑电平不容易出现反转，能传输更远的距离，在工业上用得比较多。</p>
<p>所以我们上面PC拿到的数据是不对的,那么需要一个TTL转RS232的电平转换芯片。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/4.jpg"></p>
<h1><span id="4-uart-kong-zhi-qi">4 UART控制器</span><a href="#4-uart-kong-zhi-qi" class="header-anchor">#</a></h1><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/5.png"></p>
<p>发送数据：<br>    内存将数据放入发送FIFO（64byte），通过发送移位器将数据一位一位的依次发送到TXDn，这样PC就可以从总线上依次get到数据。</p>
<p>接收数据：<br>    当pc的TXDn端将数据发送到总线后，arm获取RXDn的引脚电平依次get到数据，逐位放进接收移位器，再放入FIFO，写入内存。</p>
<p>当然,也可不使用fifo,直接让内存与移位器交互，不过这样会造成浪费内存资源，内存的频率是很高滴，降低了内存的吞吐量。</p>
<h1><span id="5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</span><a href="#5-uart-kong-zhi-qi-bian-cheng" class="header-anchor">#</a></h1><p>s3c2440支持3个UART串口，以uart0为例讲解。<br>那么我们需要实现以下这几个函数完成串口的最基本功能：	</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）uart0_init()用于初始化串口</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">putchar</span>()用于发送一个字符</span><br><span class="line">（<span class="number">3</span>）getchar()用于接收一个字符</span><br><span class="line">（<span class="number">4</span>）<span class="built_in">puts</span>()用于发送一串字符</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-chu-shi-hua-uart">5.1 初始化UART</span><a href="#5-1-chu-shi-hua-uart" class="header-anchor">#</a></h2><h3><span id="5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</span><a href="#5-1-1-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h3><p>配置uart0引脚</p>
<ol>
<li>根据原理图GPH2,3用于TxD0, RxD0。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/6.png"></li>
<li>查看dataset,配置GPH控制寄存器，让GPH2,3配成uart模式；为了将其保持为高电平，先设置其为上拉。<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br></pre></td></tr></table></figure>
<img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/7.png"></li>
</ol>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/8.png"></p>
<h3><span id="5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</span><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</span><a href="#5-1-2-1-she-zhi-shi-zhong-yuan" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 时钟源选择PCLK,中断/查询模式 */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/9.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/10.png"></p>
<h4><span id="5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</span><a href="#5-1-2-2-she-zhi-bo-te-lu" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* uart clock=50M，假设我们想要波特率=115200，</span></span><br><span class="line"><span class="comment">** 根据公式UBRDIVn = (int)(UART clock/( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment">** 得到UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/11.png"></p>
<h4><span id="5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</span><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/12.png"><br>数据格式设置为常用的8n1，表示8个数据位, 无较验位, 1个停止位</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位（数据+校验）, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure>
<h2><span id="5-2-putchar-x2f-getchar">5.2 putchar&#x2F;getchar</span><a href="#5-2-putchar-x2f-getchar" class="header-anchor">#</a></h2><pre><code>putchar就是向发送寄存器(UTXH0)写入值进去。
getchar就是从接受寄存器(URXH0)取出值。
无论是getchar还是putchar都可以通过读取状态寄存器（UTRSTAT0）来作为传输结束判断标志。
</code></pre>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/13.png"></p>
<pre><code>查询其第2位判断发送buff是否为空，即上一次发送是否完成，如果完成即向UTXH0写入要发送的新数据；
查询其第0位判断接收buff是否有数据接受到，如果有数据接收到，返回接收buffer的值。
</code></pre>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">putchar</span>(<span class="params"><span class="built_in">int</span> c</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">	UTXH0 = (unsigned <span class="built_in">char</span>)c;	</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getchar</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line">	<span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-3-puts">5.3 puts</span><a href="#5-3-puts" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">puts</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *s</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*s)&#123;</span><br><span class="line">		putchar(*s);</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
        <tag>boot启动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-nandflash</title>
    <url>/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nandflash-yuan-li">1 nandflash原理</a><ul>
<li><a href="#1-1-yuan-li-tu">1.1 原理图</a></li>
<li><a href="#1-2-yin-jiao-miao-shu">1.2 引脚描述</a></li>
<li><a href="#1-3-nand-cun-chu-jie-gou">1.3 nand存储结构</a><ul>
<li><a href="#1-3-1-block-kuai">1.3.1 Block块</a></li>
<li><a href="#1-3-2-page-ye">1.3.2 Page页</a></li>
<li><a href="#1-3-3-oob-qu-yu">1.3.3 oob区域</a></li>
<li><a href="#1-3-4-cun-chu-dan-wei-guan-xi">1.3.4 存储单位关系</a></li>
</ul>
</li>
<li><a href="#1-4-feature-te-xing">1.4 Feature特性</a></li>
<li><a href="#1-5-chang-jian-de-flash-han-shang">1.5 常见的flash厂商</a></li>
</ul>
</li>
<li><a href="#2-nand-kong-zhi-qi">2 Nand控制器</a><ul>
<li><a href="#2-1-om-qi-dong-jie-zhi-xuan-ze">2.1 OM启动介质选择</a></li>
<li><a href="#2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi">2.2 nand控制器引脚配置</a></li>
</ul>
</li>
<li><a href="#3-nand-kong-zhi-qi-fang-wen-shi-xu">3 Nand控制器访问时序</a><ul>
<li><a href="#3-1-ming-ling-di-zhi-suo-cun-shi-xu-xie-ming-ling-di-zhi">3.1 命令&#x2F;地址锁存时序(写命令&#x2F;地址)</a><ul>
<li><a href="#3-1-1-k9f2g08u0c-ming-ling-di-zhi-suo-cun-shi-xu">3.1.1 K9F2G08U0C命令&#x2F;地址锁存时序</a></li>
</ul>
</li>
<li><a href="#3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju">3.2 数据锁存时序(写数据)</a></li>
<li><a href="#3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju">3.3 数据顺序读时序(读数据)</a></li>
</ul>
</li>
<li><a href="#4-nandflash-chu-shi-hua-he-shi-bie">4 nandFlash初始化和识别</a><ul>
<li><a href="#4-1-nandflash-ming-ling-biao">4.1 nandFlash命令表</a></li>
<li><a href="#4-2-du-id-shi-xu">4.2 读ID时序</a></li>
<li><a href="#4-3-chu-shi-hua">4.3 初始化</a><ul>
<li><a href="#4-3-1-chu-shi-hua-nand-kong-zhi-qi">4.3.1 初始化nand控制器</a><ul>
<li><a href="#4-3-1-1-nfconf-pei-zhi-ji-cun-qi">4.3.1.1 NFCONF-配置寄存器</a></li>
<li><a href="#4-3-1-2-nfcont-kong-zhi-ji-cun-qi">4.3.1.2 NFCONT-控制寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-4-shi-bie-nandflash">4.4 识别nandflash</a><ul>
<li><a href="#4-4-1-nfcmmd-ming-ling-ji-cun-qi">4.4.1 NFCMMD-命令寄存器</a></li>
<li><a href="#4-4-2-nfdata-shu-ju-ji-cun-qi">4.4.2 NFDATA-数据寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-nandflash-shu-ju-cao-zuo">5 NandFlash数据操作</a><ul>
<li><a href="#5-1-du-shu-ju">5.1 读数据</a><ul>
<li><a href="#5-1-1-nfstat-zhuang-tai-ji-cun-qi">5.1.1 NFSTAT-状态寄存器</a></li>
<li><a href="#5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong">5.1.2 自动识别是nor还是nand启动</a></li>
</ul>
</li>
<li><a href="#5-2-ca-shu-ju">5.2 擦数据</a></li>
<li><a href="#5-3-xie-shu-ju">5.3 写数据</a></li>
<li><a href="#5-4-ce-shi">5.4 测试</a></li>
<li><a href="#5-5-pi-kuai-de-biao-ji-he-jie-chu">5.5 坏快的标记和解除</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nandflash-yuan-li">1 nandflash原理</span><a href="#1-nandflash-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-yuan-li-tu">1.1 原理图</span><a href="#1-1-yuan-li-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/1.png"></p>
<h2><span id="1-2-yin-jiao-miao-shu">1.2 引脚描述</span><a href="#1-2-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/2.png"></p>
<table>
<thead>
<tr>
<th>引脚名称</th>
<th>引脚功能</th>
</tr>
</thead>
<tbody><tr>
<td>IO0~IO7</td>
<td>数据输入输出（命令、地址、数据共用数据总线）</td>
</tr>
<tr>
<td>CLE</td>
<td>命令使能</td>
</tr>
<tr>
<td>ALE</td>
<td>地址使能</td>
</tr>
<tr>
<td>&#x2F;CE</td>
<td>芯片使能（片选）</td>
</tr>
<tr>
<td>&#x2F;RE</td>
<td>读使能</td>
</tr>
<tr>
<td>&#x2F;WE</td>
<td>写使能</td>
</tr>
<tr>
<td>R&#x2F;B</td>
<td>就绪&#x2F;忙输出信号（低电平表示操作还在进行中，高电平表示操作完成）</td>
</tr>
</tbody></table>
<h2><span id="1-3-nand-cun-chu-jie-gou">1.3 nand存储结构</span><a href="#1-3-nand-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/3.png"></p>
<p>我们常见的Nand Flash，内部只有一个chip，每个chip只有一个plane。但也有些复杂的，容量更大的Nand Flash，内部有多个chip，每个chip有多个plane，这类的Nand Flash，其实就是多了一个主控将多块flash叠加在一起，如下图：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/4.png"></p>
<h3><span id="1-3-1-block-kuai">1.3.1 Block块</span><a href="#1-3-1-block-kuai" class="header-anchor">#</a></h3><p>一个Nand Flash由很多个块（Block）组成，块的大小一般有64K，128KB，256KB，512KB，<strong>Block是Nand Flash的擦除操作的基本&#x2F;最小单位</strong>。Nand Flash中，一个块中含有1个或多个位是坏的，就称为其为<strong>坏块Bad Block</strong>。</p>
<h3><span id="1-3-2-page-ye">1.3.2 Page页</span><a href="#1-3-2-page-ye" class="header-anchor">#</a></h3><p>每个块里面又包含了很多页（page）。每个页的大小，对于现在常见的Nand Flash多数是2KB，当然也有的nand flash的页大小为4KB、8KB等。<strong>页Page，是读写操作的基本单位</strong>。</p>
<h3><span id="1-3-3-oob-qu-yu">1.3.3 oob区域</span><a href="#1-3-3-oob-qu-yu" class="header-anchor">#</a></h3><p>每一个page页，对应还附加了一块区域，一般为64byte，叫做空闲区域（spare area）&#x2F;oob区域（Out Of Band），由于nandflash在操作过程中容易产生位反转，这是nandflash的物理特性决定的，所以必须要有对应的检测和纠错机制，这种机制被叫做Error Checking and Correcting，所以设计了多余的oob区域，<strong>用于放置数据的校验值</strong>。oob的读写操作，一般是随着页的操作一起完成的，即读写页的时候，对应地就读写了oob。</p>
<p>关于oob具体用途，总结起来有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标记是否是坏快</span><br><span class="line">存储ECC数据</span><br><span class="line">存储一些和文件系统相关的数据。如jffs2就会用到这些空间存储一些特定信息</span><br></pre></td></tr></table></figure>

<h3><span id="1-3-4-cun-chu-dan-wei-guan-xi">1.3.4 存储单位关系</span><a href="#1-3-4-cun-chu-dan-wei-guan-xi" class="header-anchor">#</a></h3><p>一般情况下：1block &#x3D; 64page &#x3D; 64 * (2K+64B) &#x3D; 128K + 4K， 一个page包含2K数据和64B的oob。</p>
<h2><span id="1-4-feature-te-xing">1.4 Feature特性</span><a href="#1-4-feature-te-xing" class="header-anchor">#</a></h2><p>以<strong>K9F2G08U0C</strong>这款nandflash为例：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/5.png"></p>
<p>可以看出此款nandflash特性如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 容量为<span class="number">256</span>M，外加<span class="number">8</span>M的冗余oob存储区。</span><br><span class="line"><span class="number">2.</span> page大小为<span class="number">2</span>K，block大小为<span class="number">128</span>K</span><br><span class="line"><span class="number">3.</span> 读一个page时顺序读取至少<span class="number">25</span>*<span class="number">2048</span>ns(数据可以每字节<span class="number">25</span>ns的循环时间读出)，随机读取不超过<span class="number">40u</span>s</span><br><span class="line"><span class="number">4.</span> 写一个page一般为<span class="number">250u</span>s</span><br><span class="line"><span class="number">5.</span> 擦除一个block一般为<span class="number">2</span>ms</span><br><span class="line"><span class="number">6.</span> 封装上分为TSOP分装和FBGA封装（TSOP是指引脚在侧面，FBGA是引脚封在芯片底部，更能保障数据安全，有些客户为了保障数据安全性，防止被飞线进行数据破解，会要求用FBGA封装的flash）</span><br></pre></td></tr></table></figure>

<h2><span id="1-5-chang-jian-de-flash-han-shang">1.5 常见的flash厂商</span><a href="#1-5-chang-jian-de-flash-han-shang" class="header-anchor">#</a></h2><p>常见的flash厂商有：Micron（镁光）、Toshiba（东芝）、Samsung（三星）、MXIC(旺宏)、dosilicon(东芯)，（Winbond）华邦、ESMT等。</p>
<h1><span id="2-nand-kong-zhi-qi">2 Nand控制器</span><a href="#2-nand-kong-zhi-qi" class="header-anchor">#</a></h1><p>前面<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>介绍讲到，我们知道nand没有独立地址线，cpu无法直接访问nand上的指令，所以nand不能片上执行。那么为何程序还能支持nand启动的呢？</p>
<p>为了支持NAND启动，S3C2440A配备了一个称为“ Steppingstone”的内部SRAM缓冲区,容量为4K。 开机时，Nandflash中的前4K数据将被加载到Steppingstone中，而引导代码将被加载到SRAM中将被执行，如下图所示：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/6.png"></p>
<h2><span id="2-1-om-qi-dong-jie-zhi-xuan-ze">2.1 OM启动介质选择</span><a href="#2-1-om-qi-dong-jie-zhi-xuan-ze" class="header-anchor">#</a></h2><p>我们知道s3c2440支持2种boot方式，nand或者nor，那么需要配置OM引脚来设置引导方式，如下图：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/7.png"></p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/8.png"></p>
<p>内存控制器的地址映射表如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/9.png"></p>
<p>当SW2闭合,OM0&#x3D;1, OM[1:0]&#x3D;01, 0地址对应nor，那么从nor启动。<br>当SW2断开,OM0&#x3D;0, OM[1:0]&#x3D;00, 0地址对应bootSRAM(4K)，那么0地址对应该SRAM, 那么从nand启动。</p>
<h2><span id="2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi">2.2 nand控制器引脚配置</span><a href="#2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi" class="header-anchor">#</a></h2><p>当上电启动时，NAND Flash 控制器将通过下面的引脚配置来获取连接的 NAND Flash 的信息。</p>
<p><strong>NCON</strong>：NAND Flash 存储器选择（普通&#x2F;先进）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：普通 NAND Flash（<span class="number">256</span> 字或 <span class="number">512</span> 字节页大小，<span class="number">3</span> 或 <span class="number">4</span> 个地址周期）</span><br><span class="line"><span class="number">1</span>：先进 NAND Flash（<span class="number">1</span>K 字或 <span class="number">2</span>K 字节页大小，<span class="number">4</span> 或 <span class="number">5</span> 个地址周期）</span><br></pre></td></tr></table></figure>

<p><strong>GPG13</strong>：NAND Flash 存储器page size选择</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：页=<span class="number">256</span> 字（NCON=<span class="number">0</span>）或页=<span class="number">1</span>K 字（NCON=<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span>：页=<span class="number">512</span> 字节（NCON=<span class="number">0</span>）或页=<span class="number">2</span>K 字节（NCON=<span class="number">1</span>）</span><br></pre></td></tr></table></figure>

<p><strong>GPG14</strong>：NAND Flash 存储器地址周期选择</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">3</span> 个地址周期（NCON=<span class="number">0</span>）或 <span class="number">4</span> 个地址周期（NCON=<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span>：<span class="number">4</span> 个地址周期（NCON=<span class="number">0</span>）或 <span class="number">5</span> 个地址周期（NCON=<span class="number">1</span>）</span><br></pre></td></tr></table></figure>
<p><strong>GPG15</strong>：NAND Flash 存储器总线宽度选择</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">8</span> 位宽度</span><br><span class="line"><span class="number">1</span>：<span class="number">16</span> 位宽度</span><br></pre></td></tr></table></figure>
<p>如下表所示更直观:<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/10.png"></p>
<h1><span id="3-nand-kong-zhi-qi-fang-wen-shi-xu">3 Nand控制器访问时序</span><a href="#3-nand-kong-zhi-qi-fang-wen-shi-xu" class="header-anchor">#</a></h1><p>nandflash访问时需要遵循一定的时序才能完成命令、地址、数据的发送。nandflash有8bit位宽数据总线，那么没有地址线它是怎么和cpu通信的呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>nandflash是DATA0～DATA7上既传输数据，又传输地址，又传输命令；</span><br><span class="line">	①当ALE为高电平时传输的是地址；</span><br><span class="line">	②当CLE为高电平时传输的是命令；</span><br><span class="line">	③当ALE，CLE都为低电平表示传输的是数据</span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span> 先发送片选CS和WE/RE信号</span><br><span class="line"> <span class="number">3.</span> 再发送CLE</span><br><span class="line"> <span class="number">4.</span> 再发送ALE</span><br><span class="line"> <span class="number">5.</span> 最后发送数据</span><br></pre></td></tr></table></figure>

<p>下面分别介绍命令、地址、数据的发送过程。</p>
<h2><span id="3-1-ming-ling-x2f-di-zhi-suo-cun-shi-xu-xie-ming-ling-x2f-di-zhi">3.1 命令&#x2F;地址锁存时序(写命令&#x2F;地址)</span><a href="#3-1-ming-ling-x2f-di-zhi-suo-cun-shi-xu-xie-ming-ling-x2f-di-zhi" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/11.png"></p>
<ol>
<li>首先看时钟，nand控制器的时钟源采用的是HCLK, 也就是AHB高速总线模式，可以参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a>那么HCLK&#x3D;100Mhz, T&#x3D;1&#x2F;HCLK&#x3D;10ns。</li>
<li>从上图可知命令、地址锁存的时序是一样的，复用一个时序图，当到达①的位置时，CLE&#x2F;ALE&#x3D;0; </li>
<li>当到达位置②时，CLE&#x2F;ALE&#x3D;1,表示命令&#x2F;地址信号拉高，命令&#x2F;地址开始使能，然后往数据总线DATA上放入命令或地址;</li>
<li>经过TACLS时间，到达位置③时，拉低nWE引脚，这时数据总线DATA上的命令&#x2F;地址开始被锁存，锁存需要一定的时间，所以经过TWRPH0时间后，数据总线DATA上的命令&#x2F;地址锁存完成；</li>
<li>到达位置④，此时释放nWE信号，nWE&#x3D;1，这时还需要经过TWRPH1时间后，释放CLE&#x2F;ALE，此时一个完整的命令&#x2F;地址锁存过程完成。</li>
</ol>
<p>上面分析了命令&#x2F;地址的锁存时序过程，下面详细解释下上面几个时间参数的含义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TACLS：CLE/ALE使能信号发送多久后才可以发送nWE信号</span><br><span class="line">TWRPH0:nWE信号发送多久后数据（commamd/addr）才会被锁存成功</span><br><span class="line">TWRPH1：nWE信号释放多久后才能释放CLE/ALE</span><br></pre></td></tr></table></figure>

<p>这些时间参数要根据我们实际使用的具体nandflash型号和性能来配置我们的nand控制器。</p>
<h3><span id="3-1-1-k9f2g08u0c-ming-ling-x2f-di-zhi-suo-cun-shi-xu">3.1.1 K9F2G08U0C命令&#x2F;地址锁存时序</span><a href="#3-1-1-k9f2g08u0c-ming-ling-x2f-di-zhi-suo-cun-shi-xu" class="header-anchor">#</a></h3><p>以K9F2G08U0C这款nandflash为例进行讲解，规格书上命令和地址锁存周期如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/12.png"></p>
<p>和nand控制器的命令&#x2F;地址锁存时序图对比发现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TACLS = max(tCLS,tALS) - tWP;</span><br><span class="line">TWRPH0 = tWP;</span><br><span class="line">TWRPH0 = max(tCLH,tALH);</span><br></pre></td></tr></table></figure>

<p>nand控制器把命令、地址锁存时序复用成了一个时序图，其实命令和地址锁存时序参数基本一致，只不过发命令只需要一个周期就OK了，发地址需要5个时钟周期，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你想，命令多简单，无非就是读写擦，像我们这款nand数据位宽8bit，一个周期绰绰有余。但地址就不一样了，比如此款nandflash容量256M = 2^28，那么需要28根数据线来传输才能一个周期传输完，但这款nandflash的数据总线位宽只有8bit, 只有8根数据线，所以需要把地址拆分成多次发送，先发送col地址，再发送row地址，此款nandflash是用了5个周期发送地址。</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju">3.2 数据锁存时序(写数据)</span><a href="#3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju" class="header-anchor">#</a></h2><p>从前面的命令地址锁存时序图中我们得知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLE信号拉高，ALE信号拉低时，表示发送的命令；</span><br><span class="line">CLE信号拉低，ALE信号拉高时，表示发送的地址；</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/13.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLE信号拉低, ALE信号拉低时，表示发送的数据;</span><br></pre></td></tr></table></figure>

<ol>
<li>当到达①时，nWE还是高电平，写使能没有开启；</li>
<li>当到达②,③时，那么经过了tWP时间（TDS时间），数据开始被锁存；</li>
<li>到达④，经过tDH时间，数据锁存完成;</li>
<li>到达⑤，也就是数据开始锁存后再过了tWH时间后释放nWE信号；</li>
<li>重复②③④⑤过程,得到DIN0, DIN1, DIN final。</li>
</ol>
<p>根据上面这三个图（手册上的命令、地址、数据锁存时序图），下面详细解释各个时间参数的含义：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/14.png"></p>
<h2><span id="3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju">3.3 数据顺序读时序(读数据)</span><a href="#3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/15.png"></p>
<ol>
<li>①处，表示要过tRR后才能发送读使能信号nRE进行访问（上一次的访问结束后，需要等待ready状态稳定后才可以进行下一次访问）；</li>
<li>当到达②，需要经过rREA时间后nRE信号才有效（待nRE稳定）；</li>
<li>当到达③，DATA总线上的读取被读取；</li>
<li>当到达④，nRE释放tREH时间后才允许下一次读使能；</li>
</ol>
<p>我们看到连续顺序访问时，单次访问的时间为tRC，那么这些时间参数的值也可以从K9F2G08U0C datasheet中找到：为25ns</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/16.png"></p>
<h1><span id="4-nandflash-chu-shi-hua-he-shi-bie">4 nandFlash初始化和识别</span><a href="#4-nandflash-chu-shi-hua-he-shi-bie" class="header-anchor">#</a></h1><h2><span id="4-1-nandflash-ming-ling-biao">4.1 nandFlash命令表</span><a href="#4-1-nandflash-ming-ling-biao" class="header-anchor">#</a></h2><p>找到K9F2G08U0C datasheet，对NAND FLASH的操作需要发出命令，下面有个NAND FLASH的命令表格，用此表格上的命令来访问我们的nandflash：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/17.png"></p>
<h2><span id="4-2-du-id-shi-xu">4.2 读ID时序</span><a href="#4-2-du-id-shi-xu" class="header-anchor">#</a></h2><p>命令表中的读id还不太直观，下图是从nand芯片手册中截取出的读id时序图：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/18.png"></p>
<ol>
<li>第一条竖线位置，发送了nCE,CLE,nWE信号，所以90命令被锁存（readID命令）；</li>
<li>第二条竖线位置，发送了nCE,ALE,nWE信号，所以地址00被锁存；继续往后，命令、地址都发完了，要read数据了，所以释放nWE，ALE，这里tAR表示ALE释放多久后才可以发送nRE信号，tREA表示nRE信号的建立时间；</li>
<li>第三条竖线位置，发送了nCE,nRE信号，所以数据被锁存，第一个访问周期锁存的数据为marker code，值为0xEC，第二个访问周期的数据为device code，值为0xDA。读id时读5个周期含义对应如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/19.png"></li>
</ol>
<p>该款nandflash的5个周期读出来的值对应如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/20.png"></p>
<p>第四个访问周期含义如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/21.png"></p>
<p>第五个访问周期含义如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/22.png"></p>
<p>根据第4、5个访问周期的结果0x15、0x44我们得知该flash的block_size&#x3D;128K，page_size&#x3D;2k, 有2个plane，plane_size&#x3D;1Gb &#x3D; 128M, 共256M。</p>
<h2><span id="4-3-chu-shi-hua">4.3 初始化</span><a href="#4-3-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="4-3-1-chu-shi-hua-nand-kong-zhi-qi">4.3.1 初始化nand控制器</span><a href="#4-3-1-chu-shi-hua-nand-kong-zhi-qi" class="header-anchor">#</a></h3><h4><span id="4-3-1-1-nfconf-pei-zhi-ji-cun-qi">4.3.1.1 NFCONF-配置寄存器</span><a href="#4-3-1-1-nfconf-pei-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p>nand控制器要按照我们nandflash的实际型号和性能来设置初始值。NFCONF寄存器，也叫nand配置寄存器：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/23.png"></p>
<p>以K9F2G08U0C这款nandflash为例：</p>
<p>前面<strong>第3.1.1小节</strong>分析了TACLS &#x3D; max(tCLS,tALS) - tWP，我们得知tCLS、tALS、tWP最小都可以取到12ns, 所以我们可以取TACLS&#x3D;0；</p>
<p>TWRPH0 &#x3D; tWP，我们的nand手册上要求tWP最少12ns, 那么取TWRPH0 &#x3D;1， Duration &#x3D; HCLK*(TWRPH0+1)&#x3D;20ns&gt;12ns，满足要求；</p>
<p>TWRPH0 &#x3D; max(tCLH,tALH), 我们的nand手册上要求tCLH、tALH最少5ns， 那么取TWRPH1 &#x3D;0， Duration &#x3D; HCLK*(TWRPH1+1)&#x3D;10ns&gt;5ns，满足要求。</p>
<p>再配置BusWidth总线位宽为8bit；<br>所以NFCONF寄存器设置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH0  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH1  0</span></span><br><span class="line"><span class="comment">/*设置NAND FLASH的时序*/</span></span><br><span class="line">NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="4-3-1-2-nfcont-kong-zhi-ji-cun-qi">4.3.1.2 NFCONT-控制寄存器</span><a href="#4-3-1-2-nfcont-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/24.png"><br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/25.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODE [<span class="number">0</span>]: 设置为<span class="number">1</span>，使能NAND控制器。</span><br><span class="line">Reg_nCE [<span class="number">1</span>]: 设置为<span class="number">1</span>，禁止片选（等要使用的时候再使能片选信号）</span><br></pre></td></tr></table></figure>

<p>所以NFCONF寄存器设置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使能NAND FLASH控制器，禁止片选*/</span></span><br><span class="line">NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2><span id="4-4-shi-bie-nandflash">4.4 识别nandflash</span><a href="#4-4-shi-bie-nandflash" class="header-anchor">#</a></h2><h3><span id="4-4-1-nfcmmd-ming-ling-ji-cun-qi">4.4.1 NFCMMD-命令寄存器</span><a href="#4-4-1-nfcmmd-ming-ling-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/26.png"></p>
<p>我们可以使用2440上的NAND FLASH控制器简化操作，只需要往NFCMMD寄存器写入要传输的命令就可以了，NAND FLASH控制器默认把上面复杂的时序发出来。</p>
<p>NFADDR-地址寄存器<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/27.png"><br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/28.png"></p>
<p>发命令后，后面就需要发送地址了，当nWE和ALE有效的时候，表示锁存的是地址，往NFADDR寄存器中写值就可以了，比如：NFADDR&#x3D;0x00。<br>我们得知地址需要用5个周期来发送，前2个周期为col地址，后三个周期为row(page)地址。前面<strong>第3小节</strong>已详细分析过了命令、地址、数据锁存时序过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> column: 列地址A0~A10，就是页内地址，地址范围是从<span class="number">0</span>到<span class="number">2047</span>。（A11用来确定oob的地址，即<span class="number">2048</span><span class="number">-2111</span>这<span class="number">64</span>个字节的范围）</span><br><span class="line"><span class="number">2.</span> page：A12～A30，称作页号，page(row)编号。</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-2-nfdata-shu-ju-ji-cun-qi">4.4.2 NFDATA-数据寄存器</span><a href="#4-4-2-nfdata-shu-ju-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/29.png"></p>
<p>当命令、地址都发送完后就可以从数据总线上DATA[7:0]获取数据或者写入数据。同样往NFDATA寄存器中写值或者读值就可以了，如unsigned char buf&#x3D;NFDATA,由于是数据位宽是8位的，所以访问时数据组织形式如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/30.png"></p>
<p>从上图可以看出，当byte access时，只需一个时钟周期；当wold access的时候，需要4个时钟周期，小端模式下第一个时钟周期对应低字节，第四个时钟周期对应高字节。</p>
<p>识别nandflash代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*初始化nand控制器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TACLS   0</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TWRPH0  1</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TWRPH1  0</span></span><br><span class="line">	NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使能片选*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_select</span><span class="params">(<span class="type">void</span>)</span> &#123;		</span><br><span class="line">	NFCONT &amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*禁止片选*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_deselect</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	NFCONT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发命令*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line">	NFCCMD = cmd;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发地址*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_addr_byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line">	NFADDR = addr;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/*读数据*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">nand_data</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>	NFDATA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*识别nandflash*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_chip_probe</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	nand_select(); </span><br><span class="line">	nand_cmd(<span class="number">0x90</span>);</span><br><span class="line">	nand_addr_byte(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">	buf[<span class="number">0</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">1</span>] = nand_data();	</span><br><span class="line">	buf[<span class="number">2</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">3</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">4</span>] = nand_data();	</span><br><span class="line">	nand_deselect(); 	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;maker   id  = 0x%x\n\r&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;device  id  = 0x%x\n\r&quot;</span>,buf[<span class="number">1</span>]);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">2</span>]);		</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4th byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">3</span>]);			</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;page  size  = %d kb\n\r&quot;</span>,<span class="number">1</span>  &lt;&lt;  (buf[<span class="number">3</span>] &amp; <span class="number">0x03</span>));	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;block size  = %d kb\n\r&quot;</span>,<span class="number">64</span> &lt;&lt; ((buf[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x03</span>));	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5th byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="5-nandflash-shu-ju-cao-zuo">5 NandFlash数据操作</span><a href="#5-nandflash-shu-ju-cao-zuo" class="header-anchor">#</a></h1><h2><span id="5-1-du-shu-ju">5.1 读数据</span><a href="#5-1-du-shu-ju" class="header-anchor">#</a></h2><p>读数据以page为单位的。下图的表格，来说明NAND FLASH内部结构，前面2K(0<del>2047)表示页数据，后边64字节(2048</del>2111)表示oob。</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/31.png"></p>
<p>CPU想读取，第2048个数据，它是哪以一个？</p>
<pre><code>是Page1的第0个字节。CPU使用某个地址访问数据的时候，是在页数据空间来寻址的。
</code></pre>
<p>下图为读NAND FLASH的read时序操作：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/32.png"></p>
<ol>
<li>首先需要锁存00命令，nCE、CLE、nWE有效，0x00命令被锁存；</li>
<li>此时CLE无效，ALE开始有效,地址被锁存（从NAND FLASH的地址周期中可以看出来，先发出2个周期的col列地址，再发出3个周期的Row行地址）；</li>
<li>锁存0x30命令；</li>
<li>然后会有一个busy时间段，R&#x2F;nB为低电平。tRR表示busy状态的持续时间（手册上最小为20ns）。</li>
<li>开始锁存数据，nRE使能，nand上的数据被同步到数据nand控制器上。我们的nand是8bit数据位宽，所以每隔一个read时钟周期（tRC），传输1byte数据。每传输1byte数据，地址会自动往后偏移1byte，一般我们会连续读取1page数据。</li>
</ol>
<p>下面开始写代码：</p>
<h3><span id="5-1-1-nfstat-zhuang-tai-ji-cun-qi">5.1.1 NFSTAT-状态寄存器</span><a href="#5-1-1-nfstat-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>当发完命令、地址后再进行读数据前我们知道有一段时间tRR处于busy状态，我们可以通过查询NFSTAT寄存器来确定busy状态有没有结束，是不是已经ready了。<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/33.png"></p>
<p>wait_ready函数等待NAND FLASH空闲，从上图可以看出当NFSTAT寄存器[0]的值为1时NAND FLASH是空闲的，我们可以通过该位来判断NAND FLASH是否繁忙。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	 <span class="keyword">while</span> (!(NFSTAT &amp; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nand_read函数为NAND FLASH的读函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	<span class="type">int</span> col  = addr &amp; (<span class="number">2048</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	nand_select(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">		<span class="comment">/* 发出00h命令 */</span></span><br><span class="line">		nand_cmd(<span class="number">00</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 发出地址 */</span></span><br><span class="line">		<span class="comment">/* col addr */</span></span><br><span class="line">		nand_addr_byte(col &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((col&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* row/page addr */</span></span><br><span class="line">		nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 发出30h命令 */</span></span><br><span class="line">		nand_cmd(<span class="number">0x30</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 等待就绪 */</span></span><br><span class="line">		wait_ready();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 读数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (; (col &lt; <span class="number">2048</span>) &amp;&amp; (i &lt; len); col++)</span><br><span class="line">			buf[i++] = nand_data();			</span><br><span class="line">		</span><br><span class="line">		col = <span class="number">0</span>;</span><br><span class="line">		page++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nand_deselect(); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到每read一个page，都要重新发送命令地址，因为这里是顺序访问，flash的读写都是以page为单位的。</p>
<h3><span id="5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong">5.1.2 自动识别是nor还是nand启动</span><a href="#5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong" class="header-anchor">#</a></h3><p>在init.c文件中，加上如下代码，用来判断所使用的FLASH是NOR FLASH还是NAND FLASH。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*我们知道nand启动0地址对应片内SRAM，可以像内存一样的写0地址；nor启动，0地址对应nor,nor不能像内存一样的写地址，</span></span><br><span class="line"><span class="comment">**所以往0地址写入数据成功表示nand启动，写不成功表示nor启动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isBootFromNorFlash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val = *p;</span><br><span class="line"></span><br><span class="line">	*p = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">if</span> (*p == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">		<span class="comment">/* 写成功, 对应nand启动 */</span></span><br><span class="line">		*p = val;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是代码重定位时可以自动区分nand和nor启动，无论是nand启动还是nor启动，都能将程序重定位到sdram中去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">            <span class="comment">/* 要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line"><span class="comment">            * 然后从0地址把数据复制到__code_start</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> len = (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;__bss_start) - (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;__code_start);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (isBootFromNorFlash()) &#123;</span><br><span class="line">              <span class="keyword">while</span> (dest &lt; end)</span><br><span class="line">                    *dest++ = *src++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	    nand_init();</span><br><span class="line">    	    nand_read((<span class="type">unsigned</span> <span class="type">int</span>)src, dest, len);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-2-ca-shu-ju">5.2 擦数据</span><a href="#5-2-ca-shu-ju" class="header-anchor">#</a></h2><p>擦除数据以block为单位的。block erase时序图的过程大致如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/34.png"></p>
<pre><code>1.首先发送0x60命令
2.发送row地址（由于擦除是以block为单位的，所以无需知道页内地址，只需要知道要擦除哪个page、哪个block即可）
3.发送0xd0,执行擦除动作
4.然后会有一个busy时间段，R/nB为低电平
5.发送0x70命令，用来读取状态
6.判断NFDATA寄存器的第0位是否擦除成功
</code></pre>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nand_erase</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">		<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (addr &amp; (<span class="number">0x1FFFF</span>)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, addr is not block align\n\r&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (len &amp; (<span class="number">0x1FFFF</span>)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, len is not block align\n\r&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		nand_select(); </span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			page = addr / <span class="number">2048</span>;</span><br><span class="line">			</span><br><span class="line">			nand_cmd(<span class="number">0x60</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/* page addr */</span></span><br><span class="line">			nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">			nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">			nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">	</span><br><span class="line">			nand_cmd(<span class="number">0xD0</span>);</span><br><span class="line">	</span><br><span class="line">			wait_ready();</span><br><span class="line">	</span><br><span class="line">			nand_cmd(<span class="number">0x70</span>);</span><br><span class="line">			<span class="keyword">if</span> (nand_data()&amp;<span class="number">0x1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, at addr:0x%x\n\r&quot;</span>, addr);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			len -= (<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">			<span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			addr += (<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		nand_deselect(); 	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-xie-shu-ju">5.3 写数据</span><a href="#5-3-xie-shu-ju" class="header-anchor">#</a></h2><p>写数据以page为单位。往NAND FLASH写数据时，只需要把要写的数据复制给NFDATA寄存器即可。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_w_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">	NFDATA = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>page write的写时序图如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/35.png"></p>
<pre><code>1.首先发送0x80命令
2.发送地址（5个周期）
3.发送数据
4.发送0x10命令，执行烧写动作
4.然后会有一个busy时间段，R/nB为低电平
5.发送0x70命令，用来读取状态
6.判断NFDATA寄存器的第0位是否烧写成功
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	<span class="type">int</span> col  = addr &amp; (<span class="number">2048</span> - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	nand_select(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		nand_cmd(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 发出地址 */</span></span><br><span class="line">		<span class="comment">/* col addr */</span></span><br><span class="line">		nand_addr_byte(col &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((col&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* row/page addr */</span></span><br><span class="line">		nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 发出数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (; (col &lt; <span class="number">2048</span>) &amp;&amp; (i &lt; len); col++)  <span class="comment">//还需确认</span></span><br><span class="line">			nand_w_data(buf[i++]);</span><br><span class="line">		</span><br><span class="line">		nand_cmd(<span class="number">0x10</span>);</span><br><span class="line">		wait_ready();</span><br><span class="line">        </span><br><span class="line">		nand_cmd(<span class="number">0x70</span>);</span><br><span class="line">		<span class="keyword">if</span> (nand_data() &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_write err, at page:0x%x, addr:0x%x\n\r&quot;</span>, page, page&lt;&lt;<span class="number">11</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i == len)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 开始下一个循环page */</span></span><br><span class="line">		col = <span class="number">0</span>;</span><br><span class="line">		page++;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	nand_deselect(); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到每写一个page，都要重新发送命令地址，因为这里是顺序访问，flash的读写都是以page为单位的。</p>
<h2><span id="5-4-ce-shi">5.4 测试</span><a href="#5-4-ce-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">	nand_erase(addr, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	nand_read(addr, buf, <span class="number">64</span>);</span><br><span class="line">	p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)buf;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line">	<span class="comment">/* 长度固定为64 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="comment">/* 每行打印16个数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 先打印数值 */</span></span><br><span class="line">			c = *p++;</span><br><span class="line">			str[j] = c;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 后打印字符 */</span></span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line">	nand_write(addr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：本节的读、写、擦都只涉及到页数据区，不涉及到oob区的操作。</strong></p>
<h2><span id="5-5-pi-kuai-de-biao-ji-he-jie-chu">5.5 坏快的标记和解除</span><a href="#5-5-pi-kuai-de-biao-ji-he-jie-chu" class="header-anchor">#</a></h2><p>Nand Flash怎么标记某一个BLOCK是坏的? 如何识别一个flash中的坏快？ </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">它使用该BLOCK中第<span class="number">1</span>个扇区的OOB数据中某一个字节来标记: 其值为<span class="number">0xff</span>表示该BLOCK是好的， 其值为非<span class="number">0xff</span>表示该BLOCK是坏的。</span><br><span class="line">在uboot中直接输入“nand bad ”命令即可识别某一个块是否为坏快，在linux用户态的情况下，需要用ioctl(MEMGETBADBLOCK)来获取该block是否为坏快。</span><br><span class="line">有时候我们会误写这个OOB区的值导致有些BLOCK被误认为是<span class="string">&quot;坏块&quot;</span>,可以在u-boot中执行<span class="string">&quot;nand scrub&quot;</span>后, 根据提示信息输入小写字母<span class="string">&#x27;y&#x27;</span>并回车, 它会强制擦除整个Nand <span class="title function_">Flash</span><span class="params">(包括把OOB擦除为<span class="number">0xff</span>)</span>, 这样就可以恢复被误标为坏块的区域了。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
        <tag>存储驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-代码重定位和清bss</title>
    <url>/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</a><ul>
<li><a href="#1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</a></li>
<li><a href="#1-2-lian-jie-jiao-ben">1.2 链接脚本</a><ul>
<li><a href="#1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</a><ul>
<li><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</a></li>
<li><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</a></li>
</ul>
</li>
<li><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</a></li>
<li><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</a><ul>
<li><a href="#1-2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li>
<li><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-qing-chu-bss">2 清除bss</a><ul>
<li><a href="#2-1-bss-duan-jie-shao">2.1 bss段介绍</a></li>
<li><a href="#2-2-qing-bss">2.2 清bss</a></li>
<li><a href="#2-3-qing-bss-you-hua">2.3 清bss优化</a><ul>
<li><a href="#2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li>
<li><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</a></li>
<li><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-wei-zhi-wu-guan-ma">3 位置无关码</a><ul>
<li><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</a><ul>
<li><a href="#3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</a></li>
<li><a href="#3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</a></li>
<li><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</span><a href="#1-yin-ru-dai-ma-chong-ding-wei" class="header-anchor">#</a></h1><p>s3c2440的cpu默认是从0地址开始取指令执行，当从nor启动时,0地址对应nor, nor可以像内存一样读，但不能像内存一样写，前面<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a> 讲过，写入norflash要进行按照spec进行命令表写入。因此我们能够从nor上取指令执行。</p>
<p>当nand启动的时候，我们nand中的前4K指令会变自动加载到sram中去，这时的0地址对应sram。那么我们的程序如果大于4K,要从nand启动，sram只拷贝了nand中的前4K代码，那么如何解决这个问题呢？</p>
<p>就需要重定位代码到dram(ddr)中去，dram的容量较大，又可以直接被cpu访问。</p>
<h2><span id="1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</span><a href="#1-1-cheng-xu-di-zhi-kong-jian" class="header-anchor">#</a></h2><p>我们知道，程序包含：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">代码段（.text）</span><br><span class="line">数据段(.data):存放初始值不为<span class="number">0</span>的全局变量/静态变量</span><br><span class="line">rodata段(.rodata)：<span class="type">const</span>修饰的全局变量或静态变量</span><br><span class="line">bss段(.bss)：存放初始值为<span class="number">0</span>或者未初始化的全局变量/静态变量</span><br><span class="line">commen段(.commen):注释</span><br></pre></td></tr></table></figure>

<p>下面展开一个实验引入为什么要代码重定位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharB = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharC = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharD = <span class="string">&#x27;D&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_roval = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">		g_Char++;         <span class="comment">/* nor启动时, 此代码无效，由于nor启动，nor上不可写 */</span></span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将上面的代码编译出的裸机程序分别烧录到nand和nor flash，看看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 烧录到nor flash, 程序一直输出`AAAA`。</span><br><span class="line">2. 烧录到nand flash,程序无任何输出。</span><br></pre></td></tr></table></figure>

<p>我们发现nor启动时, 对全局变量g_char++无效, nand启动程序无任何输出。我们对程序进行反汇编处理：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/1.png"></p>
<p>可以看到.text段是从0地址开始的，证明cpu的确从0地址取指令进行译码、执行。<br>当从nor启动时，0地址对应nor；当从nand启动时，0地址对应sram，所以无论从nand还是从nor启动cpu都能取指令执行。</p>
<p>再进一步分析反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/2.png"></p>
<p>可以看到.data段的起始地址是0x8474(即g_Char变量的地址为0x8474）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 当把程序烧录进nor,  .data段在nor上的某一段区域, 由于nor能像内存一样读，但不能像内存一样直接写，因此对<span class="string">&#x27;g_Char&#x27;</span>修改无效。</span><br><span class="line"><span class="number">2.</span> 当把程序烧录进nand, .data段在nand的某一区域，nand启动时硬件会自动把nand上的前<span class="number">4</span>K数据copy到SRAM,然后cpu从sram取指令执行。但是.data段的起始地址<span class="number">0x8474</span>&gt;<span class="number">0x1000</span>，超过了<span class="number">4</span>K, cpu没法把.data段也copy到SRAM,所以当访问<span class="string">&#x27;g_Char&#x27;</span>时，发生了异常（abt数据访问终止，这个异常后面有在下一节“异常与中断”里面专门讲解)，因此程序卡死。</span><br></pre></td></tr></table></figure>

<p>再仔细看看反汇编，发现.rodata段和.text段是连续的,但是.rodata段和.data段中间有一段”空洞”。用图形表示更形象，bin文件的内容分布如下所示：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/3.png"><br>那么我们怎么去掉空洞，让.data段了紧接着.rodata段呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 链接脚本(后面1.2有专门讲)</span><br><span class="line">2. 直接在编译的时候用 &quot;-Tdata 0x800&quot;，这样指定.data段基地址为0x800,这样nand启动时.data就能自动copy到SRAM了。</span><br></pre></td></tr></table></figure>

<p>我们现在使用<code>-Tdata 0x800</code>编译出裸机程序，对应反汇编如下：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/4.png"></p>
<p>这时我们烧录程序到nand，从nand启动，发现能输出<code>ABCDEFG</code>了，这就对了，因为.data段数据从nand自动拷贝到了sram。</p>
<p>有人说为什么不吧.data段指向到dram呢，这样无论时nor启动还是nand启动不就都能对全局变量写了？<br>当然这个没错，我做了这个尝试，编译时用<code>-Tdata 0x30000000</code>, 发现编译出来的bin文件有800多M,为什么有这么大呢？由于我们指定.data段存放在0x30000000(sdram的基地址)，这时bin文件的内部结构如下所示：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/5.png"></p>
<p>这么大的bin文件根本无法烧录。通过上面的例子，现在总结下为什么要代码重定位:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.nand启动，前4K代码被自动copy到sram，当程序大于4K的时候需要重定位代码到sdram。</span><br><span class="line">2.nor启动， 全局变量在nor上，不能像内存一样直接写该全局变量，那么也需要重定位到sdram。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-lian-jie-jiao-ben">1.2 链接脚本</span><a href="#1-2-lian-jie-jiao-ben" class="header-anchor">#</a></h2><h3><span id="1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</span><a href="#1-2-1-chong-ding-wei-data-duan" class="header-anchor">#</a></h3><p>我们发现<code>arm-linux-ld -Ttext 0 -Tdata 0x30000000</code>这种方式编译出来的bin文件有800多M,这肯定是不行的。可以通过AT参数指定.data段在编译时的存放位置，我们发现这样指定太不方便了，而且不好确定要放在bin文件的哪个位置。这里就要引入链接脚本，它可以帮我们解决这个不必要的麻烦。</p>
<h4><span id="1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</span><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/6.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = <span class="number">0x00000000</span>; <span class="comment">//表示当前地址为0</span></span><br><span class="line">	. = ALIGN(<span class="number">4</span>);  <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.text  :   </span><br><span class="line">	&#123;</span><br><span class="line">	  cpu/arm920t/start.o	(.text)</span><br><span class="line">	  board/lyb2440/boot_init.o (.text)</span><br><span class="line">	  *(.text)</span><br><span class="line">	&#125;	<span class="comment">//表示.text段从0x4开始存放,其中可以手动调整代码段的位置，</span></span><br><span class="line">	    <span class="comment">//比如让start.o，boot_init.o中的函数放在最前面,然后存放剩余的代码段</span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.rodata : &#123; *(.rodata) &#125; <span class="comment">//从该位置开始存放所有的.rodata段</span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.data : <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//从该位置开始存放所有的.data段 设置运行</span></span><br><span class="line"></span><br><span class="line">	__bss_start = .; <span class="comment">//设置.bss段的起始位置</span></span><br><span class="line">	.bss : &#123; *(.bss) &#125; <span class="comment">//从该位置开始存放所有的.bss段</span></span><br><span class="line">	_end = .;<span class="comment">//设置.bss段的结束位置（也就是整个链接脚本的结束为止）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是从uboot中裁剪过来的链接脚本，注释已经链接脚本的结构讲解的差不多了。这里.data段指定了程序的<strong>运行（链接）地址为sdram的base_addr（0x30000000）</strong>，通过<strong>AT指定加载（在bin文件的存放）地址0x800</strong>。</p>
<h4><span id="1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</span><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi" class="header-anchor">#</a></h4><p>对于nor启动时，我们可以直接从nor上取指令执行，所以可以只进行数据段的重定位（数据段需要写入），我们编写链接脚本sdram.lds如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    .text   <span class="number">0</span>  : &#123; *(.text) &#125;<span class="comment">//所有文件的.text</span></span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125; <span class="comment">//只读数据段</span></span><br><span class="line">    .data <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//放在0x800,但运行时在0x3000000</span></span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;<span class="comment">//所有文件的bss段，所有文件的.COMMON段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将程序烧录进nor flash，程序运行时会将.data拷贝到0x0x30000000也就是sdram中去。只重定位数据段的过程用下图更直观:</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/7.png"></p>
<p>因此就可以对g_char进行写入了。Makefile如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">       arm-linux-gcc -c -o led.o led.c</span><br><span class="line">       arm-linux-gcc -c -o uart.o uart.c</span><br><span class="line">       arm-linux-gcc -c -o init.o init.c</span><br><span class="line">       arm-linux-gcc -c -o main.o main.c</span><br><span class="line">       arm-linux-gcc -c -o start.o start.S</span><br><span class="line">       <span class="comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span></span><br><span class="line">       arm-linux-ld -T sdram.lds start.o led.o uart.o init.o main.o -o sdram.elf</span><br><span class="line">       arm-linux-objcopy -O binary -S sdram.elf sdram.bin</span><br><span class="line">       arm-linux-objdump -D sdram.elf &gt; sdram.dis</span><br></pre></td></tr></table></figure>

<p>修改start.s进行.data段的重定位。我们需要将以0x800为.data段基地址的整个数据段copy到0x30000000处:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">	.global _start</span><br><span class="line">	_start:</span><br><span class="line">		/* 关闭看门狗 */</span><br><span class="line">		/* 初始化时钟 */</span><br><span class="line">		/* 设置栈 */</span><br><span class="line">		/*初始化sdram*/</span><br><span class="line">	...</span><br><span class="line">		/* 重定位data段，把加载地址0x800（bin文件中在nor中）的数据段的内容重定位到sdram的baseaddr */</span><br><span class="line">		mov r1, #0x800</span><br><span class="line">		ldr r0, [r1]</span><br><span class="line">		mov r1, #0x30000000</span><br><span class="line">		str r0, [r1]</span><br><span class="line">	</span><br><span class="line">		bl main</span><br><span class="line">	halt:</span><br><span class="line">		b halt</span><br></pre></td></tr></table></figure>

<p>用几行简单的数据加载存储指令即可实现数据段的重定位，这里是用的相对跳转指令bl main，因为还没有重定位整个完整的代码，所以不能用ldr绝对跳转。前面的初始化时钟、sdram我就不写了，参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> , <a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>。</p>
<p>缺点：<br>这里只是人为的对.data段写死了,那么当我有多个全局变量时，还要计算重定位的次数,而且我们也不知道有多少个全局变量，所以这重定位方式有缺陷。那么我们对这种重定位.data断的方法做一个改进，将链接脚本修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    .text   0  : &#123; *(.text) &#125;</span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125;</span><br><span class="line">    .data 0x30000000 : AT(0x800) </span><br><span class="line">    &#123; </span><br><span class="line">    data_load_addr = LOADADDR(.data);	/* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    data_start = . ;			/* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    *(.data) 				</span><br><span class="line">    data_end = . ;			/* data段结束地址 */</span><br><span class="line">    &#125;</span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接脚本用一个变量data_load_addr指定了加载地址(data段在bin文件中的地址，即0x800），用变量data_start指定了运行地址（即为0x30000000），那么用data_end - data_start就是我们数据段的总长度。</p>
<p>对start.s重定位过程做出如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 重定位data段 */</span><br><span class="line">    ldr r1, =data_load_addr  /* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    ldr r2, =data_start 	 /* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    ldr r3, =data_end 	     /* data段结束地址 */</span><br><span class="line">cpy:</span><br><span class="line">    ldrb r4, [r1]</span><br><span class="line">    strb r4, [r2] /*r2存入data_load_addr 0x400, 然后，r2,r1依次自加*/</span><br><span class="line">    add r1, r1, #1</span><br><span class="line">    add r2, r2, #1</span><br><span class="line">    cmp r2, r3</span><br><span class="line">    ble cpy</span><br><span class="line"></span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">    b halt</span><br></pre></td></tr></table></figure>

<p>这里start.s中用到了链接脚本中的label地址。</p>
<h3><span id="1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</span><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan" class="header-anchor">#</a></h3><p>由于我们的程序可能会大于SRAM或者nor的容量，那么就必须连代码段也一起进行重定位，这种重定位方式更好，在实际应用中也是用的这种方式去做的重定位。</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/8.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = <span class="number">0x30000000</span>;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将代码段的地址设置为0x3000_0004，然后紧接着放.rodata段，然后再紧接着放.data段。这样我们的bin文件就不再有“空洞”了。再来看重定位代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">	.global _start</span><br><span class="line">	_start:</span><br><span class="line">		...</span><br><span class="line">		/* 重定位text, rodata, data段整个程序 */</span><br><span class="line">		mov r1, #0</span><br><span class="line">		ldr r2, =_start 	    /* 第1条指令运行时的地址，也就是.text段的runtime addr，在这里是0x3000_0004*/</span><br><span class="line">		ldr r3, =__bss_start    /* bss段的起始地址,也就是整个程序的结束地址  */</span><br><span class="line">	cpy:</span><br><span class="line">		ldrb r4, [r1]</span><br><span class="line">		strb r4, [r2]</span><br><span class="line">		add r1, r1, #1</span><br><span class="line">		add r2, r2, #1</span><br><span class="line">		cmp r2, r3</span><br><span class="line">		ble cpy</span><br><span class="line">	</span><br><span class="line">		bl main  	</span><br><span class="line">	halt:</span><br><span class="line">		b halt</span><br></pre></td></tr></table></figure>

<p>整个bin文件程序的长度（.text + .rodata + .data）为__bss_start - _start,那么我们是把bin文件从存储介质的0地址copy到程序的运行地址0x3000_0004，这样我们访问.data段时就是访问sdram中重定位后的数据段了。</p>
<h3><span id="1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</span><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua" class="header-anchor">#</a></h3><h4><span id="1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h4><p>前面重定位时，我们使用的是ldrb命令从的Nor Flash读取1字节数据，再用strb命令将1字节数据写到SDRAM里面。<br>我们开发板的Nor Flash是16位，SDRAM是32位。 假设现在需要复制16byte数据。</p>
<table>
<thead>
<tr>
<th>不同的读写指令</th>
<th>cpu读取nor的次数</th>
<th>cpu写入sdram的次数</th>
</tr>
</thead>
<tbody><tr>
<td>ldrb、strb</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>ldr、str</td>
<td>8</td>
<td>4</td>
</tr>
</tbody></table>
<p>可以看出我们更换读写指令后读写次数变少了，提升了cpu的访问效率。修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cpy:</span><br><span class="line">    ldr r4, [r1]</span><br><span class="line">    str r4, [r2]</span><br><span class="line">    add r1, r1, #4 //r1加4</span><br><span class="line">    add r2, r2, #4 //r2加4</span><br><span class="line">    cmp r2, r3 //如果r2 =&lt; r3继续拷贝</span><br><span class="line">    ble cpy</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</span><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = <span class="number">0x30000000</span>;</span><br><span class="line">    __code_start = .;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> 	&#123;</span><br><span class="line">    <span class="comment">//要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line">    <span class="comment">//然后从0地址把数据复制到__code_start</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dest &lt; end) &#123;</span><br><span class="line">        *dest++ = *src++; <span class="comment">//从0地址依次copy到__code_start(代码段的运行地址)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start.s中设置栈指针sp后，即可执行bl copy2sdram进行重定位代码。如何设置栈指针参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> 有实现，重复代码我就不贴上来了。</p>
<h1><span id="2-qing-chu-bss">2 清除bss</span><a href="#2-qing-chu-bss" class="header-anchor">#</a></h1><h2><span id="2-1-bss-duan-jie-shao">2.1 bss段介绍</span><a href="#2-1-bss-duan-jie-shao" class="header-anchor">#</a></h2><p>bss段是什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">	printHex(g_A);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">		g_Char++;         <span class="comment">/* nor启动时, 此代码无效 ，重定位到sdram的baseaddr后有效*/</span></span><br><span class="line">		<span class="built_in">putchar</span>(g_Char3);</span><br><span class="line">		g_Char3++;</span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把程序烧进去，然后打印g_A，但是发现g_A这个值并不是0，而是一个随机值。我们学习linux时知道全局变量g_A, g_B输出肯定是0，裸机输出不是0，为什么呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原因：程序执行汇编过程做完了重定位后把代码copy到了sdram上，然后sdram上紧接着的地址就是.bss的基地址了，这时候bss段的这块内存没有经过任何处理，所以是随机的。</span><br><span class="line">那么我们重定位完代码后需要进行清除sdram上.bss段的数据，因为我们知道bss是未初始化和初始值为<span class="number">0</span>的全局变量。</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-qing-bss">2.2 清bss</span><a href="#2-2-qing-bss" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x30000000;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .text      :&#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除bss段的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 清除BSS段 */</span><br><span class="line">	ldr r1, =__bss_start</span><br><span class="line">	ldr r2, =_end</span><br><span class="line">	mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">	strb r3, [r1]</span><br><span class="line">	add r1, r1, #1</span><br><span class="line">	cmp r1, r2</span><br><span class="line">	ble clean</span><br><span class="line"></span><br><span class="line">	bl main</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>我们把程序再烧进去，然后打印g_A，但是发现g_A的值是0了。本质上就是对重定位后的bss段数据清0。</p>
<h2><span id="2-3-qing-bss-you-hua">2.3 清bss优化</span><a href="#2-3-qing-bss-you-hua" class="header-anchor">#</a></h2><h3><span id="2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ldr r1, =__bss_start</span><br><span class="line">    ldr r2, =_end</span><br><span class="line">    mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">    str r3, [r1]</span><br><span class="line">    add r1, r1, #4</span><br><span class="line">    cmp r1, r2</span><br><span class="line">    ble clean</span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</span><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clean_bss</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 从lds文件中获得 __bss_start, _end*/</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> _end, __bss_start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *start = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">		*start++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：汇编代码获取的是链接脚本中的变量的地址，而C语言代码中获取的是链接脚本中的变量的值</strong>，所以这里的用C语言改进重定位还是清bss都是要加取址符。</p>
<h3><span id="2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</span><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi" class="header-anchor">#</a></h3><p>前面为了加快重定位和清bss的速度,用到了ldr,str这样以4字节为单位进行读写，但是还可能导致一个问题，假设现在链接脚本没有进行用ALIGN(4)让不同的段以4字节对齐，那么就会出现访问错乱的情况。举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">	printHex(g_A);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将链接脚本中.data段和.bss之间的**ALIGN(4)**去掉。那么我们会发现程序执行的时候输出的g_A&#x3D;0，为什么呢，我们明明初始化g_A&#x3D;‘A’呀？</p>
<p>打开反汇编分析：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/9.png"></p>
<p>我们的.bss段紧接着.data段后面，可知在对bss段进行清除的时候，由于我们是以4字节为单位操作的，所以我们清除g_A的时候，连带g_Char,g_Char的值也一起清除了。</p>
<p>所以data段和数据段之间添加ALIGN(4)。修改后就会发现bss段的地址以0x30000248开始了，如下图：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/10.png"></p>
<h1><span id="3-wei-zhi-wu-guan-ma">3 位置无关码</span><a href="#3-wei-zhi-wu-guan-ma" class="header-anchor">#</a></h1><h2><span id="3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</span><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling" class="header-anchor">#</a></h2><h3><span id="3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</span><a href="#3-1-1-xiang-dui-tiao-zhuan" class="header-anchor">#</a></h3><p>使用b, bl跳转指令。</p>
<p>对<code>bl sdram_test</code>指令进行分析，查看反汇编, 代码段的链接地址为0x3000,0000。</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/11.png"><br><code>这里的bl 3000036c不是跳转到3000036c，这个时候sdram并未初始化,那么这个物理地址是无法访问的.</code></p>
<p>为了验证，我们做另一个实验，修改连接脚本sdram.lds, 链接地址改为0x3000,0800，编译查看反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/12.png"><br><code>可以看到现在变成了bl 300003ec,但两个的机器码e1a0c00d都是一样的，机器码一样，执行的内容肯定都是一样的。 因此这里并不是跳转到显示的地址，而是跳转到: pc + offset，这个由链接器决定。</code></p>
<p>假设程序从0x30000000执行，当前指令地址：0x3000005c ,那么就是跳到0x3000036c；如果程序从0运行，当前指令地址:0x5c 跳到：0x000003ec。<br>因此：跳转到某个地址并不是由bl指令所决定，而是由当前pc值和offset偏移量决定。反汇编显示这个值只是为了方便读代码。</p>
<p>结论： 反汇编文件里， B或BL 某个值，只是起到方便查看的作用，并不是真的跳转。</p>
<h3><span id="3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</span><a href="#3-1-2-jue-dui-tiao-zhuan" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</span><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao" class="header-anchor">#</a></h3><p>怎么写位置无关码？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用相对跳转命令 b或bl;</span><br><span class="line">重定位之前，不可使用绝对地址(因为你sdram还没初始化，没有重定位代码过去，跳转过去不就死机了)，也不可访问有初始值的数组(因为初始值放在rodata里，使用绝对地址来访问)；</span><br><span class="line">重定位之后，使用ldr pc = xxx，跳转到/runtime地址；</span><br><span class="line">写位置无关码，其实就是不使用绝对地址</span><br></pre></td></tr></table></figure>

<p>因此，前面的重定位和清bss例子，程序使用bl命令相对跳转，程序仍在NOR&#x2F;sram执行，要想让main函数在SDRAM执行，需要修改代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>boot启动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-内存控制器</title>
    <url>/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nei-cun-jie-kou-gai-nian">1 内存接口概念</a><ul>
<li><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</a></li>
<li><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</a><ul>
<li><a href="#1-2-1-men-dian-lu-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</a></li>
<li><a href="#1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</a><ul>
<li><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</a></li>
<li><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</a></li>
<li><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</a></li>
<li><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</a></li>
<li><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</a></li>
</ul>
</li>
<li><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</a><ul>
<li><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</a></li>
</ul>
</li>
<li><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</a></li>
<li><a href="#5-sdram-fang-wen-shi-li">5 SDRAM访问实例</a><ul>
<li><a href="#5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</a></li>
<li><a href="#5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</a></li>
<li><a href="#5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</a></li>
<li><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</a></li>
<li><a href="#5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</a><ul>
<li><a href="#5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</a></li>
<li><a href="#5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</a></li>
<li><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</a></li>
<li><a href="#5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</a></li>
<li><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</a></li>
<li><a href="#5-5-6-ce-shi-dai-ma">5.5.6 测试代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-norflash-fang-wen-shi-li">6 NorFlash访问实例</a><ul>
<li><a href="#6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</a></li>
<li><a href="#6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</a></li>
<li><a href="#6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</a></li>
<li><a href="#6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</a></li>
<li><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</a></li>
<li><a href="#6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</a><ul>
<li><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</a><ul>
<li><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</a><ul>
<li><a href="#6-6-1-1-1-tacc">6.6.1.1.1 Tacc</a></li>
<li><a href="#6-6-1-1-2-tacs-tcos-tcoh-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-6-2-ce-shi-dai-ma">6.6.2 测试代码</a><ul>
<li><a href="#6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</a><ul>
<li><a href="#7-1-cao-zuo-norflash">7.1 操作NorFlash</a><ul>
<li><a href="#7-1-1-reset">7.1.1 reset</a></li>
<li><a href="#7-1-2-du-id">7.1.2 读ID</a></li>
<li><a href="#7-1-3-du-shu-ju">7.1.3 读数据</a></li>
<li><a href="#7-1-4-du-shu-xing">7.1.4 读属性</a></li>
<li><a href="#7-1-5-xie-shu-ju">7.1.5 写数据</a><ul>
<li><a href="#7-1-5-1-ca-chu">7.1.5.1 擦除</a></li>
<li><a href="#7-1-5-2-xie-ru">7.1.5.2 写入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</a><ul>
<li><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</a></li>
<li><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</a></li>
<li><a href="#7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</a><ul>
<li><a href="#8-1-shi-bie-norflash">8.1 识别NorFlash</a><ul>
<li><a href="#8-1-1-fa-ming-ling">8.1.1 发命令</a></li>
<li><a href="#8-1-2-du-yi-ci-shu-ju">8.1.2 读一次数据</a></li>
<li><a href="#8-1-3-shi-bie-han-shu">8.1.3 识别函数</a></li>
</ul>
</li>
<li><a href="#8-2-du-shu-ju">8.2 读数据</a></li>
<li><a href="#8-3-ca-shu-ju">8.3 擦数据</a></li>
<li><a href="#8-3-xie-shu-ju">8.3 写数据</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nei-cun-jie-kou-gai-nian">1 内存接口概念</span><a href="#1-nei-cun-jie-kou-gai-nian" class="header-anchor">#</a></h1><h2><span id="1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</span><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi" class="header-anchor">#</a></h2><p>S3C2440是个片上系统，有GPIO控制器（接有GPIO管脚(GPA-GPH)）,有串口控制器 (接有TXD RXD引脚),有memory controller内存控制器，有Nand控制器等…</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/1.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）GPIO控制器属于门电路，不涉及到时序，相对简单。</span><br><span class="line">（<span class="number">2</span>）串口控制器属于协议类接口，类似的协议类接口还有iic、iis、spi等。 </span><br><span class="line">（<span class="number">3</span>）前面的GPIO/门电路接口、协议类接口，都不会把地址输出到外部设备，仅仅只是将地址写入到相应的控制器。</span><br><span class="line">接下来的内存类接口，会把地址输出到外部，cpu将地址写入内存控制器，内存控制器还需访问外部设备，比如NorFlash、网卡、SDRAM。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</span><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi" class="header-anchor">#</a></h2><p>GPIO&#x2F;门电路接口、协议类接口、内存类接口都属于CPU的统一编址。但对于Nand Flash，它没有独立的地址线和cpu的地址总线相连接，因此它不参与CPU的统一编址。</p>
<h3><span id="1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</span><a href="#1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于门电路接口、协议类接口，直接访问寄存器即可。</p>
<h3><span id="1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</span><a href="#1-2-2-nei-cun-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于内存类接口，交给内存控制器去处理。下面详细分析：</p>
<p>CPU只管发出一个地址，内存控制器根据该地址范围选择不同的模块，然后从模块中得到数据或者发送数据到模块中。<br>如下图，SDRAM、DM9000网卡、Nor Flash都接在s3c2440的数据总线和地址总线上，CPU把数据和地址发送出去，然后内存控制器根据地址范围确定要拉低选中哪个片选信号（nCS），再根据片选信号（nCS）选择相应的设备，进行收发地址和数据，互不干扰。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpg"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="image-20240411202307277"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)当CPU发出的指令的地址范围处于<span class="number">0x00000000</span> - <span class="number">0x08000000</span>，</span><br><span class="line">内存控制器就会使nGCS0处于低电平（片选引脚被选中），NorFlash被选中。(NorFlash启动时才行，nand启动时nGCS0这块对应SRAM)</span><br><span class="line">(<span class="number">2</span>)当CPU发出的指令的地址范围处于<span class="number">0x20000000</span> - <span class="number">0x28000000</span>，</span><br><span class="line">内存控制器就会使nGCS4处于低电平（片选引脚被选中），网卡DM9000被选中。</span><br><span class="line">(<span class="number">3</span>)当CPU发出的指令的地址范围处于<span class="number">0x30000000</span> - <span class="number">0x38000000</span>，</span><br><span class="line">内存控制器就会使nGCS6处于低电平（片选引脚被选中），SDRAM被选中</span><br></pre></td></tr></table></figure>

<p>内存控制器根据不同的地址地址范围，发出不同的片选引脚，只有被片选引脚选中的芯片才能正常工作，不被选中的芯片就像不存在一样，不工作。</p>
<p>从s3c2440 datasheet中我们得知内存控制器可访问的地址范围有1G(0x0000,0000-0x4000,0000)，8个bank,每个bank_size为128M。理论上需要2^30（30条地址线）来确定是哪个bank,哪个地址。但是实际上只用到了27条,那么是怎么确定是哪个bank被选中了呢？</p>
<p>cpu每次发给内存控制器的地址都是Addr[31:0],但是内存控制器发给外设（sdram，nor,dm9000）却只用到了A[26:0]。第[29:27]被用来确定要拉低哪个nGCS，即要选中哪个bank:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">bit[<span class="number">29</span>:<span class="number">27</span>]		bit[<span class="number">26</span>:<span class="number">0</span>]</span><br><span class="line"><span class="number">0b000</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank0被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b001</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  (bank1被选中 （<span class="number">128</span>M）)</span><br><span class="line">...				...</span><br><span class="line"><span class="number">0b110</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank6被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b111</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  （bank7被选中 （<span class="number">128</span>M））</span><br></pre></td></tr></table></figure>

<p>那么对于大容量的nandflash，理论上需要更多的地址线来确认访问地址，那既然没有地址线，cpu是如何访问nand的呢？当然是通过nand控制器，nand是地址、命令、数据都共用数据总线。这里只是引入一个话题，具体见<a href="https://www.cnblogs.com/fuzidage/p/13020052.html">s3c2440裸机-nand控制器</a>。</p>
<h1><span id="2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</span><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi" class="header-anchor">#</a></h1><p>s3c2440芯片手册上外设rom与CPU地址总线连接如下：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/4.png"></p>
<h2><span id="2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</span><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/5.png"></p>
<h2><span id="2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</span><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/6.png"></p>
<h2><span id="2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</span><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/7.png"></p>
<h2><span id="2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</span><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/8.png"></p>
<h2><span id="2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</span><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/9.png"><br>从上面的图中，我们知道可以对2片位宽为8bit的内存扩展级联成1个16bit的内存，同理可用4片位宽为8bit的内存进行级联成1个32bit的内存。</p>
<h1><span id="3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</span><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian" class="header-anchor">#</a></h1><p>从上面的图中，我们还看见一个规律:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">当外设总线位宽为<span class="number">8b</span>it时， 外设A0接CPU的地址总线ADDR[<span class="number">0</span>],</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">1</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">16b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">1</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">2</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">32b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">2</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">3</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>为什么要这样设计呢？先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0， #3</span><br><span class="line">LDRB R1, [R0]  @ 从内存地址为3的地方，读出一个字节到R1</span><br></pre></td></tr></table></figure>

<p>如图有8bitROM、16bitROM、32bitROM:<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）对于8bitROM ，8bit是一次读写的最小单位，即0地址是第一个8bit，1地址是第二个8bit;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，8bitROM的A0和A1收到的也都是1，</span><br><span class="line">于是找到了ROM上地址为3的8bit数据,包含了我们需要的数据。</span><br><span class="line"></span><br><span class="line">（2）对于16bitROM ，16bit是一次读写的最小单位，即0地址是第一个16bit，里面有两个8bit数据;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，16bitROM的A0和A1分别收到的是1和0，</span><br><span class="line">于是找到了ROM上地址为1的16bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br><span class="line"></span><br><span class="line">（3）对于32bitROM ，32bit是一次读写的最小单位，即0地址是第一个32bit，里面有四个8bit数据;</span><br><span class="line">CPU发出的地址3，即A0和A1都为0，32bitROM的A0和A1收到的都是0，</span><br><span class="line">于是找到了ROM上地址为0的32bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br></pre></td></tr></table></figure>

<p>用表格更好理解：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址</th>
<th>ROM返回数据</th>
<th>内存控制器挑选出数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000011</td>
<td>0b000011</td>
<td>编号3的存储单元中的8数据</td>
<td>编号3的存储单元中的8数据</td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000011</td>
<td>0b000001</td>
<td>编号1的存储单元中的16数据</td>
<td>根据”A0&#x3D;1”,挑出低8bit数据</td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000011</td>
<td>0b000000</td>
<td>编号0的存储单元中的32数据</td>
<td>根据”A1A0&#x3D;11”,挑出最低8bit数据</td>
</tr>
</tbody></table>
<p>对上图的数据再次整理：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址（内存控制器转发给rom）</th>
<th>ROM返回数据</th>
<th>内存控制器组装数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000100</td>
<td>0b000100</td>
<td>地址4的一个1byte数据</td>
<td>组装地址7、6、5、4数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000101</td>
<td>地址5的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000110</td>
<td>地址6的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000111</td>
<td>地址7的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000100</td>
<td>0b00010</td>
<td>地址2的一个2byte数据</td>
<td>组装地址3、2的数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b00011</td>
<td>地址3的一个2byte数据</td>
<td></td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000100</td>
<td>0b00001</td>
<td>地址1的一个4byte数据</td>
<td>直接返回4字节数据</td>
</tr>
</tbody></table>
<p>这里牵扯到地址、内存中数据的排列存储，有点深入，如果实在无法理解，记住怎么去错位相连就好了。<br><strong>结论：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>和cpu地址总线相连的外设地址线确定了要访问外设的地址，即哪个存储单元；</span><br><span class="line"><span class="number">2.</span>然后内存控制器拿到外设存储单元中的数据后，再根据那几个错开的引脚[A1-A0]的值（CPU地址总线没接的那几个引脚的值），来挑出相应的数据给CPU。</span><br></pre></td></tr></table></figure>

<p>再举一个例子， 假如读取一个32位的数据时，前面读的是8位数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0,   #4</span><br><span class="line">LDR  R1,  [R0]  @去地址4，读取4字节数据</span><br></pre></td></tr></table></figure>

<p>我们知道CPU发出的是32bit地址,那么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于32bit Rom，内存控制器会给它发1次，rom也会相应的接收1次;</span><br><span class="line">对于16bit Rom，内存控制器会给它发2次，rom也会相应的接收2次;</span><br><span class="line">对于8bit  Rom，内存控制器给它发4次， rom接收4次，</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</span><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan" class="header-anchor">#</a></h2><p>接不同的rom外设，s3c2440内存控制器总线位宽要配置成不一样。位宽和等待控制寄存器如下：<br>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER):</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/11.png" alt="img"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000</code></p>
<h1><span id="4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</span><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei" class="header-anchor">#</a></h1><p>怎样确定芯片的访问地址？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 根据片选信号确定基地址</span><br><span class="line">2. 根据芯片所接地址线确定范围</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/12.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/13.png"></p>
<table>
<thead>
<tr>
<th>外设类型</th>
<th>接内存控制器的哪个片选</th>
<th>基地址</th>
<th>占用CPU的地址总线</th>
<th>地址范围(offset + size)</th>
</tr>
</thead>
<tbody><tr>
<td>nor</td>
<td>nGCS0</td>
<td>0x0000,0000</td>
<td>ADDR0-ADDR20</td>
<td>0x0000,0000 ~ 0x001f,ffff(2M)</td>
</tr>
<tr>
<td>dm9000网卡</td>
<td>nGCS4</td>
<td>0x2000,0000</td>
<td>ADDR0和ADDR2</td>
<td>0x2000,0000 ~ 0x2000,0005(5byte)</td>
</tr>
<tr>
<td>sdram</td>
<td>nGCS6</td>
<td>0x3000,0000</td>
<td>ADDR0-ADDR25</td>
<td>0x3000,0000 ~ 0x3000,0000 + RAM_SIZE</td>
</tr>
</tbody></table>
<p>这里再次提醒一下: 有人发现上图中nor没有和CPU的ADDR0相连接，sdram没有和CPU的ADDR0、ADDR1相连接。不要觉得ADDR0、ADDR1没用到，由于nor数据位宽是16bit，ADDR0是给内存控制器拆分数据用的，同样sdram数据位宽32bit，ADDR0、ADDR1也是给内存控制器拆分数据用的。这个上面已分析过，这也是什么要错位连接的原因。</p>
<h1><span id="5-sdram-fang-wen-shi-li">5 SDRAM访问实例</span><a href="#5-sdram-fang-wen-shi-li" class="header-anchor">#</a></h1><p>以EM63A165TS-6G这款外接SRAM存储来展开介绍。</p>
<h2><span id="5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</span><a href="#5-1-sdram-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpg"></p>
<h2><span id="5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</span><a href="#5-2-sdram-yin-jiao-jie-xian" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/15.png"></p>
<p>这里采用2片 EM63A165TS-6G 级联作为外接内存，关于EM63A165TS-6G的规则描述参考datasheet。可以看到该sdram是16bit 的，从接线可以看出第一片存储低16位数据，第二片存储高16位数据。</p>
<p>引脚说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A0-A12：地址总线</span><br><span class="line">D0-D15:数据总线（位宽<span class="number">16</span>,<span class="number">2</span>片级联成位宽<span class="number">32</span>）</span><br><span class="line">BA0-BA1:bank选择</span><br><span class="line">nSCS：片选</span><br><span class="line">nSRAS:行地址选择</span><br><span class="line">nSCAS:列地址选择</span><br><span class="line">nWE:写使能</span><br><span class="line">SCLK:时钟</span><br><span class="line">SCKE:时钟使能</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</span><a href="#5-3-sdram-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面提到片选接了nGCS6，地址映射的base_addr&#x3D;0x3000,0000,那么size是多大呢？</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/16.png"></p>
<p>容量为：4M word x 16-bit x 4-bank &#x3D; 32M，再看原理图我们是两片级联，所以容量为4M word x 32-bit x 4-bank&#x3D;64M。所以地址范围是**[0x3000_0000 ~ 0x33ff_ffff]**</p>
<p>在对比另一款W9825G6KH SDRAM为例，地址总线A0-A12,数据总线D0-D15,因此内存大小：2^13 * 2^9 &#x3D;  &#x3D; 4194304,等于4M,加上有4个bank，数据为宽16位，因此内存大小4Mx4x2字节。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/17.png" alt="image"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/18.png" alt="image"></p>
<p>框图翻译成中文形式：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/19.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLK：时钟线，SDRAM 是同步动态随机存储器，“同步”的意思就是时钟，因此需要一根额外的时钟线，这是和 SRAM 最大的不同，SRAM 没有时钟线。</span><br><span class="line">CKE：时钟使能信号线，SRAM 没有 CKE 信号。</span><br><span class="line">CS：片选信号，这个和 SRAM 一样，都有片选信号。</span><br><span class="line">RAS：行选通信号，低电平有效，SDRAM 和 SRAM 的寻址方式不同，SDRAM 按照行、列来确定某个具体的存储区域。因此就有行地址和列地址之分，行地址和列地址共同复用同一组地址线，要访问某一个地址区域，必须要先后发送行地址和列地址</span><br><span class="line">CAS：列选通信号，和 RAS 类似，低电平有效，选中以后就可以发送列地址了。</span><br><span class="line">WE：写使能信号，低电平有效</span><br><span class="line">A0-A12: 地址线</span><br><span class="line">DQ0-DQ15: 16位数据线</span><br><span class="line">BS0-BS1: BANK 选择线</span><br><span class="line">LDQM,UDQM: 高低字节数据选择线</span><br></pre></td></tr></table></figure>

<h2><span id="5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</span><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>我们知道64M&#x3D;2^20*2^6&#x3D;2^26，那么需要26条地址线，再看看原理图，我们发现SDRAM的地址线A[12:0]只有13条，那么最多只能访问2^13&#x3D;8K的数据，地址线明显配不上这么大的容量,那么它是如何解决的呢？</p>
<p>答：当然是<strong>拆分地址了，多次传输</strong>。</p>
<p>我们从SDRAM的内部存储结构得知要确定SDRAM的一个存储单元，先确定是哪个bank,然后再确定在哪一行、哪一列即可。SDRAM有4个bank,由BA0、BA1决定选中哪个bank,查看SDRAM手册见下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/20.png"></p>
<p>通过选中nSRAS选中行地址,从而发送行地址；最后通过选中nSCAS选中列地址，从而发送列地址。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldr	r0, =0x30000000;</span><br><span class="line">ldr r1, [r0]; 从SDRAM基地址读取4byte数据</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>发出片选信号nGCS6，选中SDRAM</span><br><span class="line"><span class="number">2.</span>发出bank选中信号(BA0，BA1),确定是SDRAM上的哪个bank，从原理图得知CPU的ADDR24、ADDR25对应SDRAM上的BA0，BA1,所以让BA0、BA1=<span class="number">00</span>,选中bankA。</span><br></pre></td></tr></table></figure>

<p>然后从sdram规格书确定行列地址的数目：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/21.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span>发出行地址信号nSRAS,使能行地址传输。传输行地址，确定是哪一行（看SDRAM手册确定行地址数(A12-A0)<span class="number">13</span>条）</span><br><span class="line"><span class="number">4.</span>发出列地址信号nnSCAS,使能列地址传输。传输列地址，确定是哪一列(看SDRAM手册确定列地址(A8-A0)<span class="number">9</span>条)</span><br></pre></td></tr></table></figure>

<p>从而发送完整的0x30000000地址到了SDRAM,SDRAM返回4byte数据给CPU。</p>
<h2><span id="5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</span><a href="#5-5-sdram-qu-dong-shi-li" class="header-anchor">#</a></h2><p>s3c2440内存控制器共有13个寄存器。我们要设置内存控制器参数，适配外接SDRAM。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BANK0--BANK5只需要设置BWSCON和BANKCONx(x为0～5）两个寄存器；</span><br><span class="line">BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</span><a href="#5-5-1-wei-kuan-ji-cun-qi" class="header-anchor">#</a></h3><p>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/22.png"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000。</code></p>
<h3><span id="5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</span><a href="#5-5-2-bank-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKCONTROLREGISTER:</p>
<p>在8个BANK中，只有BANK6和BANK7可以外接SRAM或SDRAM。BANKCON6设置参数如下：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/23.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MT[<span class="number">16</span>:<span class="number">15</span>]：设置BANK是ROM/SRAM还是DRAM，我们用的SDRAM，属于DRAM。</span><br><span class="line">Trcd[<span class="number">3</span>:<span class="number">2</span>]：行地址和列地址间隔多长时间，看SDRAM芯片手册时间间隔Trcd&gt;<span class="number">18</span>ns，我们HCLK=<span class="number">100</span>MHZ,clocks为<span class="number">10</span>ns,所以设置为<span class="number">2</span>clocks即可。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</span><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>REFRESH(REFRESHCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/24.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">REFEN[<span class="number">23</span>]：设置开启SDRAM的刷新功能。</span><br><span class="line">TREFMD[<span class="number">22</span>]：SDRAM的刷新模式，<span class="number">0</span>=CBR/AutoRefresh，选择自动刷新。</span><br><span class="line"></span><br><span class="line">Trp[<span class="number">21</span>：<span class="number">20</span>]：根据sdram手册Trp&gt;<span class="number">18</span>ns, 设为<span class="number">0</span>(<span class="number">2</span> clocks)即可。</span><br><span class="line">Tsrc[<span class="number">19</span>：<span class="number">18</span>]: Tsrc = Trc - Trp = Trc<span class="number">-20</span>, 根据sdram手册Trc&gt;=<span class="number">60</span>,我们取Trc =<span class="number">70</span>, 则Tsrc= <span class="number">50</span>ns(<span class="number">5</span>clocks)即可。</span><br><span class="line">RefreshCounter[<span class="number">10</span>:<span class="number">0</span>]：Refresh period = (<span class="number">211</span>-refresh_count+<span class="number">1</span>)/HCLK，</span><br><span class="line">RefreshCount = <span class="number">211</span> + <span class="number">1</span> - <span class="number">100</span>*Refresh period，看SDRAM手册“<span class="number">8192</span> refresh cycles/<span class="number">64</span>ms”， Refresh period= <span class="number">64000u</span>s/<span class="number">8192</span> = <span class="number">7.8u</span>s，</span><br><span class="line">RefreshCount取推荐值<span class="number">1269</span>= <span class="number">0x4f5</span>.</span><br><span class="line">综上，REFRESH寄存器设为<span class="number">0x8404F5</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</span><a href="#5-5-4-banksize-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKSIZEREG ISTER</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/25.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BURST_EN[<span class="number">7</span>]：<span class="number">0</span>=ARM核禁上突发传输，<span class="number">1</span>=ARM核支持突发传输(推荐)；</span><br><span class="line">SCKEEN[<span class="number">5</span>]：<span class="number">0</span>=不使用SCKE信号令SDRAM进入省电模式，<span class="number">1</span>=使用SCKE信号令SDRAM进入省电模式(推荐)；</span><br><span class="line">SCLK-EN[<span class="number">4</span>]：<span class="number">0</span>=时刻发出SCLK信号，<span class="number">1</span>=仅在访问SDRAM期间发出SCLK信号（推荐）；</span><br><span class="line">BK76MAP[<span class="number">2</span>:<span class="number">0</span>]：配置banksize成<span class="number">64</span>M</span><br><span class="line">因此，BANKSIZE寄存器设为<span class="number">0xB1</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</span><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>SDRAM MODE REGISTER SET REGISTER(MRSR)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/26.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CL[<span class="number">6</span>:<span class="number">4</span>]:表示发出行、列地址后，等多久才返回收到数据， 看SDRAM手册发现Tcas &gt;=<span class="number">18</span>ns,所以配置成<span class="number">2</span> clocks即可。</span><br><span class="line">MRSRB6寄存器设置为<span class="number">0x20</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-6-ce-shi-dai-ma">5.5.6 测试代码</span><a href="#5-5-6-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdram_init</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	BWSCON = <span class="number">0x22000000</span>;</span><br><span class="line">	BANKCON6 = <span class="number">0x18001</span>;</span><br><span class="line">	BANKCON7 = <span class="number">0x18001</span>;</span><br><span class="line">	REFRESH  = <span class="number">0x8404f5</span>;</span><br><span class="line">	BANKSIZE = <span class="number">0xb1</span>;</span><br><span class="line">	MRSRB6   = <span class="number">0x20</span>;</span><br><span class="line">	MRSRB7   = <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">sdram_test</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *p = (<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *)<span class="number">0x30000000</span>;<span class="comment">//sdram base addr</span></span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	<span class="comment">// write sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		p[i] = <span class="number">0x55</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (p[i] != <span class="number">0x55</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	sdram_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sdram_test() == <span class="number">0</span>)</span><br><span class="line">		led_test();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进行sdram_init后可已访问0x3000_0000地址的内容，led流水灯闪烁。<br>不初始化sdram_init，sdram_test执行会导致程序卡死。</p>
<h1><span id="6-norflash-fang-wen-shi-li">6 NorFlash访问实例</span><a href="#6-norflash-fang-wen-shi-li" class="header-anchor">#</a></h1><h2><span id="6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</span><a href="#6-1-flash-chong-lei-te-xing-jie-shao" class="header-anchor">#</a></h2><p>flash一般分为nand flash和nor flash，各自特性如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Nor</th>
<th>NAND</th>
</tr>
</thead>
<tbody><tr>
<td>XIP(片上执行)</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>性能(擦除)</td>
<td>非常慢(5s,块太大)</td>
<td>快(3ms)</td>
</tr>
<tr>
<td>性能(写)</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>性能(读)</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>可靠性</td>
<td>高</td>
<td>一般（容易出现位反转）</td>
</tr>
<tr>
<td>可擦除次数</td>
<td>10000 ~ 100000</td>
<td>100000 ~ 1000000</td>
</tr>
<tr>
<td>接口</td>
<td>与ram类似，可直接访问任意地址</td>
<td>I&#x2F;O接口（无地址线,必须串行访问，命令、地址、数据共用8位IO）</td>
</tr>
<tr>
<td>易用性</td>
<td>容易</td>
<td>复杂</td>
</tr>
<tr>
<td>主要用途</td>
<td>常用于保存代码和关键数据</td>
<td>用于保存数据</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>容量</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>常用文件系统类型</td>
<td>jffs</td>
<td>yaffs</td>
</tr>
</tbody></table>
<p>nor有以下优缺点相对nand：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">    操作简单（可以像内存一样随机访问）</span><br><span class="line">    读取速度快</span><br><span class="line">    可靠性高，不易出现位反转</span><br><span class="line">缺点：</span><br><span class="line">    容量小，价格贵</span><br><span class="line">    擦写慢</span><br><span class="line">    寿命短</span><br></pre></td></tr></table></figure>

<h2><span id="6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</span><a href="#6-2-norflash-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面介绍内存控制器地址映射范围说了，得知nor接了bank 0,地址范围是0x0000,0000 ~ 0x001f,ffff。</p>
<h2><span id="6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</span><a href="#6-3-norflash-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p>下面是一款典型的nor flash原理图<strong>MX29LV800BBTC</strong>。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/27.png"></p>
<p>引脚信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址线（A0-A20）</span><br><span class="line">数据线(DQ0-DQ15)</span><br><span class="line">片选信号（nCE）</span><br><span class="line">读写使能信号(LnOE/LnWE)</span><br></pre></td></tr></table></figure>

<p>Nor Flash可以像内存一样读，但是不能像内存一样写，需要做一些特殊的操作才能进行写操作，这是因为nor是属于rom（只读存储器），不能像ram一样可以任意的写0写1，只能将存储介质中的电平由1变成0，不能将0变成1，所以要向nor中写入数据，必须先进行擦除动作。</p>
<h2><span id="6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</span><a href="#6-4-norflash-ying-jian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/28.jpg"></p>
<h2><span id="6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</span><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>下图是S3C2440的内存控制器的可编程访问周期读写时序，里面的时间参数要根据外部norflash的性能进行配置。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/29.png"></p>
<p>时序含义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tacs: Address <span class="built_in">set</span>-up time before nGCSn（表示地址信号A发出多久后才能发出nGCS片选）</span><br><span class="line">Tcos: Chip selection <span class="built_in">set</span>-up time before nOE（表示片选信号nGCS发出多久后才能发出读使能信号）</span><br><span class="line">Tacc: access cycle（数据访问周期）</span><br><span class="line">Tacp: page模式下的访问周期</span><br><span class="line">Tcoh: Chip selection hold time after <span class="title function_">nOE</span> <span class="params">(nOE信号释放多久后才能释放片选nGCS)</span></span><br><span class="line">Tcah: Address hold time after <span class="title function_">nGCSn</span> <span class="params">(片选nGCS释放多久后才能释放地址信号A)</span></span><br></pre></td></tr></table></figure>
<p>下面我们根据此款norflash <strong>MX29LV160D</strong>手册中的访问时序图来分析，如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/30.png"><br>从上面<strong>MX29LV160D</strong>手册的时序图中我们看见：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)先发送地址信号A</span><br><span class="line">(2)发送片选CE</span><br><span class="line">(3)发送读使能OE</span><br><span class="line">(4)从数据总线上读出数据</span><br><span class="line">(5)释放信号...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发出地址数据(Addresses)后，要等待Taa(要求大于等于70ns)时间，地址数据才有效;</span><br><span class="line">发出片选信号(CE#)后，要等待Tce(要求大于等于70ns)时间，片选信号才有效;</span><br><span class="line">发出读信号(OE#)后要等待Toe(要求大于等于30ns)时间，读信号才有效;</span><br></pre></td></tr></table></figure>

<p>Tas（地址建立时间，也就是地址发送多久后才能继续发后面的片选信号）最小可以为0，那么说明地址信号（A）、片选(CE)、读(OE)使能信号可以一起发出。</p>
<p>为了简单我们把地址(Addresses)，片选信号(CE#)，读信号(OE#)，同时发出，然后让它们都等待70ns即可(等待地址信号，片选信号，读写使能信号有效)。</p>
<p>我们再看看上面的nor访问时序图，释放地址、片选、读使能信号都没有时间差值dt要求，那么说明地址、片选、读使能信号可以同时释放。</p>
<h2><span id="6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</span><a href="#6-6-norflash-shi-xu-chu-shi-hua" class="header-anchor">#</a></h2><p>打开s3c2440内存控制器。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/31.png"></p>
<h3><span id="6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</span><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi" class="header-anchor">#</a></h3><h4><span id="6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</span><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi" class="header-anchor">#</a></h4><h5><span id="6-6-1-1-1-tacc">6.6.1.1.1 Tacc</span><a href="#6-6-1-1-1-tacc" class="header-anchor">#</a></h5><p>Tacc表示数据访问周期：</p>
<p>从上图可以看到Tacc的默认值是111，对应14个clocks。s3c2440系统上电采用12MHz的晶振，HCLK&#x3D;OSC&#x3D;12MHz，那么Tacc&#x3D;(1&#x2F;(12*10^6)) * 14≈1166 ns，这个值很大，远超过了我们的nor手册上的Trc&#x3D;70ns，几乎可以满足所有NorFlash的要求,这也是为什么我们不做初始化也能访问norflash的原因。</p>
<p>启动后，由于我们的时钟HCLK设置成了100MHz，T&#x3D;1000&#x2F;100&#x3D;10ns，Tacc&#x3D; 10ns*14 &gt;70ns, 所以内存控制器不配置Tacc也是能访问该flash的。为了让访问速率加快，因此设置Tacc&gt;70ns即可，配置成101，8个clocks即可。</p>
<h5><span id="6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</span><a href="#6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah" class="header-anchor">#</a></h5><p>从nor的分析中，我们得知地址、片选、读使能同时发出和同时释放，所以配置Tacs,Tcos,Tcoh,Tcah皆为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BANKCON0 = (*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)(<span class="number">0x48000004</span>));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank0_tacc_set</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	BANKCON0 = val &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bank0_tacc_set</span>(<span class="number">0x5</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="6-6-2-ce-shi-dai-ma">6.6.2 测试代码</span><a href="#6-6-2-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	unsigned <span class="built_in">char</span> c;</span><br><span class="line">	uart0_init();<span class="comment">//参考前面的uart编程</span></span><br><span class="line">	puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		c = getchar();</span><br><span class="line">		putchar(c);</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;7&#x27;</span>) &#123;</span><br><span class="line">			bank0_tacc_set(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			led_test();<span class="comment">//跑马灯代码我就不贴了，谁都会</span></span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">			puts(<span class="string">&quot;Error, val should between 0~7\n\r&quot;</span>);</span><br><span class="line">			puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</span><a href="#6-6-2-1-ce-shi-jie-guo" class="header-anchor">#</a></h4><p>输入0~4,Tacc小于70ns,无法读取Nor Flash上数据，LED不能闪烁。</p>
<p>输入5~7，Tacc大于70ns,可以读取Nor Flash上数据，LED不断闪烁，且值越小越快。</p>
<p>结论：我们的内存控制器默认配置的tacc一般都能兼容大多数市面上的norflash，一般都是可以访问的，无需进行对内存控制器进行多余的配置。</p>
<h1><span id="7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</span><a href="#7-u-boot-ming-ling-fang-wen-norflash" class="header-anchor">#</a></h1><p><strong>前提</strong>：<br>    norflash初始化正常，能够正常从nor上执行。</p>
<p>对s3c2440而言，cpu总是从0地址读取指令执行程序。当cpu设置成nor启动时，0地址对应nor。cpu从nand启动时，0地址对应sram。</p>
<h2><span id="7-1-cao-zuo-norflash">7.1 操作NorFlash</span><a href="#7-1-cao-zuo-norflash" class="header-anchor">#</a></h2><p>将板子设为nor启动，那么0地址对应nor，我们先将uboot烧写到nor中,启动uboot。</p>
<p>打开这款<strong>MX29LV800BBTC</strong> norflash手册，找到操作flash的命令表：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/32.png"></p>
<h3><span id="7-1-1-reset">7.1.1 reset</span><a href="#7-1-1-reset" class="header-anchor">#</a></h3><p>往任何一个地址写入F0即可。</p>
<h3><span id="7-1-2-du-id">7.1.2 读ID</span><a href="#7-1-2-du-id" class="header-anchor">#</a></h3><p>很多的Nor Flash可以配置成位宽16bit(Word)，位宽8bit(Byte)，我们这款norflash数据位宽为16bit。下面我们按照nor手册上的命令表尝试一下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">往地址<span class="number">555</span>H写入AAH(解锁)	</span><br><span class="line">往地址<span class="number">2</span>AAH写入<span class="number">55</span>H(解锁)</span><br><span class="line">往地址<span class="number">555</span>H写入<span class="number">90</span>H（命令）</span><br><span class="line">读<span class="number">0</span>地址得到厂家ID(C2H)</span><br><span class="line">读<span class="number">1</span>地址得到设备ID(<span class="number">22</span>DAH或<span class="number">225B</span>H)</span><br><span class="line">退出读ID状态(给任意地址写F0H就可以了)</span><br></pre></td></tr></table></figure>

<p>上面的地址是对于norflash的，那么我们CPU要怎么发送地址呢？从原理图接线我们知道CPU和nor的地址是错位相连的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/33.png"></p>
<table>
<thead>
<tr>
<th>cpu地址</th>
<th>nor地址</th>
</tr>
</thead>
<tbody><tr>
<td>A15~A1</td>
<td>A14~A0</td>
</tr>
</tbody></table>
<p>那么可以看到cpu的地址实际相当于是nor地址左移了一位，那么比如要想给nor上的555H地址写入AAH,那么CPU要发出的地址应该为0x555&lt;&lt;1,也就是nor地址的2倍。</p>
<p>下面对在Nor Flash的操作，cpu的操作，U-BOOT上的操作进行比较，如下表：</p>
<table>
<thead>
<tr>
<th>Nor Flash的操作</th>
<th>cpu的操作</th>
<th>U-BOOT上的操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写入AAH(解锁)</td>
<td>往地址AAAH写入AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写入55H(解锁)</td>
<td>往地址554H写入55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写入90H(命令)</td>
<td>往地址AAAH写入90H(命令)</td>
<td>mw.w aaa 90</td>
</tr>
<tr>
<td>读0地址得到厂家ID(C2H)</td>
<td>读0地址得到厂家ID(C2H)</td>
<td>md.w 0 1 (1:表示读一次)</td>
</tr>
<tr>
<td>读1地址得到设备ID(22DAH或225BH)</td>
<td>读2地址得到设备ID(22DAH或225BH)</td>
<td>md.w 2 1</td>
</tr>
<tr>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>mw.w 0 f0</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/34.png"></p>
<p>我们读出厂家id为c2，设备id为2249，和我们的nor手册上是一致的。我们发出f0命令，进行复位，这时读取的数据就不再是厂家id和设备id了，而是我们norflash中的实际的数据17 00 00 ea。</p>
<h3><span id="7-1-3-du-shu-ju">7.1.3 读数据</span><a href="#7-1-3-du-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，只要做好内存控制器的初始化工作就可以直接读了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/35.png"></p>
<p>我们再用二进制编辑器打开我们烧进去的uboot.bin，发现内容一样，说明我们从norflash中读出来的数据是正确的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/36.png"></p>
<h3><span id="7-1-4-du-shu-xing">7.1.4 读属性</span><a href="#7-1-4-du-shu-xing" class="header-anchor">#</a></h3><p>通常Linux内核里面要识别一个 Nor Flash 有两种方法：</p>
<p>一种是 jedec 探测，就是在内核里面事先定义一个数组，该数组里面放有不同厂家各个芯片的一些参数，探测的时候将 flash 的 ID 和数组里面的 ID 一一比较，如果发现相同的，就使用该数组的参数。 jedec 探测的优点就是简单，只要通过flash的数组编号，即可访问该款flash属性，缺点是如果内核要支持的 flash 种类很多，这个数组就会很庞大。</p>
<p>一种是 CFI(common flash interface)探测，就是直接发各种命令来读取芯片的信息，比如 ID、容量等，芯片本身就包含了电压有多大，容量有有多少等信息。</p>
<p>我们的这款norflash属于cfi探测，下面对在Nor Flash上操作，s3c2440上操作，U-BOOT上进行cfi 探测（读取芯片信息）。</p>
<p>下图是从datasheet中检索出进入cfi模式后的一些flash属性查找表，可以按照表格命令查询norflash的一些属性(容量、电压、block信息等)：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/37.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/38.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>根据命令表往<span class="number">55</span>H地址写入<span class="number">98</span>H进入cfi模式</span><br><span class="line"><span class="number">2.</span>读取`qry`字符</span><br><span class="line"><span class="number">3.</span>获取属性</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Nor Flash上操作cfi</th>
<th>2440上操作cfi</th>
<th>U-BOOT上操作cfi</th>
</tr>
</thead>
<tbody><tr>
<td>往55H地址写入98H（进入cfi模式）</td>
<td>往AAH地址写入98H</td>
<td>mw.w aa 98</td>
</tr>
<tr>
<td>读地址10H得到0051（’q’）</td>
<td>读地址20H得到0051</td>
<td>md.w 20 1</td>
</tr>
<tr>
<td>读地址11H得到0052(‘r’)</td>
<td>读地址22H得到0052</td>
<td>md.w 22 1</td>
</tr>
<tr>
<td>读地址12H得到0059(‘y’)</td>
<td>读地址24H得到0059</td>
<td>md.w 24 1</td>
</tr>
<tr>
<td>读地址27H得到容量</td>
<td>读地址4EH得到容量</td>
<td>md.w 4e 1</td>
</tr>
<tr>
<td>读地址1BH得到VCCmin</td>
<td>读地址36H得到VCCmin</td>
<td>md.w 36 1</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/39.png"></p>
<p>从测试结果我们看到容量为2^21&#x3D;2M，Vcc最小提供电压是2.7v。</p>
<h3><span id="7-1-5-xie-shu-ju">7.1.5 写数据</span><a href="#7-1-5-xie-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，用md命令直接读取，不能像内存一样直接写，不信我们试试：</p>
<ol>
<li><p>我们在Nor Flash地址0x10000读数据</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/40.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于我们的uboot只有162k,烧录到norflash后，norflash上的的0x100000地址还没有被写入数据，norflash的容量为2M(0~0x200000),所以读取NorFlash的0x10000的地址数据是0xffff...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Nor flash的0x10000地址写数据0x1234，然后在这个地址读出数据：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/41.png"></p>
<p>可以看到0x1234无法写进去，读出来还是0xfffff。为什么呢？要怎么才能将0x1234写进去。找到命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash上写操作</th>
<th>2440上写操作</th>
<th>U-BOOT上写操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH(解锁)</td>
<td>往地址AAAH写AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写55H(解锁)</td>
<td>往地址554H写55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写A0H</td>
<td>往地址AAAH写A0H</td>
<td>mw.w aaa a0</td>
</tr>
<tr>
<td>往地址PA写PD</td>
<td>往地址0x100000写1234h</td>
<td>mw.w 100000 1234</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/42.png"></p>
</li>
</ol>
<p>可以看到0x1234已被写入到地址0x100000。再次往0x100000地址处，写入0x5678：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/43.png"></p>
<p>这时我们发现0x100000地址处的数据不是0x5678，而是0x1230，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因：flash有无法位反转的特性。</span><br><span class="line">具体分析：</span><br><span class="line">由于原来的数据已经是0x1234不是全0xffff，flash存储介质中只能1变成0，不能将0变成1。所以在0x1234的基础上不去擦出直接继续去写0x5678是会有问题的。</span><br><span class="line">如果将0x1234不擦就去写成0x5678,过程如下：</span><br><span class="line">0001 0010 0011 0100(0x1234)</span><br><span class="line">0101 0110 0111 1000(0x5678)</span><br><span class="line">----------------------------</span><br><span class="line">0001 0010 0011 0000(0x1230)</span><br></pre></td></tr></table></figure>

<p>所以得到就是0x1230, 因此flash写入前一定要先擦除。</p>
<h4><span id="7-1-5-1-ca-chu">7.1.5.1 擦除</span><a href="#7-1-5-1-ca-chu" class="header-anchor">#</a></h4><p>从datasheet找到擦除命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash擦操作</th>
<th>u-boot擦操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址555H写80H</td>
<td>mw.w    aaa   80</td>
</tr>
<tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址PA写30H</td>
<td>mw.w  100000  30</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/44.png"></p>
<p>擦除后再读取发现数据就已经变成了0xffff,后面就可以进行写操作了。</p>
<h4><span id="7-1-5-2-xie-ru">7.1.5.2 写入</span><a href="#7-1-5-2-xie-ru" class="header-anchor">#</a></h4><p>找到写入命令表，进行写入：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/45.png"></p>
<p>现在数据就变成我们的0x5678了。</p>
<p>注意：在写norflash时，要注意不要写0地址或者是uboot所在的地址，这样写入后norflash上的uboot程序就被破坏了。比如本测试就是写了0x100000地址,这个地址在uboot之外。</p>
<h2><span id="7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</span><a href="#7-2-cao-zuo-norflash-tuo-zhan" class="header-anchor">#</a></h2><h3><span id="7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</span><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi" class="header-anchor">#</a></h3><p>uboot发送md.w 0, md.w 2, md.w 4等偶地址命令能够读取norflash，但使用md.w 1, md.w 3,md.w 5就会出现死机，为什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">由于我们的norflash是<span class="number">16b</span>it数据位宽的，访问时要<span class="number">2b</span>yte对齐。如果不想以<span class="number">2b</span>yte为单位进行访问，那么要用uboot中用md.b <span class="number">1</span>,md.b <span class="number">3</span>这种单字节读取命令。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/46.png"></p>
<h3><span id="7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</span><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu" class="header-anchor">#</a></h3><p>操作norflash进行擦写的时候能够解锁一次，擦写多次吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不能，每次擦写都要进行解锁动作。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/47.png" alt="image-20240412144608560"></p>
<h3><span id="7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</span><a href="#7-2-3-ca-chu-dan-wei-kuai" class="header-anchor">#</a></h3><p>擦除那么是以块（block）为单位的，那么当进行擦除时发送的地址并不是以块对齐的，会有什么结果？</p>
<p><code>也能擦除成功，会根据地址范围确定在哪一个块中。</code></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/48.png"></p>
<p>填入的地址是0x100009,也是擦除0x100000地址对应的块。</p>
<h1><span id="8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</span><a href="#8-norflash-qu-dong-shi-li" class="header-anchor">#</a></h1><h2><span id="8-1-shi-bie-norflash">8.1 识别NorFlash</span><a href="#8-1-shi-bie-norflash" class="header-anchor">#</a></h2><p>我们知道要识别norflash属性，要让norflash进入cfi模式，然后按照手册上的表格发送一系列的命令就能获取norflash属性。</p>
<h3><span id="8-1-1-fa-ming-ling">8.1.1 发命令</span><a href="#8-1-1-fa-ming-ling" class="header-anchor">#</a></h3><p>实现一个cpu向nor发命令的一个函数nor_cmd()。我们的norflash是16bit位宽的，所以访问nor是以16位为单位访问的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NOR_FLASH_BASE  0  <span class="comment">/* s3c2440, nor--&gt;cs0, base addr = 0 */</span></span></span><br><span class="line"><span class="comment">/* 比如:   55H 98 </span></span><br><span class="line"><span class="comment">** 本意是: 往(0 + (0x55)&lt;&lt;1)写入0x98</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_write_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">	*p = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> cmd)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">nor_write_word</span>(NOR_FLASH_BASE, offset, cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nor_cmd(0x55, 0x90);</code>即可往norflash的0x55写入了0x98。</p>
<h3><span id="8-1-2-du-yi-ci-shu-ju">8.1.2  读一次数据</span><a href="#8-1-2-du-yi-ci-shu-ju" class="header-anchor">#</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_read_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">nor_read_word</span>(NOR_FLASH_BASE, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>nor_dat(0x100000)</code>即可得到该地址的数据。</p>
<h3><span id="8-1-3-shi-bie-han-shu">8.1.3 识别函数</span><a href="#8-1-3-shi-bie-han-shu" class="header-anchor">#</a></h3><p>有了发命令函数nor_cmd和读一次数据函数nor_dat,那么就就可以参考nor芯片手册的命令表进行操作norflash了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/49.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进入NOR FLASH的CFI模式</span></span><br><span class="line"><span class="comment"> * 读取flash属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_scan_nor_flash</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> regions, i;</span><br><span class="line">	<span class="type">int</span> region_info_base = <span class="number">0x2d</span>; <span class="comment">//第0块region的基地址2d，第1块region的基地址31,第2块region的基地址35......（参考手册表4-3）</span></span><br><span class="line">	<span class="type">int</span> block_addr=<span class="number">0</span>, blocks, block_size, j;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> vendor, device;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打印厂家ID、设备ID */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0x90</span>);    <span class="comment">/* read id */</span></span><br><span class="line">	vendor = <span class="built_in">nor_dat</span>(<span class="number">0</span>);</span><br><span class="line">	device = <span class="built_in">nor_dat</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);        <span class="comment">/* reset */</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x55</span>, <span class="number">0x98</span>);  <span class="comment">/* 进入cfi模式 */</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x10</span>);	<span class="comment">//读地址10H得到0051（&#x27;q&#x27;）</span></span><br><span class="line">	str[<span class="number">1</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x11</span>);	<span class="comment">//读地址11H得到0052(&#x27;r&#x27;)</span></span><br><span class="line">	str[<span class="number">2</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x12</span>);	<span class="comment">//读地址12H得到0059(&#x27;y&#x27;)</span></span><br><span class="line">	str[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n\r&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印容量 */</span></span><br><span class="line">	size = <span class="number">1</span>&lt;&lt;(<span class="built_in">nor_dat</span>(<span class="number">0x27</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;vendor id = 0x%x, device id = 0x%x, nor size = 0x%x = %dM\n\r&quot;</span>, vendor, device, size, size/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印各个扇区的起始地址 */</span></span><br><span class="line">	<span class="comment">/* 名词解释:</span></span><br><span class="line"><span class="comment">	 * region : 一个nor flash含有1个或多个region, 一个region含有1个或多个block(扇区).</span></span><br><span class="line"><span class="comment">	 * Erase block region[i] information:</span></span><br><span class="line"><span class="comment">	 *    前2字节+1    : 表示该region有多少个block </span></span><br><span class="line"><span class="comment">	 *    后2字节*256  : 表示block的大小</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Block/Sector start Address:\n\r&quot;</span>);</span><br><span class="line">	regions = <span class="built_in">nor_dat</span>(<span class="number">0x2c</span>);  <span class="comment">//读出region数量</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regions; i++) &#123;</span><br><span class="line">		blocks = <span class="number">1</span> + <span class="built_in">nor_dat</span>(region_info_base) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		block_size = <span class="number">256</span> * (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">2</span>) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">3</span>)&lt;&lt;<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\rregion %d, blocks = %d, block_size = 0x%x, block_addr = 0x%x\n\r&quot;</span>, i, blocks, block_size, block_addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blocks; j++) &#123;</span><br><span class="line">			<span class="comment">/* 打印每个block的起始地址 */</span></span><br><span class="line">			<span class="built_in">printHex</span>(block_addr);</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">				</span><br><span class="line">			block_addr += block_size;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		region_info_base += <span class="number">4</span>;	<span class="comment">/*得到region[i]的基地址*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="comment">/* 退出CFI模式 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/50.png"></p>
<p>从测试结果来看每个region的block个数和block_size不一定一样，像region[0]只有一个block，block_size为4*64K；<br>region[1]有2个block，block_size&#x3D;2*64K。</p>
<h2><span id="8-2-du-shu-ju">8.2 读数据</span><a href="#8-2-du-shu-ju" class="header-anchor">#</a></h2><p>由于NOR Flash是内存类接口，可以像内存一样读取，那么do_read_nor_flash函数代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read_nor_flash</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">	addr = <span class="built_in">get_uint</span>();</span><br><span class="line"></span><br><span class="line">	p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			c = *p++;</span><br><span class="line">			str[j] = c;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="8-3-ca-shu-ju">8.3 擦数据</span><a href="#8-3-ca-shu-ju" class="header-anchor">#</a></h2><p>norflash擦写都是需要一定时间的，那么当我执行擦除或者写入动作后什么时候代表一次擦写动作已经完成了呢？</p>
<p>芯片手册提供了一个方法，每次擦除或者烧写过程中都可以查询数据总线上的第6位（Q6）,当它保持稳定的时候表示一次擦除或者烧写动作完成，如下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/51.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pre;</span><br><span class="line"></span><br><span class="line">	pre = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	val = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> ((val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) != (pre &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>))) &#123;</span><br><span class="line">		pre = val;</span><br><span class="line">		val = nor_dat(addr&gt;&gt;<span class="number">1</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nor_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0x80</span>);	 <span class="comment">/* erase sector */</span></span><br><span class="line">	</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, <span class="number">0x30</span>);	 <span class="comment">/* 发出扇区地址 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/52.png"></p>
<p>可以看到擦除后这个block就是全0xffff了。</p>
<h2><span id="8-3-xie-shu-ju">8.3 写数据</span><a href="#8-3-xie-shu-ju" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_nor_flash</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* str[0],str[1]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 * str[2],str[3]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[i] &amp;&amp; str[j]) &#123;</span><br><span class="line">		val = str[i] + (str[j]&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 烧写 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">		nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">		<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">		wait_ready(addr);</span><br><span class="line"></span><br><span class="line">		i += <span class="number">2</span>;</span><br><span class="line">		j += <span class="number">2</span>;</span><br><span class="line">		addr += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val = str[i];</span><br><span class="line">	<span class="comment">/* 烧写 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">	<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/53.png"></p>
<p>由于我的norflash是位宽为16bit的，所以我们上面代码do_write_nor_flash进行写入时是以2byte（wold）为单位进行写入的。</p>
<p>总结：只要从spec中拿到了命令操作表，读写擦，识别就可以很轻松应对实现。</p>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>boot启动</tag>
        <tag>存储驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-电阻触摸屏</title>
    <url>/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</a><ul>
<li><a href="#1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</a></li>
<li><a href="#1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</a></li>
</ul>
</li>
<li><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</a><ul>
<li><a href="#2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</a></li>
<li><a href="#2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</a></li>
<li><a href="#2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</a></li>
<li><a href="#2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</a><ul>
<li><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</a></li>
<li><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</a><ul>
<li><a href="#3-1-normal-conversion-mode">3.1 Normal Conversion Mode</a></li>
<li><a href="#3-2-separate-x-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</a></li>
<li><a href="#3-3-auto-sequential-x-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</a></li>
<li><a href="#3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</a></li>
</ul>
</li>
<li><a href="#4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</a><ul>
<li><a href="#4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</a></li>
<li><a href="#4-2-data-ji-cun-qi">4.2 DATA寄存器</a><ul>
<li><a href="#4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</a></li>
<li><a href="#4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</a></li>
</ul>
</li>
<li><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</a></li>
</ul>
</li>
<li><a href="#5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</a><ul>
<li><a href="#5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</a><ul>
<li><a href="#5-1-1-zhong-duan-yuan">5.1.1 中断源</a></li>
<li><a href="#5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</a></li>
<li><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</a></li>
<li><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</a><ul>
<li><a href="#5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</a></li>
<li><a href="#5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</a><ul>
<li><a href="#5-2-1-chu-shi-hua">5.2.1 初始化</a><ul>
<li><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</a></li>
<li><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</a></li>
<li><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</a></li>
</ul>
</li>
<li><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</a><ul>
<li><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</a><ul>
<li><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</a></li>
<li><a href="#5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</a></li>
</ul>
</li>
<li><a href="#5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</a></li>
<li><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</a><ul>
<li><a href="#5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</a></li>
<li><a href="#5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</a><ul>
<li><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</a><ul>
<li><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</span><a href="#1-dian-zu-hong-mo-ping-yuan-li" class="header-anchor">#</a></h1><p>触摸屏包含上下叠合的两个透明层，一般覆盖在lcd表面，两个透明层是由均匀的电阻介质组成，如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/1.png"></p>
<p>当触摸屏表面受到的压力（如通过笔尖或手指进行按压）足够大时，顶层与底层之间的薄膜会产生接触，此时会形成x方向和y方向的坐标。那么x，y坐标的值是怎么得来的呢？本质上就是通过ADC转换得来的。</p>
<p>触摸屏的等效电路可以看成如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/2.jpg"></p>
<p>计算触点的X，Y坐标分为如下两步： </p>
<h2><span id="1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</span><a href="#1-1-ji-suan-y-zuo-biao" class="header-anchor">#</a></h2><p>在Y+电极施加驱动电压Vdrive， Y-电极接地，由于上下两层膜形成触点，X+做为触点的引出端，测量得到接触点的电压，触点电压与Vdrive电压之比等于触点Y坐标与屏高度之比。如下图：</p>
<h2><span id="1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</span><a href="#1-2-ji-suan-x-zuo-biao" class="header-anchor">#</a></h2><p>在X+电极施加驱动电压Vdrive， X-电极接地，由于上下两层膜形成触点，Y+做为触点的引出端，测量得到接触点的电压，Y+做为引出端测量得到接触点的电压，触点电压与Vdrive电压之比等于触点X坐标与屏宽度之比。如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/3.jpg"></p>
<h1><span id="2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</span><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi" class="header-anchor">#</a></h1><h2><span id="2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</span><a href="#2-1-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h2><p>平时的时候上下两层膜并不粘在一起，我们把这种状态称为<strong>“等待中断模式”</strong>， 等效电路如下图的右边那幅图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/4.png"></p>
<p>s5、s4闭合，s1、s2、s3断开，这个时候Y_ADC&#x2F;XP通过S5接上拉电阻，处于高电平状态,X_ADC&#x2F;YP接地。没法读取x,y坐标。</p>
<h2><span id="2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</span><a href="#2-2-du-qu-x-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给X方向通电，也就是让S1、S3开关闭合，s2、s4断开，那么当屏幕按下，触点YP的电平就对应x坐标。（XP到XM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/5.png"></p>
<pre><code>x_adc电压/vcc = x坐标/width, 所以x坐标= width * x_adc电压/vcc
</code></pre>
<h2><span id="2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</span><a href="#2-3-du-qu-y-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给Y方向通电，也就是让S2、S4开关闭合，s1、s3断开，那么当屏幕按下，触点XP的电平就对应y坐标。（YP到YM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/6.png"></p>
<pre><code>y_adc电压/vcc = Y坐标/height, 所以y坐标= height * y_adc电压/vcc
</code></pre>
<h2><span id="2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</span><a href="#2-4-ts-zhong-duan-liu-cheng" class="header-anchor">#</a></h2><p>总结一下单次触发TS中断，使用触摸屏的流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 按下触摸屏，产生TS中断</span><br><span class="line"><span class="number">2.</span> 启动ADC(目的是获取x,y方向上的坐标值)</span><br><span class="line"><span class="number">3.</span> ADC转换完成，产生adc中断（adc转换需要一定的时间）</span><br><span class="line"><span class="number">4.</span> ADC中断中来读取x y坐标</span><br><span class="line"><span class="number">5.</span> 松开，结束</span><br></pre></td></tr></table></figure>

<p>我们知道，现在的手机都是支持屏幕滑动翻页和长按的功能。那么这些功能是如何做到的呢？</p>
<h3><span id="2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</span><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi" class="header-anchor">#</a></h3><p>如何让触摸屏支持长按或者滑动操作（多次触发TS中断）？</p>
<p>答案:<strong>定时器</strong>，当长按屏幕，会产生多次TS中断，因此我们需要用定时器来判断，当定时一段时间后，还有TS中断产生，那么我们认为是长按操作，进行中断响应。滑动也是类似的道理，当定时时间到后，如果还有TS中断产生，且坐标发生了改变，就认为是滑动操作。</p>
<pre><code>&lt;5&gt; 启动定时器
&lt;6&gt; 一段时间后，定时器中断发生，判断触摸屏是否仍被按下(是否有定时器中断产生)，如果有就循环上述过程&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;
</code></pre>
<p>可以用如下流程图概括TSC的整个SW flow.</p>
<h3><span id="2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</span><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/7.png" alt="image"></p>
<h1><span id="3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</span><a href="#3-hong-mo-ping-jie-kou-mo-shi" class="header-anchor">#</a></h1><h2><span id="3-1-normal-conversion-mode">3.1 Normal Conversion Mode</span><a href="#3-1-normal-conversion-mode" class="header-anchor">#</a></h2><p>正常转换模式，一般情况下可以配置ADCCON和ADCDAT0来读取数据。</p>
<h2><span id="3-2-separate-x-x2f-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</span><a href="#3-2-separate-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/8.png"><br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/9.png"></p>
<p>x,y坐标分离转换格式，x坐标会写入ADCDAT0, y坐标会写入ADCDAT1,所以会产生2次中断开分开完成x,y的坐标转换。</p>
<h2><span id="3-3-auto-sequential-x-x2f-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</span><a href="#3-3-auto-sequential-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p>自动转换模式，当触摸屏按下后，会一次性对x,y方向的坐标进行转换，x坐标会写入ADCDAT0, x坐标会写入ADCDAT1。会产生一次中断进行x,y坐标的自动转换。 </p>
<h2><span id="3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</span><a href="#3-4-waiting-for-interrupt-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/10.jpg"></p>
<p> 等待中断模式 。可以设置rADCTSC&#x3D;0xd3;也就是对应下图寄存器 &#x2F;&#x2F; XP_PU, XP_Dis, XM_Dis, YP_Dis, YM_En.当产生中断信号(INT_TC)后，等待中断模式必须清除.(即XY_PST sets to the No operation Mode).</p>
<h1><span id="4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</span><a href="#4-hong-mo-ping-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</span><a href="#4-1-ts-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p>电阻触摸屏的原理本质上就是ADC，ADC相关寄存器介绍详见<a href="https://www.cnblogs.com/fuzidage/p/13396987.html">s3c2440裸机-ADC编程</a>或者<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/">s3c2440裸机编程-ADC | Hexo (fuzidage.github.io)</a><br>TSC相比ADC多了一个ADCTSC寄存器，如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/11.jpg" alt="image"><br>当bit[2]&#x3D;0，normal mode时，那么bit[1:0]需要配置成01或者10进行手工测量x,y.<br>当bit[2]&#x3D;1，auto mode时，那么bit[1:0]需要配置成0,进行自动测量。</p>
<h2><span id="4-2-data-ji-cun-qi">4.2 DATA寄存器</span><a href="#4-2-data-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</span><a href="#4-2-1-x-zuo-biao-adcdata0" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/12.png" alt="image"></p>
<h3><span id="4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</span><a href="#4-2-2-y-zuo-biao-adcdata1" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/13.png" alt="image"></p>
<h2><span id="4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</span><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi" class="header-anchor">#</a></h2><p>这个寄存器可以检测是否有触摸中断产生，是按下触摸屏了，还是松开触摸屏了。<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/14.png" alt="image"></p>
<h1><span id="5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</span><a href="#5-hong-mo-ping-bian-cheng-shi-li" class="header-anchor">#</a></h1><h2><span id="5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</span><a href="#5-1-adc-zhong-duan-chan-sheng" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/15.png" alt="img"></p>
<h3><span id="5-1-1-zhong-duan-yuan">5.1.1 中断源</span><a href="#5-1-1-zhong-duan-yuan" class="header-anchor">#</a></h3><p>ADC和TSC共用一个中断源，如下：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/16.png" alt="img"></p>
<p>SRCPND表示哪个中断源产生了中断请求。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/17.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/18.png" alt="img"></p>
<h3><span id="5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</span><a href="#5-1-2-zhong-duan-mo-shi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/19.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/20.png" alt="img"></p>
<h3><span id="5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</span><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/21.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/22.png" alt="img"></p>
<h3><span id="5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</span><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi" class="header-anchor">#</a></h3><p>用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/23.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/24.png" alt="img"></p>
<p>从SRCPND寄存器可以读到ADC和TSC复用的同一个中断源，那么如何区分呢？</p>
<p>可以从SUBSRCPND寄存器配置，如下：</p>
<h4><span id="5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</span><a href="#5-1-4-1-subsrcpnd-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/25.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/26.png" alt="img"></p>
<p> 当bit 9被置1时，表示TSC中断。那么我们需要打开subsrcmask寄存器：</p>
<h4><span id="5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</span><a href="#5-1-4-2-intsubmsk-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/27.png" alt="img"></p>
<p>所以TSC中断的产生流程如下：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/28.png" alt="img"></p>
<h2><span id="5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</span><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化TSC，ADCTSC寄存器</span><br><span class="line"><span class="number">2.</span> 设定TSC处于“等待中断模式”</span><br><span class="line"><span class="number">3.</span> 使能TSC中断</span><br><span class="line">　　　　　　INTSUBMSK</span><br><span class="line">　　　　　　MSK/MODE</span><br><span class="line"><span class="number">4.</span> 按下，进入TSC中断</span><br><span class="line">　　　　　　进入自动采集转换模式</span><br><span class="line">　　　　　　启动ADC</span><br><span class="line"><span class="number">5.</span> ADC中断</span><br><span class="line">　　　　　　读数据</span><br><span class="line">　　　　　　再次进入”等待中断模式“</span><br><span class="line">　　　　　　启动定时器（为了处理长按或者滑动操作）</span><br><span class="line"><span class="number">6.</span> 定时器中断</span><br><span class="line">　　　　　　若松开，结束</span><br><span class="line">　　　　　　如任然按下，进入步骤<span class="number">4</span>的启动ADC流程</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/29.png" alt="img"></p>
<h3><span id="5-2-1-chu-shi-hua">5.2.1 初始化</span><a href="#5-2-1-chu-shi-hua" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置触摸屏接口:寄存器 */</span></span><br><span class="line">    adc_ts_reg_init();</span><br><span class="line">    <span class="comment">/* 设置中断 */</span></span><br><span class="line">    adc_ts_int_init();</span><br><span class="line">    <span class="comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</span><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>主要是设置预分频，产生ADC clk &#x3D; 1MHz。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">     * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">     * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">     * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">     * [2]   : STDBM</span></span><br><span class="line"><span class="comment">     * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    ADCDLY = <span class="number">0xff</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</span><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua" class="header-anchor">#</a></h4><p>为了将中断源开启，这里设置SUBSRCPND 和INTSUBMSK让中断源开启。通过register_irq（）注册中断号和中断服务程AdcTsIntHandle，查表得出中断号为31，这样当硬件产生中断后可以从INTOFFSET区分是哪个中断号。如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/30.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_int_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    register_irq(<span class="number">31</span>, AdcTsIntHandle);    <span class="comment">/*31号中断*/</span></span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    INTSUBMSK &amp;= ~((<span class="number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="number">1</span>&lt;&lt;TC_INT_BIT));<span class="comment">//防止屏蔽（SUBMSK）</span></span><br><span class="line">    <span class="comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);//reg_irq已经使能了31中断号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</span><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/31.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/32.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/33.png" alt="img"></p>
<p>进入等待中断模式，YM闭合， YP， XP， XM断开，需要pull up，WAIT_PEN_DOWN表示要等待的是按下中断，当触摸屏按下时就会产生一个TSC irq,反之WAIT_PEN_UP表示要等待的是松开中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_INT_BIT (10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TC_INT_BIT  (9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_ADC_TC   (31)</span></span><br><span class="line"><span class="comment">/* ADCTSC&#x27;s bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_DOWN    (0&lt;&lt;8) <span class="comment">/*触摸笔按下*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_UP      (1&lt;&lt;8) <span class="comment">/*触摸笔松开*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_ENABLE        (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_DISABLE       (0&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_ENABLE        (0&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_DISABLE       (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_ENABLE        (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_DISABLE       (0&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_ENABLE        (0&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_DISABLE       (1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_ENABLE    (0&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_DISABLE   (1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)    <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)    <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_down_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待按下模式*/</span> &#123;</span><br><span class="line">	ADCTSC = WAIT_PEN_DOWN | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | 	WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_up_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待松开模式*/</span> &#123;</span><br><span class="line">	ADCTSC = WAIT_PEN_UP | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</span><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h3><p>SUBSRCPND的bit9, bit10可以区分是TC中断还是ADC中断。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/34.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*触摸屏中断服务程序*/</span> &#123;</span><br><span class="line">　　	<span class="built_in">printf</span>(<span class="string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br><span class="line">　　	<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">//dat寄存器的第15位判断按下还是松开</span></span><br><span class="line">　　　　	<span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">　　　　	enter_wait_pen_down_mode();</span><br><span class="line">　　	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　	<span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">　　　　	<span class="comment">/* 进入&quot;等待触摸笔松开的模式&quot; */</span></span><br><span class="line">　　　　	enter_wait_pen_up_mode();</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　	<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT)) <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　	Isr_Tc();</span><br><span class="line">　　	<span class="comment">// if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT)) /* ADC中断 */</span></span><br><span class="line">　　	<span class="comment">// Isr_Adc();</span></span><br><span class="line">　　	SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">　　	<span class="comment">//SRCPND = 1&lt;&lt;31;/*在interrupt.c已经清中断了*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdcTsIntHandle函数： 这里先注解掉ADC中断，只检测单独的按下松开触摸屏操作。那当isr处理完后为了能够正常响应下一次中断，需要清中断，否则会一直触发interrupt。</span><br><span class="line">Isr_Tc函数：ADCDAT0 寄存器的第15位判断按下还是松开。那么当按下后，要将控制器进入”等待松开模式“，当松开后，要将控制器配置进入”等待按下模式“。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/35.png" alt="img"></p>
<h4><span id="5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</span><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao" class="header-anchor">#</a></h4><h5><span id="5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</span><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi" class="header-anchor">#</a></h5><p>Auto(Sequential) X&#x2F;Y Position Conversion Mode。打开TS控制寄存器，也就是ADCTSC寄存器：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/36.png" alt="img"></p>
<p>让bit[2] &#x3D;1, bit[1:0]&#x3D;00，则会进入auto measurement。如果bit[2]&#x3D;0，则需配置bit[1::0]&#x3D;01 or 10是手动测量x,y坐标。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)        <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)        <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_auto_measure_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　ADCTSC = AUTO_PST | NO_OPR_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</span><a href="#5-2-2-1-2-qi-dong-adc" class="header-anchor">#</a></h5><p>触摸屏坐标就是通过ADC获取的。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/37.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>所以TSC isr程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">/*触摸屏中断服务程序*/</span></span><br><span class="line">      <span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">            enter_wait_pen_down_mode();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">            <span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">            enter_auto_measure_mode();</span><br><span class="line">            <span class="comment">/* 启动ADC */</span></span><br><span class="line">            ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当检测到按下后，需要进入auto measure mode，启动adc，然后就会进行自动坐标转换，转换结束后又会触发ADC中断，再次进入<code>AdcTsIntHandle</code>函数，进而进入<code>Isr_Adc</code>，SUBSRCPND可以区分中断源 。如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT))  <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　Isr_Tc();</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="comment">/* ADC中断 */</span></span><br><span class="line">　　　　Isr_Adc();</span><br><span class="line">　　SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道ADC进行坐标转换结束后，那么会产生ADC中断，在<code>Isr_Adc</code>中即可获取我们的x,y坐标数据。由于我们按下后是进入了 “自动测量” 模式，因此那当数据获取完后我们得进入 “等待松开” 模式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Adc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="type">int</span> x = ADCDAT0;</span><br><span class="line">      <span class="type">int</span> y = ADCDAT1;</span><br><span class="line">      <span class="keyword">if</span> (!(ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))) &#123; <span class="comment">/* 在isr_Tc按下后，如果仍然按下才打印 */</span></span><br><span class="line">            x &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            y &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);</span><br><span class="line">      &#125;</span><br><span class="line">      enter_wait_pen_up_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有可能触摸屏的测量过程非常长，那当ADC转换结束后，它已经松开了，这时不应该进行打印出坐标，所以这里在isr_Tc按下后，如果仍然按下才打印。</p>
<h4><span id="5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</span><a href="#5-2-2-2-adcdly-ji-cun-qi" class="header-anchor">#</a></h4><p>由于触摸屏采样的转换速率问题，按下后需要过一段电压才能稳定下来，那么数据才能稳定可能需要一定的延迟，所以需要配置ADC delay，让ADC慢一点产生中断，也就是等坐标稳定后在通知用户。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/38.png" alt="img"></p>
<p>ADCDLY就是用来延时ADC启动的时间，让数据稳定后再进行转换。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/39.png" alt="img"></p>
<p><code>可以看到，进行auto or manual measure 坐标转换的时序要满足：A = Dx,D表示ADCDLY的值。 现在晶振的频率是12Mhz, 那么根据触摸屏规格书我们取A= 5ms，那么D= 0.005s *12*1000000 = 60000，所以ADCDLY配置成60000.</code></p>
<p>修改前面的<code>adc_ts_reg_init</code>函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">       * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">       * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">       * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">       * [2]   : STDBM</span></span><br><span class="line"><span class="comment">       * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">      <span class="comment">/*  按下触摸屏, 延时一会再发出TC中断</span></span><br><span class="line"><span class="comment">       *  延时时间 = ADCDLY * 晶振周期 = ADCDLY * 1 / 12000000 = 5ms</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCDLY = <span class="number">60000</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</span><a href="#5-3-ts-hong-mo-ping-ce-shi" class="header-anchor">#</a></h2><p>从左往右依次点击触摸屏，可以看到x坐标没有明显变化，y坐标反而线性变大。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/40.png" alt="img"></p>
<p>同理，从上往下依次按下触摸屏，可以看到y坐标没有明显变化，x坐标反而线性变大。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/41.png" alt="img"></p>
<p>这里是由于硬件上xp与yp接反了，ym与xm接反了，如下图：但这里并不影响我们的时候，这里我们软件上可以进行x,y坐标的转换：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/42.png" alt="img"></p>
<p>我们软件上可以对x,y轴进行flip， mirror, rotaion旋转等一系列操作即可。比如：</p>
<p>Case1：ts与lcd吻合</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/43.png" alt="img"></p>
<p>Case2：ts与lcd相反</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/44.png" alt="img"></p>
<h2><span id="5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</span><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong" class="header-anchor">#</a></h2><h3><span id="5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</span><a href="#5-4-1-gai-jin-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有讲到在<code>handle_irq_c()</code>中去区分中断源，执行不同的<code>isr</code>。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/45.png" alt="image-20240501173712329"></p>
<p>那现在通过<code>register_timer</code>注册对应的定时器中断服务程序，<code>timer_irq</code>进行执行不同的定时器中断服务程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_NUM  32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL  ((void *)0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*timer_func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_desc</span> &#123;</span></span><br><span class="line">　　<span class="type">char</span> *name;</span><br><span class="line">　　timer_func fp;</span><br><span class="line">&#125;timer_desc, *p_timer_desc;</span><br><span class="line"></span><br><span class="line">timer_desc timer_array[TIMER_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">register_timer</span><span class="params">(<span class="type">char</span> *name, timer_func fp)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = name;</span><br><span class="line">　　　　　　timer_array[i].fp   = fp;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_timer</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(timer_array[i].name, name)) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　timer_array[i].fp   = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].fp();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要用timer来进行进行流水灯实验，那么假如点灯函数为:<br><code>Isr_timer_led()&#123;&#125;</code></p>
<p>那么则只需要在<code>led init</code>的时候进行调用<code>register_timer(“led”, Isr_timer_led)</code>, 那么当时间到后触发定时器中断，便会执行<code>timer_irq</code>.进入<code>Isr_timer_led</code>。</p>
<h3><span id="5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</span><a href="#5-4-2-chu-shi-hua-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有具体讲解，这里采用PWM定时器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="comment">/* 设置TIMER0的时钟 */</span></span><br><span class="line">　　<span class="comment">/* Timer clk = PCLK / &#123;prescaler value+1&#125; / &#123;divider value&#125;</span></span><br><span class="line"><span class="comment">             = 50000000/(49+1)/16</span></span><br><span class="line"><span class="comment">             = 62500</span></span><br><span class="line"><span class="comment"> 　　*/</span></span><br><span class="line">　　TCFG0 = <span class="number">49</span>;  <span class="comment">/* Prescaler 0 = 49, 用于timer0,1 */</span></span><br><span class="line">　　TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">　　TCFG1 |= <span class="number">3</span>;  <span class="comment">/* MUX0 : 1/16 */</span></span><br><span class="line">　　<span class="comment">/* 设置TIMER0的初值 */</span></span><br><span class="line">　　TCNTB0 = <span class="number">625</span>;  <span class="comment">/* 10Ms中断一次 */</span></span><br><span class="line">　　<span class="comment">/* 加载初值, 启动timer0 */</span></span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);   <span class="comment">/* Update from TCNTB0 &amp; TCMPB0 */</span></span><br><span class="line">　　<span class="comment">/* 设置为自动加载并启动 */</span></span><br><span class="line">　　TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);  <span class="comment">/* bit0: start, bit3: auto reload */</span></span><br><span class="line">　　<span class="comment">/* 设置中断 */</span></span><br><span class="line">　　register_irq(<span class="number">10</span>, timer_irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</span><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong" class="header-anchor">#</a></h4><p>我们之前是2s timer触发一次中断，那如果是要支持触摸屏，我们必须让定时器10ms就触发一次中断。因此需要修改timer_init中的寄存器参数。</p>
<p>当按下触摸屏会产生TSC中断，然后启动ADC进而产生<code>adc</code>中断的时候，在<code>Isr_Adc</code>函数中进行定时器的设置，检测长按和滑动操作。</p>
<h5><span id="5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</span><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_status_of_ts_timer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">return</span> g_ts_timer_enable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 每10ms该函数被调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (get_status_of_ts_timer() == <span class="number">0</span>)</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">/* 如果松开 */</span></span><br><span class="line">　　　　ts_timer_disable();</span><br><span class="line">　　　　enter_wait_pen_down_mode();</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span></span><br><span class="line">　　<span class="keyword">else</span> &#123;  <span class="comment">/* 按下状态 */</span></span><br><span class="line">　　　　<span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">　　　　enter_auto_measure_mode();</span><br><span class="line">　　　　<span class="comment">/* 启动ADC */</span></span><br><span class="line">　　　　ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/46.png" alt="image-20240501174908562"></p>
<p>来分析一下这个程序的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 在touchscreen_init的时候我们先注册了一个timer，然后修改了定时器的产生中断的时间间隔为<span class="number">10</span>ms中断一次，所以touchscreen_timer_irq会每间隔<span class="number">10</span>ms调用一次。没有按下，则touchscreen_timer_irq虽然也有走，但是就直接<span class="keyword">return</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 然后如果按下触摸屏，产生tsc中断，启动adc，产生adc中断。</span><br><span class="line"></span><br><span class="line">如果产生了adc中断，但是读取状态发现已经松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效。那么要是状态是被按下，则开启ts_timer_enable。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 当使能touchscreen_timer_irq这个定时器中断服务程序后，并且<span class="number">10</span>ms到了touchscreen_timer_irq函数执行生效。</span><br><span class="line"></span><br><span class="line">如果松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效，表示没有长按或者滑动。</span><br><span class="line"></span><br><span class="line">如果任然按下，输出长按或者滑动后的坐标结果。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-时钟体系</title>
    <url>/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zong-xian-kuang-jia">1 总线框架</a></li>
<li><a href="#2-shi-zhong-kuang-jia">2 时钟框架</a><ul>
<li><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</a></li>
<li><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</a></li>
</ul>
</li>
<li><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</a><ul>
<li><a href="#3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</a></li>
<li><a href="#3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</a><ul>
<li><a href="#3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</a></li>
<li><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</a></li>
<li><a href="#3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-zong-xian-kuang-jia">1 总线框架</span><a href="#1-zong-xian-kuang-jia" class="header-anchor">#</a></h1><p>下图是s3c2440的总线框架，其中有AHB(Advanced High performance Bus)高速总线,APB(Advanced Peripheral Bus)外围总线。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/1.jpg"></p>
<p>不同总线对应不同的时钟。</p>
<pre><code>SOC &lt;-&gt; FCLK
AHB &lt;-&gt; HCLK	
APB &lt;-&gt; PCLK 
</code></pre>
<p>其中：</p>
<p>1.使用AHB总线的有：LCD控制器、usb控制器、中断控制器、内存控制器等…<br>2.使用APB总线的有：i2c、spi、timer、gpio、adc等…具体上图。</p>
<h1><span id="2-shi-zhong-kuang-jia">2 时钟框架</span><a href="#2-shi-zhong-kuang-jia" class="header-anchor">#</a></h1><p>下图表示s3c2440 Soc的时钟框图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/2.png"></p>
<p>下面从细节上讲解时钟体系：</p>
<h2><span id="2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</span><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan" class="header-anchor">#</a></h2><p>s3c2440时钟源有2个，一个是OSC，一个是外部时钟EXTCLK,上面的时钟框图有标记，当然大家也可以查看手册“Figure 7-1. Clock Generator Block Diagram”。</p>
<p>那么如何选择是OSC还是EXTCLK呢？</p>
<p>打开原理图，OM3,OM2的引脚接地，那么OM[3,2]&#x3D;00.所以根据手册“Table 7-1. Clock Source Selection at Boot-Up”可知时钟源为OSC晶振。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/3.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/4.png"></p>
<h2><span id="2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</span><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk" class="header-anchor">#</a></h2><p>先了解下PLL, DIV</p>
<pre><code>PLL:用锁相环进行倍频
DIV:用分频器进行分频
</code></pre>
<p>如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/5.png"></p>
<p>生成的MPLL(Main PLL)和UPLL(USB PLL)，MPLL直接提供给FCLK，通过HDIVN分频给HCLK，通过PDIVN分频给PCLK，再传给下面的各个设备。<br>osc经过UPLL(USB PLL)得到UCLK。</p>
<h1><span id="3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</span><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</span><a href="#3-1-s3c2440-shi-zhong-shi-xu" class="header-anchor">#</a></h2><p>下图是2440时钟配置时序：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/6.jpg"></p>
<p>1.上电后，nRESET复位信号拉低，此时cpu还无法取指令工作。<br>2.nRESET复位信号结束后变为高电平，此时cpu开始工作。此时cpu主频FCLK&#x3D;osc。<br>3.此时可以配置PLL，经过lock time后，FCLK倍频成新的时钟。</p>
<h2><span id="3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</span><a href="#3-2-ru-he-pei-zhi-shi-zhong" class="header-anchor">#</a></h2><p>在参考手册的特性里介绍了S3C2440的工作频率，Fclk最高400MHz，Hclk最高136MHz，Pclk最高68MHz。那么 我们干脆配置FCLK：HCLK:PCLK&#x3D; 400：100：50 (MHz).</p>
<h3><span id="3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</span><a href="#3-2-1-pei-zhi-lock-time" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/7.png"></p>
<pre><code>我们取芯片手册上的推荐值。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>
<h3><span id="3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</span><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/8.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/9.png"></p>
<p>也可参考配置表取值<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/10.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">** MPLL(FCLK) = 2*m*Fin/(p*2^s)</span><br><span class="line">** 不妨取：</span><br><span class="line">** m = MDIV+8 = 92+8=100</span><br><span class="line">** p = PDIV+2 = 1+2 = 3</span><br><span class="line">** s = SDIV = 1</span><br><span class="line">** 则：</span><br><span class="line">** FCLK= 2*100*12/(3*2^1)=400M</span><br><span class="line">*/</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>

<p>注意：如果也要配置了UPLL,那么先配置UPLL,要个7个NOP后才能再配置MPLL.</p>
<p>###3,配置CLKDIVN得到HCLK,PCLK<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>

<p>注意：如果HDIV设置为非0，CPU的总线模式要进行改变，默认情况下FCLK &#x3D; HCLK，CPU工作在fast bus mode快速总线模式下，HDIV设置为非0后， FCLK与HCLK不再相等，要将CPU改为asynchronous bus mod异步总线模式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15, 0, r1, c1, c0, 0         /* 读取CP15 C1寄存器 */ </span><br><span class="line">orr r1, r1, #0xc0000000           /* 设置CPU总线模式 */ </span><br><span class="line">mcr p15, 0, r1, c1, c0, 0         /* 写回CP15 C1寄存器 */</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</span><a href="#3-2-2-wan-zheng-hui-bian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">/* 关闭看门狗 */</span><br><span class="line">ldr r0, =0x53000000</span><br><span class="line">ldr r1, =0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15,0,r0,c1,c0,0</span><br><span class="line">orr r0,r0,#0xc0000000   //R1_nF:OR:R1_iA</span><br><span class="line">mcr p15,0,r0,c1,c0,0</span><br><span class="line"></span><br><span class="line">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0) </span><br><span class="line"> *  m = MDIV+8 = 92+8=100</span><br><span class="line"> *  p = PDIV+2 = 1+2 = 3</span><br><span class="line"> *  s = SDIV = 1</span><br><span class="line"> *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M</span><br><span class="line"> */</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定</span><br><span class="line"> * 然后CPU工作于新的频率FCLK</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* 设置内存: sp 栈 */</span><br><span class="line">/* 分辨是nor/nand启动</span><br><span class="line"> * 写0到0地址, 再读出来</span><br><span class="line"> * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</span><br><span class="line"> * 否则就是nor启动</span><br><span class="line"> */</span><br><span class="line">mov r1, #0</span><br><span class="line">ldr r0, [r1] /* 读出原来的值备份 */</span><br><span class="line">str r1, [r1] /* 0-&gt;[0] */ </span><br><span class="line">ldr r2, [r1] /* r2=[0] */</span><br><span class="line">cmp r1, r2</span><br><span class="line">ldr sp, =0x40000000+4096</span><br><span class="line">moveq sp, #4096  /* r1=r2， nand启动，修改栈指针=4096（此时sram对应0地址） */</span><br><span class="line">streq r0, [r1]   /* 恢复原来的值 */</span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>boot启动</tag>
        <tag>时钟体系</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-bootm和bootz启动内核</title>
    <url>/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-images-quan-ju-bian-liang">1 images 全局变量</a><ul>
<li><a href="#1-1-bootm-tou-bu-jie-gou">1.1 bootm头部结构</a><ul>
<li><a href="#1-1-1-xi-tong-jing-xiang-tou-bu-jie-gou">1.1.1 系统镜像头部结构</a></li>
<li><a href="#1-1-2-xi-tong-jing-xiang-jie-gou">1.1.2 系统镜像结构</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-do-bootz-han-shu">2 do_bootz 函数</a><ul>
<li><a href="#2-1-bootz-start">2.1 bootz_start</a><ul>
<li><a href="#2-1-1-bootm-start">2.1.1 bootm_start</a></li>
<li><a href="#2-1-2-bootz-setup">2.1.2 bootz_setup</a></li>
<li><a href="#2-1-3-bootm-find-images">2.1.3 bootm_find_images</a></li>
</ul>
</li>
<li><a href="#2-2-do-bootm-states">2.2 do_bootm_states</a><ul>
<li><a href="#2-2-1-bootm-os-get-boot-func">2.2.1 bootm_os_get_boot_func</a></li>
<li><a href="#2-2-2-boot-pre-linux">2.2.2 boot_pre_linux</a></li>
<li><a href="#2-2-3-boot-jump-linux">2.2.3 boot_jump_linux</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-zong-jie-bootz-qi-dong-guo-cheng">3 总结bootz启动过程</a></li>
<li><a href="#4-uboot-qi-dong-linux-ce-shi">4 uboot 启动 Linux 测试</a><ul>
<li><a href="#4-1-emmc-qi-dong-linux">4.1 EMMC 启动 Linux</a></li>
<li><a href="#4-2-wang-luo-qi-dong-linux">4.2 网络启动 Linux</a></li>
</ul>
</li>
<li><a href="#5-fu-lu-bi-te-yu-shi-liu-jin-zhi-zhuan-huan-kuai-cha-biao">5 附录：比特与十六进制转换快查表</a></li>
<li><a href="#6-mkimage-gong-ju">6 mkimage工具</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-images-quan-ju-bian-liang">1 images 全局变量</span><a href="#1-images-quan-ju-bian-liang" class="header-anchor">#</a></h1><p>不管是<code>bootz</code>还是<code>bootm</code>命令,启动kernel都会用到<code>images</code>全局变量。<code>images 定义在文件 cmd/bootm.c</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/1.png" alt="image"><br><code>include/image.h </code>中的定义了<code>bootm_headers_t</code>结构：该结构描述的是<code>bootm</code>启动时的头部信息。该结构又包含了系统镜像头部和系统镜像。</p>
<h2><span id="1-1-bootm-tou-bu-jie-gou">1.1 bootm头部结构</span><a href="#1-1-bootm-tou-bu-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">304</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> &#123;</span></span><br><span class="line"><span class="number">305</span> 	<span class="comment">/*</span></span><br><span class="line"><span class="comment">306 	* Legacy os image header, if it is a multi component image</span></span><br><span class="line"><span class="comment">307 	* then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class="line"><span class="comment">308 	* data from second and third component accordingly.</span></span><br><span class="line"><span class="comment">309 	*/</span></span><br><span class="line"><span class="number">310</span> 	<span class="type">image_header_t</span> *legacy_hdr_os; <span class="comment">/* image header pointer */</span></span><br><span class="line"><span class="number">311</span> 	<span class="type">image_header_t</span> legacy_hdr_os_copy; <span class="comment">/* header copy */</span></span><br><span class="line"><span class="number">312</span> 	ulong legacy_hdr_valid;</span><br><span class="line"><span class="number">313</span></span><br><span class="line">......</span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">334</span> 	<span class="meta">#<span class="keyword">ifndef</span> USE_HOSTCC</span></span><br><span class="line"><span class="number">335</span> 	<span class="type">image_info_t</span> os; <span class="comment">/* OS 镜像信息 */</span></span><br><span class="line"><span class="number">336</span> 	ulong ep; <span class="comment">/* OS 入口点 */</span></span><br><span class="line"><span class="number">337</span></span><br><span class="line"><span class="number">338</span> 	ulong rd_start, rd_end; <span class="comment">/* ramdisk 开始和结束位置 */</span></span><br><span class="line"><span class="number">339</span></span><br><span class="line"><span class="number">340</span> 	<span class="type">char</span> *ft_addr; <span class="comment">/* 设备树地址 */</span></span><br><span class="line"><span class="number">341</span> 	ulong ft_len; <span class="comment">/* 设备树长度 */</span></span><br><span class="line"><span class="number">342</span></span><br><span class="line"><span class="number">343</span> 	ulong initrd_start; <span class="comment">/* initrd 开始位置 */</span> </span><br><span class="line"><span class="number">344</span> 	ulong initrd_end; <span class="comment">/* initrd 结束位置 */</span></span><br><span class="line"><span class="number">345</span> 	ulong cmdline_start; <span class="comment">/* cmdline 开始位置 */</span></span><br><span class="line"><span class="number">346</span> 	ulong cmdline_end; <span class="comment">/* cmdline 结束位置 */</span></span><br><span class="line"><span class="number">347</span> 	<span class="type">bd_t</span> *kbd;</span><br><span class="line"><span class="number">348</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">349</span></span><br><span class="line"><span class="number">350</span> 	<span class="type">int</span> verify; <span class="comment">/* getenv(&quot;verify&quot;)[0] != &#x27;n&#x27; */</span></span><br><span class="line"><span class="number">351</span></span><br><span class="line"><span class="number">352</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_START (0x00000001)</span></span><br><span class="line"><span class="number">353</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOS (0x00000002)</span></span><br><span class="line"><span class="number">354</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOTHER (0x00000004)</span></span><br><span class="line"><span class="number">355</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_LOADOS (0x00000008)</span></span><br><span class="line"><span class="number">356</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_RAMDISK (0x00000010)</span></span><br><span class="line"><span class="number">357</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FDT (0x00000020)</span></span><br><span class="line"><span class="number">358</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_CMDLINE (0x00000040)</span></span><br><span class="line"><span class="number">359</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_BD_T (0x00000080)</span></span><br><span class="line"><span class="number">360</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_PREP (0x00000100)</span></span><br><span class="line"><span class="number">361</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_FAKE_GO (0x00000200)<span class="comment">/*&#x27;Almost&#x27; run the OS*/</span></span></span><br><span class="line"><span class="number">362</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_GO (0x00000400)</span></span><br><span class="line"><span class="number">363</span> 	<span class="type">int</span> state;</span><br><span class="line"><span class="number">364</span></span><br><span class="line"><span class="number">365</span> 	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_LMB</span></span><br><span class="line"><span class="number">366</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">lmb</span> <span class="title">lmb</span>;</span> <span class="comment">/* 内存管理相关，不深入研究 */</span></span><br><span class="line"><span class="number">367</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">368</span> &#125; <span class="type">bootm_headers_t</span>;</span><br></pre></td></tr></table></figure>

<p>第 352~362 行这 11 个宏定义表示 BOOT 的不同阶段。</p>
<h3><span id="1-1-1-xi-tong-jing-xiang-tou-bu-jie-gou">1.1.1 系统镜像头部结构</span><a href="#1-1-1-xi-tong-jing-xiang-tou-bu-jie-gou" class="header-anchor">#</a></h3><p>先来看下<code>image_header_t</code>结构，也就是系统镜像头部信息：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">image_header</span> &#123;</span></span><br><span class="line">	__be32		ih_magic;	<span class="comment">/* Image Header Magic Number	*/</span></span><br><span class="line">	__be32		ih_hcrc;	<span class="comment">/* Image Header CRC Checksum	*/</span></span><br><span class="line">	__be32		ih_time;	<span class="comment">/* Image Creation Timestamp	*/</span></span><br><span class="line">	__be32		ih_size;	<span class="comment">/* Image Data Size		*/</span></span><br><span class="line">	__be32		ih_load;	<span class="comment">/* Data	 Load  Address		*/</span></span><br><span class="line">	__be32		ih_ep;		<span class="comment">/* Entry Point Address		*/</span></span><br><span class="line">	__be32		ih_dcrc;	<span class="comment">/* Image Data CRC Checksum	*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_os;		<span class="comment">/* Operating System		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_arch;	<span class="comment">/* CPU architecture		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_type;	<span class="comment">/* Image Type			*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_comp;	<span class="comment">/* Compression Type		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_name[IH_NMLEN];	<span class="comment">/* Image Name		*/</span></span><br><span class="line">&#125; <span class="type">image_header_t</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-xi-tong-jing-xiang-jie-gou">1.1.2 系统镜像结构</span><a href="#1-1-2-xi-tong-jing-xiang-jie-gou" class="header-anchor">#</a></h3><p>再来看下<code>image_info_t</code>结构，也就是系统镜像信息结构：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">image_info</span> &#123;</span></span><br><span class="line">	ulong		start, end;		<span class="comment">/* start/end of blob */</span></span><br><span class="line">	ulong		image_start, image_len; <span class="comment">/* start of image within blob, len of image */</span></span><br><span class="line">	ulong		load;			<span class="comment">/* load addr for the image */</span></span><br><span class="line">	<span class="type">uint8_t</span>		comp, type, os;		<span class="comment">/* compression, type of image, os type */</span></span><br><span class="line">	<span class="type">uint8_t</span>		arch;			<span class="comment">/* CPU architecture */</span></span><br><span class="line">&#125; <span class="type">image_info_t</span>;</span><br></pre></td></tr></table></figure>

<h1><span id="2-do-bootz-han-shu">2 do_bootz 函数</span><a href="#2-do-bootz-han-shu" class="header-anchor">#</a></h1><p><code>do_bootz </code>函数定义在<code>cmd/bootm.c</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/4.png" alt="image"><br>先执行<code>bootz_start</code>。先执行<code>BOOTM_STATE_START </code>阶段。<br>第 638 行，设置<code>images.os.os</code>为<code> IH_OS_LINUX</code>，也就是设置系统镜像为 Linux，表示我们要启动的是 Linux 系统！后面会用到 <code>images.os.os </code>来挑选具体的启动函数。<br>第 639 行，调用函数<code>do_bootm_states</code>来执行不同的 BOOT 阶段，这里要执行的 BOOT 阶段有：<code>BOOTM_STATE_OS_PREP 、BOOTM_STATE_OS_FAKE_GO 和BOOTM_STATE_OS_GO</code>。</p>
<h2><span id="2-1-bootz-start">2.1 bootz_start</span><a href="#2-1-bootz-start" class="header-anchor">#</a></h2><p><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/5.png" alt="image"></p>
<ol>
<li><p>调用函数<code> do_bootm_states</code>，执行 <code>BOOTM_STATE_START </code>阶段。</p>
</li>
<li><p>593 行，设置<code> images 的 ep</code>，也就是系统镜像的入口点，使用<code>bootz</code>命令启动系统的时候就会设置系统在 DRAM 中的存储位置，这个存储位置就是系统镜像的入口点，因此<code> images-&gt;ep=0X80800000</code>。镜像加载地址定义在<code>include/configs/mx6ullevk.h</code><br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/6.png" alt="image"></p>
</li>
<li><p>调用<code>bootz_setup</code>函数，此函数会判断当前的系统镜像文件是否为 Linux 的镜像文件，并且会打印出镜像相关信息，<code>bootz_setup </code>函数稍后会讲解。</p>
</li>
<li><p>调用<code>bootm_find_images</code>查找<code>ramdisk</code>和<code>设备树(dtb)</code>文件，但是我们没有用到 <code>ramdisk</code>，因此此函数在这里仅仅用于查找<code>设备树(dtb)</code>文件，此函数稍后也会讲解。</p>
</li>
</ol>
<h3><span id="2-1-1-bootm-start">2.1.1 bootm_start</span><a href="#2-1-1-bootm-start" class="header-anchor">#</a></h3><p>执行<code>BOOTM_STATE_START</code>阶段时，执行<code>bootm_start</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/7.png" alt="image"><br>初始化<code>verfify </code>成员， 设置<code>images</code>状态为 <code>BOOTM_STATE_START</code>。</p>
<h3><span id="2-1-2-bootz-setup">2.1.2 bootz_setup</span><a href="#2-1-2-bootz-setup" class="header-anchor">#</a></h3><p>定义在文件 <code>arch/arm/lib/bootm.c</code>:<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/8.png" alt="image"></p>
<ol>
<li>宏<code>LINUX_ARM_ZIMAGE_MAGIC</code>就是 ARM Linux 系统<code>魔术数</code>。</li>
<li>从传递进来的参数<code> image(也就是系统镜像首地址)</code>中获取<code>zimage</code>头。</li>
<li>判断<code>image</code>是否为 ARM 的 Linux 系统镜像，如果不是的话就直接返回，并且打印出<code>“Bad Linux ARM zImage magic!”</code>，比如我们输入一个错误的启动命令：<br><code>bootz 80000000 – 900000000</code><br>因为我们并没有在<code>0X80000000</code>处存放 <code>Linux 镜像文件(zImage)</code>，因此上面的命令肯定会执行出错如下:<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/9.png" alt="image"></li>
<li>初始化函数<code>bootz_setup</code>的参数<code> start 和 end</code>。</li>
<li>打印启动信息，如果 Linux 系统镜像正常的话打印如下：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/10.png" alt="image"></li>
</ol>
<h3><span id="2-1-3-bootm-find-images">2.1.3 bootm_find_images</span><a href="#2-1-3-bootm-find-images" class="header-anchor">#</a></h3><p>定义在文件<code> common/bootm.c</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/11.png" alt="image"></p>
<ol>
<li>查找<code> ramdisk</code>，但是我们没有用到 <code>ramdisk</code>，因此这部分代码不用管。</li>
<li>查找<code>设备树(dtb)</code>文件，找到以后就将设备树的起始地址和长度分别写到<code>images </code>的<code>ft_addr</code>和 <code>ft_len </code>成员变量中。我们使用 <code>bootz </code>启动 Linux 的时候已经指明了设备树在DRAM 中的存储地址，因此<code> images.ft_addr=0X83000000</code>，长度根据具体的设备树文件而定，比如我现在使用的设备树文件长度为<code> 0X8C81</code>，因此<code> images.ft_len=0X8C81</code>。</li>
</ol>
<h2><span id="2-2-do-bootm-states">2.2 do_bootm_states</span><a href="#2-2-do-bootm-states" class="header-anchor">#</a></h2><p><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/12.png" alt="image"><br>前面将<code>state</code>先处理了<code>BOOTM_STATE_START</code>阶段，接下来处里下面三个状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-1-bootm-os-get-boot-func">2.2.1 bootm_os_get_boot_func</span><a href="#2-2-1-bootm-os-get-boot-func" class="header-anchor">#</a></h3><p>进入第658行，通过<code>bootm_os_get_boot_func</code>来查找系统启动函数。由于前面提到<code>images-&gt;os.os </code>就是系统类型设置 为 <code>IH_OS_LINUX</code>，根据这个<code>os</code>类型来选择对应的启动函数名为<code>do_bootm_linux</code>:<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/13.png" alt="image"></p>
<h3><span id="2-2-2-boot-pre-linux">2.2.2 boot_pre_linux</span><a href="#2-2-2-boot-pre-linux" class="header-anchor">#</a></h3><p>第 676-677 行，处理<code>BOOTM_STATE_OS_PREP</code>状态，调用函数<code> do_bootm_linux，do_bootm_linux</code>调用<code>boot_prep_linux</code>来完成具体的处理过程。<code>boot_prep_linux </code>主要用于处理环境变量<code>bootargs，bootargs </code>保存着传递给<code>Linux kernel</code>的参数：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/14.png" alt="image"></p>
<pre><code>设备树的chosen节点下存放了子节点bootargs，bootargs子节点存放bootargs环境变量
</code></pre>
<h3><span id="2-2-3-boot-jump-linux">2.2.3 boot_jump_linux</span><a href="#2-2-3-boot-jump-linux" class="header-anchor">#</a></h3><p>第699行，调用函数<code>boot_selected_os</code>启动 Linux 内核，此函数第 4 个参数为 Linux 系统镜像头，第 5 个参数就是 Linux 系统启动函数<code> do_bootm_linux</code>。<code>boot_selected_os </code>函数定义在文件<code>common/bootm_os.c</code>如下：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/15.png" alt="image"><br>最终调用<code> boot_selected_os-&gt;boot_fn(即do_bootm_linux)-&gt;boot_jump_linux</code>来启动 Linux 内核：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/16.png" alt="image"><br><code>boot_jump_linux</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/17.png" alt="image"></p>
<ol>
<li><p>我们的板子IMX6ULL是armv7 32位架构，因此从else开始，第293 行，变量 <code>machid </code>保存机器 ID，如果不使用设备树的话这个机器 ID 会被传递给 Linux内核，Linux 内核会在自己的机器 ID 列表里面查找是否存在与<code>uboot</code>传递进来的<code>machid</code>匹配的项目，如果存在就说明 Linux 内核支持这个机器，那么 Linux 就会启动！如果使用设备树的话这个<code>machid</code>就无效了，设备树存有一个“兼容性”这个属性，Linux 内核会比较“兼容性”属性的值(字符串)来查看是否支持这个机器。</p>
</li>
<li><p>第 295 行，函数<code> kernel_entry</code>，看名字“内核_进入”，说明此函数是进入 Linux 内核的，也就是最终的大boss！此函数有三个参数：<code>zero，arch，params</code>，第一个参数<code>zero</code>同样为 0；第二个参数为<code>机器 ID</code>；第三个参数<code> ATAGS 或者设备树(DTB)首地址</code>，<code>ATAGS </code>是传统的方法，用于传递一些命令行信息啥的，如果使用设备树的话就要传递<code>设备树(DTB)</code>。</p>
</li>
<li><p>第 299 行，获取 <code>kernel_entry </code>函数，函数<code>kernel_entry</code>并不是 <code>uboot </code>定义的，而是 Linux 内核定义的，Linux 内核镜像文件的第一行代码就是函数<code> kernel_entry</code>，而 <code>images-&gt;ep </code>保存着 Linux内核镜像的起始地址，起始地址保存的正是 Linux 内核第一行代码！</p>
</li>
<li><p>第 313 行，调用函数<code>announce_and_cleanup</code>来打印一些信息并做一些清理工作：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/18.png" alt="image"><br>因此每次启动 Linux 之前输出<code>“Starting kernel ...”</code>信息如下：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/19.png" alt="image"></p>
</li>
<li><p>继续回到函数<code> boot_jump_linux</code>,第 315~318 行是设置寄存器<code> r2</code> 的值。为什么要设置<code>r2</code>的值呢？Linux 内核一开始是汇编代码，因此函数<code>kernel_entry</code>就是个汇编函数。向汇编函数传递参数要使用<code> r0、r1 和 r2</code>(参数数量不超过 3 个的时候)，所以<code> r2</code> 寄存器就是函数<code>kernel_entry</code>的第三个参数。</p>
</li>
<li><p>第 316 行，如果使用设备树的话，<code>r2 </code>应该是设备树的起始地址，而设备树地址保存在<code> images</code>的<code>ftd_addr</code>成员变量中。</p>
</li>
<li><p>第 317 行，如果不使用设备树的话，<code>r2</code> 应该是<code>uboot</code>传递给 Linux 的参数起始地址，也就是环境变量<code>bootargs</code>的值，</p>
</li>
<li><p>最后调用调用<code>kernel_entry</code>函数进入 Linux 内核，至此<code>Uboot</code>的整个运行流程结束，<code>uboot </code>的使命也就完成了。</p>
</li>
</ol>
<h1><span id="3-zong-jie-bootz-qi-dong-guo-cheng">3 总结bootz启动过程</span><a href="#3-zong-jie-bootz-qi-dong-guo-cheng" class="header-anchor">#</a></h1><p><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/20.png" alt="image"></p>
<h1><span id="4-uboot-qi-dong-linux-ce-shi">4 uboot 启动 Linux 测试</span><a href="#4-uboot-qi-dong-linux-ce-shi" class="header-anchor">#</a></h1><h2><span id="4-1-emmc-qi-dong-linux">4.1 EMMC 启动 Linux</span><a href="#4-1-emmc-qi-dong-linux" class="header-anchor">#</a></h2><p>编译出来的 Linux 镜像文件 <code>zImage </code>和设备树文件保存在 EMMC中，<code>uboot </code>从 EMMC 中读取这两个文件并启动，这个是我们产品最终的启动方式。但是我们目前还没有讲解如何移植linux 和设备树文件，以及如何将 <code>zImage </code>和设备树文件保存到 EMMC中。不过大家拿到手的 I.MX6U-ALPHA 开发板(EMMC 版本)已经将<code> zImage</code> 文件和设备树文件烧写到了 EMMC 中，所以我们可以直接读取来测试。先检查一下 EMMC 的分区 1 中有没有<code>zImage </code>文件和设备树文件，输入命令<code>ls mmc 1:1</code>:<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/21.png" alt="image"><br>EMMC 分区 1 中存在<code>zimage</code>和 <code>imx6ull-alientek-emmc.dtb</code>这两个文件，所以我们可以测试新移植的 uboot能不能启动 linux 内核。设置 <code>bootargs </code>和<code> bootcmd</code>这两个环境变量:<br><code>setenv bootargs &#39;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#39;</code><br><code>setenv bootcmd &#39;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#39;</code><br><code>saveenv</code><br>直接输入<code> boot</code>，或者<code>run bootcmd</code>即可启动 Linux 内核，如果 Linux 内核启动成功的话就会输出如下：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/22.png" alt="image"></p>
<h2><span id="4-2-wang-luo-qi-dong-linux">4.2 网络启动 Linux</span><a href="#4-2-wang-luo-qi-dong-linux" class="header-anchor">#</a></h2><p>调试过程中由于我们不断更改kernel, 那么如果每次都烧录进emmc，从emmc启动就很繁琐，直接从网络启动。<br>先将<code>zImage</code>和<code>dtb</code>文件放在tftp共享目录下，通过<code>nfs 或者 tftp</code>从 Ubuntu 中下载<code>zImage</code>和设备树文件：</p>
<p><code>setenv bootargs &#39;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#39;</code><br><code>setenv bootcmd &#39;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#39;</code><br><code>saveenv</code><br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/23.png" alt="image"><br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/24.png" alt="image"></p>
<h1><span id="5-fu-lu-bi-te-yu-shi-liu-jin-zhi-zhuan-huan-kuai-cha-biao">5 附录：比特与十六进制转换快查表</span><a href="#5-fu-lu-bi-te-yu-shi-liu-jin-zhi-zhuan-huan-kuai-cha-biao" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * include/linux/sizes.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> * it under the terms of the GNU General Public License version 2 as</span></span><br><span class="line"><span class="comment"> * published by the Free Software Foundation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LINUX_SIZES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LINUX_SIZES_H__</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_1				0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_2				0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_4				0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_8				0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_16				0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_32				0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_64				0x00000040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_128				0x00000080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_256				0x00000100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_512				0x00000200</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_1K				0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_2K				0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_4K				0x00001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_8K				0x00002000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_16K				0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_32K				0x00008000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_64K				0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_128K				0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_256K				0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_512K				0x00080000</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_1M				0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_2M				0x00200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_4M				0x00400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_8M				0x00800000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_16M				0x01000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_32M				0x02000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_64M				0x04000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_128M				0x08000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_256M				0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_512M				0x20000000</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_1G				0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_2G				0x80000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __LINUX_SIZES_H__ */</span></span></span><br></pre></td></tr></table></figure>

<h1><span id="6-mkimage-gong-ju">6 mkimage工具</span><a href="#6-mkimage-gong-ju" class="header-anchor">#</a></h1><p>用来制作不压缩或者压缩的多种可启动映象文件。比如内核启动镜像(给zImage镜像添加64字节的头信息成uImage)，再比如<code>rootfs.img</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: ./mkimage -l image</span><br><span class="line">          -l ==&gt; list image header information</span><br><span class="line">       ./mkimage [-x] -A arch -O os -T type -C comp -a addr -e ep -n name -d data_file[:data_file...] image</span><br><span class="line">          -A ==&gt; set architecture to &#x27;arch&#x27; </span><br><span class="line">          -O ==&gt; set operating system to &#x27;os&#x27;</span><br><span class="line">          -T ==&gt; set image type to &#x27;type&#x27;</span><br><span class="line">          -C ==&gt; set compression type &#x27;comp&#x27;</span><br><span class="line">          -a ==&gt; set load address to &#x27;addr&#x27; (hex)</span><br><span class="line">          -e ==&gt; set entry point to &#x27;ep&#x27; (hex)</span><br><span class="line">          -n ==&gt; set image name to &#x27;name&#x27;</span><br><span class="line">          -d ==&gt; use image data from &#x27;datafile&#x27;</span><br><span class="line">          -x ==&gt; set XIP (execute in place)</span><br><span class="line">       ./mkimage [-D dtc_options] -f fit-image.its fit-image</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-A</td>
<td>指定CPU的架构，比如：arm或者x86</td>
</tr>
<tr>
<td>-O</td>
<td>指定操作系统的类型，比如：linux</td>
</tr>
<tr>
<td>-T</td>
<td>指定镜像的类型，比如：standalone、kernel、ramdisk、multi、firmware、script、filesystem</td>
</tr>
<tr>
<td>-C</td>
<td>指定压缩的方式，比如：none 不压缩、gzip 用gzip的压缩方式、bzip2 用bzip2的压缩方式</td>
</tr>
<tr>
<td>-a</td>
<td>指定镜像在内存中的加载地址</td>
</tr>
<tr>
<td>-e</td>
<td>指定镜像运行的入口点地址</td>
</tr>
<tr>
<td>-n</td>
<td>指定镜像的名字</td>
</tr>
<tr>
<td>-d</td>
<td>指定制作镜像的源文件</td>
</tr>
<tr>
<td>-x</td>
<td>镜像是否可以片上执行</td>
</tr>
</tbody></table>
<p><code>mkimage</code>命令举例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mkimage -n &quot;My Kernel&quot; -A arm -O linux -T kernel -C gzip –a 0x8000 –e 0x8000 -d kernel.gz kernel.img</span></span><br></pre></td></tr></table></figure>
<p>以上命令将压缩了的内核二进制文件<code>kernel.gz</code>转换成u-boot能够辨认的二进制文件<code>kernel.img</code>，并指定<code>kernel.img</code>的名字为<code>“My Kernel”</code>，处理器体系架构为arm，操作系统类型为linux，程序类型为操作系统内核，程序由gzip压缩，程序的链接起始地址为0x8000，程序的入口地址为0x8000，注意这两个地址一定要是物理地址而不是对应的虚拟地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mkimage -n &quot;My Rootfs&quot; -A arm -O linux -T ramdisk -C gzip -d ramdisk.gz ramdisk.img</span></span><br></pre></td></tr></table></figure>
<p>以上命令将压缩了的ramdisk根文件系统二进制文件<code>ramdisk.gz</code>转换成u-boot能够辨认的二进制文件<code>ramdisk.img</code>，并指定<code>ramdisk.img</code>的名字为<code>“My Rootfs”</code>，处理器体系架构为arm，操作系统类型为linux，程序类型为ramdisk，程序由gzip压缩，不需要指定ramdisk的链接起始地址和入口地址。</p>
<p>如果我们将<code>kernel.img</code>和<code>ramdisk.img</code>文件分别写到flash芯片的<code>0xFF000000</code>和<code>0xFF200000</code>位置，系统启动后进入u-boot命令行界面，执行以下u-boot命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># bootm 0xFF000000 0xFF200000</span></span><br></pre></td></tr></table></figure>
<p>那么u-boot将把<code>0xFF000000</code>位置的Linux内核解压缩到RAM中的<code>0x8000</code>位置，再将<code>0xFF200000</code>位置的ramdisk文件系统映像文件刨掉u-boot头部后复制到RAM中的某个位置，然后跳转到内核的入口地址<code>0x8000</code>位置启动内核，同时把板子信息、ramdisk在RAM中的起始地址和结束地址、命令行字符串传给内核，这样Linux开始启动运行。</p>
<p>如果没有可以片上执行的norflash:</p>
<ol>
<li>mkimage<br><code>mkimage -n &#39;linux-2.6.14&#39; -A arm -O linux -T kernel -C none -a 0x30008000 -e 0x30008040 -d zImage zImage.img</code></li>
<li>tftp下载到ddr<br><code>ftp 0x30008000 zImage.img</code></li>
<li>启动内核<br><code>bootm 0x30008000</code></li>
</ol>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>tailq队列</title>
    <url>/2024/04/11/tailq%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-tailq-dui-lie-jie-shao">1 tailq队列介绍</a><ul>
<li><a href="#1-1-queue-jian-jie">1.1 queue 简介</a></li>
<li><a href="#1-2-slist">1.2 SLIST</a></li>
<li><a href="#1-3-stailq">1.3 STAILQ</a></li>
<li><a href="#1-4-list">1.4 LIST</a></li>
<li><a href="#1-5-tailq">1.5 TAILQ</a></li>
<li><a href="#1-6-circleq">1.6 CIRCLEQ</a></li>
</ul>
</li>
<li><a href="#2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</a><ul>
<li><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</a></li>
<li><a href="#2-2-dui-lie-tou">2.2 队列头</a></li>
<li><a href="#2-3-chu-shi-hua">2.3 初始化</a></li>
<li><a href="#2-4-cha-ru-yuan-su">2.4 插入元素</a><ul>
<li><a href="#2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</a></li>
<li><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</a></li>
</ul>
</li>
<li><a href="#2-5-shan-chu-yuan-su">2.5 删除元素</a></li>
<li><a href="#2-6-di-yi-ge-yuan-su">2.6 第一个元素</a></li>
<li><a href="#2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</a></li>
<li><a href="#2-8-xia-yi-ge-yuan-su">2.8 下一个元素</a></li>
<li><a href="#2-9-qian-yi-ge-yuan-su">2.9 前一个元素</a></li>
<li><a href="#2-10-pan-kong">2.10 判空</a></li>
<li><a href="#2-11-pan-man">2.11 判满</a></li>
<li><a href="#2-12-bian-li">2.12 遍历</a></li>
<li><a href="#2-13-dao-bian-li">2.13 倒遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-tailq-dui-lie-jie-shao">1 tailq队列介绍</span><a href="#1-tailq-dui-lie-jie-shao" class="header-anchor">#</a></h1><p>TAILQ队列是FreeBSD内核中的一种队列数据结构，主要是把队列头抽象成一个单独的结构体。它实现在Linux queue中。</p>
<h2><span id="1-1-queue-jian-jie">1.1 queue 简介</span><a href="#1-1-queue-jian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/1.png" alt="img"></p>
<p>可以include &lt;sys&#x2F;queue.h&gt;后直接使用。queue 分为 SLIST、LIST、STAILQ、TAILQ、CIRCLEQ 。queue 的所有源码都是宏定义，因此完全包含于queue.h当中，无需编译为库文件。</p>
<p>可以从toolchains或者系统路径&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;sys&#x2F;queue.h找到实现。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/2.png" alt="img"></p>
<h2><span id="1-2-slist">1.2 SLIST</span><a href="#1-2-slist" class="header-anchor">#</a></h2><p>SLIST 是Singly-linked List 的缩写，意为单向无尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/3.png" alt="img"></p>
<h2><span id="1-3-stailq">1.3 STAILQ</span><a href="#1-3-stailq" class="header-anchor">#</a></h2><p>单向有尾链表，节点n为尾节点。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/4.png" alt="img"></p>
<h2><span id="1-4-list">1.4 LIST</span><a href="#1-4-list" class="header-anchor">#</a></h2><p>双向无尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/5.png" alt="img"></p>
<h2><span id="1-5-tailq">1.5 TAILQ</span><a href="#1-5-tailq" class="header-anchor">#</a></h2><p>双向有尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/6.png" alt="img"></p>
<h2><span id="1-6-circleq">1.6 CIRCLEQ</span><a href="#1-6-circleq" class="header-anchor">#</a></h2><p>双向循环链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/7.png" alt="img"></p>
<h1><span id="2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</span><a href="#2-tailq-shi-xian-yuan-li-tu-jie" class="header-anchor">#</a></h1><p>双向有尾链表,也就是有一个表头和表尾，表头指向节点1和尾节点。</p>
<h2><span id="2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</span><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_ENTRY(type)                                                   \</span></span><br><span class="line"><span class="keyword">struct</span> &#123;                                                                    \</span><br><span class="line">    <span class="keyword">struct</span> type *tqe_next;      <span class="comment">/* next element */</span>                          \</span><br><span class="line">    <span class="keyword">struct</span> type **tqe_prev;     <span class="comment">/* address of previous next element */</span>      \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tqe_next是指向下一个元素的指针，tqe_prev是指向前一个元素的tqe_next地址，对它解引用后</span></span><br><span class="line"><span class="comment">（*tqe_priv）指向当前元素的地址。*/</span></span><br><span class="line">如：</span><br><span class="line"><span class="keyword">struct</span> item&#123;</span><br><span class="line">　　<span class="built_in">int</span> val;</span><br><span class="line">　　TAILQ_ENTRY(item) entries;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/8.png" alt="img"></p>
<h2><span id="2-2-dui-lie-tou">2.2 队列头</span><a href="#2-2-dui-lie-tou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    TAILQ_HEAD(name, type)                        \</span></span><br><span class="line"><span class="keyword">struct</span> name &#123;                                \</span><br><span class="line">    <span class="keyword">struct</span> type *tqh_first;    <span class="comment">/* first element */</span>            \</span><br><span class="line">    <span class="keyword">struct</span> type **tqh_last;    <span class="comment">/* addr of last next element */</span>        \</span><br><span class="line">&#125;</span><br><span class="line">STAILQ_HEAD(my_tailq,  tailq_entry) queue_head;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/9.png" alt="img"></p>
<p>先看TAILQ_HEAD:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tqh_first为队列第一个元素的地址；</span><br><span class="line">tqh_last为最后一个元素tqe_next的地址；</span><br><span class="line">tqh_last指向的指针为<span class="number">0</span>；</span><br></pre></td></tr></table></figure>

<p>再看TAILQ_ENTRY:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tqe_next为队列下一个元素的地址；</span><br><span class="line">tqe_prev为队列上一个元素tqe_next的地址；</span><br><span class="line">tqe_prev指向的指针为当前元素的地址；</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-chu-shi-hua">2.3 初始化</span><a href="#2-3-chu-shi-hua" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/10.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INIT(head) do &#123;                                               \</span></span><br><span class="line">    (head)-&gt;tqh_first = NULL;                                               \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;                                  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-cha-ru-yuan-su">2.4 插入元素</span><a href="#2-4-cha-ru-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_TAIL(head, elm, field) do &#123;                  \</span></span><br><span class="line">    (elm)-&gt;field.tqe_next = NULL;                                 \</span><br><span class="line">    (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;                     \</span><br><span class="line">    *(head)-&gt;tqh_last = (elm);                                    \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</span><a href="#2-4-1-cha-ru-1-ge-yuan-su" class="header-anchor">#</a></h3><ol>
<li><p>将要插入的node加入到尾部：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/11.png" alt="img"></p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next = NULL;                         </span><br><span class="line">(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;<span class="comment">//将要插入的节点prev指向最后一个node </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>更新头节点:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/12.png" alt="img"></p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);          </span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</span><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su" class="header-anchor">#</a></h3><p>同理多个元素时尾插。</p>
<ol>
<li><p>将要插入的node加入到尾部:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/13.png" alt="img"></p>
</li>
<li><p>更新头节点:</p>
</li>
</ol>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/14.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);           <span class="comment">//尾节点指向新的尾巴</span></span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next; <span class="comment">//head的last指向新的尾巴</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-5-shan-chu-yuan-su">2.5 删除元素</span><a href="#2-5-shan-chu-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_REMOVE(head, elm, field) do &#123;                       \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.tqe_next) != NULL)                          \</span><br><span class="line">        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;      \</span><br><span class="line">    <span class="keyword">else</span>                                                                    \</span><br><span class="line">        (head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;                           \</span><br><span class="line">    *(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;                         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/15.png"></p>
<p>我们现在要把val&#x3D;3的elm删除：<br>elm中的tqe_next不为空，表示elm不是尾节点。那么</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;</span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure>

<p>这2句执行完后:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/16.png" alt="img"></p>
<p>然后free掉该elm,</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/17.png" alt="img"></p>
<p>同理再删除val&#x3D;2的elm：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/18.png" alt="img"></p>
<p>然后free掉该elm，</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/19.png" alt="img"></p>
<p>最后如果要把val&#x3D;4的elm删除：</p>
<p>elm中的tqe_next为空，表示elm是尾节点。那么，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;               <span class="comment">//让head的last指向新的尾巴        </span></span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;    <span class="comment">//让elm的前一个node的next指向该elm的后一个node</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/20.png" alt="img"></p>
<h2><span id="2-6-di-yi-ge-yuan-su">2.6 第一个元素</span><a href="#2-6-di-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</span><a href="#2-7-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_LAST(head, headname) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last))</span><br></pre></td></tr></table></figure>

<p>这个实现看起来有点绕，我们先做一个实验:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> _QUEUE_ITEM &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">    TAILQ_ENTRY(QUEUE_ITEM) entries;</span><br><span class="line">&#125;QUEUE_ITEM;</span><br><span class="line"></span><br><span class="line">TAILQ_HEAD(TAIL_QUEUE, QUEUE_ITEM) queue_head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> **argv</span>)</span> &#123;</span><br><span class="line">    QUEUE_ITEM *item[<span class="number">5</span>];</span><br><span class="line">    TAILQ_INIT(&amp;queue_head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        item[i] = (<span class="keyword">struct</span> QUEUE_ITEM*)malloc(<span class="keyword">sizeof</span>(QUEUE_ITEM));</span><br><span class="line">        item[i]-&gt;<span class="keyword">value</span> = i;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;queue_head, item[i], entries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            printf(<span class="string">&quot;item[%d]: item:%#x, next:%#x,&amp;next:%#x, prev:%#x, *prev:%#x\n&quot;</span>,</span><br><span class="line">　　　　　　　　i, item[i], item[i]-&gt;entries.tqe_next, &amp;(item[i]-&gt;entries.tqe_next), item[i]-&gt;entries.tqe_prev, *(item[i]-&gt;entries.tqe_prev));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;queue_head:%#x, first:%#x, last:%#x\n&quot;</span>, &amp;queue_head, queue_head.tqh_first, queue_head.tqh_last);</span><br><span class="line">    printf(<span class="string">&quot;last item:%p\n&quot;</span>, TAILQ_LAST(&amp;queue_head, TAIL_QUEUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/21.png" alt="img"></p>
<p>可以用图形来描述:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/22.png" alt="img"></p>
<p><code>TAILQ_LAST(&amp;queue_head, TAIL_QUEUE);</code>这句话展开:<br><code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code></p>
<p><code>((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))</code>这句话,我们把地址0x601060代入进去得0x602098，即为：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/23.png" alt="img"></p>
<p>然后<code>(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last)</code>得到0x602078,<br>认真的同学此时已经发现，此时对应倒数第二元素的next地址，</p>
<p>最后取<code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code>得到0x602090,这就是最后一个元素的地址。</p>
<p><strong>总结：这里核心其实就是把最后一个元素的entries成员当成head指针来使用</strong>。因为本质上最后一个节点的TAILQ_ENTRY域和TAILQ_HEAD是同样的结构。</p>
<h2><span id="2-8-xia-yi-ge-yuan-su">2.8 下一个元素</span><a href="#2-8-xia-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_NEXT(elm, field)                ((elm)-&gt;field.tqe_next)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-9-qian-yi-ge-yuan-su">2.9 前一个元素</span><a href="#2-9-qian-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_PREV(elm, headname, field) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span><br></pre></td></tr></table></figure>

<p>这里和TAILQ_LAST原理一样，将0x602090代入进去得:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/24.png" alt="img"><br>然后对*(0x602058)得0x602070,即得到了前一个node的地址。</p>
<h2><span id="2-10-pan-kong">2.10 判空</span><a href="#2-10-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_EMPTY(head)                ((head)-&gt;tqh_first == NULL)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-11-pan-man">2.11 判满</span><a href="#2-11-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-12-bian-li">2.12 遍历</span><a href="#2-12-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH(var, head, field)                                        \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = ((head)-&gt;tqh_first);                                \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = ((<span class="keyword">var</span>)-&gt;field.tqe_next))</span><br></pre></td></tr></table></figure>

<h2><span id="2-13-dao-bian-li">2.13 倒遍历</span><a href="#2-13-dao-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH_REVERSE(var, head, headname, field)                \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last));        \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((<span class="keyword">var</span>)-&gt;field.tqe_prev))-&gt;tqh_last)))</span><br></pre></td></tr></table></figure>

<p>当看懂之前的<strong>最后一个元素</strong>原理时，倒遍历的实现是不是超级简单。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-menuconfig和Kconfig图像化配置</title>
    <url>/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-ncurses-ku-an-zhuang">1 ncurses 库安装</a></li>
<li><a href="#2-menuconfig-cai-dan-shi-yong-shuo-ming-he-ju-li">2 menuconfig菜单使用说明和举例</a></li>
<li><a href="#3-menuconfig-tu-xing-hua-pei-zhi-yuan-li">3 menuconfig 图形化配置原理</a><ul>
<li><a href="#3-1-make-menuconfig-guo-cheng">3.1 make menuconfig 过程</a><ul>
<li><a href="#3-1-1-kconfig-yu-fa-jian-jie">3.1.1 Kconfig 语法简介</a><ul>
<li><a href="#3-1-1-1-mainmenu">3.1.1.1 mainmenu</a></li>
<li><a href="#3-1-1-2-zi-kconfig">3.1.1.2 子Kconfig</a></li>
<li><a href="#3-1-1-3-menu-endmenu-cai-dan">3.1.1.3 menu&#x2F;endmenu 菜单</a></li>
<li><a href="#3-1-1-4-config-tiao-mu">3.1.1.4 config条目</a></li>
<li><a href="#3-1-1-5-depends-on-he-select">3.1.1.5 depends on 和 select</a></li>
<li><a href="#3-1-1-6-choice-endchoice">3.1.1.6 choice&#x2F;endchoice</a></li>
<li><a href="#3-1-1-7-menuconfig">3.1.1.7 menuconfig</a></li>
<li><a href="#3-1-1-8-comment">3.1.1.8 comment</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-menuconfig-cai-dan-shi-zhan-lian-xi">4 menuconfig菜单实战练习</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-ncurses-ku-an-zhuang">1 ncurses 库安装</span><a href="#1-ncurses-ku-an-zhuang" class="header-anchor">#</a></h1><p>uboot 或 Linux 内核可以通过输入<code>make menuconfig</code>来打开图形化配置界面，<code>menuconfig</code>是一套图形化的配置工具，需要<code>ncurses</code>库支持。<br><code>sudo apt-get install build-essential</code><br><code>sudo apt-get install libncurses5-dev</code></p>
<h1><span id="2-menuconfig-cai-dan-shi-yong-shuo-ming-he-ju-li">2 menuconfig菜单使用说明和举例</span><a href="#2-menuconfig-cai-dan-shi-yong-shuo-ming-he-ju-li" class="header-anchor">#</a></h1><p><code>menuconfig </code>重点会用到两个文件：<code>.config </code>和 <code>Kconfig</code>，<code>.config </code>文件前面已经说了，这个文件保存着 uboot 的配置项，使用 <code>menuconfig </code>配置完 uboot 以后会更新<code>.config </code>文件。<code>Kconfig</code>文件是图形界面的描述文件，也就是描述界面应该有什么内容，很多目录下都会有<code>Kconfig</code>文件。<br><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfig</code><br><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</code><br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/1.png" alt="image"><br>通过键盘上的<code>“↑”</code>和<code>“↓”</code>键来选择要配置的菜单，按下<code>“Enter”</code>键进入子菜单。菜单中高亮的字母就是此菜单的热键，在键盘上按下此高亮字母对应的键可以快速选中对应的菜单。选中子菜单以后按下<code>“Y”</code>键就会将相应的代码编译进 Uboot 中，菜单前面变为<code>“&lt; * &gt;”</code>。按下<code>“N”</code>键不编译相应的代码，按下<code>“M”</code>键就会将相应的代码编译为模块，菜单前面变为<code>“&lt; M &gt;”</code>。按两下<code>“Esc”</code>键退出，也就是返回到上一级，按下<code>“?”</code>键查看此菜单的帮助信息，按下<code>“/”</code>键打开搜索框，可以在搜索框输入要搜索的内容。<br>在配置界面下方会有五个按钮，这五个按钮的功能如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;Select&gt;：选中按钮，和“Enter”键的功能相同，负责选中并进入某个菜单。</span><br><span class="line">&lt;Exit&gt;：退出按钮，和按两下“Esc”键功能相同，退出当前菜单，返回到上一级。</span><br><span class="line">&lt;Help&gt;：帮助按钮，查看选中菜单的帮助信息。</span><br><span class="line">&lt;Save&gt;：保存按钮，保存修改后的配置文件。</span><br><span class="line">&lt;Load&gt;：加载按钮，加载指定的配置文件。</span><br></pre></td></tr></table></figure>
<p>就以如何使能<code>dns</code>命令为例，讲解一下如何通过图形化界面来配置 uboot。进入<code>“Command line interface ---&gt;”</code>这个配置项:<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/2.png" alt="image"><br>选择<code>“Network commands ---&gt;”</code>，进入网络相关命令配置项:<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/3.png" alt="image"><br>可以看出，uboot 中有很多和网络有关的命令，比如<code>bootp、tftpboot、dhcp</code>等等。选中<code> dns</code>，然后按下键盘上的<code>“Y”</code>键，此时<code>dns</code>前面的<code>“[ ]”</code>变成了<code>“[ * ]” </code>:<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/4.png" alt="image"><br>细心的朋友应该会发现，在<code>mx6ull_alientek_emmc.h</code>里面我们配置使能了<code> dhcp</code> 和<code>ping</code>命令，但是在上图中的<code>“[ ]”</code>并不是<code>“[ * ]”</code>，也就是说不编译<code>dhcp</code>和 <code>ping</code>命令，这不是冲突了吗？实际情况是<code> dhcp</code> 和<code> ping</code> 命令是会编译的。之所以在上图中没有体现出来时因为我们是直接在<code>mx6ull_alientek_emmc.h</code>中定义的宏<code>CONFIG_CMD_PING</code>和<code>CONFIG_CMD_DHCP</code>，而<code> menuconfig</code> 是通过读取<code>.config </code>文件来判断使能了哪些功能，<code>.config</code>里面并没有宏<code>CONFIG_CMD_PING</code>和<code>CONFIG_CMD_DHCP</code>,因此<code>menuconfig</code>不会选中这两项。<br>总结下：配置选项来自2个地方，一个是<code>mx6ull_alientek_emmc.h</code>，一个是<code>.config</code><br>选中<code> dns</code>，然后按下<code>“H”</code>或者<code>“?”</code>键可以打开<code>dns</code>命令的帮助提示信息：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/5.png" alt="image"><br>选择<code>dns</code>命令以后，按两下 <code>ESC </code>键（按两下<code>ESC</code>键相当于返回上一层），退出当前配置项，进入到上一层配置项，输入<code>Y</code>保存修改后的配置到<code>.config</code>。<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/6.png" alt="image"><br>再打开<code>.config</code>，会发现多了<code>“CONFIG_CMD_DNS=y”</code>这一行：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/7.png" alt="image"><br>再次编译：<br><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</code><br>烧录uboot进sd卡，开机从sd卡启动,进入uboot命令行后，输入<code>help或者?</code>就可以看到uboot支持了dns命令。<br>测试：先将板子连接能上外网的路由器，要先设置一下<code>dns</code>服务器的 IP 地址，也就是设置环境变量 <code>dnsip </code>的值：<br><code>setenv dnsip 114.114.114.114</code><br><code>saveenv</code><br>设置好以后就可以使用 dns 命令查看百度官网的 IP 地址了:<br><code>dns www.baidu.com</code><br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/8.png" alt="image"><br>可以看到dns解析命令功能正常。</p>
<h1><span id="3-menuconfig-tu-xing-hua-pei-zhi-yuan-li">3 menuconfig 图形化配置原理</span><a href="#3-menuconfig-tu-xing-hua-pei-zhi-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-make-menuconfig-guo-cheng">3.1 make menuconfig 过程</span><a href="#3-1-make-menuconfig-guo-cheng" class="header-anchor">#</a></h2><p>同<code>defconfig</code>一样，<code>make menuconfig</code> 也会匹配到顶层<code> Makefile。</code> </p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html">Uboot顶层Makefile解析-1. defconfig过程分析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<p><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/9.png" alt="image"><br>其中 <code>build=-f ./scripts/Makefile.build obj</code>, 展开后：<br><code>make -f ./scripts/Makefile.build obj=scripts/kconfig menuconfig</code><br><code>Makefile.build </code>会读取<code>scripts/kconfig/Makefile</code>中的内容，在<code>scripts/kconfig/Makefile</code>中可以找到如下代码：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/10.png" alt="image"><br>其中<code>obj= scripts/kconfig</code>，<code>silent</code>是设置静默编译的，在这里可以忽略不计，<code>Kconfig=Kconfig</code>，因此扩展以后就是：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/11.png" alt="image"><br><code>scripts/kconfig/mconf.c </code>这个文件会被编译，生成 <code>mconf </code>这个可执行文件。<code>mconf </code>会调用 uboot 根目录下的 <code>Kconfig </code>文件开始构建图形配置界面。</p>
<h3><span id="3-1-1-kconfig-yu-fa-jian-jie">3.1.1 Kconfig 语法简介</span><a href="#3-1-1-kconfig-yu-fa-jian-jie" class="header-anchor">#</a></h3><h4><span id="3-1-1-1-mainmenu">3.1.1.1 mainmenu</span><a href="#3-1-1-1-mainmenu" class="header-anchor">#</a></h4><p>输入<code>make menuconfig</code>以后打开的默认界面就是<code>mainmenu</code>，在顶层<code> Kconfig</code> 中有如下代码：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/12.png" alt="image"><br>我们的uboot是<code>UBOOTVERSION=2016.03</code>，如下：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/13.png" alt="image"></p>
<h4><span id="3-1-1-2-zi-kconfig">3.1.1.2 子Kconfig</span><a href="#3-1-1-2-zi-kconfig" class="header-anchor">#</a></h4><p><code>Kconfig </code>也可以调用其他子目录中的<code>Kconfig</code>文件，调用方法如下:<br><code>source &quot;xxx/Kconfig&quot;</code><br>顶层<code>Kconfig</code>中，调用了很多子<code>Kconfig</code>:<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/14.png" alt="image"></p>
<h4><span id="3-1-1-3-menu-x2f-endmenu-cai-dan">3.1.1.3 menu&#x2F;endmenu 菜单</span><a href="#3-1-1-3-menu-x2f-endmenu-cai-dan" class="header-anchor">#</a></h4><p><code>menu </code>用于生成菜单，<code>endmenu </code>就是菜单结束标志。在顶层<code>Kconfig </code>中有如下代码：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/15.png" alt="image"><br>体现在主菜单界面如下所示：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/16.png" alt="image"><br>在<code>“General setup”</code>菜单上面还有 <code>“Architecture select (ARM architecture)”</code>和<code>“ARM architecture”</code>这两个子菜单，但是在顶层 <code>Kconfig </code>中并没有看到这两个子菜单对应的<code>menu/endmenu </code>代码块，那这两个子菜单是怎么来的呢？这两个子菜单就是<code>arch/Kconfig</code>文件生成的。包括主界面中的<code>“Boot timing”、“Console recording”</code>等等这些子菜单，都是分别由顶层<code>Kconfig </code>所调用的 <code>common/Kconfig、cmd/Kconfig</code> 等这些子<code>Kconfig</code>文件来创建的。</p>
<h4><span id="3-1-1-4-config-tiao-mu">3.1.1.4 config条目</span><a href="#3-1-1-4-config-tiao-mu" class="header-anchor">#</a></h4><p>顶层<code>Kconfig</code>中的<code>“General setup”</code>子菜单内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">14 menu <span class="string">&quot;General setup&quot;</span></span><br><span class="line">15</span><br><span class="line">16 config LOCALVERSION</span><br><span class="line">17 string <span class="string">&quot;Local version - append to U-Boot release&quot;</span></span><br><span class="line">18 help</span><br><span class="line">19 Append an extra string to the end of your U-Boot version.</span><br><span class="line">20 This will show up on your boot log, for example.</span><br><span class="line">21 The string you set here will be appended after the contents of</span><br><span class="line">22 any files with a filename matching localversion* in your</span><br><span class="line">23 object and source tree, in that order. Your total string can</span><br><span class="line">24 be a maximum of 64 characters.</span><br><span class="line">25 </span><br><span class="line">26 config LOCALVERSION_AUTO</span><br><span class="line">27 bool <span class="string">&quot;Automatically append version information to the version </span></span><br><span class="line"><span class="string">string&quot;</span></span><br><span class="line">28 default y</span><br><span class="line">29 help</span><br><span class="line">......</span><br><span class="line">45 </span><br><span class="line">46 config CC_OPTIMIZE_FOR_SIZE</span><br><span class="line">47 bool <span class="string">&quot;Optimize for size&quot;</span></span><br><span class="line">48 default y</span><br><span class="line">49 help</span><br><span class="line">......</span><br><span class="line">54 </span><br><span class="line">55 config SYS_MALLOC_F</span><br><span class="line">56 bool <span class="string">&quot;Enable malloc() pool before relocation&quot;</span></span><br><span class="line">57 default y if DM</span><br><span class="line">58 help</span><br><span class="line">......</span><br><span class="line">63 </span><br><span class="line">64 config SYS_MALLOC_F_LEN</span><br><span class="line">65 hex <span class="string">&quot;Size of malloc() pool before relocation&quot;</span></span><br><span class="line">66 depends on SYS_MALLOC_F</span><br><span class="line">67 default 0x400</span><br><span class="line">68 help</span><br><span class="line">......</span><br><span class="line">73 </span><br><span class="line">74 menuconfig EXPERT</span><br><span class="line">75 bool <span class="string">&quot;Configure standard U-Boot features (expert users)&quot;</span></span><br><span class="line">76 default y</span><br><span class="line">77 help</span><br><span class="line">......</span><br><span class="line">82 </span><br><span class="line">83 if EXPERT</span><br><span class="line">84 config SYS_MALLOC_CLEAR_ON_INIT</span><br><span class="line">85 bool <span class="string">&quot;Init with zeros the memory reserved for malloc (slow)&quot;</span></span><br><span class="line">86 default y</span><br><span class="line">87 help</span><br><span class="line">......</span><br><span class="line">99 <span class="keyword">endif</span></span><br><span class="line">100 endmenu <span class="comment"># General setup</span></span><br></pre></td></tr></table></figure>
<p>可以看到有大量的<code>“config xxxx”</code>的代码块，也就是<code>config</code>条目。<code>“General setup”</code>菜单的<code>config</code>条目具体配置项如下：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/17.png" alt="image"><br><code>“config LOCALVERSION”</code>对应着第一个配置项，<code>“config LOCALVERSION_AUTO”</code>对应着 第 二 个 配 置 项。</p>
<p>① 第 16 和 26 行，这两行都以 <code>config </code>关键字开头，后面跟着 <code>LOCALVERSION </code>和<code>LOCALVERSION_AUTO</code>，这两个就是配置项名字。假如我们使能了<code> LOCALVERSION_AUTO</code>这个功能，那么就会下<code>.config</code> 文件中生成 <code>CONFIG_LOCALVERSION_AUTO</code>。</p>
<p>②<code>config</code>关键字下面的这几行是配置项属性，17<del>24 行是<code> LOCALVERSION</code> 的属性，27</del>44 行是<code> LOCALVERSION_AUTO</code> 的属性。</p>
<p>③ 属性里面描述了配置项的类型、输入提示、依赖关系、帮助信息和默认值等。第 17 行的<code>string</code>是变量类型，也就<code>“CONFIG_ LOCALVERSION”</code>的变量类型。可以为：<code>bool、tristate、string、hex 和 int</code>，一共 5 种。最常用的是 <code>bool、tristate 和 string </code>这三种，<code>bool </code>类型有两种值：<code>y 和 n</code>，当为 y 的时候表示使能这个配置项，当为 n 的时候就禁止这个配置项。<code>tristate </code>类型有三种值：<code>y、m 和 n</code>，其中 y 和 n 的涵义与 bool 类型一样，m 表示将这个配置项编译为模块。<code>string </code>为字符串类型，所以 <code>LOCALVERSION </code>是个字符串变量，用来存储本地字符串，选中以后即可输入用户定义的本地版本号，如下图：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/18.png" alt="image"></p>
<p><code>string </code>后面的<code>“Local version - append to U-Boot release”</code>就是这个配置项在图形界面上的显示出来的标题。<br>④ 第 18 行，<code>help </code>表示帮助信息，告诉我们配置项的含义，当我们按下<code>“h”或“?”</code>弹出来的帮助界面就是 <code>help </code>的内容。<br>⑤ 第 27 行，说明<code>“CONFIG_LOCALVERSION_AUTO”</code>是个<code>bool </code>类型，可以通过按下 Y 或N 键来使能或者禁止 <code>CONFIG_LOCALVERSION_AUTO</code>。<br>⑥ 第 28 行，<code>“default y”</code>表示 <code>CONFIG_LOCALVERSION_AUTO </code>的默认值就是 y，所以这一行默认会被选中。</p>
<h4><span id="3-1-1-5-depends-on-he-select">3.1.1.5 depends on 和 select</span><a href="#3-1-1-5-depends-on-he-select" class="header-anchor">#</a></h4><p>打开 <code>arch/Kconfig </code>文件，在里面有这如下代码：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/19.png" alt="image"><br>第 9 行，<code>“depends on”</code>说明<code>“SYS_GENERIC_BOARD”</code>项依赖于<code>“HAVE_GENERIC_BOARD”</code>,也就是说<code>“HAVE_GENERIC_BOARD”</code>被选中以后<code>“SYS_GENERIC_BOARD”</code>才能被选中。<br>第 17~20 行，<code>“select”</code>表示方向依赖，当选中<code>“ARC”</code>以后，<code>“HAVE_PRIVATE_LIBGCC”、“HAVE_GENERIC_BOARD”、“SYS_GENERIC_BOARD”和“SUPPORT_OF_CONTROL”</code>这四个也会被选中。</p>
<h4><span id="3-1-1-6-choice-x2f-endchoice">3.1.1.6 choice&#x2F;endchoice</span><a href="#3-1-1-6-choice-x2f-endchoice" class="header-anchor">#</a></h4><p>在<code>arch/Kconfig</code>文件中有如下代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">11 choice</span><br><span class="line">12 prompt <span class="string">&quot;Architecture select&quot;</span></span><br><span class="line">13 default SANDBOX</span><br><span class="line">14 </span><br><span class="line">15 config ARC</span><br><span class="line">16 bool <span class="string">&quot;ARC architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">21 </span><br><span class="line">22 config ARM</span><br><span class="line">23 bool <span class="string">&quot;ARM architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">29 </span><br><span class="line">30 config AVR32</span><br><span class="line">31 bool <span class="string">&quot;AVR32 architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">35 </span><br><span class="line">36 config BLACKFIN</span><br><span class="line">37 bool <span class="string">&quot;Blackfin architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">40 </span><br><span class="line">41 config M68K</span><br><span class="line">42 bool <span class="string">&quot;M68000 architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">117</span><br><span class="line">118 endchoice</span><br></pre></td></tr></table></figure>

<p><code>choice/endchoice </code>代码段定义了一组可选择项，将多个类似的配置项组合在一起，供用户单选或者多选。该示例就是选择处理器架构，可以从<code>ARC、ARM、AVR32</code>等这些架构中选择，这里是单选。在 uboot 图形配置界面上选择<code>“Architecture select”</code>，进入以后如下图：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/20.png" alt="image"><br>第 12 行的<code>prompt</code>给出这个<code>choice/endchoice </code>段的提示信息为<code>“Architecture select”</code>。</p>
<h4><span id="3-1-1-7-menuconfig">3.1.1.7 menuconfig</span><a href="#3-1-1-7-menuconfig" class="header-anchor">#</a></h4><p><code>menuconfig 和 menu </code>很类似，但是 <code>menuconfig </code>是个<strong>带选项的菜单</strong>,如顶层<code>Kconfig</code>中的<code>“General setup”</code>中的列表中有一项<code>menuconfig EXPERT</code>：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/21.png" alt="image"><br>结果如下：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/22.png" alt="image"><br>可以看到，前面有<code>“[ ]”</code>说明这个<strong>菜单是可选的</strong>，当选中这个菜单以后就可以进入到子选项中：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/23.png" alt="image"><br>如果不选择<code>“Configure standard U-Boot features (expert users)”</code>，那么所描述的菜单就不会显示出来，进去以后是空白的。</p>
<h4><span id="3-1-1-8-comment">3.1.1.8 comment</span><a href="#3-1-1-8-comment" class="header-anchor">#</a></h4><p><code>comment</code>用于注释， 也就是在图形化界面中显示一行注释。例如<code>drivers/mtd/nand/Kconfig</code>中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">74 config NAND_ARASAN</span><br><span class="line">75 bool <span class="string">&quot;Configure Arasan Nand&quot;</span></span><br><span class="line">76 help</span><br><span class="line">......</span><br><span class="line">80</span><br><span class="line">81 comment <span class="string">&quot;Generic NAND options&quot;</span></span><br></pre></td></tr></table></figure>
<p>第 81 行使用<code>comment</code>标注了一行注释，注释内容为：<code>“Generic NAND options”</code>，这行注释在配置项<code> NAND_ARASAN</code> 的下面。<br>在配置项<code>“Configure Arasan Nand”</code>下面有一行注释，注释内容为<code>“*** Generic NAND options ***”</code>：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/24.png" alt="image"></p>
<h1><span id="4-menuconfig-cai-dan-shi-zhan-lian-xi">4 menuconfig菜单实战练习</span><a href="#4-menuconfig-cai-dan-shi-zhan-lian-xi" class="header-anchor">#</a></h1><p>接下来自定义一个菜单进行练习，自定义菜单要求如下：<br>①、在主界面中添加一个名为<code>“My test menu”</code>，此菜单内部有一个配置项。<br>②、配置项为<code>“MY_TESTCONFIG”</code>，此配置项处于菜单<code>“My test menu”</code>中。<br>③、配置项的为变量类型为<code> bool</code>，默认值为 <code>y</code>。<br>④、配置项菜单名字为<code>“This is my test config”</code><br>⑤、配置项的帮助内容为<code>“This is a empty config, just for tset!”</code>。<br>在顶层 <code>Kconfig</code>，在最后面加入如下代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1 menu <span class="string">&quot;My test menu&quot;</span></span><br><span class="line">2</span><br><span class="line">3 config MY_TESTCONFIG</span><br><span class="line">4 bool <span class="string">&quot;This is my test config&quot;</span></span><br><span class="line">5 default y</span><br><span class="line">6 help</span><br><span class="line">7 This is a empty config, just for test!</span><br><span class="line">8</span><br><span class="line">9 endmenu <span class="comment"># my test menu</span></span><br></pre></td></tr></table></figure>
<p>再次执行<code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</code>：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/25.png" alt="image"><br>可以看出，主菜单最后面出现了一个名为<code>“My test menu”</code>的子菜单，这个就是上面添加进来的子菜单。进入此子菜单：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/26.png" alt="image"><br>可以看出，配置项也添加成功，按H查看帮助信息：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/27.png" alt="image"><br>保存退出，打开.config文件：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/28.png" alt="image"><br>配置项<code>MY_TESTCONFIG</code>默认也是被选中的，因此在<code>.config </code>文件中肯定会有<code>“CONFIG_MY_TESTCONFIG=y”</code>这一行。</p>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-命令和环境变量</title>
    <url>/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-1-help-huo-zhe">1.1 help或者？</a><ul>
<li><a href="#1-1-1-help-ju-ti-ming-ling">1.1.1 help+具体命令</a></li>
</ul>
</li>
<li><a href="#1-2-xin-xi-cha-xun">1.2 信息查询</a><ul>
<li><a href="#1-2-1-bdinfo">1.2.1 bdinfo</a></li>
<li><a href="#1-2-2-printenv">1.2.2 printenv</a></li>
<li><a href="#1-2-3-version">1.2.3 version</a></li>
</ul>
</li>
<li><a href="#1-3-huan-jing-bian-liang">1.3 环境变量</a><ul>
<li><a href="#1-3-1-setenv-she-ding-huan-jing-bian-liang">1.3.1 setenv设定环境变量</a></li>
<li><a href="#1-3-2-saveenv-bao-cun-huan-jing-bian-liang">1.3.2 saveenv保存环境变量</a></li>
<li><a href="#1-3-3-setenv-shan-chu-huan-jing-bian-liang">1.3.3 setenv删除环境变量</a></li>
<li><a href="#1-3-4-huan-jing-bian-liang-yuan-li">1.3.4 环境变量原理</a><ul>
<li><a href="#1-3-4-1-bootcmd-zhan-kai">1.3.4.1 bootcmd展开</a></li>
<li><a href="#1-3-4-2-bootargs-zhan-kai">1.3.4.2 bootargs展开</a></li>
<li><a href="#1-3-4-3-bootdlelay">1.3.4.3 bootdlelay</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-4-nei-cun-cao-zuo">1.4 内存操作</a><ul>
<li><a href="#1-4-1-md">1.4.1 md</a></li>
<li><a href="#1-4-2-nm-ming-ling">1.4.2 nm命令</a></li>
<li><a href="#1-4-3-mm-ming-ling">1.4.3 mm命令</a></li>
<li><a href="#1-4-4-mw-ming-ling">1.4.4 mw命令</a></li>
<li><a href="#1-4-5-cp-ming-ling">1.4.5 cp命令</a></li>
<li><a href="#1-4-6-cmp-ming-ling">1.4.6 cmp命令</a></li>
</ul>
</li>
<li><a href="#1-5-wang-luo-cao-zuo-ming-ling">1.5 网络操作命令</a><ul>
<li><a href="#1-5-1-ping-ming-ling">1.5.1 ping命令</a></li>
<li><a href="#1-5-2-dhcp-ming-ling-zi-dong-ip-huo-qu">1.5.2 dhcp命令（自动ip获取）</a></li>
<li><a href="#1-5-3-nfs-ming-ling">1.5.3 nfs命令</a></li>
<li><a href="#1-5-4-tftp-ming-ling">1.5.4 tftp命令</a></li>
</ul>
</li>
<li><a href="#1-6-emmc-he-sd-qia-zhi-ling">1.6 emmc和sd卡指令</a><ul>
<li><a href="#1-6-1-mmc-info">1.6.1 mmc info</a></li>
<li><a href="#1-6-2-mmc-rescan">1.6.2 mmc rescan</a></li>
<li><a href="#1-6-3-mmc-list">1.6.3 mmc list</a></li>
<li><a href="#1-6-4-mmc-dev">1.6.4 mmc dev</a></li>
<li><a href="#1-6-5-mmc-part">1.6.5 mmc part</a></li>
<li><a href="#1-6-6-mmc-read">1.6.6 mmc read</a></li>
<li><a href="#1-6-7-mmc-write">1.6.7 mmc write</a></li>
<li><a href="#1-6-7-mmc-erase">1.6.7 mmc erase</a></li>
</ul>
</li>
<li><a href="#1-7-wen-jian-cao-zuo-ming-ling-fat-wen-jian-xi-tong">1.7 文件操作命令（fat文件系统）</a><ul>
<li><a href="#1-7-1-fatinfo">1.7.1 fatinfo</a></li>
<li><a href="#1-7-1-fatls">1.7.1 fatls</a></li>
<li><a href="#1-7-3-fstype">1.7.3 fstype</a></li>
<li><a href="#1-7-4-fatload">1.7.4 fatload</a></li>
<li><a href="#1-7-5-fatwrite">1.7.5 fatwrite</a></li>
</ul>
</li>
<li><a href="#1-8-wen-jian-cao-zuo-ming-ling-ext-wen-jian-xi-tong">1.8 文件操作命令（ext文件系统）</a></li>
<li><a href="#1-9-nandflash-cao-zuo-ming-ling">1.9 nandflash操作命令</a><ul>
<li><a href="#1-9-1-nand-info">1.9.1 nand info</a></li>
<li><a href="#1-9-2-nand-device">1.9.2 nand device</a></li>
<li><a href="#1-9-3-nand-erase">1.9.3 nand erase</a></li>
<li><a href="#1-9-3-nand-write">1.9.3 nand write</a></li>
<li><a href="#1-9-4-nand-read">1.9.4 nand read</a></li>
</ul>
</li>
<li><a href="#1-10-she-bei-shu-xiang-guan">1.10 设备树相关</a><ul>
<li><a href="#1-10-1-fdt-addr">1.10.1 fdt addr</a></li>
<li><a href="#1-10-2-fdt-header">1.10.2 fdt header</a></li>
<li><a href="#1-10-3-fdt-print">1.10.3 fdt print</a></li>
</ul>
</li>
<li><a href="#1-11-qi-dong-xiang-guan">1.11 启动相关</a><ul>
<li><a href="#1-11-1-bootz-qi-dong-zimage">1.11.1 bootz (启动zImage)</a></li>
<li><a href="#1-11-1-bootm-qi-dong-uimage">1.11.1 bootm (启动uImage)</a></li>
<li><a href="#1-11-3-boot">1.11.3 boot</a></li>
<li><a href="#1-11-4-go-ming-ling">1.11.4 go命令</a></li>
<li><a href="#1-11-5-run">1.11.5 run</a></li>
</ul>
</li>
<li><a href="#1-12-nei-cun-ce-shi-mtest">1.12 内存测试mtest</a></li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="1-1-help-huo-zhe">1.1 help或者？</span><a href="#1-1-help-huo-zhe" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/1.png" alt="image"></p>
<h3><span id="1-1-1-help-ju-ti-ming-ling">1.1.1 help+具体命令</span><a href="#1-1-1-help-ju-ti-ming-ling" class="header-anchor">#</a></h3><p><code>? bootz 或 help bootz</code><br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/2.png" alt="image"></p>
<h2><span id="1-2-xin-xi-cha-xun">1.2 信息查询</span><a href="#1-2-xin-xi-cha-xun" class="header-anchor">#</a></h2><h3><span id="1-2-1-bdinfo">1.2.1 bdinfo</span><a href="#1-2-1-bdinfo" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/3.png" alt="image"></p>
<h3><span id="1-2-2-printenv">1.2.2 printenv</span><a href="#1-2-2-printenv" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/4.png" alt="image"><br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/5.png" alt="image"><br>前确保 uboot 中的环境变量 bootargs 内容如下:<br><code>console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm/boot/zImage /home/zuozhongkai/linux/tftpboot/ -f</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm/boot/dts/imx6ull-14x14-evk.dtb /home/zuozhongkai/linux/tftpboot/ -f</span><br><span class="line">tftp 80800000 zImage </span><br><span class="line">tftp 83000000 imx6ull-14x14-evk.dtb</span><br><span class="line">bootz 80800000 - 83000000</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-3-version">1.2.3 version</span><a href="#1-2-3-version" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.png" alt="image"></p>
<h2><span id="1-3-huan-jing-bian-liang">1.3 环境变量</span><a href="#1-3-huan-jing-bian-liang" class="header-anchor">#</a></h2><h3><span id="1-3-1-setenv-she-ding-huan-jing-bian-liang">1.3.1 setenv设定环境变量</span><a href="#1-3-1-setenv-she-ding-huan-jing-bian-liang" class="header-anchor">#</a></h3><p>设置<code>bootdelay</code>时间为5s.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootdelay 5</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/7.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv author zuozhongkai</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>新建环境变量也是用setenv。</p>
<h3><span id="1-3-2-saveenv-bao-cun-huan-jing-bian-liang">1.3.2 saveenv保存环境变量</span><a href="#1-3-2-saveenv-bao-cun-huan-jing-bian-liang" class="header-anchor">#</a></h3><h3><span id="1-3-3-setenv-shan-chu-huan-jing-bian-liang">1.3.3 setenv删除环境变量</span><a href="#1-3-3-setenv-shan-chu-huan-jing-bian-liang" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv author</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>设置变量为空表示删除掉该环境变量，重启该环境变量就不会存在了。</p>
<h3><span id="1-3-4-huan-jing-bian-liang-yuan-li">1.3.4 环境变量原理</span><a href="#1-3-4-huan-jing-bian-liang-yuan-li" class="header-anchor">#</a></h3><p><code>include/env_default.h</code>定义了很多环境变量，如<code>bootargs,bootdelay,bootcmd等</code>：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/8.png" alt="image"><br>由 于 没 有 定 义<code>DEFAULT_ENV_INSTANCE_EMBEDDED和CONFIG_SYS_REDUNDAND_ENVIRONMENT</code>，因此 <code>uchar default_environment[]</code>数组保存环境变量。</p>
<h4><span id="1-3-4-1-bootcmd-zhan-kai">1.3.4.1 bootcmd展开</span><a href="#1-3-4-1-bootcmd-zhan-kai" class="header-anchor">#</a></h4><p>如<code>CONFIG_BOOTCOMMAND</code>等一系列宏都是定义在<code>include/configs/mx6ull_alientek_emmc.h</code>:<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/9.png" alt="image"><br> uboot 使用了类似 shell 脚本语言的方式来编写的,首先<code>run findfdt</code>， findfdt 是用来查找开发板对应的设备树文件(.dtb)，IMX6ULL EVK 的设备树文件为<code>imx6ull-14x14-evk.dtb，findfdt</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;findfdt=&quot;</span>\</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;echo WARNING: Could not determine dtb to use; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure>

<p>那么<code>run findfdt</code>就等同于执行<code>setenv fdt_file imx6ull-14x14-evk.dtb</code>。设置fdt_file环境变量等于imx6ull-14x14-evk.dtb。<br><code>mmc dev $&#123;mmcdev&#125;</code>用于切换 mmc 设备，mmcdev 为 1，因此这行代码就是：mmc dev 1，也就是切换到 EMMC 上。<br>先执行<code> mmc dev $&#123;mmcdev&#125;</code>切换到 EMMC 上，然后使用命令<code> mmc rescan</code> 扫描看有没有 SD 卡或者 EMMC 存在，如果没有的话就直接跳到else，执行<code> run netboot</code>，netboot也是一个自定义的环境变量，这个变量是从网络启动 Linux 的。<br>扫描到EMMC后，<code>run loadbootscript</code>：<br>    <code>loadbootscript=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;</code><br>其中 mmcdev&#x3D;1，mmcpart&#x3D;1，loadaddr&#x3D;0x80800000，script&#x3D; boot.scr，因此展开以后就是：<br>    <code>loadbootscript=fatload mmc 1:1 0x80800000 boot.scr;</code><br>loadbootscript 就是从 mmc1 的分区 1 中读取文件 boot.src 到 DRAM 的 0X80800000 处。但是 mmc1 的分区 1 中没有 boot.src 这个文件，可以使用命令<code>ls mmc 1:1</code>查看一下 mmc1 分区1 中的所有文件，看看有没有 boot.src 这个文件。再展开bootscript：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bootscript=<span class="built_in">echo</span> Running bootscript from mmc ...;</span><br><span class="line"><span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>由于boot.src 文件不存在，所以 bootscript 也就不会运行。就运行环境变量 loadimage:<br><code>loadimage=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;image&#125;</code><br>loadimage展开：<br><code>loadimage=fatload mmc 1:1 0x80800000 zImage</code><br>fatload就是从 mmc1 的分区中读取 zImage 到内存的 0X80800000 处，而 mmc1的分区 1 中存在 zImage。<br>loadimage执行完，执行mmcboot环境变量，run mmcboot：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/10.png" alt="image"><br>①打印Booting from mmc …<br>②运行环境变量 mmcargs，mmcargs 用来设置 bootargs，后面分析 bootargs 的时候在学习。<br>③判断boot_fdt是否为yes或者try，根据uboot输出的环境变量信息可知boot_fdt&#x3D;try。因此执行loadfdt。<br>④执行loadfdt环境变量,如下：<br><code>loadfdt=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;</code><br>展开以后就是:<br><code>loadfdt=fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb</code><br>因此 loadfdt 的作用就是从 mmc1 的分区 1 中读取 imx6ull-14x14-evk.dtb 文件并放到 0x83000000处。<br>⑤loadfdt加载dtb成功后，调用命令 bootz 启动 linux：<br>    <code>bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;</code><br>展开：<br>    <code>bootz 0x80800000 - 0x83000000 (注意‘-’前后要有空格)</code></p>
<p>总结一下bootcmd展开：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="comment">//切换到 EMMC</span></span><br><span class="line">fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">0x80800000</span> zImage <span class="comment">//读取 zImage 到 0x80800000 处</span></span><br><span class="line">fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">0x83000000</span> imx6ull<span class="number">-14</span>x14-evk.dtb <span class="comment">//读取设备树到 0x83000000 处</span></span><br><span class="line">bootz <span class="number">0x80800000</span> - <span class="number">0x83000000</span> <span class="comment">//启动 Linux</span></span><br></pre></td></tr></table></figure>

<p>我们可以将bootcmd环境变量进行简化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define CONFIG_BOOTCOMMAND \</span></span><br><span class="line"> <span class="string">&quot;mmc dev 1;&quot;</span> \</span><br><span class="line"> <span class="string">&quot;fatload mmc 1:1 0x80800000 zImage;&quot;</span> \</span><br><span class="line"> <span class="string">&quot;fatload mmc 1:1 0x83000000 imx6ull-alientek-emmc.dtb;&quot;</span> \</span><br><span class="line"> <span class="string">&quot;bootz 0x80800000 - 0x83000000;&quot;</span></span><br></pre></td></tr></table></figure>
<p>或者：<br><code>setenv bootcmd &#39;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ullalientek-emmc.dtb; bootz 80800000 - 83000000;&#39;</code></p>
<h4><span id="1-3-4-2-bootargs-zhan-kai">1.3.4.2 bootargs展开</span><a href="#1-3-4-2-bootargs-zhan-kai" class="header-anchor">#</a></h4><p>bootargs 保存着 uboot 传递给 Linux 内核的参数。从emmc启动时，bootargs 环境变量是由 mmcargs 设置的：<br><code>mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</code><br>其中：<br><code>console=ttymxc0，baudrate=115200，mmcroot=/dev/mmcblk1p2 rootwait rw</code><br>mmcargs展开以后就是:<br><code>mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</code></p>
<p>可以看出环境变量 mmcargs 就是设置 bootargs 的值为<code>console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</code>。<br>①<code>console=ttymxc0,115200 </code>综合起来就是设置 ttymxc0（也就是串口 1）作为 Linux 的终端，并且串口波特率设置为 115200。<br>②<code>root=/dev/mmcblk1p2 </code>用于指明根文件系统存放在mmcblk1 设备的分区 2 中。在 I.MX6U-ALPHA 开发板中&#x2F;dev&#x2F;mmcblk1 表示 EMMC，而&#x2F;dev&#x2F;mmcblk1p2 表示EMMC 的分区 2。<br>③root 后面有<code>rootwait rw</code>，rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话mmc 设备还没初始化完成就挂载根文件系统会出错的。rw 表示根文件系统是可以读写的，不加rw 的话可能无法在根文件系统中进行写操作，只能进行读操作。</p>
<h4><span id="1-3-4-3-bootdlelay">1.3.4.3 bootdlelay</span><a href="#1-3-4-3-bootdlelay" class="header-anchor">#</a></h4><p>uboot命令行倒计时</p>
<h2><span id="1-4-nei-cun-cao-zuo">1.4 内存操作</span><a href="#1-4-nei-cun-cao-zuo" class="header-anchor">#</a></h2><h3><span id="1-4-1-md">1.4.1 md</span><a href="#1-4-1-md" class="header-anchor">#</a></h3><pre><code>md[.b, .w, .l] address [# of objects]
</code></pre>
<p>注意：uboot 命令中的数字都是十六进制的</p>
<ol>
<li>命令中的<code>[.b .w .l]对应 byte、word 和 long</code>，也就是分别以 1 个字节、2 个字节、4 个字节来显示内存值.</li>
<li>address 就是要查看的内存起始地址.</li>
<li><code>[# of objects]</code>表示要查看的数据长度:</li>
</ol>
<p>这个数据长度单位不是字节，而是跟你所选择的显示格式有关。比如你设置要查看的内存长度为20(十六进制为 0x14)，如果显示格式为.b 的话那就表示 20 个字节；如果显示格式为.w 的话就表示 20 个 word，也就是<code> 20*2=40 个字节</code>；如果显示格式为.l 的话就表示 20 个 long，也就是<code>20*4=80 </code>个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">md.b <span class="number">80000000</span> <span class="number">10</span> <span class="comment">//读16字节</span></span><br><span class="line">md.w <span class="number">80000000</span> <span class="number">10</span> <span class="comment">//读32字节</span></span><br><span class="line">md.l <span class="number">80000000</span> <span class="number">10</span> <span class="comment">//读64字节</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/11.png" alt="image"></p>
<h3><span id="1-4-2-nm-ming-ling">1.4.2 nm命令</span><a href="#1-4-2-nm-ming-ling" class="header-anchor">#</a></h3><p>写内存，写成功后地址不会自增。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nm [.b, .w, .l] address</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/12.png" alt="image"><br>0500e031 表示地址 0x80000000 现在的数据，<code>？</code>后面就可以输入要修改后的数据 0x12345678，输入完成以后按下回车，然后再输入‘q’即可退出。<br>退出后输入md.l查看。<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/13.png" alt="image"></p>
<h3><span id="1-4-3-mm-ming-ling">1.4.3 mm命令</span><a href="#1-4-3-mm-ming-ling" class="header-anchor">#</a></h3><p>写内存，写成功后地址会自增。<br>比如以.l 格式修改从地址 0x80000000 开始的连续 3 个内存块<code>(3*4=12个字节)</code>的数据为 0X05050505.<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/14.png" alt="image"><br>输入md命令查看一下：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/15.png" alt="image"></p>
<h3><span id="1-4-4-mw-ming-ling">1.4.4 mw命令</span><a href="#1-4-4-mw-ming-ling" class="header-anchor">#</a></h3><p>写一段连续的内存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mw [.b, .w, .l] address value [count]</span><br></pre></td></tr></table></figure>

<p>比如使用.l 格式将以 0X80000000 为起始地址的 0x10 个内存块<code>(0x10 * 4=64 字节)</code>填充为 0X0A0A0A0A</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mw.l 80000000 0A0A0A0A 10</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/16.png" alt="image"></p>
<h3><span id="1-4-5-cp-ming-ling">1.4.5 cp命令</span><a href="#1-4-5-cp-ming-ling" class="header-anchor">#</a></h3><p>数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 Nor Flash 中的数据拷贝到 DRAM 中。</p>
<pre><code>cp [.b, .w, .l] source target count
</code></pre>
<p>我们使用.l 格式将 0x80000000 处的地址拷贝到 0X80000100 处，长度为 0x10 个内存块<code>(0x10 * 4=64 个字节).</code></p>
<pre><code>cp.l 80000000 80000100 10
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/17.png" alt="image"></p>
<h3><span id="1-4-6-cmp-ming-ling">1.4.6 cmp命令</span><a href="#1-4-6-cmp-ming-ling" class="header-anchor">#</a></h3><p>比较两段内存的数据是否相等。</p>
<pre><code>cmp [.b, .w, .l] addr1 addr2 count
</code></pre>
<p>比较 0x80000000 和 0X80000100 这两个地址数据是否相等，比较长度为 0x10 个内存块<code>(16 * 4=64 个字节)</code></p>
<pre><code>cmp.l 80000000 80000100 10
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/18.png" alt="image"><br>我们再随便挑两段内存比较一下，比如地址0x80002000 和 0x800003000，长度为 0X10.<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/19.png" alt="image"><br>可以看出，0x80002000 处的数据和 0x80003000 处的数据就不一样.</p>
<h2><span id="1-5-wang-luo-cao-zuo-ming-ling">1.5 网络操作命令</span><a href="#1-5-wang-luo-cao-zuo-ming-ling" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>环境变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ipaddr</td>
<td>开发板 ip 地址，可以不设置，使用 dhcp 命令来从路由器获取 IP 地址</td>
</tr>
<tr>
<td>ethaddr</td>
<td>开发板的 MAC 地址，一定要设置</td>
</tr>
<tr>
<td>gatewayip</td>
<td>网关地址</td>
</tr>
<tr>
<td>netmask</td>
<td>子网掩码</td>
</tr>
<tr>
<td>serverip</td>
<td>服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码</td>
</tr>
</tbody></table>
<p>预先设置号网络相关环境变量：</p>
<pre><code>setenv ipaddr 192.168.1.50
setenv ethaddr b8:ae:1d:01:00:00
setenv gatewayip 192.168.1.1
setenv netmask 255.255.255.0
setenv serverip 192.168.1.253
saveenv
</code></pre>
<h3><span id="1-5-1-ping-ming-ling">1.5.1 ping命令</span><a href="#1-5-1-ping-ming-ling" class="header-anchor">#</a></h3><pre><code>ping 192.168.1.100
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/20.png" alt="image"></p>
<h3><span id="1-5-2-dhcp-ming-ling-zi-dong-ip-huo-qu">1.5.2 dhcp命令（自动ip获取）</span><a href="#1-5-2-dhcp-ming-ling-zi-dong-ip-huo-qu" class="header-anchor">#</a></h3><p>dhcp 用于从路由器获取 IP 地址，前提得开发板连接到路由器上的，如果开发板是和电脑<br>直连的，那么 dhcp 命令就会失效。直接输入 dhcp 命令即可通过路由器获取到 IP 地址。</p>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/21.png" alt="image"><br>DHCP 不单单是获取 IP 地址，其还会通过 TFTP 来启动 linux 内核，输入<code>? dhcp</code>即<br>可查看 dhcp 命令详细的信息：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/22.png" alt="image"></p>
<h3><span id="1-5-3-nfs-ming-ling">1.5.3 nfs命令</span><a href="#1-5-3-nfs-ming-ling" class="header-anchor">#</a></h3><p>nfs(Network File System)网络文件系统,通过网络将编译好的 linux 镜像和设备树文件下载<br>到 DRAM 中，然后就可以直接运行。<br>虚拟机Ubuntu先搭建好nfs服务，详见：<a href="https://www.cnblogs.com/fuzidage/p/16694496.html" title="nfs服务搭建">nfs服务搭建</a> <a href="https://fuzidage.github.io/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/">linux搭建nfs服务 | Hexo (fuzidage.github.io)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfs [loadAddress] [[hostIPaddr:]bootfilename]</span><br></pre></td></tr></table></figure>

<p>loadAddress 是要保存的 DRAM 地址，<code>[[hostIPaddr:]bootfilename]</code>是要下载的文件地址,<br>我们将正点原子官方编译出来的 Linux 镜像文件 zImage 下载到开发板 DRAM 的 0x80800000这个地址处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfs 80800000 192.168.1.253:/home/zuozhongkai/linux/nfs/zImage</span><br></pre></td></tr></table></figure>
<p>下载过程如图下：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/23.png" alt="image"></p>
<p>下载完成以后查看 0x80800000 地址处的数据，使用命令 md.b 来查看前 0x100 个字节的数据。<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/24.png" alt="image"><br>我们再用UE打开编译出的zImage，对比一下说明 nfs 命令下载到的zImage 是正确的。<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/25.png" alt="image"></p>
<h3><span id="1-5-4-tftp-ming-ling">1.5.4 tftp命令</span><a href="#1-5-4-tftp-ming-ling" class="header-anchor">#</a></h3><p>tftp 命令的作用和 nfs 命令一样，都是用于通过网络下载东西到 DRAM 中。tftp服务搭建参考：<a href="https://www.cnblogs.com/fuzidage/p/11997775.html" title="tftp服务搭建">tftp服务搭建</a> <a href="https://fuzidage.github.io/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/">linux搭建tftp和ftp服务 | Hexo (fuzidage.github.io)</a></p>
<pre><code>tftpboot [loadAddress] [[hostIPaddr:]bootfilename]
</code></pre>
<p> loadAddress 是文 件在 DRAM 中的 存放 地址 ，<br><code>[[hostIPaddr:]bootfilename]</code>是要从 Ubuntu 中下载的文件。但是和 nfs 命令的区别在于，tftp 命令不需要输入文件在 Ubuntu 中的完整路径，只需要输入文件名即可。比如我们现在将 tftpboot 文件夹里面的 zImage 文件下载到开发板 DRAM 的 0X80800000 地址处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tftp 80800000 zImage</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/26.png" alt="image"></p>
<h2><span id="1-6-emmc-he-sd-qia-zhi-ling">1.6 emmc和sd卡指令</span><a href="#1-6-emmc-he-sd-qia-zhi-ling" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/27.png" alt="image"></p>
<p>mmc相关命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mmc info</td>
<td>输出 MMC 设备信息</td>
</tr>
<tr>
<td>mmc read</td>
<td>读取 MMC 中的数据</td>
</tr>
<tr>
<td>mmc wirte</td>
<td>向 MMC 设备写入数据</td>
</tr>
<tr>
<td>mmc rescan</td>
<td>扫描 MMC 设备</td>
</tr>
<tr>
<td>mmc part</td>
<td>列出 MMC 设备的分区</td>
</tr>
<tr>
<td>mmc dev</td>
<td>切换 MMC 设备</td>
</tr>
<tr>
<td>mmc list</td>
<td>列出当前有效的所有 MMC 设备</td>
</tr>
<tr>
<td>mmc hwpartition</td>
<td>设置 MMC 设备的分区</td>
</tr>
<tr>
<td>mmc bootbus……</td>
<td>设置指定 MMC 设备的 BOOT_BUS_WIDTH 域的值</td>
</tr>
<tr>
<td>mmc bootpart……</td>
<td>设置指定 MMC 设备的 boot 和 RPMB 分区的大小</td>
</tr>
<tr>
<td>mmc partconf……</td>
<td>设置指定 MMC 设备的 PARTITION_CONFG 域的值</td>
</tr>
<tr>
<td>mmc rst</td>
<td>复位 MMC 设备</td>
</tr>
<tr>
<td>mmc setdsr</td>
<td>设置 DSR 寄存器的值</td>
</tr>
</tbody></table>
<h3><span id="1-6-1-mmc-info">1.6.1 mmc info</span><a href="#1-6-1-mmc-info" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/28.png" alt="image"></p>
<p>当前选中的 MMC 设备是EMMC，版本为 5.0，容量为 7.1GiB(EMMC为 8GB)，速度为 52000000Hz&#x3D;52MHz，8 位宽的总线。还有一个与 mmc info 命令相同功能的命令：mmcinfo，“mmc”和“info”之间没有空格。</p>
<h3><span id="1-6-2-mmc-rescan">1.6.2 mmc rescan</span><a href="#1-6-2-mmc-rescan" class="header-anchor">#</a></h3><p>mmc rescan 命令用于扫描当前开发板上所有的 MMC 设备，包括 EMMC 和 SD 卡。</p>
<h3><span id="1-6-3-mmc-list">1.6.3 mmc list</span><a href="#1-6-3-mmc-list" class="header-anchor">#</a></h3><p>查看当前开发板一共有几个 MMC 设备.<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/29.png" alt="image"></p>
<p>可以看出当前开发板有两个 MMC 设备：<code>FSL_SDHC:0 和 FSL_SDHC:1 (eMMC)</code>，这是因为我现在用的是 EMMC 版本的核心板，加上 SD 卡一共有两个 MMC 设备，<code>FSL_SDHC:0 是 SD卡，FSL_SDHC:1(eMMC)是 EMMC</code>。默认会将 EMMC 设置为当前 MMC 设备，这就是为什么输入<code>mmc info</code>查询到的是 EMMC 设备信息，而不是 SD 卡。要想查看 SD 卡信息，就要使用命令<code>mmc dev</code>来将 SD 卡设置为当前的 MMC 设备。</p>
<h3><span id="1-6-4-mmc-dev">1.6.4 mmc dev</span><a href="#1-6-4-mmc-dev" class="header-anchor">#</a></h3><p>选择切换当前emmc设备。</p>
<pre><code>mmc dev [dev] [part]
</code></pre>
<p>[dev]用来设置要切换的 MMC 设备号，[part]是分区号。如果不写分区号的话默认为分区 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">0</span> <span class="comment">//切换到 SD 卡，0 为 SD 卡，1 为 eMMC</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/30.png" alt="image"><br>切换到sd这个mmc后，输入mmc info命令既可以查看sd信息：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/31.png" alt="image"></p>
<p>可以看到当前 SD 卡为 3.0 版本的，容量为 14.8GiB(16GB 的 SD 卡)，4 位宽的总线。</p>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/32.png" alt="image"></p>
<h3><span id="1-6-5-mmc-part">1.6.5 mmc part</span><a href="#1-6-5-mmc-part" class="header-anchor">#</a></h3><p>查看mmc分区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="comment">//切换到 EMMC</span></span><br><span class="line">mmc part <span class="comment">//查看 EMMC 分区</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/33.png" alt="image"></p>
<p>切到核心板的emmc后，<code>mmc part</code>显示分区信息，此时 EMMC 有两个分区，第一个分区起始扇区为 20480，长度为 262144 个扇区；第二个分区起始扇区为 282624，长度为 14594048 个扇区。<br>如果 EMMC 里面烧写了 Linux 系统的话，EMMC 是有 3 个分区的，第 0 个分区存放 uboot，第 1 个分区存放Linux 镜像文件和设备树，第 2 个分区存放根文件系统。但是在上图中只有两个分区，那是因为第 0 个分区没有格式化，所以识别不出来，实际上第 0 个分区是存在的。一个新的 SD卡默认只有一个分区，那就是分区 0，所以前面讲解的 uboot 烧写到 SD 卡，其实就是将 u-boot.bin烧写到了 SD 卡的分区 0 里面.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="number">2</span> <span class="comment">//将 EMMC 的分区 2 设置为当前 MMC 设备</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/34.png" alt="image"></p>
<h3><span id="1-6-6-mmc-read">1.6.6 mmc read</span><a href="#1-6-6-mmc-read" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc <span class="built_in">read</span> addr blk<span class="comment"># cnt</span></span><br></pre></td></tr></table></figure>
<p>读mmc设备中的数据。addr 是数据读取到 DRAM 中的地址，blk 是要读取的块起始地址(十六进制)，一个块是 512字节，这里的块和扇区是一个意思，在 MMC 设备中我们通常说扇区，cnt 是要读取的块数量(十六进制)。比如从 EMMC 的第 1536(0x600)个块开始，读取 16(0x10)个块的数据到 DRAM 的0X80800000 地址处</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="number">0</span> <span class="comment">//切换到 MMC 分区 0</span></span><br><span class="line">mmc read <span class="number">80800000</span> <span class="number">600</span> <span class="number">10</span> <span class="comment">//读取数据</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/35.png" alt="image"><br>这里我们还看不出来读取是否正确，通过 md.b 命令查看 0x80800000 处的数据就行了，查看<code> 16*512=8192(0x2000)</code>个字节的数据。<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/36.png" alt="image"></p>
<p>可以看到<code>baudrate=115200.board_name=EVK.board_rev=14X14</code>等字样，<br>这个就是 uboot 中的环境变量。EMMC 核心板 uboot 环境变量的存储起始地址就是<code>1536*512=786432</code>。</p>
<h3><span id="1-6-7-mmc-write">1.6.7 mmc write</span><a href="#1-6-7-mmc-write" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc write addr blk<span class="comment"># cnt</span></span><br></pre></td></tr></table></figure>
<p>从DRAM写数据到mmc设备。<br>比如通过 nfs 或者 tftp 命令将新的 u-boot.bin 下载到开发板的 DRAM 中，然后再使用命令<code>mmc write</code>将其写入到 MMC设备中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">0</span> <span class="comment">//切换到 SD 卡</span></span><br><span class="line">version <span class="comment">//查看uboot版本号</span></span><br><span class="line">tftp <span class="number">80800000</span> u-boot.imx</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/37.png" alt="image"><br>可以看出，u-boot.imx 大小为 <code>379904 字节，379904/512=742</code>，所以我们要向 SD 卡中写入742 个块，如果有小数的话就要加 1 个块。使用命令<code>mmc write</code>从 SD 卡分区 0 第 2 个块(扇区)开始烧写，一共烧写 742(0x2E6)个块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">0</span> <span class="number">0</span></span><br><span class="line">mmc write <span class="number">80800000</span> <span class="number">2</span> <span class="number">2E6</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/38.png" alt="image"></p>
<p>烧写成功，重启开发板(从 SD 卡启动)，重启以后再输入 version 来查看版本号：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/39.png" alt="image"><br>这样就给mmc0也就是sd卡烧录了uboot, 同理要烧录emmc也是同理，切到mmc1即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="number">0</span> <span class="comment">//切换到 EMMC 分区 0</span></span><br><span class="line">tftp <span class="number">80800000</span> u-boot.imx <span class="comment">//下载 u-boot.imx 到 DRAM</span></span><br><span class="line">mmc write <span class="number">80800000</span> <span class="number">2</span> <span class="number">32</span>E <span class="comment">//烧写 u-boot.imx 到 EMMC 中</span></span><br><span class="line">mmc partconf <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">//分区配置，EMMC 需要这一步！</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：千万不要写 SD 卡或者 EMMC 的前两个块(扇区)，里面保存着分区表！</strong></p>
<h3><span id="1-6-7-mmc-erase">1.6.7 mmc erase</span><a href="#1-6-7-mmc-erase" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc erase blk<span class="comment"># cnt</span></span><br></pre></td></tr></table></figure>
<p>擦除 MMC 设备的指定块, blk 为要擦除的起始块，cnt 是要擦除的数量。</p>
<h2><span id="1-7-wen-jian-cao-zuo-ming-ling-fat-wen-jian-xi-tong">1.7 文件操作命令（fat文件系统）</span><a href="#1-7-wen-jian-cao-zuo-ming-ling-fat-wen-jian-xi-tong" class="header-anchor">#</a></h2><h3><span id="1-7-1-fatinfo">1.7.1 fatinfo</span><a href="#1-7-1-fatinfo" class="header-anchor">#</a></h3><pre><code>fatinfo &lt;interface&gt; [&lt;dev[:part]&gt;]
</code></pre>
<p>于查询指定 MMC 设备分区的文件系统信息，interface 表示接口，比如 mmc，dev 是查询的设备号，part 是要查询的分区。比如我们要查询 EMMC 分区 1 的文件系统信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fatinfo mmc <span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/40.png" alt="image"><br>上图显示mmc1也就是emmc设备的分区1的文件系统为fat32格式。</p>
<h3><span id="1-7-1-fatls">1.7.1 fatls</span><a href="#1-7-1-fatls" class="header-anchor">#</a></h3><pre><code>fatls &lt;interface&gt; [&lt;dev[:part]&gt;] [directory]
</code></pre>
<p>查询设备分区的目录和文件信息。interface 是要查询的接口，比如 mmc，dev 是要查询的设备号，part 是要查询的分区，directory是要查询的目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fatls mmc <span class="number">1</span>:<span class="number">1</span>   <span class="comment">//查询 mmc1设备（EMMC 设备）中分区 1 中的所有的目录和文件</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/41.png" alt="image"></p>
<h3><span id="1-7-3-fstype">1.7.3 fstype</span><a href="#1-7-3-fstype" class="header-anchor">#</a></h3><pre><code>fstype &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;
</code></pre>
<p>查看 MMC 设备某个分区的文件系统格式.正点原子 EMMC 核心板上的 EMMC 默认有 3 个分区, 分区 0 格式未知，因为分区 0 存放的 uboot，并且分区 0 没有格式化，所以文件系统格式未知。分区 1 的格式为 fat，分区 1 用于存放 linux 镜像和设备树。分区 2 的格式为 ext4，用于存放 Linux 的根文件系统(rootfs)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fstype mmc <span class="number">1</span>:<span class="number">0</span></span><br><span class="line">fstype mmc <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">fstype mmc <span class="number">1</span>:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/42.png" alt="image"></p>
<h3><span id="1-7-4-fatload">1.7.4 fatload</span><a href="#1-7-4-fatload" class="header-anchor">#</a></h3><pre><code>fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]
</code></pre>
<p>将指定的文件读取到 DRAM.<br>interface 为接口，比如 mmc，dev 是设备号，part 是分区，addr 是保存在 DRAM 中的起始地址，filename 是要读取的文件名字。bytes 表示读取多少字节的数据，如果 bytes 为 0 或者省略的话表示读取整个文件。pos 是要读的文件相对于文件首地址的偏移，如果为 0 或者省略的话表示从文件首地址开始读取.</p>
<pre><code>fatload mmc 1:1 80800000 zImage  //将 EMMC 分区 1 中的 zImage 文件读取到 DRAM 中的0X80800000 地址处
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/43.png" alt="image"></p>
<p> 225ms 内读取了 6785272 个字节的数据，速度为 28.8MiB&#x2F;s，速度是非常快的，因为这是从 EMMC 里面读取的，而 EMMC 是 8 位的，速度肯定会很快的。</p>
<h3><span id="1-7-5-fatwrite">1.7.5 fatwrite</span><a href="#1-7-5-fatwrite" class="header-anchor">#</a></h3><p>将 DRAM 中的数据写入到 MMC 设备。<br>uboot 默认没有使能<code> fatwrite</code> 命令，需要修改板子配置头文件，比如 <code>mx6ullevk.h、 mx6ull_alientek_emmc.h </code>等,需要开启宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FAT_WRITE <span class="comment">/* 使能 fatwrite 命令 */</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/44.png" alt="image"></p>
<pre><code>fatwrite &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt;
</code></pre>
<p>interface 为接口，比如 mmc，dev 是设备号，part 是分区，addr 是要写入的数据在 DRAM中的起始地址，filename 是写入的数据文件名字，bytes 表示要写入多少字节的数据。</p>
<p>比如我们通过nfs or tftp命令下载镜像到DRAM后，通过fatwrite去烧写image：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/45.png" alt="image"><br>zImage 大小为<code>6785272(0X6788f8)</code>个字节(注意，由于开发板系统在不断的更新中，因此zImage 大小不是固定的，一切以实际大小为准)，接下来使用命令<code>fatwrite</code>将其写入到 EMMC 的分区 1 中，文件名字为 zImage：</p>
<pre><code>fatwrite mmc 1:1 80800000 zImage 6788f8
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/46.png" alt="image"></p>
<p>完成以后使用<code>fatls</code>命令查看一下 EMMC 分区 1 里面的文件：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/47.png" alt="image"></p>
<h2><span id="1-8-wen-jian-cao-zuo-ming-ling-ext-wen-jian-xi-tong">1.8 文件操作命令（ext文件系统）</span><a href="#1-8-wen-jian-cao-zuo-ming-ling-ext-wen-jian-xi-tong" class="header-anchor">#</a></h2><p>ext文件系统是linux常用的文件系统，一般rootfs就是典型的ext2文件系统。<br><code>ext2load、ext2ls、ext4load、ext4ls 和 ext4write</code>。这些命令的含义和使用与<code> fatload、fatls 和 fatwrite</code>一样，只是 ext2 和 ext4 都是针对 ext 文件系统的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ext4ls mmc <span class="number">1</span>:<span class="number">2</span>	<span class="comment">//emmc设备分区2就是ext4文件系统，存放了rootfs</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/48.png" alt="image"></p>
<h2><span id="1-9-nandflash-cao-zuo-ming-ling">1.9 nandflash操作命令</span><a href="#1-9-nandflash-cao-zuo-ming-ling" class="header-anchor">#</a></h2><p>输入<code>? nand</code>即可查看NAND 相关命令：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/49.png" alt="image"></p>
<h3><span id="1-9-1-nand-info">1.9.1 nand info</span><a href="#1-9-1-nand-info" class="header-anchor">#</a></h3><p>打印 NAND Flash 信息:<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/50.png" alt="image"></p>
<h3><span id="1-9-2-nand-device">1.9.2 nand device</span><a href="#1-9-2-nand-device" class="header-anchor">#</a></h3><p>用于切换 NAND Flash，如果你的板子支持多片 NAND 的话就可以使用此命令来设置当前所使用的 NAND。</p>
<h3><span id="1-9-3-nand-erase">1.9.3 nand erase</span><a href="#1-9-3-nand-erase" class="header-anchor">#</a></h3><p><code>nand erase </code>命令用于擦除 NAND Flash，NAND Flash 的特性(位翻转，只能由1变成0,而不能由0变成1)决定了在向 NAND Flash 写数据之前一定要先对要写入的区域进行擦除.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand erase[.spread] [clean] off size <span class="comment">//从指定地址开始(off)开始，擦除指定大小(size)的区域。</span></span><br><span class="line">nand erase.part [clean] partition <span class="comment">//擦除指定的分区</span></span><br><span class="line">nand erase.chip [clean] <span class="comment">//全篇擦除</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-9-3-nand-write">1.9.3 nand write</span><a href="#1-9-3-nand-write" class="header-anchor">#</a></h3><pre><code>nand write addr off size
</code></pre>
<p>addr 是要写入的数据首地址，off 是 NAND 中的目的地址，size 是要写入的数据大小。</p>
<p>编译出来 NAND版本的 kernel 和 dtb 文件，在烧写之前要先对 NAND 进行分区，也就是规划好 uboot、linux kernel、设备树和根文件系统的存储区域，I.MX6U-ALPHA 开发板出厂系统 NAND 分区如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x000000000000</span><span class="number">-0x0000003FFFFF</span> : <span class="string">&quot;boot&quot;</span></span><br><span class="line"><span class="number">0x000000400000</span><span class="number">-0x00000041FFFF</span> : <span class="string">&quot;env&quot;</span></span><br><span class="line"><span class="number">0x000000420000</span><span class="number">-0x00000051FFFF</span> : <span class="string">&quot;logo&quot;</span></span><br><span class="line"><span class="number">0x000000520000</span><span class="number">-0x00000061FFFF</span> : <span class="string">&quot;dtb&quot;</span></span><br><span class="line"><span class="number">0x000000620000</span><span class="number">-0x000000E1FFFF</span> : <span class="string">&quot;kernel&quot;</span></span><br><span class="line"><span class="number">0x000000E20000</span><span class="number">-0x000020000000</span> : <span class="string">&quot;rootfs&quot;</span></span><br></pre></td></tr></table></figure>

<p>一共有六个分区，第一个分区存放 uboot，地址范围为<code> 0x0~0x3FFFFF(共 4MB)</code>；第二个分区存放 env（环境变量），地址范围为 <code>0x400000~0x420000(共 128KB)</code>；第三个分区存放 logo(启动图标)，地址范围为<code> 0x420000~0x51FFFF(共 1MB)</code>；第四个分区存放 dtb(设备树)，地址范围为<code>0x520000~0x61FFFF(共 1MB)</code>；第五个分区存放 kernel(也就是 linux kernel)，地址范围为<code>0x620000~0xE1FFFF(共 8MB)</code>；剩下的所有存储空间全部作为最后一个分区，存放 rootfs(根文件系统)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x87800000</span> zImage <span class="comment">//下载 zImage 到 DRAM 中</span></span><br><span class="line">nand erase <span class="number">0x620000</span> <span class="number">0x800000</span> <span class="comment">//从地址 0x620000 开始擦除 8MB 的空间</span></span><br><span class="line">nand write <span class="number">0x87800000</span> <span class="number">0x620000</span> <span class="number">0x800000</span> <span class="comment">//将接收到的 zImage 写到 NAND 中</span></span><br></pre></td></tr></table></figure>

<p>这里我们擦除了 8MB 的空间，因为一般 zImage 就是 6,7MB 左右，8MB 肯定够了，如果不够的话就再多擦除一点就行了。同理烧录dtb:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x87800000</span> imx6ull<span class="number">-14</span>x14-emmc<span class="number">-7</span><span class="number">-1024</span>x600-c.dtb <span class="comment">//下载 dtb 到 DRAM 中</span></span><br><span class="line">nand erase <span class="number">0x520000</span> <span class="number">0x100000</span> <span class="comment">//从地址 0x520000 开始擦除 1MB 的空间</span></span><br><span class="line">nand write <span class="number">0x87800000</span> <span class="number">0x520000</span> <span class="number">0x100000</span> <span class="comment">//将接收到的 dtb 写到 NAND 中</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-9-4-nand-read">1.9.4 nand read</span><a href="#1-9-4-nand-read" class="header-anchor">#</a></h3><pre><code>nand read addr off size
</code></pre>
<p>从 NAND 中的指定地址读取指定大小的数据到 DRAM.<br>addr 是目的地址，off 是要读取的 NAND 中的数据源地址，size 是要读取的数据大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand read <span class="number">0x83000000</span> <span class="number">0x520000</span> <span class="number">0x19000</span>  <span class="comment">//读取设备树(dtb)文件到 0x83000000 地址处</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/51.png" alt="image"></p>
<h2><span id="1-10-she-bei-shu-xiang-guan">1.10 设备树相关</span><a href="#1-10-she-bei-shu-xiang-guan" class="header-anchor">#</a></h2><h3><span id="1-10-1-fdt-addr">1.10.1 fdt addr</span><a href="#1-10-1-fdt-addr" class="header-anchor">#</a></h3><p>设置设备树起始地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand read <span class="number">0x83000000</span> <span class="number">0x520000</span> <span class="number">0x19000</span> <span class="comment">//比如把nand中dtb分区数据读到dram</span></span><br><span class="line">fdt addr <span class="number">83000000</span>	<span class="comment">//设置好设备树起始地址</span></span><br></pre></td></tr></table></figure>
<h3><span id="1-10-2-fdt-header">1.10.2 fdt header</span><a href="#1-10-2-fdt-header" class="header-anchor">#</a></h3><p>查看设备树头部信息：</p>
<pre><code>fdt header
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/52.png" alt="image"></p>
<h3><span id="1-10-3-fdt-print">1.10.3 fdt print</span><a href="#1-10-3-fdt-print" class="header-anchor">#</a></h3><p>解析出dts内容：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/53.png" alt="image"></p>
<h2><span id="1-11-qi-dong-xiang-guan">1.11 启动相关</span><a href="#1-11-qi-dong-xiang-guan" class="header-anchor">#</a></h2><h3><span id="1-11-1-bootz-qi-dong-zimage">1.11.1 bootz (启动zImage)</span><a href="#1-11-1-bootz-qi-dong-zimage" class="header-anchor">#</a></h3><pre><code>bootz [addr [initrd[:size]] [fdt]]
</code></pre>
<p>addr 是 Linux 镜像文件在 DRAM 中的位置，initrd 是 initrd 文件在DRAM 中的地址，如果不使用 initrd 的话使用‘-’代替即可，fdt 就是设备树文件在 DRAM 中的地址.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">80800000</span> zImage</span><br><span class="line">tftp <span class="number">83000000</span> imx6ull<span class="number">-14</span>x14-emmc<span class="number">-7</span><span class="number">-1024</span>x600-c.dtb</span><br><span class="line">bootz <span class="number">80800000</span> - <span class="number">83000000</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/54.png" alt="image"><br>换一张启动方式：从mmc1也就是emmc启动：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">80800000</span> zImage</span><br><span class="line">fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">83000000</span> imx6ull<span class="number">-14</span>x14-emmc<span class="number">-7</span><span class="number">-1024</span>x600-c.dtb</span><br><span class="line">bootz <span class="number">80800000</span> - <span class="number">83000000</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/55.png" alt="image"></p>
<h3><span id="1-11-1-bootm-qi-dong-uimage">1.11.1 bootm (启动uImage)</span><a href="#1-11-1-bootm-qi-dong-uimage" class="header-anchor">#</a></h3><pre><code>bootm [addr [initrd[:size]] [fdt]]
</code></pre>
<p>bootm 命令和 bootz 类似，它是启动 uImage 镜像。uImage是U-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的“头”，说明这个映像文件的类型、加载位置、生成时间、大小等信息。<br>bootm如果不需要启动设备树：</p>
<pre><code>bootm addr
</code></pre>
<h3><span id="1-11-3-boot">1.11.3 boot</span><a href="#1-11-3-boot" class="header-anchor">#</a></h3><p>boot 会读取环境变量 bootcmd 来启动 Linux 系统：<br>比如设置bootcmd如下，从网络启动linux：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setenv bootcmd <span class="string">&#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/56.png" alt="image"></p>
<p>同理，如果想从emmc启动linux,设置bootcmd如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setenv bootcmd <span class="string">&#x27;fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">savenev</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/57.png" alt="image"></p>
<h3><span id="1-11-4-go-ming-ling">1.11.4 go命令</span><a href="#1-11-4-go-ming-ling" class="header-anchor">#</a></h3><pre><code>go addr
</code></pre>
<p>跳到指定的地址处执行, addr表示DRAM地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">87800000</span> <span class="built_in">printf</span>.bin	<span class="comment">//一个裸机程序，打印输入的按键，将两个整数相加</span></span><br><span class="line">go <span class="number">87800000</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/58.png" alt="image"></p>
<h3><span id="1-11-5-run">1.11.5 run</span><a href="#1-11-5-run" class="header-anchor">#</a></h3><p>run 命令用于运行环境变量中定义的命令，比如可以通过<code>run bootcmd</code>来运行 bootcmd 中的启动命令:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setenv mybootemmc <span class="string">&#x27;fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb;bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">setenv mybootnand <span class="string">&#x27;nand read 80800000 4000000 800000;nand read 83000000 6000000 100000;bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">setenv mybootnet <span class="string">&#x27;tftp 80800000 zImage; tftp 83000000imx6ull-14x14-emmc-7-1024x600-c.dtb;</span></span><br><span class="line"><span class="string">bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>

<p>设置了3个环境变量，可以<code>run mybootemmc或者run mybootnand或者run mybootnet</code>来分别从emmc启动，从nand启动，从网络启动。</p>
<h2><span id="1-12-nei-cun-ce-shi-mtest">1.12 内存测试mtest</span><a href="#1-12-nei-cun-ce-shi-mtest" class="header-anchor">#</a></h2><pre><code>mtest [start [end [pattern [iterations]]]]
</code></pre>
<p>start 是要测试的 DRAM 开始地址，end 是结束地址，比如我们测试<code> 0X80000000~0X80001000</code>这段内存，输入<code>mtest 80000000 80001000</code><br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/59.png" alt="image"><br> 可以看出，测试范围为<code> 0X80000000~0X80001000</code>，已经测试了 486 次，如果要结束测试就按下键盘上的“Ctrl+C”键。</p>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-编译defconfig分析</title>
    <url>/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-ban-ben-hao">1 版本号</a></li>
<li><a href="#2-makeflags">2 <code>MAKEFLAGS</code></a></li>
<li><a href="#3-she-zhi-ming-ling-shu-chu-xiang-xi-cheng-du">3 设置命令输出详细程度</a></li>
<li><a href="#4-she-zhi-bian-yi-jie-guo-shu-chu-wei-zhi">4 设置编译结果输出位置</a></li>
<li><a href="#5-dai-ma-jian-cha">5 代码检查</a></li>
<li><a href="#6-zi-mo-kuai-bian-yi">6 子模块编译</a></li>
<li><a href="#7-huo-qu-zhu-ji-jia-gou-xi-tong-xin-xi">7 获取主机架构系统信息</a></li>
<li><a href="#8-she-zhi-mu-biao-jia-gou-gong-ju-lian-he-pei-zhi-wen-jian">8 设置目标架构、工具链和配置文件</a></li>
<li><a href="#9-diao-yong-scripts-kbuild-include">9 调用 <code>scripts/Kbuild.include</code></a><ul>
<li><a href="#9-1-build-bian-liang">9.1 <code>build变量</code></a><ul>
<li><a href="#9-1-1-diao-yong-scripts-makefile-build">9.1.1 调用scripts&#x2F;Makefile.build</a></li>
</ul>
</li>
<li><a href="#9-2-filechk-bian-liang">9.2 <code>filechk</code>变量</a></li>
<li><a href="#9-3-if-changed-bian-liang">9.3 if_changed变量</a></li>
<li><a href="#9-4-scripts-makefile-lib-wen-jian-zuo-yong">9.4 <code>scripts/Makefile.lib</code>文件作用</a><ul>
<li><a href="#9-4-1-ding-yi-bian-yi-xuan-xiang">9.4.1 定义编译选项</a></li>
<li><a href="#9-4-2-qu-chong">9.4.2 去重</a></li>
<li><a href="#9-4-3-modules-order">9.4.3 <code>modules.order</code></a></li>
<li><a href="#9-4-4-mu-lu-de-chu-li">9.4.4 目录的处理</a></li>
<li><a href="#9-4-5-she-bei-shu-xiang-guan">9.4.5 设备树相关</a></li>
<li><a href="#9-4-6-tian-jia-lu-jing">9.4.6 添加路径</a></li>
</ul>
</li>
<li><a href="#9-5-scripts-makefile-build-wen-jian-zuo-yong">9.5 <code>scripts/Makefile.build</code>文件作用</a><ul>
<li><a href="#9-5-1-bao-han-include-config-auto-conf">9.5.1 包含<code> include/config/auto.conf</code></a></li>
<li><a href="#9-5-2-bao-han-scripts-kbuild-include">9.5.2 包含<code> scripts/Kbuild.include</code></a></li>
<li><a href="#9-5-3-chu-li-bian-yi-mu-biao">9.5.3 处理编译目标</a></li>
<li><a href="#9-5-4-mo-ren-bian-yi-mu-biao-build">9.5.4 默认编译目标<code>_build</code></a><ul>
<li><a href="#9-5-4-1-builtin-target">9.5.4.1<code>builtin-target</code></a></li>
<li><a href="#9-5-4-2-lib-target">9.5.4.2 <code>lib-target</code></a></li>
<li><a href="#9-5-4-3-extra-y">9.5.4.3 <code>extra-y</code></a></li>
<li><a href="#9-5-4-4-obj-m">9.5.4.4 <code>obj-m</code></a></li>
<li><a href="#9-5-4-5-modorder-target">9.5.4.5 modorder-target</a></li>
<li><a href="#9-5-4-6-subdir-ym">9.5.4.6 subdir-ym</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#10-she-zhi-jiao-cha-bian-yi-qi">10 设置交叉编译器</a></li>
<li><a href="#11-he-xin-bian-liang-dao-chu">11 核心变量导出</a></li>
<li><a href="#12-make-xxx-defconfig-pei-zhi-guo-cheng">12 <code>make xxx_defconfig</code> 配置过程</a><ul>
<li><a href="#12-1-chan-sheng-ban-ben-ri-qi-xin-xi">12.1 产生版本日期信息</a></li>
<li><a href="#12-2-pei-zhi-bian-liang">12.2 配置变量</a></li>
<li><a href="#12-3-zhi-xing-3-ge-yi-lai">12.3 执行3个依赖</a><ul>
<li><a href="#12-3-1-scripts-basic">12.3.1 <code>scripts_basic</code></a><ul>
<li><a href="#12-3-1-1-scripts-makefile-build">12.3.1.1 <code>scripts/Makefile.build</code></a><ul>
<li><a href="#12-3-1-1-1-zhao-dao-mo-ren-mu-biao-build">12.3.1.1.1 找到默认目标<code>_build</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-3-2-outputmakefile">12.3.2 <code>outputmakefile</code></a></li>
<li><a href="#12-3-3-force">12.3.3 <code>FORCE</code></a></li>
</ul>
</li>
<li><a href="#12-4-chan-sheng-config">12.4 产生<code>.config</code></a></li>
<li><a href="#12-5-zhi-zuo-defconfig">12.5 制作<code>defconfig</code></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="1-ban-ben-hao">1 版本号</span><a href="#1-ban-ben-hao" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/1.png" alt="image"><br>Top Makefile的开头会有版本描述，<code>VERSION </code>是主版本号，<code>PATCHLEVEL </code>是补丁版本号，<code>SUBLEVEL </code>是次版本号，这三个一 起构成了 uboot 的版本号，比如当前的 uboot 版本号就是<code>2016.03</code>。<code>EXTRAVERSION </code>是附加 版本信息，NAME 是和名字有关的，一般不使用这两个。</p>
<h2><span id="2-makeflags">2 <code>MAKEFLAGS</code></span><a href="#2-makeflags" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/2.png" alt="image"><br>有两个特殊的变量：<code>SHELL</code>和<code>MAKEFLAGS</code>，这两个变量除非使用<code>unexport</code>声明， 否则的话在整个make的执行过程中，它们的值始终自动的传递给子make。<br><code>MAKEFLAGS</code> 追加了一些值，<code>-rR</code>表示禁止使用内置的隐 含规则和变量定义，<code>--include-dir</code>指明搜索路径，<code>$(CURDIR)</code>表示当前目录。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/3.png" alt="image"></p>
<h2><span id="3-she-zhi-ming-ling-shu-chu-xiang-xi-cheng-du">3 设置命令输出详细程度</span><a href="#3-she-zhi-ming-ling-shu-chu-xiang-xi-cheng-du" class="header-anchor">#</a></h2><p>①uboot 默认编译使用短命令。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/4.png" alt="image"><br>②设置变量<code>V=1</code>来实现完整的命令输出。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/5.png" alt="image"><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/6.png" alt="image"><br>③<code>make -s</code>设置成静默输出，将会<code>silent_输出</code>,不打印任何提示信息。如下：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/7.png" alt="image"><br><code>MAKE_VERSION</code>就是make版本号，我这里是<code>4.2.1</code>。因此<code>filter 4.%,$(MAKE_VERSION)</code>得到的过滤结果不为空。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/8.png" alt="image"></p>
<p>当使用<code>make -s</code>编译的时候，<code>-s</code>会作为 <code>MAKEFLAGS </code>变量的一部分传递给 Makefile。因此<code>$(firstword x$(MAKEFLAGS))得到xrRs</code>，最后<code>quiet=silent</code>_,否则不使用<code>silent_</code>输出。最后使用 <code>export 导出变量 quiet、Q 和 KBUILD_VERBOSE</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/9.png" alt="image"><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/10.png" alt="image"></p>
<h2><span id="4-she-zhi-bian-yi-jie-guo-shu-chu-wei-zhi">4 设置编译结果输出位置</span><a href="#4-she-zhi-bian-yi-jie-guo-shu-chu-wei-zhi" class="header-anchor">#</a></h2><p>在 make 的时候使用<code>O</code>来指定 输出目录，这么做是为了将源文件 和编译产生的文件分开，当然也可以不指定 O 参数，不指定的话源文件和编译产生的文件都在 同一个目录内。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/11.png" alt="image"><br>判断<code>O</code>是否来自于命令行，如果来自命令行的话，<code>KBUILD_OUTPUT 就为$(O)</code>，也就是输出目录。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/12.png" alt="image"><br>一开始判断<code>KBUILD_OUTPUT </code>是否为空。 如果指定了输出目录就调用 <code>mkdir </code>命令创建目录。</p>
<h2><span id="5-dai-ma-jian-cha">5 代码检查</span><a href="#5-dai-ma-jian-cha" class="header-anchor">#</a></h2><p>命令<code>make C=1</code>使能代码检查，检查那些需要重新编译的文 件。<code>make C=2</code>用于检查所有的源码文件。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/13.png" alt="image"></p>
<h2><span id="6-zi-mo-kuai-bian-yi">6 子模块编译</span><a href="#6-zi-mo-kuai-bian-yi" class="header-anchor">#</a></h2><p>使用命令<code>make M=dir</code>即可，旧语法<code>make SUBDIRS=dir</code>也是支持的。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/14.png" alt="image"><br>如果定 义 了 SUBDIRS或者M,那么<code>KBUILD_EXTMOD</code>就会被赋值。然后进入目标<code>_all 依赖 modules</code>，要先编译出<code> modules</code>，也就是编译模块。<br>否则<code>KBUILD_EXTMOD</code>为空，进入<code>all</code>编译。<br>判断<code>KBUILD_SRC</code>是否为空，如果为空的话就设置变量<code>srctree</code>为当前目录，否则<code>srctree</code>就是<code>KBUILD_SRC</code>。一般不设置 <code>KBUILD_SRC</code>。<br>设置变量<code>src</code>和<code> obj</code>，都为当前目录，设置<code>VPATH</code>，导出量<code> scrtree、objtree 和 VPATH</code>。</p>
<h2><span id="7-huo-qu-zhu-ji-jia-gou-xi-tong-xin-xi">7 获取主机架构系统信息</span><a href="#7-huo-qu-zhu-ji-jia-gou-xi-tong-xin-xi" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/15.png" alt="image"><br>最终开发服务器主机架构和操作系统信息如下:<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/16.png" alt="image"></p>
<h2><span id="8-she-zhi-mu-biao-jia-gou-gong-ju-lian-he-pei-zhi-wen-jian">8 设置目标架构、工具链和配置文件</span><a href="#8-she-zhi-mu-biao-jia-gou-gong-ju-lian-he-pei-zhi-wen-jian" class="header-anchor">#</a></h2><p><code>HOSTARCH是x86_64</code>,我们编译<code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-</code>就是用于设置目标<code> ARCH 和 CROSS_COMPILE</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/17.png" alt="image"><br><code>KCONFIG_CONFIG</code>，这里设置配置文件为<code>.config，.config </code>默认是没有的，需要使用命令<code>make xxx_defconfig</code> 对 uboot 进行配置，配置完成以后就会在 uboot 根目录下生成<code>.config</code>。<br>设置主机编译器<code>HOSTCC，HOSTCXX</code>等。</p>
<h2><span id="9-diao-yong-scripts-kbuild-include">9 调用 <code>scripts/Kbuild.include</code></span><a href="#9-diao-yong-scripts-kbuild-include" class="header-anchor">#</a></h2><p>在整个<code>Kbuild</code>系统中，<code>scripts/Kbuild.include </code>提供了大量通用函数以及变量的定义，这些定义将被 <code>Makefile.build 、Makefile.lib 和 top Makefile</code>频繁调用，以实现相应的功能,<code>scripts/Kbuild.include </code>参与整个内核编译的过程，是编译的核心脚本之一。</p>
<p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/18.png" alt="image"><br><code>Kbuild.include</code>定义了很多变量:<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/19.png" alt="image"><br>里面定了build变量，后面产生配置文件时会用到：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/20.png" alt="image"></p>
<h3><span id="9-1-build-bian-liang">9.1 <code>build变量</code></span><a href="#9-1-build-bian-liang" class="header-anchor">#</a></h3><p><code>build := -f $(srctree)/scripts/Makefile.build obj</code></p>
<p>例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/kconfig <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>当我们执行<code>make menuconfig</code>时:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">menuconfig: scripts_basic outputmakefile FORCE</span></span><br><span class="line">    make -f <span class="variable">$(srctree)</span>/scripts/Makefile.build obj=scripts/kconfig menuconfig</span><br></pre></td></tr></table></figure>

<h4><span id="9-1-1-diao-yong-scripts-x2f-makefile-build">9.1.1 调用scripts&#x2F;Makefile.build</span><a href="#9-1-1-diao-yong-scripts-x2f-makefile-build" class="header-anchor">#</a></h4><p>参见后面<code>12.3.1.1节</code>再详细介绍。</p>
<p>与<code>build变量</code>相类似的，还有以下的编译指令:</p>
<p><code>$(modbuiltin)</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">modbuiltin := -f <span class="variable">$(srctree)</span>/scripts/Makefile.modbuiltin obj</span><br></pre></td></tr></table></figure>

<p><code>$(dtbinst)</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dtbinst := -f <span class="variable">$(srctree)</span>/scripts/Makefile.dtbinst obj</span><br></pre></td></tr></table></figure>

<p><code>$(clean)</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">clean := -f <span class="variable">$(srctree)</span>/scripts/Makefile.clean obj</span><br></pre></td></tr></table></figure>

<p><code>$(hdr-inst)</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">hdr-inst := -f <span class="variable">$(srctree)</span>/scripts/Makefile.headersinst obj</span><br></pre></td></tr></table></figure>

<p>这四条指令，分别对应 <code>內建模块编译</code>、<code>dtb文件安装</code>、<code>目标清除</code>和<code>头文件安装</code>.</p>
<p>9.2 </p>
<h3><span id="9-2-filechk-bian-liang">9.2 <code>filechk</code>变量</span><a href="#9-2-filechk-bian-liang" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> filechk</span><br><span class="line">    <span class="variable">$(Q)</span>set -e;             \</span><br><span class="line">    mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>;         \</span><br><span class="line">    &#123; $(filechk_$(1)); &#125; &gt; <span class="variable">$@</span>.tmp;      \</span><br><span class="line">    if [ -r <span class="variable">$@</span> ] &amp;&amp; cmp -s <span class="variable">$@</span> <span class="variable">$@</span>.tmp; then  \</span><br><span class="line">        rm -f <span class="variable">$@</span>.tmp;           \</span><br><span class="line">    <span class="keyword">else</span>                    \</span><br><span class="line">        <span class="variable">$(kecho)</span> &#x27;  UPD     <span class="variable">$@</span>&#x27;;    \</span><br><span class="line">        mv -f <span class="variable">$@</span>.tmp <span class="variable">$@</span>;        \</span><br><span class="line">    fi</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>mkdir -p $(dir $@)</code>：如果<code>$@</code>目录不存在，就创建目录，<code>$@</code>是编译规则中的目标部分。($@ 在 Makefile 表目标文件)</li>
<li>执行<code>filechk_$(1)</code>,然后将执行结果保存到 <code>$@.tmp</code>中</li>
<li>对比<code>$@.tmp</code>和<code>$@</code>是否有更新，有更新就使用 <code>$@.tmp</code>，否则删除<code> $@.tmp</code>。</li>
</ol>
<h3><span id="9-3-if-changed-bian-liang">9.3 if_changed变量</span><a href="#9-3-if-changed-bian-liang" class="header-anchor">#</a></h3><p>下一节有详细解析介绍：</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17901135.html">uboot顶层makefile-2编译过程 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/#1-2-2-if-changed-jie-shi">uboot-编译过程Make分析 | Hexo (fuzidage.github.io)</a></p>
<h3><span id="9-4-scripts-makefile-lib-wen-jian-zuo-yong">9.4 <code>scripts/Makefile.lib</code>文件作用</span><a href="#9-4-scripts-makefile-lib-wen-jian-zuo-yong" class="header-anchor">#</a></h3><h4><span id="9-4-1-ding-yi-bian-yi-xuan-xiang">9.4.1 定义编译选项</span><a href="#9-4-1-ding-yi-bian-yi-xuan-xiang" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">asflags-y  += <span class="variable">$(EXTRA_AFLAGS)</span></span><br><span class="line">ccflags-y  += <span class="variable">$(EXTRA_CFLAGS)</span></span><br><span class="line">cppflags-y += <span class="variable">$(EXTRA_CPPFLAGS)</span></span><br><span class="line">ldflags-y  += <span class="variable">$(EXTRA_LDFLAGS)</span></span><br><span class="line"></span><br><span class="line">KBUILD_AFLAGS += $(subdir-asflags-y)</span><br><span class="line">KBUILD_CFLAGS += $(subdir-ccflags-y</span><br></pre></td></tr></table></figure>

<h4><span id="9-4-2-qu-chong">9.4.2 去重</span><a href="#9-4-2-qu-chong" class="header-anchor">#</a></h4><p>如果某个模块已经被定义在obj-y中，就没必要再编译了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去除obj-m中已经定义在obj-y中的部分</span></span><br><span class="line">obj-m := <span class="variable">$(<span class="built_in">filter</span>-out $(obj-y)</span>,$(obj-m))</span><br><span class="line"><span class="comment"># 去除lib-y中已经定义在obj-y中的部分</span></span><br><span class="line">lib-y := <span class="variable">$(<span class="built_in">filter</span>-out $(obj-y)</span>, <span class="variable">$(<span class="built_in">sort</span> $(lib-y)</span> $(lib-m)))</span><br></pre></td></tr></table></figure>

<h4><span id="9-4-3-modules-order">9.4.3 <code>modules.order</code></span><a href="#9-4-3-modules-order" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将obj-y中的目录 dir 修改为 dir/modules.order赋值给modorder，</span></span><br><span class="line"><span class="comment">#将obj-m中的.o修改为.ko赋值给modorder。 </span></span><br><span class="line">modorder    := <span class="variable">$(<span class="built_in">patsubst</span> %/,%/modules.order,\</span></span><br><span class="line"><span class="variable">                 $(<span class="built_in">filter</span> %/, $(obj-y)</span>) $(obj-m:.o=.ko))</span><br></pre></td></tr></table></figure>

<p>内核将编译的外部模块全部记录在<code> modules.order</code> 文件中，以便 <code>modprobe </code>命令在加载卸载时查询使用。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">kernel/drivers/input/mouse/psmouse.ko</span><br><span class="line">kernel/drivers/input/misc/100ask_adxl345-spi.ko</span><br><span class="line">kernel/drivers/input/evbug.ko</span><br></pre></td></tr></table></figure>

<h4><span id="9-4-4-mu-lu-de-chu-li">9.4.4 目录的处理</span><a href="#9-4-4-mu-lu-de-chu-li" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#挑选出obj-y 和 obj-m 中的纯目录部分，然后添加到subdir-y和subdir-m中。  </span></span><br><span class="line">__subdir-y  := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-y)</span>))</span><br><span class="line">subdir-y    += $(__subdir-y)</span><br><span class="line"></span><br><span class="line">__subdir-m  := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-m)</span>))</span><br><span class="line">subdir-m    += $(__subdir-m)</span><br><span class="line"></span><br><span class="line"><span class="comment">#需要被递归搜寻的子路径，带有可编译内部和外部模块的子目录。  </span></span><br><span class="line">subdir-ym   := <span class="variable">$(<span class="built_in">sort</span> $(subdir-y)</span> $(subdir-m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#obj-y 中纯目录部分则将其改名为dir/build-in.a,obj-y的其他部分则不变。  </span></span><br><span class="line">obj-y       := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.a, $(obj-y)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将obj-m中的纯目录部分剔除掉(因为已经在上面加入到subdir-m中了)。</span></span><br><span class="line">obj-m       := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-m)</span>)</span><br></pre></td></tr></table></figure>

<p>   <code>obj-y 和 obj-m </code>的定义中同时夹杂着目标文件和目标文件夹，文件夹当然是不能直接参与编译的，所以需要将文件夹提取出来。</p>
<p>将 <code>obj-y or obj-m</code>中以<code>&quot;/&quot;</code>结尾的纯目录部分提取出来，并赋值给 <code>subdir-ym</code>.</p>
<h4><span id="9-4-5-she-bei-shu-xiang-guan">9.4.5 设备树相关</span><a href="#9-4-5-she-bei-shu-xiang-guan" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">extra-y             += $(dtb-y)</span><br><span class="line">extra-<span class="variable">$(CONFIG_OF_ALL_DTBS)</span> += $(dtb-)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(CHECK_DTBS)</span>,)</span><br><span class="line">extra-y += <span class="variable">$(<span class="built_in">patsubst</span> %.dtb,%.dt.yaml, $(dtb-y)</span>)</span><br><span class="line">extra-<span class="variable">$(CONFIG_OF_ALL_DTBS)</span> += <span class="variable">$(<span class="built_in">patsubst</span> %.dtb,%.dt.yaml, $(dtb-)</span>)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>将所有的<code>dtb-y</code>赋值给<code>extra-y</code>。</p>
<h4><span id="9-4-6-tian-jia-lu-jing">9.4.6 添加路径</span><a href="#9-4-6-tian-jia-lu-jing" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">extra-y     := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(extra-y)</span>)</span><br><span class="line">always      := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,<span class="variable">$(always)</span>)</span></span><br><span class="line">targets     := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,<span class="variable">$(targets)</span>)</span></span><br><span class="line">modorder    := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,<span class="variable">$(modorder)</span>)</span></span><br><span class="line">obj-m       := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(obj-m)</span>)</span><br><span class="line">lib-y       := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(lib-y)</span>)</span><br><span class="line">subdir-obj-y    := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(subdir-obj-y)</span>)</span><br><span class="line">real-obj-y  := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(real-obj-y)</span>)</span><br><span class="line">real-obj-m  := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(real-obj-m)</span>)</span><br><span class="line">single-used-m   := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(single-used-m)</span>)</span><br><span class="line">multi-used-m    := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(multi-used-m)</span>)</span><br><span class="line">subdir-ym   := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(subdir-ym)</span>)</span><br></pre></td></tr></table></figure>

<p>文件的处理最后，给所有的变量加上相应的路径，以便编译的时候进行索引。</p>
<p><code>Makefile.lib </code>通常都被包含在于<code> Makefile.build</code>中，这个变量继承了<code>Makefile.build</code>的 <code>obj </code>变量。而 <code>Makefile.build </code>的<code>obj</code>变量则是通过调用 <code>$(build) </code>时进行赋值的。</p>
<h3><span id="9-5-scripts-makefile-build-wen-jian-zuo-yong">9.5 <code>scripts/Makefile.build</code>文件作用</span><a href="#9-5-scripts-makefile-build-wen-jian-zuo-yong" class="header-anchor">#</a></h3><h4><span id="9-5-1-bao-han-include-config-auto-conf">9.5.1 包含<code> include/config/auto.conf</code></span><a href="#9-5-1-bao-han-include-config-auto-conf" class="header-anchor">#</a></h4><p>包含<code>include/config/auto.conf</code>文件，这个文件的内容是这样的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CONFIG_RING_BUFFER=y</span><br><span class="line">CONFIG_HAVE_ARCH_SECCOMP_FILTER=y</span><br><span class="line">CONFIG_SND_PROC_FS=y</span><br><span class="line">CONFIG_SCSI_DMA=y</span><br><span class="line">CONFIG_TCP_MD5SIG=y</span><br><span class="line">CONFIG_KERNEL_GZIP=y</span><br></pre></td></tr></table></figure>

<h4><span id="9-5-2-bao-han-scripts-kbuild-include">9.5.2 包含<code> scripts/Kbuild.include</code></span><a href="#9-5-2-bao-han-scripts-kbuild-include" class="header-anchor">#</a></h4><h4><span id="9-5-3-chu-li-bian-yi-mu-biao">9.5.3 处理编译目标</span><a href="#9-5-3-chu-li-bian-yi-mu-biao" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主机程序，在前期的准备过程中可能需要用到，比如make menuconfig时需要准备命令行的图形配置。</span></span><br><span class="line"><span class="keyword">ifneq</span> ($(hostprogs-y)$(hostprogs-m)$(hostlibs-y)$(hostlibs-m)$(hostcxxlibs-y)$(hostcxxlibs-m),)</span><br><span class="line"><span class="keyword">include</span> scripts/Makefile.host</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断obj，如果obj没有指定则给出警告 </span></span><br><span class="line"><span class="keyword">ifndef</span> obj</span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> kbuild: Makefile.build is included improperly)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果有编译库的需求，则给lib-target赋值，并将 $(obj)/lib-ksyms.o 追加到 real-obj-y 中。 </span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> $(lib-y)</span> $(lib-m) $(lib-)),)</span><br><span class="line">lib-target := <span class="variable">$(obj)</span>/lib.a</span><br><span class="line">real-obj-y += <span class="variable">$(obj)</span>/lib-ksyms.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要编译 将要编译进内核(也就是obj-y指定的文件) 的模块，则赋值 builtin-target </span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> $(real-obj-y)</span> $(need-builtin)),)</span><br><span class="line">builtin-target := <span class="variable">$(obj)</span>/built-in.a</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果定义了 CONFIG_MODULES，则赋值 modorder-target。</span></span><br><span class="line"><span class="keyword">ifdef</span> CONFIG_MODULES</span><br><span class="line">modorder-target := <span class="variable">$(obj)</span>/modules.order</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p><code>modorder-target</code>将被赋值为<code>$(obj)/modules.order</code>，<code> module.order</code>这个文件记录了可加载模块在<code>Makefile</code>中出现的顺序，主要是提供给modprobe程序在匹配时使用。</p>
<h4><span id="9-5-4-mo-ren-bian-yi-mu-biao-build">9.5.4 默认编译目标<code>_build</code></span><a href="#9-5-4-mo-ren-bian-yi-mu-biao-build" class="header-anchor">#</a></h4><p>例子见<code>12.3.1.1.1</code>。</p>
<h5><span id="9-5-4-1builtin-target">9.5.4.1<code>builtin-target</code></span><a href="#9-5-4-1builtin-target" class="header-anchor">#</a></h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(builtin-target): $(real-obj-y) FORCE</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed,ar_builtin)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">real-prereqs = <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span>, <span class="variable">$^</span>)</span></span><br><span class="line">cmd_ar_builtin = rm -f <span class="variable">$@</span>; <span class="variable">$(AR)</span> rcSTP<span class="variable">$(KBUILD_ARFLAGS)</span> <span class="variable">$@</span> $(real-prereqs)</span><br></pre></td></tr></table></figure>

<p><code>ar_builtin</code>就是执行<code>cmd_ar_builtin</code>, 就是使用<code>ar</code>指令打包成<code> $(builtin-target)</code>,也就是<code>$(obj)/built-in.a</code>。它的依赖文件被保存在 <code>$(real-obj-y) </code>中。</p>
<p><code>$(real-obj-y) </code>在<code>scritps/Makefile.lib</code>被处理出来的变量, 对应目录下的所有目标文件，不包含文件夹。</p>
<h5><span id="9-5-4-2-lib-target">9.5.4.2 <code>lib-target</code></span><a href="#9-5-4-2-lib-target" class="header-anchor">#</a></h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(lib-target): $(lib-y) FORCE</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed,ar)</span></span><br></pre></td></tr></table></figure>

<p>同理，最终将调用<code>cmd_ar</code>命令:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">real-prereqs = <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span>, <span class="variable">$^</span>)</span></span><br><span class="line">cmd_ar = rm -f <span class="variable">$@</span>; <span class="variable">$(AR)</span> rcsTP<span class="variable">$(KBUILD_ARFLAGS)</span> <span class="variable">$@</span> $(real-prereqs)</span><br></pre></td></tr></table></figure>

<p>将本模块中的目标全部打包成<code>$(lib-target)</code>,也就是 <code>$(obj)/lib.a</code></p>
<h5><span id="9-5-4-3-extra-y">9.5.4.3 <code>extra-y</code></span><a href="#9-5-4-3-extra-y" class="header-anchor">#</a></h5><p><code>$(extra-y) </code>在<code>Makefile.lib</code>中被确定，主要负责<code>dtb</code>相关的编译:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">extra-y             += $(dtb-y)</span><br><span class="line">extra-<span class="variable">$(CONFIG_OF_ALL_DTBS)</span> += $(dtb-)</span><br></pre></td></tr></table></figure>

<p><code>Makefile.lib</code> 中可以找到对应的实现:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>/%.dtb: <span class="variable">$(src)</span>/%.dts <span class="variable">$(DTC)</span> FORCE</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed_dep,dtc,dtb)</span></span><br></pre></td></tr></table></figure>

<p>调用了<code> cmd_dtc</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmd_dtc = mkdir -p <span class="variable">$(<span class="built_in">dir</span> $&#123;dtc-tmp&#125;)</span> ; \</span><br><span class="line">    <span class="variable">$(HOSTCC)</span> -E <span class="variable">$(dtc_cpp_flags)</span> -x assembler-with-cpp -o $(dtc-tmp) <span class="variable">$&lt;</span> ; \</span><br><span class="line"></span><br><span class="line">    <span class="variable">$(DTC)</span> -O $(2) -o <span class="variable">$@</span> -b 0 \</span><br><span class="line">        <span class="variable">$(<span class="built_in">addprefix</span> -i,$(<span class="built_in">dir</span> <span class="variable">$&lt;</span>)</span> <span class="variable">$(DTC_INCLUDE)</span>) <span class="variable">$(DTC_FLAGS)</span> \</span><br><span class="line">        -d <span class="variable">$(depfile)</span>.dtc.tmp $(dtc-tmp) ; \</span><br><span class="line"></span><br><span class="line">    cat <span class="variable">$(depfile)</span>.pre.tmp <span class="variable">$(depfile)</span>.dtc.tmp &gt; <span class="variable">$(depfile)</span></span><br></pre></td></tr></table></figure>

<p><code>$(2) </code>为 dtb，<code>-O dtb </code>表示输出文件格式为 dtb 。<code> -o $@</code>, <code>$@ </code>为目标文件，表示输出目标文件，输入文件则是对应的<code> $&lt;</code>。</p>
<h5><span id="9-5-4-4-obj-m">9.5.4.4 <code>obj-m</code></span><a href="#9-5-4-4-obj-m" class="header-anchor">#</a></h5><p>由于它是一系列的 .o 文件，所以它的编译是通过模式规则的匹配完成的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>/%.o: <span class="variable">$(src)</span>/%.c <span class="variable">$(recordmcount_source)</span> <span class="variable">$(objtool_dep)</span> FORCE</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,force_checksrc)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed_rule,cc_o_c)</span></span><br></pre></td></tr></table></figure>

<p>执行<code>rule_cc_o_c</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> rule_cc_o_c</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,checksrc)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd_and_fixdep,cc_o_c)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,gen_ksymdeps)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,checkdoc)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,objtool)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,modversions_c)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,record_mcount)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<p>cmd 函数其实就是执行 <code>cmd_$1</code>,那么也就是上述命令中分别执行 <code>cmd_checksrc,cmd_gen_ksymdeps</code>等等。</p>
<p>其中最重要的指令就是 ： <code>$(call cmd_and_fixdep,cc_o_c)</code>，它对目标文件执行了 <code>fixdep</code>，生成依赖文件，然后执行了<code> cmd_cc_o_c</code>, 这个命令就是真正的编译指令:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmd_cc_o_c = <span class="variable">$(CC)</span> <span class="variable">$(c_flags)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>

<h5><span id="9-5-4-5-modorder-target">9.5.4.5 modorder-target</span><a href="#9-5-4-5-modorder-target" class="header-anchor">#</a></h5><p><code>modorder-target值为</code> $(obj)&#x2F;modules.order<code>，也就是大多数目录下都存在这么一个 </code>modules.orders &#96;文件，来提供一个该目录下编译模块的列表。 </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(modorder-target): $(subdir-ym) FORCE</span></span><br><span class="line">    <span class="variable">$(Q)</span>(cat /dev/null; $(modorder-cmds)) &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">modorder-cmds =                     \</span><br><span class="line">    <span class="variable">$(<span class="built_in">foreach</span> m, <span class="variable">$(modorder)</span>,           \</span></span><br><span class="line"><span class="variable">        $(<span class="built_in">if</span> $(<span class="built_in">filter</span> %/modules.order, $m)</span>, \</span><br><span class="line">            cat $m;, echo kernel/$m;))</span><br></pre></td></tr></table></figure>

<p>该操作的目的就是将需要编译的<code>.ko</code>的模块以<code>kernel/$(dir)/*.ko</code>为名记录到 <code>obj-m </code>指定的目录下。</p>
<h5><span id="9-5-4-6-subdir-ym">9.5.4.6 subdir-ym</span><a href="#9-5-4-6-subdir-ym" class="header-anchor">#</a></h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(subdir-ym):</span></span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=<span class="variable">$@</span> need-builtin=<span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">findstring</span> <span class="variable">$@</span>,$(subdir-obj-y)</span>),1)</span><br></pre></td></tr></table></figure>

<p>这就是Kbuild递归遍历子目录编译的策略，对于每个需要递归进入编译的目录，都调用：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=<span class="variable">$@</span> need-builtin=<span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">findstring</span> <span class="variable">$@</span>,$(subdir-obj-y)</span>),1)</span><br></pre></td></tr></table></figure>

<h2><span id="10-she-zhi-jiao-cha-bian-yi-qi">10 设置交叉编译器</span><a href="#10-she-zhi-jiao-cha-bian-yi-qi" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/21.png" alt="image"></p>
<h2><span id="11-he-xin-bian-liang-dao-chu">11 核心变量导出</span><a href="#11-he-xin-bian-liang-dao-chu" class="header-anchor">#</a></h2><p>在顶层 Makefile 会导出很多变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION</span><br><span class="line"><span class="built_in">export</span> ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR</span><br><span class="line"><span class="built_in">export</span> CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC</span><br><span class="line"><span class="built_in">export</span> CPP AR NM LDR STRIP OBJCOPY OBJDUMP</span><br><span class="line"><span class="built_in">export</span> MAKE AWK PERL PYTHON</span><br><span class="line"><span class="built_in">export</span> HOSTCXX HOSTCXXFLAGS DTC CHECK CHECKFLAGS</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS</span><br><span class="line"><span class="built_in">export</span> KBUILD_CFLAGS KBUILD_AFLAGS</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/22.png" alt="image"><br>打印出export的这些变量：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/23.png" alt="image"><br>①这些变量来自<code>config.mk</code>，里面定义了<code>ARCH,CPU,BOARD,VENDOR,SOC，BOARDDIR</code>等变量。变 量 <code>ARCH </code>， 值 为 <code>$(CONFIG_SYS_ARCH:&quot;%&quot;=%)</code> ， 也 就 是 提 取<code> CONFIG_SYS_ARCH</code> 里面双引号“”之间的内容。比如 <code>CONFIG_SYS_ARCH=“arm”</code>的话， <code>ARCH=arm</code>。经过展开确定了<code>CPUDIR=arch/arm/cpu/armv7</code>。<br>②这里有一个<code>sinclude</code>指令，<code>sinclude 和 include </code>的功能类似，在 Makefile 中都是读取指定文件内容，这里读取 文件<code>$(srctree)/arch/$(ARCH)/config.mk </code>的内容。<code>sinclude </code>读取的文件如果不存在的话不会报错。<br>③依次包含<code>arch,cpu,soc，vendor,board</code>相关的<code>config.mk</code><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/24.png" alt="image"><br><code>.config</code>如下：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/25.png" alt="image"></p>
<h2><span id="12-make-xxx-defconfig-pei-zhi-guo-cheng">12 <code>make xxx_defconfig</code> 配置过程</span><a href="#12-make-xxx-defconfig-pei-zhi-guo-cheng" class="header-anchor">#</a></h2><p>输入命令进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/26.png" alt="image"></p>
<h3><span id="12-1-chan-sheng-ban-ben-ri-qi-xin-xi">12.1 产生版本日期信息</span><a href="#12-1-chan-sheng-ban-ben-ri-qi-xin-xi" class="header-anchor">#</a></h3><p>先产生<code>version_h和timestamp_h</code>。<code>version_h</code>记录uboot版本和编译器版本。<code>timestamp_h</code>记录uboot的日期时间戳信息。打开这两个头文件：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/27.png" alt="image"><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/28.png" alt="image"></p>
<h3><span id="12-2-pei-zhi-bian-liang">12.2 配置变量</span><a href="#12-2-pei-zhi-bian-liang" class="header-anchor">#</a></h3><p><code>MAKECMDGOALS </code>是 make 的一个环境变量，这个变量会保存你所指 定的终极目标列表，比如执行<code>make mx6ull_alientek_emmc_defconfig</code>，那么 <code>MAKECMDGOALS </code>就为 <code>mx6ull_alientek_emmc_defconfig</code>。<code>filter</code>函数将 <code>MAKECMDGOALS</code> 中符合<code>no-dot-config-targets</code>的部分过滤出来，可以看到为空，所以<code>dot-config</code>还是等于1.</p>
<p><code>KBUILD_EXTMOD</code>前面提到没有编译子模块，<code>KBUILD_EXTMOD</code>为空，进入，在判断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifneq ($(filter config %config,$(MAKECMDGOALS),)</span><br></pre></td></tr></table></figure>
<p>当<code>make mx6ull_alientek_emmc_defconfig</code>, 明显过滤出来不为空，因此<code>config-targets=1</code>.</p>
<p><code>words $(MAKECMDGOALS)</code>等于1，最后得到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config-targets = 1</span><br><span class="line">mixed-targets = 0</span><br><span class="line">dot-config = 1</span><br></pre></td></tr></table></figure>

<h3><span id="12-3-zhi-xing-3-ge-yi-lai">12.3 执行3个依赖</span><a href="#12-3-zhi-xing-3-ge-yi-lai" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/29.png" alt="image"><br><code>KBUILD_DEFCONFIG</code>等于<code>mx6ull_14x14_ddr512_emmc_defconfig</code>，<code> KBUILD_KCONFIG</code>等于空，导出。<br>匹配到<code>%config</code>， 执行<code>scripts_basic、outputmakefile 和 FORCE </code>3个依赖.<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/30.png" alt="image"></p>
<h4><span id="12-3-1-scripts-basic">12.3.1 <code>scripts_basic</code></span><a href="#12-3-1-scripts-basic" class="header-anchor">#</a></h4><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/31.png" alt="image"></p>
<p><code>scripts/Kbuild.include</code>定义了<code>build</code>变量。<code>$Q$(MAKE) $(build)=scripts/basic</code>展开<code>build</code>变量后得：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f ./scripts/Makefile.build obj=scripts/basic</span><br></pre></td></tr></table></figure>

<h5><span id="12-3-1-1-scripts-makefile-build">12.3.1.1 <code>scripts/Makefile.build</code></span><a href="#12-3-1-1-scripts-makefile-build" class="header-anchor">#</a></h5><p><code>scripts_basic </code>会调用文件<code>./scripts/Makefile.build</code>,打开这个文件：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/32.png" alt="image"></p>
<p>这里<code>$(obj)=scripts/basic, patsubst </code>是替换函数在<code>scripts/basic</code>中查找符合<code>tpl/%</code>的部分，然后将<code>tpl/</code>取消掉，但是 <code>scripts/basic</code>没有<code>tpl/</code>，所以<code> src= scripts/basic</code>。两个<code>ifeq ($(obj),$(src))</code>都满足条件，最终<code>prefix等于.</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/33.png" alt="image"><br><code>kbuild-dir </code>展开后为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">if</span> $(filter /%, scripts/basic), scripts/basic, ./scripts/basic)</span><br></pre></td></tr></table></figure>
<p>因为没有以<code>/</code>为开头的单词，所以<code>$(filter /%, scripts/basic)</code>的结果为空，<code>kbuilddir=./scripts/basic</code>。<br><code>kbuild-file </code>展开后为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">if</span> $(wildcard ./scripts/basic/Kbuild), ./scripts/basic/Kbuild, ./scripts/basic/Makefile)</span><br></pre></td></tr></table></figure>
<p><code>scrpts/basic </code>目录中没有<code>Kbuild</code>这个文件，所以<code> kbuild-file= ./scripts/basic/Makefile</code>.<br><code>scripts/Makefile.build</code>文件包含<code>/scripts/basic/Makefile</code></p>
<h6><span id="12-3-1-1-1-zhao-dao-mo-ren-mu-biao-build">12.3.1.1.1 找到默认目标<code>_build</code></span><a href="#12-3-1-1-1-zhao-dao-mo-ren-mu-biao-build" class="header-anchor">#</a></h6><p>再继续分析<code>scripts/Makefile.build</code>：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/34.png" alt="image"></p>
<p><code>__build </code>是默认目标，因为命令<code>@make -f ./scripts/Makefile.build obj=scripts/basic</code>没有指定目标，所以会使用到默认目标：<code>__build</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/35.png" alt="image"></p>
<p>顶层 Makefile 中，<code>KBUILD_BUILTIN 为 1</code>， <code>KBUILD_MODULES 为 0</code>，因此展开后目标<code>__build </code>为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__build:$(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always)</span><br><span class="line">@:</span><br></pre></td></tr></table></figure>
<p>直接打印出这5个目标：所以最终只有一个依赖<code>scripts/basic/fixdep</code>要执行，产生<code>fixdep</code>.<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/36.png" alt="image"></p>
<p>执行打印如下：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/37.png" alt="image"><br>至此第一个依赖<code>scripts_basic</code>就结束了。<br>总结：<code>scripts_basic</code>就是利用<code>scripts/Makefile.build</code>去找到<code>_build</code>目标，然后去<code>scripts/basic</code>目录编译出<code>fixdep</code>.</p>
<h4><span id="12-3-2-outputmakefile">12.3.2 <code>outputmakefile</code></span><a href="#12-3-2-outputmakefile" class="header-anchor">#</a></h4><p>由于<code>KBUILD_SRC</code>为空，不执行。否则会为源码路径创建<code>source</code>这个符号链接，执行<code>mkmakefile</code>。</p>
<h4><span id="12-3-3-force">12.3.3 <code>FORCE</code></span><a href="#12-3-3-force" class="header-anchor">#</a></h4><p>Makefile最底下定了<code>FORCE</code>目标，可以看到什么都不执行。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/38.png" alt="image"></p>
<p>FORCE的作用：</p>
<p>可以看到它也是一个目标，没有依赖文件且没有命令部分，由于它没有命令生成FORCE，所以每次都会被更新。</p>
<p>所以它的作用就是：FORCE作为依赖时，就导致依赖列表中每次都有FORCE依赖被更新，导致目标每次被重新编译生成。</p>
<h3><span id="12-4-chan-sheng-config">12.4 产生<code>.config</code></span><a href="#12-4-chan-sheng-config" class="header-anchor">#</a></h3><p>回到<code>%config </code>处：<br><code>$(Q)$(MAKE) $(build)=scripts/kconfig $@</code>展开后</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f ./scripts/Makefile.build obj=scripts/kconfig mx6ull_14x14_ddr512_emmc_defconfig</span><br></pre></td></tr></table></figure>

<p>再次进入<code>scripts/Makefile.build， 用echo</code>得到一些变量值:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kbuild-dir = ./scripts/kconfig</span><br><span class="line">kbuild-file = ./scripts/kconfig/Makefile</span><br><span class="line">include ./scripts/kconfig/Makefile</span><br></pre></td></tr></table></figure>
<p>打开<code>./scripts/kconfig/Makefile</code>：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/39.png" alt="image"><br><code>%_defconfig: $(obj)/conf</code>匹配到我们的<code>mx6ull_14x14_ddr512_emmc_defconfig</code>，先编译依赖<code>scripts/kconfig/conf</code>,编译生成<code>scripts/kconfig/conf</code>如下：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/40.png" alt="image"><br>最终利用<code>conf</code>工具从<code>configs</code>目录找到<code>mx6ull_14x14_ddr512_emmc_defconfig</code>，将配置写成<code>.config</code>文件。<br>总结<code>defconfig</code>配置过程：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/41.png" alt="image"></p>
<h3><span id="12-5-zhi-zuo-defconfig">12.5 制作<code>defconfig</code></span><a href="#12-5-zhi-zuo-defconfig" class="header-anchor">#</a></h3><p>如果没有对应的<code>defconfig</code>可以找一个与自己板级信息类似的defconfig生成一个<code>.config</code>，再通过<code>menuconfig</code>来完成自己board的配置，并最后通过<code>savedefconfig</code>保存为自己<code>board的defconfig</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make CROSS_COMPILE=aarch64-linux-gnu- evb-rk3399_defconfig</span><br><span class="line">make menuconfig</span><br><span class="line">make savedefconfig</span><br><span class="line">cp defconfig configs/my_defconfig</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-启动流程</title>
    <url>/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-reset-han-shu">1 reset 函数</a><ul>
<li><a href="#1-1-chu-shi-hua-yi-chang-xiang-liang-biao">1.1 初始化异常向量表</a></li>
<li><a href="#1-2-save-boot-params-ret">1.2 save_boot_params_ret</a><ul>
<li><a href="#1-2-1-guan-zhong-duan-jin-ru-svc-mo-shi">1.2.1 关中断，进入SVC模式</a></li>
<li><a href="#1-2-2-cp15-pei-zhi-she-zhi-zhong-duan-xiang-liang-biao-pian-yi-vbar">1.2.2 cp15配置，设置中断向量表偏移VBAR</a></li>
<li><a href="#1-2-3-cp15-pei-zhi-guan-mmu-icache">1.2.3 cp15配置，关<code>MMU，ICACHE</code></a></li>
</ul>
</li>
<li><a href="#1-3-lowlevel-init-dui-sram-nei-cun-bu-ju">1.3 lowlevel_init对sram内存布局</a></li>
<li><a href="#1-4-s-init-han-shu">1.4 s_init函数</a></li>
</ul>
</li>
<li><a href="#2-main-han-shu">2 <code>_main</code>函数</a><ul>
<li><a href="#2-1-sram-zhong-zhi-ding-sp">2.1 sram中指定SP</a></li>
<li><a href="#2-2-board-init-f-alloc-reserve-zhi-ding-malloc-gd-zhi-zhen">2.2 board_init_f_alloc_reserve（指定<code>malloc/gd</code>指针）</a></li>
<li><a href="#2-3-board-init-f-init-reserve-chu-shi-hua-gd-gd-nei-cun-qing-0">2.3 <code>board_init_f_init_reserve</code>（<code>初始化gd，gd内存清0</code>）</a></li>
<li><a href="#2-4-board-init-f-wai-she-chu-shi-hua-he-dram-hua-fen">2.4 board_init_f(外设初始化和DRAM划分)</a></li>
<li><a href="#2-5-relocate-code-dai-ma-chong-ding-wei">2.5 relocate_code(代码重定位)</a><ul>
<li><a href="#2-5-1-chong-ding-wei-hou-de-lr-she-zhi">2.5.1 重定位后的LR设置</a></li>
<li><a href="#2-5-2-dai-ma-duan-chong-ding-wei">2.5.2 代码段重定位</a></li>
<li><a href="#2-5-3-rel-dyn-duan-chong-ding-wei">2.5.3 <code>rel.dyn</code>段重定位</a></li>
</ul>
</li>
<li><a href="#2-6-relocate-vectors-xiang-liang-biao-chong-ding-wei">2.6 relocate_vectors(向量表重定位)</a></li>
<li><a href="#2-7-board-init-r">2.7 board_init_r</a><ul>
<li><a href="#2-7-1-wai-she-chu-shi-hua">2.7.1 外设初始化</a></li>
<li><a href="#2-7-2-run-main-loop-han-shu">2.7.2 run_main_loop 函数</a><ul>
<li><a href="#2-7-2-1-uboot-version-huan-jing-bian-liang-she-zhi">2.7.2.1 Uboot version环境变量设置</a></li>
<li><a href="#2-7-2-2-bootdelay-he-bootcmd-huo-qu">2.7.2.2 bootdelay和bootcmd获取</a></li>
<li><a href="#2-7-2-3-autoboot-command-zhi-xing-bootcmd">2.7.2.3 autoboot_command(执行bootcmd)</a><ul>
<li><a href="#2-7-2-3-1-bootdelay-dao-ji-shi">2.7.2.3.1 bootdelay倒计时</a></li>
</ul>
</li>
<li><a href="#2-7-2-4-cli-loop-uboot-ming-ling-xing">2.7.2.4 cli_loop(uboot命令行)</a><ul>
<li><a href="#2-7-2-4-1-cmd-process-han-shu-fen-xi">2.7.2.4.1 cmd_process 函数分析</a></li>
<li><a href="#2-7-2-4-2-uboot-ming-ling-ding-yi-dhcp-wei-li">2.7.2.4.2 uboot命令定义(dhcp为例)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<p>下面以<code>u-boot 2016</code>为例，一行一行分析<code>armv7</code>架构cpu的uboot启动流程，用到的soc是<code>imx6ull</code>为例。总体流程如下：分为2部分：<br>①arch级初始化(架构)<br>②板级初始化<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image"></p>
<h1><span id="1-reset-han-shu">1 reset 函数</span><a href="#1-reset-han-shu" class="header-anchor">#</a></h1><h2><span id="1-1-chu-shi-hua-yi-chang-xiang-liang-biao">1.1 初始化异常向量表</span><a href="#1-1-chu-shi-hua-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p>我们知道启动入口是<code>arch/arm/lib/vectors.S</code>文件中的<code>_start</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image"><br>从函数入口<code>_start</code>可以看到，入口的指令存放的就是中断向量表，<code>0地址偏移存放reset</code>, <code>0x4地址存放_undefined_instruction</code>，<code>0x8地址存放_software_interrupt...</code><br>CPU上电最开始进入<code>_start</code>,进而进入<code>reset</code>函数，该函数定义在<code>arch/arm/cpu/armv7/start.S </code>里面。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image"><br>函数调用关系如下：<code>reset-&gt;save_boot_params-&gt;save_boot_params_ret</code>。</p>
<h2><span id="1-2-save-boot-params-ret">1.2 save_boot_params_ret</span><a href="#1-2-save-boot-params-ret" class="header-anchor">#</a></h2><h3><span id="1-2-1-guan-zhong-duan-jin-ru-svc-mo-shi">1.2.1 关中断，进入SVC模式</span><a href="#1-2-1-guan-zhong-duan-jin-ru-svc-mo-shi" class="header-anchor">#</a></h3><p><code>save_boot_params_ret </code>函数代码如下：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.png" alt="image"><br>该函数功能如注释所写主要是关闭<code>IRQ和FIQ</code>, 进入<code>SVC</code>模式，都是控制<code>cpsr</code>寄存器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一行读取 cpsr寄存器</span></span><br><span class="line"><span class="comment">//第二行对r0和0x1a进行与运算，目的是取出cpu模式。</span></span><br><span class="line"><span class="comment">//第三行如果 r1 和 0X1A 不相等，也就是 CPU 不处于 Hyp 模式的话就将 r0 寄存器的低5位清零，清除模式位</span></span><br><span class="line"><span class="comment">//第4行如果处理器不处于 Hyp 模式的话就将 r0 的寄存器的值与 0x13 进行或运算， 0x13=0b10011，也就是设置处理器进入 SVC 模式、</span></span><br><span class="line"><span class="comment">//第5行与 0xC0或运算，那么 r0 寄存器此时的值就是 0xD3，cpsr 的 I 为和 F 位分别控制 IRQ 和 FIQ 这两个中断的开关，设置为 1 就关闭了 FIQ 和 IRQ。</span></span><br><span class="line"><span class="comment">//第6行r0写入cpsr</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image"></p>
<h3><span id="1-2-2-cp15-pei-zhi-she-zhi-zhong-duan-xiang-liang-biao-pian-yi-vbar">1.2.2 cp15配置，设置中断向量表偏移VBAR</span><a href="#1-2-2-cp15-pei-zhi-she-zhi-zhong-duan-xiang-liang-biao-pian-yi-vbar" class="header-anchor">#</a></h3><p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image"><br>这里一般2个宏都没有定义，进入，这段作用是设置中断向量表偏移<code>VBAR</code>。<br>这里是把<code>CP15 SCTLR Register</code>读出来，<code>bic</code>是位清0，<code>CR_V </code>在 <code>arch/arm/include/asm/system.h </code>中定义了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">define <span class="title function_">CR_V</span> <span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">13</span>)</span> <span class="comment">/* Vectors relocated to 0xffff0000 */</span></span><br></pre></td></tr></table></figure>
<p>那么就是把<code>CP15 SCTLR Register</code>读出来,对<code>bit13清0</code>，再写进去<code>SCTLR Register</code>。</p>
<p>如下图是<code>SCTLR 寄存器</code>：<code>bit13 为 V 位</code>，此位是<code>向量表控制位</code>，当为 0 的时候向量表基地址 为 <code>0X00000000</code>，软件可以重定位向量表。为 1 的时候向量表基地址为<code> 0XFFFF0000</code>，软件不能 重定位向量表。<br>这里将 V 清零，目的就是为了接下来的向量表重定位。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image"><br>最后将<code>_start</code>给到<code>r0, r0写入到 CP15 的 c12 寄存器中</code>，也就是<code>VBAR</code>寄存器，完成中断向量表偏移的设定。<br>中断向量表的初始定义在<code>_start</code>入口位置，<code>0x87800000 </code>就是向量表的起始地址。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image"></p>
<h3><span id="1-2-3-cp15-pei-zhi-guan-mmu-icache">1.2.3 cp15配置，关<code>MMU，ICACHE</code></span><a href="#1-2-3-cp15-pei-zhi-guan-mmu-icache" class="header-anchor">#</a></h3><p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/11.png" alt="image"><br><code>bl cpu_init_cp15</code>一看就是初始化协处理器寄存器<code>CP15</code>, 比如关闭<code>MMU, ICACHE</code>等。<code>cpu_init_cp15</code>函数如下：都是一些<code>CP15</code>协寄存器操作指令，就不再一一解释。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/12.png" alt="image"><br><strong>总结</strong>：<code>save_boot_params_ret</code>做的事情：<br>    ①初始化中断向量表<br>    ②关<code>FIQ,IRQ</code><br>    ③进入<code>SVC</code>模式<br>    ④设置中断向量表偏移<code>VBAR</code><br>    ⑤初始化<code>CP15</code>,关<code>MMU,ICACHE</code>等。</p>
<h2><span id="1-3-lowlevel-init-dui-sram-nei-cun-bu-ju">1.3 lowlevel_init对sram内存布局</span><a href="#1-3-lowlevel-init-dui-sram-nei-cun-bu-ju" class="header-anchor">#</a></h2><p>初始化<code>CP15</code>,关<code>MMU,ICACHE</code>后，会继续执行进入<code>cpu_init_crit</code>：<code>cpu_init_crit</code>也是直接跳到<code>lowlevel_init</code>函数。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/13.png" alt="image"><br><code>lowlevel_init </code>在文件<code>arch/arm/cpu/armv7/lowlevel_init.S</code>中定义：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/14.png" alt="image"><br>前面2行定义<code>sp </code>指向 <code>CONFIG_SYS_INIT_SP_ADDR</code>设置<code>SP</code>指针，<code>CONFIG_SYS_INIT_SP_ADDR </code>在 <code>include/configs/mx6ullevk.h</code><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/15.png" alt="image"><br><code>IRAM_BASE_ADDR </code>和<code>IRAM_SIZE</code>在 文 件<code>arch/arm/include/asm/arch-mx6/imx-regs.h</code>中有定义，imx6ull这颗芯片内部有一个sram叫做<code>ocram</code>,基地址就是<code>0x00900000</code>，size为<code>128k(0x20000)</code>。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/16.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/17.png" alt="image"><br>再来看<code>GENERATED_GBL_DATA_SIZE</code>的值：该定义是编译生成的<code>include/generated/generic-asm-offsets.h</code>中：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/18.png" alt="image"><br>这里提一句，<code>GENERATED_GBL_DATA_SIZE </code>的含义为<code> (sizeof(struct global_data) + 15) &amp; ~15</code>，该结构体后面会讲到。<br>综上所述，<code>CONFIG_SYS_INIT_SP_ADDR </code>值如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_SYS_INIT_SP_OFFSET = <span class="number">0x00020000</span> – <span class="number">256</span> = <span class="number">0x1FF00</span></span><br><span class="line">CONFIG_SYS_INIT_SP_ADDR = <span class="number">0x00900000</span> + <span class="number">0X1FF00</span> = <span class="number">0X0091FF00</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/19.png" alt="image"><br>从图可知：<br>内部<code>sram</code>的地址范围：<code>0x00900000~0x0091ffff (128k)</code><br><code>SP</code>指向：<code>0x0091ff00</code><br>继续分析汇编代码，<code>sp</code>又继续减了一个<code>GD_SIZE</code>,然后8字节对齐，赋值给<code>r9</code>。<br><code>GD_SIZE</code> 同样在 <code>generic-asm-offsets.h </code>中定义了，大小为 248。最后<code>SP</code>指针位置就定义好了，将<code>ip,lr</code>入栈，进入函数<code>s_init</code>函数，<code>s_init</code>函数返回后，<code>ip和lr</code>出栈，并将<code>lr赋给pc</code>。最终内存指向如下：<code>SP指向：0x0091fe08</code>。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/20.png" alt="image"><br>总结：<code>lowlevel_init</code>函数就是在内部<code>sram下设置SP</code>指针，来为c语言的运行配置环境。</p>
<h2><span id="1-4-s-init-han-shu">1.4 s_init函数</span><a href="#1-4-s-init-han-shu" class="header-anchor">#</a></h2><p><code>s_init </code>函数定义在文件<code> arch/arm/cpu/armv7/mx6/soc.c</code>。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/21.png" alt="image"><br>由于我们的<code>cpu是mx6ull</code>,那么满足最开始的<code>if</code>判断，那么<code>s_init</code>函数直接返回，什么也没做。<br>总结<code>_reset</code>过程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s_init返回了，lowlevel_init也返回了，cpu_init_crit也返回了，回到 save_boot_params_ret。</span><br></pre></td></tr></table></figure>
<p>总结下整个系统上电的reset过程：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/22.png" alt="image"></p>
<h1><span id="2-main-han-shu">2 <code>_main</code>函数</span><a href="#2-main-han-shu" class="header-anchor">#</a></h1><p><code>_main </code>函数定义在文件<code>arch/arm/lib/crt0.S</code>中：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/23.png" alt="image"></p>
<h2><span id="2-1-sram-zhong-zhi-ding-sp">2.1 sram中指定SP</span><a href="#2-1-sram-zhong-zhi-ding-sp" class="header-anchor">#</a></h2><p>如注释写的，第<code>76行</code>，初始化c语言运行环境，<code>SP设置到CONFIG_SYS_INIT_SP_ADDR，也就是0x0091ff00</code>。第<code>83行</code>，8字节对齐。</p>
<h2><span id="2-2-board-init-f-alloc-reserve-zhi-ding-malloc-gd-zhi-zhen">2.2 board_init_f_alloc_reserve（指定<code>malloc/gd</code>指针）</span><a href="#2-2-board-init-f-alloc-reserve-zhi-ding-malloc-gd-zhi-zhen" class="header-anchor">#</a></h2><p>第<code> 86 行</code>，调用数<code> board_init_f_alloc_reserve，r0</code>作为形参传给该函数。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/24.png" alt="image"><br>该函数主要是留出早期的<code>malloc</code>内存区域和 <code>gd </code>内存区域，其中<code>CONFIG_SYS_MALLOC_F_LEN=0X400</code>( 在 文 件 <code>include/generated/autoconf.h </code>中定义， <code>CONFIG_SYS_MALLOC_F</code>也同样定义成1) ，<code> sizeof(struct global_data)=248</code>(<code>GD_SIZE </code>值)。<code>rounddown</code>是一个向下对齐的函数。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/25.png" alt="image"><br>因此最终的内存分布如下图：最终<code>top=0X0091FA00</code>。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/26.png" alt="image"><br>回到<code>87行</code>，<code>r0</code>存储了函数的返回值，进入<code>89行</code>，把<code>top的值继续存到r9</code>。记住<code>r9</code>寄存器，对uboot很重要，它是记录了全局变量<code>gd</code>的地址。<br>在文件<code>arch/arm/include/asm/global_data.h</code>中有定义：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/27.png" alt="image"><br>可以看到<code>gd</code>是一个全局的指针变量，<code>gd_t</code>结构体类型，在<code>include/asm-generic/global_data.h</code>里面有定义：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/28.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/29.png" alt="image"></p>
<h2><span id="2-3-board-init-f-init-reserve-chu-shi-hua-gd-gd-nei-cun-qing-0">2.3 <code>board_init_f_init_reserve</code>（<code>初始化gd，gd内存清0</code>）</span><a href="#2-3-board-init-f-init-reserve-chu-shi-hua-gd-gd-nei-cun-qing-0" class="header-anchor">#</a></h2><p>回到<code>_main</code>函数继续执行<code>board_init_f_init_reserve</code>，在文件<code>common/init/board_init.c</code>中有定义：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/30.png" alt="image"><br>此函数用于初始化<code> gd</code>，其实就是清零处理。再设置了 <code>gd-&gt;malloc_base</code> 为<code> gd 基地址+gd 大小=0X0091FA00+248=0X0091FAF8</code>，在做 16 字节对齐，最 终<code> gd-&gt;malloc_base=0X0091FB00</code>，这个也就是<code>early malloc</code>的起始地址。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/31.png" alt="image"></p>
<h2><span id="2-4-board-init-f-wai-she-chu-shi-hua-he-dram-hua-fen">2.4 board_init_f(外设初始化和DRAM划分)</span><a href="#2-4-board-init-f-wai-she-chu-shi-hua-he-dram-hua-fen" class="header-anchor">#</a></h2><p>此函数定义在文件<code> common/board_f.c</code>，该函数非常重要，主要功能如下：<br>①、初始化一系列外设，比如串口、定时器，或者打印一些消息等。<br>②、初始化 <code>gd </code>的各个成员变量，uboot 会将自己重定位到 DRAM 最后面的地址区域，也就是将自己拷贝到 DRAM 最后面的内存区域中。这么做的目的是给 Linux 腾出空间，防止 Linux kernel 覆盖掉 uboot，将 DRAM 前面的区域完整的空出来。在拷贝之前肯定要给 uboot 各部分 分配好内存位置和大小，比如<code> gd</code> 应该存放到哪个位置，malloc 内存池应该存放到哪个位置等等。这些信息都保存在<code>gd</code>的成员变量中，因此要对<code>gd</code>的这些成员变量做初始化。最终形成一个完整的内存“分配图”，在后面重定位 uboot 的时候就会用到这个内存“分配图”。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/32.png" alt="image"><br>所有外设模块初始化详见<code>initcall_run_list</code>函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/33.png" alt="image"><br><code>init_sequence_f </code>也是定义在文件<code>common/board_f.c</code>中，<code>init_sequence_f </code>的内容比较长，简要概括如下：实际list里面函数更多。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/34.png" alt="image"></p>
<ol>
<li><code>setup_mon_len </code>函数设置 <code>gd </code>的<code> mon_len</code> 成员变量，此处为<code>__bss_end -_start</code>，也就 是整个代码的长度。<code>0X878A8E74-0x87800000=0XA8E74</code>，这个就是代码长度。</li>
<li><code>initf_malloc </code>函数初始化<code>gd</code>中跟 malloc 有关的成员变量，比如 <code>malloc_limit</code>，此函 数会设置 <code>gd-&gt;malloc_limit = CONFIG_SYS_MALLOC_F_LEN=0X400</code>。<code>malloc_limit </code>表示 malloc 内存池大小。</li>
<li><code>initf_console_record</code> ，如果定义了宏<code>CONFIG_CONSOLE_RECORD</code>和 宏 <code>CONFIG_SYS_MALLOC_F_LEN </code>的话此函数就会调用函数 <code>console_record_init</code>，但是 IMX6ULL 的 uboot 没有定义宏<code> CONFIG_CONSOLE_RECORD</code>，所以此函数直接返回 0。</li>
<li><code>arch_cpu_init</code></li>
<li><code>initf_dm </code>函数，驱动模型的一些初始化。</li>
<li><code>arch_cpu_init_dm </code>函数未实现</li>
<li><code>board_early_init_f </code>函数，板子相关的早期的一些初始化设置，I.MX6ULL 用来初始 化串口的 IOMUX 配置</li>
<li><code>timer_init</code>，初始化定时器</li>
<li><code>board_postclk_init</code>，对于 I.MX6ULL 来说是设置 VDDSOC 电压</li>
<li><code>env_init </code>函数是和环境变量有关的，设置<code>gd</code>的成员变量 env_addr&#96;，也就是环境变量的保存地址。</li>
<li><code>init_baud_rate </code>函数用于初始化波特率，根据环境变量<code>baudrate</code>来初始化 <code>gd-&gt;baudrate</code>。</li>
<li><code>serial_init</code>，初始化串口。</li>
<li><code>console_init_f</code>初始化控制台。</li>
<li><code>display_options</code>，通过串口输出一些信息：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/35.png" alt="image"></li>
<li><code>display_text_info</code>，打印一些文本信息，如果开启 UBOOT 的 <code>DEBUG </code>功能的话就 会输出<code> text_base、bss_start、bss_end</code>，形式如下：<br><code>debug(&quot;U-Boot code: %08lX -&gt; %08lX BSS: -&gt; %08lX\n&quot;,text_base, bss_start, bss_end)；</code><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/36.png" alt="image"></li>
<li><code>print_cpuinfo </code>函数用于打印 CPU 信息。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/37.png" alt="image"></li>
<li><code>show_board_info </code>函数用于打印板子信息。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/38.png" alt="image"></li>
<li><code>INIT_FUNC_WATCHDOG_INIT, INIT_FUNC_WATCHDOG_RESET</code>表示初始化，复位看门狗。对于 I.MX6ULL 来说是空函数。</li>
<li><code>init_func_i2c </code>函数用于初始化 I2C。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/39.png" alt="image"></li>
<li><code>announce_dram_init,dram_init</code>初始化DDR,其实只是设置<code>gd-&gt;ram_size</code>,I.MX6ULL 开发板 EMMC 版本核心板来说就是 512MB。</li>
<li><code>post_init_f</code>，此函数用来完成一些测试，初始化<code> gd-&gt;post_init_f_time</code>。</li>
<li><code>setup_dest_addr</code>,设置目的地址。主要设置<code>gd-&gt;ram_size，gd-&gt;ram_top，gd-&gt;relocaddr </code>这三个的值。修改 uboot 代码，直接将这些值通过串口打印出来，比如这里我们修改文件<code>common/board_f.c的setup_dest_addr</code>函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/40.png" alt="image"><br>烧录运行打印出来如下：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/41.png" alt="image"><br>可以看出：<br><code>gd-&gt;ram_size = 0X20000000 //ram 大小为 0X20000000=512MB</code><br><code>gd-&gt;ram_top = 0XA0000000 //ram 最高地址为 0X80000000+0X20000000=0XA0000000</code><br><code>gd-&gt;relocaddr = 0XA0000000 //重定位后最高地址为 0XA0000000</code></li>
<li><code>reserve_round_4k</code>， 对 <code>gd-&gt;relocaddr </code>做 4KB 对齐，因为<code> gd-&gt;relocaddr=0XA0000000</code>，已经是 4K 对齐了，所以调整后不变。</li>
<li><code>reserve_mmu</code>，留出 MMU 的 TLB 表的位置，分配 MMU 的 TLB 表内存以后会 对<code>gd-&gt;relocaddr</code>做 64K 字节对齐。完成以后 <code>gd-&gt;arch.tlb_size、gd-&gt;arch.tlb_addr 和 gd-&gt;relocaddr</code>如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/42.png" alt="image"><br>可以看出：<br><code>gd-&gt;arch.tlb_size= 0X4000 //MMU 的 TLB 表大小</code><br><code>gd-&gt;arch.tlb_addr=0X9FFF0000 //MMU 的 TLB 表起始地址，64KB 对齐以后</code><br><code>gd-&gt;relocaddr=0X9FFF0000 //relocaddr 地址</code></li>
<li><code>reserve_trace </code>函数，留出跟踪调试的内存。</li>
<li><code>reserve_uboot</code>，留出重定位后的 uboot 所占用的内存区域，uboot 所占用大小由<code>gd-&gt;mon_len</code>所指定，留出 uboot 的空间以后还要对<code>gd-&gt;relocaddr</code>做 4K 字节对齐，并且重新设 置 <code>gd-&gt;start_addr_sp</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/43.png" alt="image"><br>可以看出, <code>relocaddr</code>一直再减：<br><code>gd-&gt;mon_len = 0XA8EF4</code><br><code>gd-&gt;start_addr_sp = 0X9FF47000//0X9FFF0000 -0XA8EF4=9FF4710C,4k再对齐一下就是0X9FF47000</code><br><code>gd-&gt;relocaddr = 0X9FF47000</code></li>
<li><code>reserve_malloc</code>，留出 malloc 区域，调整 <code>gd-&gt;start_addr_sp </code>位置。malloc 区域由宏<code>TOTAL_MALLOC_LEN</code>定义：<br><code>#define TOTAL_MALLOC_LEN (CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)</code><br><code>mx6ull_alientek_emmc.h </code>文件中定义宏 <code>CONFIG_SYS_MALLOC_LEN 为16MB=0X1000000</code>， 宏 <code>CONFIG_ENV_SIZE=8KB=0X2000</code>，因此 <code>TOTAL_MALLOC_LEN=0X1002000</code>。调整以后<code>gd-&gt;start_addr_sp</code>如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/44.png" alt="image"><br>可以看出：<br><code>TOTAL_MALLOC_LEN=0X1002000</code><br><code>gd-&gt;start_addr_sp=0X9EF45000 //0X9FF47000-16MB-8KB=0X9EF45000</code></li>
<li><code>reserve_board</code>， 预留<code>bd 内存</code>，<code>bd </code>是结构体<code> bd_t，bd_t 大小为 80 字节</code>:<br><code>gd-&gt;start_addr_sp=0X9EF44FB0//0X9EF45000 -80</code><br><code>gd-&gt;bd=0X9EF44FB0</code></li>
<li><code>setup_machine</code>，设置机器 ID，linux 启动的时候会和这个机器 ID 匹配，如果匹 配的话 linux 就会启动正常。以前老版本的 uboot 和 linux 使用的，新版本使用设备树了，因此此函数无效。</li>
<li><code>reserve_global_data</code>，保留出<code> gd</code>，<code>gd_t 结构体大小为 248B</code>：<br><code>gd-&gt;start_addr_sp=0X9EF44EB8 //0X9EF44FB0-248=0X9EF44EB8</code><br><code>gd-&gt;new_gd=0X9EF44EB8</code></li>
<li><code>reserve_fdt</code>，留出设备树相关的内存。</li>
<li><code>reserve_arch </code>是个空函数。</li>
<li><code>reserve_stacks</code>，留出栈空间，先对 <code>gd-&gt;start_addr_sp </code>减去 16，然后做 16 字节对齐。如果使能 IRQ 的话还要留出 IRQ 相应的内存，具体工作是由<code>arch/arm/lib/stack.c </code>文件中的 函数<code>arch_reserve_stacks</code>完成。这里uboot启动没有enable IRQ,因此不会留出 IRQ 相应的内存：<br><code>gd-&gt;start_addr_sp=0X9EF44E90</code></li>
<li><code>setup_dram_config</code>，设置 <code>dram bank</code>信息,后面会传递给 linux 内核，告诉 linux DRAM 的起始地址和大小:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/45.png" alt="image"></li>
<li><code>show_dram_config</code>，打印<code>dram</code>信息:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/46.png" alt="image"></li>
<li><code>display_new_sp</code>，显示新的<code>sp</code>位置，也就是<code> gd-&gt;start_addr_sp</code>，要开启宏 <code>DEBUG</code>才能看到:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/47.png" alt="image"></li>
<li><code>reloc_fdt</code>，数用于重定位<code> fdt</code>，没有用到。</li>
<li><code>setup_reloc</code>，设置 <code>gd </code>的其他一些成员变量，供后面重定位的时候使用，并且将以 前的 <code>gd </code>拷贝到 <code>gd-&gt;new_gd </code>处。需要使能 <code>DEBUG </code>才能看到相应的信息输出:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/48.png" alt="image"><br>可以看出，uboot 重定位后的偏移为<code> 0X18747000</code>，重定位后的新地址为<code> 0X9FF4700</code>，新的<code> gd</code> 首地址为 <code>0X9EF44EB8</code>，最终的<code>sp</code>为<code> 0X9EF44E90</code>。<br>至此，<code>board_init_f </code>函数就执行完成了，最终的内存分配如下：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/49.png" alt="image"></li>
</ol>
<h2><span id="2-5-relocate-code-dai-ma-chong-ding-wei">2.5 relocate_code(代码重定位)</span><a href="#2-5-relocate-code-dai-ma-chong-ding-wei" class="header-anchor">#</a></h2><p>既然dram划分好了，那么就开始需要对代码重定位了。</p>
<h3><span id="2-5-1-chong-ding-wei-hou-de-lr-she-zhi">2.5.1 重定位后的LR设置</span><a href="#2-5-1-chong-ding-wei-hou-de-lr-she-zhi" class="header-anchor">#</a></h3><p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/50.png" alt="image"><br>回到<code>_main</code>第 103 行，获取<code>gd-&gt;start_addr_sp</code>的值赋给<code> sp</code>， <code>board_init_f</code> 中会初始化<code>gd</code>的所有成员进行内存预留，其中<br><code>gd-&gt;start_addr_sp=0X9EF44E90</code><br>所以这里<code>sp=0X9EF44E90</code>。<br>第 109 行，<code>sp</code> 做 8 字节对齐。<br>第 111 行，获取<code>gd-&gt;bd</code>的地址赋给 <code>r9</code>，之前<code>r9</code>存放的是老的<code> gd</code>，<code>GD_BD=0</code>来自<code>include\generated\generic-asm-offsets.h</code>，<code>bd</code>就是<code>gd</code>结构体的首个成员，因此<code>offset是0</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/51.png" alt="image"><br>那么新<code>gd</code>地址（<code>board_init_f</code>时确定了<code>gd-&gt;bd</code>的地址为<code>0X9EF44FB0</code>)也是它。<br>第 112 行，<code>r9</code>再减一个<code>GD_SIZE</code>,得到<code>gd-&gt;new_gd</code>,也就是<code>0X9EF44EB8</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/52.png" alt="image"><br><strong>重点来了：</strong><br>第 114 行，设置<code>lr</code>寄存器为<code> here</code>，这样后面执行其他函数返回的时候就返回到了第 122 行 的<code>here</code>位置处(比如执行完<code>relocate_code</code>就直接返回到<code>here</code>)。<br>后面第115行~116行用来让lr指向重定位后的<code>here</code>位置。<br>第 115，读取<code>gd-&gt;reloc_off</code>的值复制给<code>r0</code>寄存器，<code>GD_RELOC_OFF=64</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/53.png" alt="image"><br>第 116 行，lr 寄存器的值加上<code>r0</code>寄存器的值，重新赋值给<code>lr</code>寄存器。 此时<code>lr </code>就存放了重定位后的<code>here</code>位置，因为重定位完就去重定位后的DDR去执行了，无需返回sram了。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/12038514.html">s3c2440裸机-代码重定位(1.重定位的引入,为什么要代码重定位) - fuzidage - 博客园 (cnblogs.com)</a><br><a href="https://www.cnblogs.com/fuzidage/p/12043586.html">s3c2440裸机-代码重定位（2.编程实现代码重定位） - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/">s3c2440裸机编程-代码重定位和清bss | Hexo (fuzidage.github.io)</a></p>
<p>关键词：<strong>位置无关码、相对跳转指令，相对寻址</strong></p>
<p>第 120 行，读取<code>gd-&gt;relocaddr</code>的值赋给 <code>r0 </code>寄存器，此时<code>r0</code>寄存器就保存着 uboot 要拷贝的目的地址，我们打印出来为<code>0X9FF47000</code>。<code>r0</code>作为形参给<code>relocate_code</code>函数。</p>
<h3><span id="2-5-2-dai-ma-duan-chong-ding-wei">2.5.2 代码段重定位</span><a href="#2-5-2-dai-ma-duan-chong-ding-wei" class="header-anchor">#</a></h3><p>重定位的具体实现在<code>arch/arm/lib/relocate.S</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/54.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/55.png" alt="image"></p>
<ol>
<li>80-83行是设置重定位<code>r4</code>偏移量，源拷贝地址，判断是否要拷贝。<code>u-boot.map</code>获取符号的地址：</li>
</ol>
<table>
<thead>
<tr>
<th><code>__image_copy_start</code></th>
<th>0x87800000</th>
<th>uboot拷贝的首地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>__image_copy_end</code></td>
<td>0x8785dd54</td>
<td>uboot拷贝的结束地址</td>
</tr>
</tbody></table>
<p>如果<code>r4等于0</code>（也就是目标地址<code>r0</code>就是<code>uboot.map</code>中的地址），那么无需拷贝，跳转到<code>relocate_done</code>即可。<br>2. 85-89是循环拷贝，多寄存器加载存储指令<code>LDMIA，STMIA</code>。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17703733.html">arm汇编和cpu运行模式 - fuzidage - 博客园 (cnblogs.com)</a><br><a href="https://fuzidage.github.io/tags/arm%E6%B1%87%E7%BC%96/">Tag: arm汇编 | Hexo (fuzidage.github.io)</a> </p>
<p>88行判断是否拷贝结束，<code>r1</code>会每次加4，当<code>r1</code>等于<code>r2</code>表示拷贝完成了，否则继续执行<code>copy_loop</code>。</p>
<h3><span id="2-5-3-rel-dyn-duan-chong-ding-wei">2.5.3 <code>rel.dyn</code>段重定位</span><a href="#2-5-3-rel-dyn-duan-chong-ding-wei" class="header-anchor">#</a></h3><p>编译uboot使用<code>-pie选项</code>以后会生成一个<code>.rel.dyn 段</code>，需要对这个段进行重定位和拷贝：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/56.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">94-97行，从.rel.dyn 段开始，每次读取两个 4 字节的数据存放到 r0 和 r1 寄存器中，r0 存放低 4 字节的数据，也就是 Label 地址；r1 存放高 4 字节的数据，也就是 Label 标志。</span><br><span class="line">第 98 行，取 r1 的低 8 位。</span><br><span class="line">第 99 行，判断 r1 中的值是否等于 23(0X17)。</span><br><span class="line">第 100 行，如果 r1 不等于 23 的话就说明不是描述 Label 的，执行函数 fixnext，否则的话继续执行下面的代码。</span><br><span class="line">103-104行，r0 保存着 Label 值，r4 保存着重定位的偏移量，r0+r4 就得到了重定位后的Label 值。</span><br><span class="line">105-106行，重定位后的变量地址写入到重定位后的 Label 中。</span><br><span class="line">第 108 行，比较 r2 和 r3，查看.rel.dyn 段重定位是否完成。</span><br><span class="line">第 109 行，如果 r2 和 r3 不相等，说明.rel.dyn 重定位还未完成，因此跳到 fixloop 继续重定位.rel.dyn 段。</span><br></pre></td></tr></table></figure>

<h2><span id="2-6-relocate-vectors-xiang-liang-biao-chong-ding-wei">2.6 relocate_vectors(向量表重定位)</span><a href="#2-6-relocate-vectors-xiang-liang-biao-chong-ding-wei" class="header-anchor">#</a></h2><p><code>relocate.S </code>中同时也定义了中断向量表的重定位:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/57.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第 <span class="number">29</span> 行，如果定义了 CONFIG_CPU_V7M 的话就执行第 <span class="number">30</span>~<span class="number">36</span> 行的代码，对于 I.MX6ULL 来说不是ARMv7-M,不执行。</span><br><span class="line">由于在.config 里面定义了 CONFIG_HAS_VBAR，因此执行下面的代码。</span><br><span class="line"><span class="number">43</span> 行，r0=gd-&gt;relocaddr，重定位后 uboot 的首地址，也就是向量表地址，因为异常向量表就在uboot代码段最开始的地方。</span><br><span class="line"><span class="number">44</span>行，CP15 的 VBAR寄存器写入r0。这样重定位后的向量表就设置好了。</span><br></pre></td></tr></table></figure>

<h2><span id="2-7-board-init-r">2.7 board_init_r</span><a href="#2-7-board-init-r" class="header-anchor">#</a></h2><h3><span id="2-7-1-wai-she-chu-shi-hua">2.7.1 外设初始化</span><a href="#2-7-1-wai-she-chu-shi-hua" class="header-anchor">#</a></h3><p>前面<code>board_init_f</code>初始化了芯片级外设（<code>uart,Timer,console</code>等）并且进行了DRAM划分，为代码重定位做准备。接下来<code>board_init_r</code>进行板级的外设初始化。<br><code>init_sequence_r </code>定义在文件<code> common/board_r.c</code>，负责初始化各个硬件外设，比如<code>flash,网卡，i2c，sdio</code>等等：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/58.png" alt="image"></p>
<p><strong><code>initr_trace</code></strong> 函数，如果定义了宏<code>CONFIG_TRACE</code>的话就会调用函数<code> trace_init</code>， 初始化和调试跟踪有关的内容。<br><strong><code>initr_reloc</code></strong> 函数用于设置<code> gd-&gt;flags</code>，标记重定位完成。<br><strong><code>initr_caches</code></strong> 函数用于初始化 cache，使能 cache。<br><strong><code>initr_reloc_global_data</code></strong> 函数，初始化重定位后<code>gd</code>的一些成员变量。<br><strong><code>initr_barrier</code></strong> 函数，I.MX6ULL 未用到。<br><strong><code>initr_malloc</code></strong> 函数，初始化 malloc。<br><strong><code>initr_console_record</code></strong> 函数，初始化控制台相关的内容，I.MX6ULL 未用到，空函数。<br><strong><code>bootstage_relocate</code></strong> 函数，启动状态重定位。<br><strong><code>initr_bootstage</code></strong> 函数，初始化<code>bootstage</code>什么的。<br><strong><code>board_init</code></strong> 函数，板级初始化，包括<code>FEC、USB 和 QSPI </code>等。 这里执行的是 <code>mx6ull_alientek_emmc.c </code>文件中的 <code>board_init </code>函数。<br><strong><code>stdio_init_tables</code></strong> 函数，<code>stdio </code>相关初始化。<br><strong><code>initr_serial</code></strong> 函数，初始化串口。<br><strong><code>power_init_board</code></strong> 函数，初始化电源芯片，正点原子的 I.MX6ULL 开发板没有用到。<br><strong><code>initr_flash</code></strong> 函数，对于 I.MX6ULL 而言，没有定义宏 <code>CONFIG_SYS_NO_FLASH </code>的话函数<code>initr_flash</code>才有效。但是 <code>mx6_common.h </code>中定义了宏 <code>CONFIG_SYS_NO_FLASH</code>，所以 此函数无效。<br><strong><code>initr_nand</code></strong> 函数，初始化 NAND，如果使用 NAND 版本核心板的话就会初始化 NAND。<br><strong><code>initr_mmc</code></strong> 函数，初始化 EMMC，如果使用 EMMC 版本核心板的话就会初始化 EMMC：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/59.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/60.png" alt="image"><br><strong><code>initr_env</code></strong> 函数，初始化环境变量。<br><strong><code>initr_secondary_cpu</code></strong> 函数，初始化其他 CPU 核，I.MX6ULL 只有一个核，因此此函数没用。<br><strong><code>stdio_add_devices</code></strong> 函数，各种输入输出设备的初始化，如 LCD driver，I.MX6ULL 使用 <code>drv_video_init </code>函数初始化 LCD：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/61.png" alt="image"><br><strong><code>initr_jumptable</code></strong> 函数，初始化跳转表。<br><strong><code>console_init_r</code></strong> 函数 ， 控制台初始化， 初始化完成以后此函数会调用<code>stdio_print_current_devices</code>函数来打印出当前的控制台设备：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/62.png" alt="image"><br><strong><code>interrupt_init</code></strong> 函数，初始化中断。<br><strong><code>initr_enable_interrupts</code></strong> 函数，使能中断。<br><strong><code>initr_ethaddr</code></strong> 函数，初始化网络地址，也就是获取 MAC 地址。读取环境变量 <code>ethaddr</code>的值。<br><strong><code>board_late_init</code></strong> 函数，板子后续初始化，此函数定义在文件<code>mx6ull_alientek_emmc.c</code>中，如果环境变量存储在 EMMC 或者 SD 卡中的话此函数会调用 <code>board_late_mmc_env_init </code>函数 初始化 <code>EMMC/SD</code>。会切换到正在时候用的 emmc 设备，如下图所示：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/63.png" alt="image"><br><code>cmd</code>构造成<code>mmc dev 1</code>,切换到正在使用的 EMMC 设备。因为dev0为sd卡，dev1为emmc：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/64.png" alt="image"><br><strong><code>initr_net</code></strong> 函数，初始化网络设备，调用关系<code>initr_net-&gt;eth_initialize-&gt;board_eth_init()</code>。<br>最后**<code>run_main_loop</code>**，主循环，处理命令。</p>
<h3><span id="2-7-2-run-main-loop-han-shu">2.7.2 run_main_loop 函数</span><a href="#2-7-2-run-main-loop-han-shu" class="header-anchor">#</a></h3><h4><span id="2-7-2-1-uboot-version-huan-jing-bian-liang-she-zhi">2.7.2.1 Uboot version环境变量设置</span><a href="#2-7-2-1-uboot-version-huan-jing-bian-liang-she-zhi" class="header-anchor">#</a></h4><p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/65.png" alt="image"><br>第 48 行，调用 <code>bootstage_mark_name </code>函数，打印出启动进度。<br>第 57 行，如果定义了宏 <code>CONFIG_VERSION_VARIABLE</code>,设置版本号环境变量，<code>cmd/version.c </code>中定义了<code>version_string</code>字符串，<code>version.h</code>定义了<code>U_BOOT_VERSION_STRING</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/66.png" alt="image"><br><code>U_BOOT_VERSION </code>定义在文件<code>include/generated/version_autogenerated.h</code>中：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/67.png" alt="image"><br>比如我的板子uboot命令行输入<code>version</code>打印版本信息：打印uboot版本，编译日期时间，<code>CONFIG_IDENT_STRING</code>为板子<code>identity</code>信息，我这里是<code>cvitek_athena2</code>，如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/68.png" alt="image"><br>最后打印出<code>toolchain</code>信息是因为编译生成<code>version_autogenerated.h</code>，输入<code>version</code>命令打印如下<code>do_version</code>函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/69.png" alt="image"><br>Uboot中的命令都是调用<code>cmd_process</code>函数来解析执行。（会面有具体分析<code>cmd_process</code>)</p>
<h4><span id="2-7-2-2-bootdelay-he-bootcmd-huo-qu">2.7.2.2 bootdelay和bootcmd获取</span><a href="#2-7-2-2-bootdelay-he-bootcmd-huo-qu" class="header-anchor">#</a></h4><p>第 60 行，<code>cli_init()</code>，<code>cli</code>是一个命令行接口，一般裸机开发都喜欢移植<code>cli</code>，来注册各种命令参数。<br>第 62 行，<code>run_preboot_environment_command()</code>获取系统环境变量<code>preboot</code>的值，我们没有定义该环境变量。<br>第 68 行,<code>bootdelay_process()</code>设置倒计时全局变量。我的板子<code>bootdelay</code>环境变量是1，<code>.config</code>也配置的1。<br>该函数是获取<code>bootcmd</code>环境变量，返回<code>bootcmd</code>环境变量，如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/70.png" alt="image"></p>
<h4><span id="2-7-2-3-autoboot-command-zhi-xing-bootcmd">2.7.2.3 autoboot_command(执行bootcmd)</span><a href="#2-7-2-3-autoboot-command-zhi-xing-bootcmd" class="header-anchor">#</a></h4><p><code>main_loop</code>的第72行，自动执行<code>bootcmd</code>。当然我们在命令行输入<code>run bootcmd</code>也会执行<code>bootcmd</code>里面指令，如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/71.png" alt="image"><br><code>autoboot_command</code>函数定义在<code>common/autoboot.c</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/72.png" alt="image"><br>我这里<code>stored_bootdelay</code>全局变量等于1，<code>s</code>字符串是<code>bootcmd</code>环境变量不为空。最后<code>abortboot</code>函数的返回值也为0，因此执行<code>run_command_list</code>，执行<code>bootcmd</code>里面的命令，启动kernel rootfs。</p>
<h5><span id="2-7-2-3-1-bootdelay-dao-ji-shi">2.7.2.3.1 bootdelay倒计时</span><a href="#2-7-2-3-1-bootdelay-dao-ji-shi" class="header-anchor">#</a></h5><p>分析<code>abortboot()</code>函数：<br><code>abortboot</code>调用<code>abortboot_normal</code>，该函数就是判断<code>bootdelay</code>倒计时内是否有按键按下，倒计时结束没有按键按下，那么执行<code>bootcmd</code>，否则uboot命令行等待用户输入,代码逻辑如下：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/73.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/74.png" alt="image"><br>总结：有按键输入，<code>abortboot()</code>函数返回1，否则返回0, 这样<code>autoboot_command</code>才会执行<code>bootcmd</code>。</p>
<h4><span id="2-7-2-4-cli-loop-uboot-ming-ling-xing">2.7.2.4 cli_loop(uboot命令行)</span><a href="#2-7-2-4-cli-loop-uboot-ming-ling-xing" class="header-anchor">#</a></h4><p>再来回到<code>main_loop</code>，如果倒计时结束有按键按下，<code>abortboot</code>返回1，那么<code>autoboot_command</code>函数什么都不干直接返回，执行<code>cli_loop()</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/75.png" alt="image"><br><code>cli_loop</code> 函数是 uboot 的命令行处理函数，我们在 uboot 中输入各种命令，就是<code>cli_loop </code>来处理的，此函数定义在文件 <code>common/cli.c</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/76.png" alt="image"><br>这里我们有定义<code>CONFIG_SYS_HUSH_PARSER</code>，因此执行<code>parse_file_outer-&gt;parse_stream_outer</code>，<code>common/cli_hush.c</code>定义了该函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/77.png" alt="image"><br>该函数调用<code>parse_stream </code>进行命令解析。然后调用<code>run_list </code>函数来执行解析出来的命令。</p>
<h5><span id="2-7-2-4-1-cmd-process-han-shu-fen-xi">2.7.2.4.1 cmd_process 函数分析</span><a href="#2-7-2-4-1-cmd-process-han-shu-fen-xi" class="header-anchor">#</a></h5><p>当命令行有用户输入命令，并且解析到匹配的uboot命令，执行<code>run_list-&gt;run_list_real-&gt;run_pipe_real-&gt;cmd_process</code>。<br>前面提到Uboot中的命令都是调用<code>cmd_process</code>函数来解析执行，如<code>version</code>命令：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/78.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/79.png" alt="image"><br>①先调用<code>find_cmd</code>，返回<code>cmd_tbl_t</code>指针：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/80.png" alt="image"><br>传入的<code>cmd </code>字符串就是所查找的命令名字，uboot 中的命令表其实就是<code>cmd_tbl_t</code>结构体数组。<br><code>ll_entry_start </code>得到数组的第一个元素，也就是命令表起始地址。通过函数<code>ll_entry_count</code>得到数组长度，也就是命令表的长度。<br><code>find_cmd_tbl</code> 在命令表中找到所需的命令，每个命令都有一个<code> name 成员</code>，如下图根据字符串名字去匹配对应的命令：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/81.png" alt="image"><br>②调用<code>cmd_call</code>，执行<code>cmd_tbl_t </code>结构里面对应的处理函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/82.png" alt="image"></p>
<h5><span id="2-7-2-4-2-uboot-ming-ling-ding-yi-dhcp-wei-li">2.7.2.4.2 uboot命令定义(dhcp为例)</span><a href="#2-7-2-4-2-uboot-ming-ling-ding-yi-dhcp-wei-li" class="header-anchor">#</a></h5><p>uboot 使用宏 <code>U_BOOT_CMD </code>来定义命令，宏<code> U_BOOT_CMD</code> 定义在 <code>include/command.h</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/83.png" alt="image"><br>①**<code>ll_entry_declar</code>**<br>定义在文件<code> include/linker_lists.h</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/84.png" alt="image"><br><code>_type</code> 为<code> cmd_tbl_t</code>，因此<code>ll_entry_declare</code>就是定义了一个<code>cmd_tbl_t</code>变量，这里用到了 C 语 言中的<code>##</code>连接符。其中的<code>##_list</code>表示用<code>_list </code>的值来替换，<code>##_name</code>就是用<code>_name </code>的值来替换。<br>比如<code>dhcp</code>命令代入进去：</p>
<p><code>ll_entry_declare(cmd_tbl_t, dhcp, cmd)展开后</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cmd_tbl_t</span> _u_boot_list_2_#<span class="meta">#cmd##_2_##dhcp __aligned(4)		\</span></span><br><span class="line"><span class="meta">	__attribute__((unused,section(<span class="string">&quot;.u_boot_list_2_cmd_2_dhcp)))</span></span></span><br></pre></td></tr></table></figure>

<p>②**<code>U_BOOT_CMD_MKENT_COMPLETE</code>**<br><code># </code>表示将<code> _name</code> 传 递 过 来 的 值 字 符 串 化。<br>继续以<code>dhcp</code>命令代入：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/85.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD_MKENT_COMPLETE(dhcp, <span class="number">3</span>, <span class="number">1</span>, do_dhcp, \</span><br><span class="line"> <span class="string">&quot;boot image via network using DHCP/TFTP protocol&quot;</span>, \</span><br><span class="line"><span class="string">&quot;[loadAddress] [[hostIPaddr:]bootfilename]&quot;</span>, \</span><br><span class="line">NULL);</span><br></pre></td></tr></table></figure>
<p>继续代入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;dhcp&quot;</span>, <span class="number">3</span>, <span class="number">1</span>, do_dhcp, \</span><br><span class="line"> <span class="string">&quot;boot image via network using DHCP/TFTP protocol&quot;</span>, \</span><br><span class="line"> <span class="string">&quot;[loadAddress] [[hostIPaddr:]bootfilename]&quot;</span>,\ </span><br><span class="line"><span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>

<p>最后宏<code> U_BOOT_CMD</code>对<code>dhcp</code>命令展开如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cmd_tbl_t</span> _u_boot_list_2_cmd_2_dhcp __aligned(<span class="number">4</span>) \</span><br><span class="line">__attribute__((unused,section(.u_boot_list_2_cmd_2_dhcp))) = \</span><br><span class="line">&#123; <span class="string">&quot;dhcp&quot;</span>, <span class="number">3</span>, <span class="number">1</span>, do_dhcp, \</span><br><span class="line"><span class="string">&quot;boot image via network using DHCP/TFTP protocol&quot;</span>, \</span><br><span class="line"><span class="string">&quot;[loadAddress] [[hostIPaddr:]bootfilename]&quot;</span>,\</span><br><span class="line"><span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到就是定义了一个<code>cmd_tbl_t</code>结构体变量，对它进行初始化。这个变量名为<code>_u_boot_list_2_cmd_2_dhcp</code>，此变量 4 字节对齐。<br>使 用 <code>__attribute__ </code>关 键 字 设 置 变 量<code>_u_boot_list_2_cmd_2_dhcp</code>存 储 在<code>.u_boot_list_2_cmd_2_dhcp </code>段中。<code>u-boot.lds </code>链接脚本中有一个名为<code>.u_boot_list</code>的段专门存放uboot命令表:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/86.png" alt="image"></p>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-链接脚本lds分析</title>
    <url>/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-u-boot-lds-jie-du-armv8">1 <code>u-boot.lds</code>解读（armv8）</a></li>
<li><a href="#2-u-boot-spl-lds-jie-du-armv8">2 <code>u-boot-spl.lds</code>解读（armv8）</a></li>
<li><a href="#3-u-boot-lds-armv7">3 <code>u-boot.lds</code> (armv7)</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-u-boot-lds-jie-du-armv8">1 <code>u-boot.lds</code>解读（armv8）</span><a href="#1-u-boot-lds-jie-du-armv8" class="header-anchor">#</a></h1><p>文件位于<code>u-boot-2021.10\arch\arm\cpu\armv8\u-boot.lds</code>。分析过程已在<code>lds</code>内部注释了.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0+ */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2013</span></span><br><span class="line"><span class="comment"> * David Feng &lt;fenghua@phytium.com.cn&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2002</span></span><br><span class="line"><span class="comment"> * Gary Jennejohn, DENX Software Engineering, &lt;garyj@denx.de&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/psci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf64-littleaarch64&quot;</span>, <span class="string">&quot;elf64-littleaarch64&quot;</span>, <span class="string">&quot;elf64-littleaarch64&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_start) -------------------------------------------------------------------- (<span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（1）首先定义了二进制程序的输出格式为&quot;elf64-littleaarch64&quot;，</span></span><br><span class="line"><span class="comment"> *    架构是&quot;aarch64&quot;，程序入口为&quot;_start&quot;符号；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV8_SECURE_BASE -------------------------------------------------- (2)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（2）ARMV8_SECURE_BASE是u-boot对PSCI的支持，在定义时可以将PSCI的文本段，</span></span><br><span class="line"><span class="comment"> *    数据段，堆栈段重定向到指定的内存，而不是内嵌到u-boot中。</span></span><br><span class="line"><span class="comment"> *    不过一般厂商实现会使用atf方式使其与bootloader分离，这个功能不常用；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> /DISCARD/ : &#123; *(.rela._secure*) &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> . = <span class="number">0x00000000</span>; -------------------------------------------------------------- (<span class="number">3</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（3）定义了程序链接的基地址，默认是0，通过配置CONFIG_SYS_TEXT_BASE可修改</span></span><br><span class="line"><span class="comment"> *    这个默认值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start) --------------------------------------------------- (<span class="number">4</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（4）__image_copy_start和__image_copy_end用于定义需要重定向的段，</span></span><br><span class="line"><span class="comment"> *    u-boot将启动初始化分为了两个部分，重定向前初始化board_f和</span></span><br><span class="line"><span class="comment"> *    重定向后初始化  board_r，在重定向之前完成一些必要初始化，</span></span><br><span class="line"><span class="comment"> *    包括可能的ddr初始化，然后通过__image_copy_start和__image_copy_end</span></span><br><span class="line"><span class="comment"> *    将u-boot搬运到ddr中，并在ddr中进行重定向后初始化。</span></span><br><span class="line"><span class="comment">  CPUDIR/start.o (.text*) -------------------------------------------------- (5)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（5）定义了链接程序的头部文本段，armv8就是</span></span><br><span class="line"><span class="comment"> *    arch/arm/cpu/armv8/start.S，</span></span><br><span class="line"><span class="comment"> *    start.S中所有文本段将会链接到此段中并且段入口符号就是_start；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* This needs to come before *(.text*) */</span></span><br><span class="line"> .efi_runtime : &#123; ------------------------------------------------------------ (<span class="number">6</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（6）在定义了efi运行时相关支持时才会出现使用的段，一般不用关心；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">		__efi_runtime_start = .;</span><br><span class="line">  *(.text.efi_runtime*)</span><br><span class="line">  *(.rodata.efi_runtime*)</span><br><span class="line">  *(.data.efi_runtime*)</span><br><span class="line">		__efi_runtime_stop = .;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .text_rest : ---------------------------------------------------------------- (<span class="number">7</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（7）除了start.o，其他的所有文本段将会链接到此段中；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#123;</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV8_PSCI -------------------------------------------------------- (8)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（8）同（2），是PSCI相关功能的支持，一般不会使用；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> .__secure_start :</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARMV8_SECURE_BASE</span></span><br><span class="line">  ALIGN(CONSTANT(COMMONPAGESIZE))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> &#123;</span><br><span class="line">  KEEP(*(.__secure_start))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARMV8_SECURE_BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ARMV8_SECURE_BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ARMV8_PSCI_STACK_IN_RAM</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> .secure_text CONFIG_ARMV8_SECURE_BASE :</span><br><span class="line">  AT(ADDR(.__secure_start) + SIZEOF(.__secure_start))</span><br><span class="line"> &#123;</span><br><span class="line">  *(._secure.text)</span><br><span class="line">  . = ALIGN(<span class="number">8</span>);</span><br><span class="line">  __secure_svc_tbl_start = .;</span><br><span class="line">  KEEP(*(._secure_svc_tbl_entries))</span><br><span class="line">  __secure_svc_tbl_end = .;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .secure_data : AT(LOADADDR(.secure_text) + SIZEOF(.secure_text))</span><br><span class="line"> &#123;</span><br><span class="line">  *(._secure.data)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .secure_stack <span class="title function_">ALIGN</span><span class="params">(ADDR(.secure_data) + SIZEOF(.secure_data),</span></span><br><span class="line"><span class="params">	   CONSTANT(COMMONPAGESIZE))</span> <span class="params">(NOLOAD)</span> :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARMV8_PSCI_STACK_IN_RAM</span></span><br><span class="line">  <span class="title function_">AT</span><span class="params">(ADDR(.secure_stack))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="title function_">AT</span><span class="params">(LOADADDR(.secure_data) + SIZEOF(.secure_data))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> &#123;</span><br><span class="line">  KEEP(*(.__secure_stack_start))</span><br><span class="line"></span><br><span class="line">  . = . + CONFIG_ARMV8_PSCI_NR_CPUS * ARM_PSCI_STACK_SIZE;</span><br><span class="line"></span><br><span class="line">  . = ALIGN(CONSTANT(COMMONPAGESIZE));</span><br><span class="line"></span><br><span class="line">  KEEP(*(.__secure_stack_end))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ARMV8_PSCI_STACK_IN_RAM</span></span><br><span class="line"> . = LOADADDR(.secure_stack);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> .__secure_end : AT(ADDR(.__secure_end)) &#123;</span><br><span class="line">  KEEP(*(.__secure_end))</span><br><span class="line">  LONG(<span class="number">0x1d1071c</span>); <span class="comment">/* Must output something to reset LMA */</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> .rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125; ------------------- (<span class="number">9</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（9）所有仅读数据将会在这个段中对齐排序存放好；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> .data : &#123; -------------------------------------------------------------------- (<span class="number">10</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（10）所有数据段将会链接到此段中；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  *(.data*)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> . = .;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> .u_boot_list : &#123; ------------------------------------------------------------- (<span class="number">11</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（11）u_boot_list段定义了系统中当前支持的所有命令和设备驱动，此段把散落在各个文件中</span></span><br><span class="line"><span class="comment"> *     通过U_BOOT_CMD的一系列拓展宏定义的命令和U_BOOT_DRIVER的拓展宏定义的设备驱动收集到一起，</span></span><br><span class="line"><span class="comment"> *     并按照名字排序存放，以便后续在命令行快速检索到命令并执行和检测注册的设备和设备树匹配</span></span><br><span class="line"><span class="comment"> *     probe设备驱动初始化；（设备驱动的probe只在定义了dm模块化驱动时有效）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> .efi_runtime_rel : &#123;</span><br><span class="line">				__efi_runtime_rel_start = .;</span><br><span class="line">  *(.rel*.efi_runtime)</span><br><span class="line">  *(.rel*.efi_runtime.*)</span><br><span class="line">				__efi_runtime_rel_stop = .;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> .image_copy_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> .rel_dyn_start : -------------------------------------------------------- (<span class="number">12</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（12）一般u-boot运行时是根据定义的基地址开始执行，如果加载地址和链接地址</span></span><br><span class="line"><span class="comment"> *     不一致则会出现不能执行u-boot的问题。通过一个</span></span><br><span class="line"><span class="comment"> *     配置CONFIG_POSITION_INDEPENDENT即可打开地址无关功能，</span></span><br><span class="line"><span class="comment"> *     此选项会在链接u-boot时添加-PIE参数。此参数会在u-boot ELF文件中</span></span><br><span class="line"><span class="comment"> *     生成rela*段，u-boot通过读取此段中表的相对地址值与实际运行时地址值</span></span><br><span class="line"><span class="comment"> *     依次遍历进行修复当前所有需要重定向地址，使其可以实现地址无关运行；</span></span><br><span class="line"><span class="comment"> *     即无论链接基地址如何定义，u-boot也可以在任意ram地址</span></span><br><span class="line"><span class="comment"> *     运行（一般需要满足最低4K或者64K地址对齐）；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     注意此功能只能在sram上实现，因为此功能会在运行时修改文本段数据段中的地址，</span></span><br><span class="line"><span class="comment"> *     如果此时运行在片上flash，则不能写flash，导致功能失效无法实现地址无关；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_start)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .rela.dyn : &#123;</span><br><span class="line">  *(.rela*)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .rel_dyn_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_end)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> _end = .;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> .bss_start : &#123; -------------------------------------------------------- (<span class="number">13</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（13）众所周知的bbs段；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  KEEP(*(.__bss_start));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .bss : &#123;</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .bss_end : &#123;</span><br><span class="line">  KEEP(*(.__bss_end));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /DISCARD/ : &#123; *(.dynsym) &#125; -------------------------------------------- (<span class="number">14</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（14）一些在链接时无用需要丢弃的段；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> /DISCARD/ : &#123; *(.dynstr*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.dynamic*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.plt*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.interp*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.gnu*) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LINUX_KERNEL_IMAGE_HEADER ----------------------------------- (15)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（15）在efi加载时会很有用，主要在u-boot的二进制头部添加了一些头部信息，</span></span><br><span class="line"><span class="comment"> *     包括大小端，数据段文本段大小等，以便于efi相关的加载器读取信息，</span></span><br><span class="line"><span class="comment"> *     此头部信息来自于Linux arm64的Image的头部信息；该头部也不属于u-boot的</span></span><br><span class="line"><span class="comment"> *     一部分只是被附加上去的；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux-kernel-image-header-vars.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="2-u-boot-spl-lds-jie-du-armv8">2 <code>u-boot-spl.lds</code>解读（armv8）</span><a href="#2-u-boot-spl-lds-jie-du-armv8" class="header-anchor">#</a></h1><p>文件位于<code>u-boot-2021.10\arch\arm\cpu\armv8\u-boot-spl.lds</code>。一般<code>u-boot-spl</code>只有很小的可运行内存块，所以spl中会舍去大量不需要用的段只保留关键的文本段数据段等，并且通过<code>&gt;.sram</code>的形式将不在ddr初始化前用到的段定义到sdram中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0+ */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2013</span></span><br><span class="line"><span class="comment"> * David Feng &lt;fenghua@phytium.com.cn&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2002</span></span><br><span class="line"><span class="comment"> * Gary Jennejohn, DENX Software Engineering, &lt;garyj@denx.de&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2010</span></span><br><span class="line"><span class="comment"> * Texas Instruments, &lt;www.ti.com&gt;</span></span><br><span class="line"><span class="comment"> *	Aneesh V &lt;aneesh@ti.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">MEMORY &#123; .sram : ORIGIN = IMAGE_TEXT_BASE,</span><br><span class="line">		LENGTH = IMAGE_MAX_SIZE &#125;</span><br><span class="line">MEMORY &#123; .sdram : ORIGIN = CONFIG_SPL_BSS_START_ADDR,</span><br><span class="line">		LENGTH = CONFIG_SPL_BSS_MAX_SIZE &#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf64-littleaarch64&quot;</span>, <span class="string">&quot;elf64-littleaarch64&quot;</span>, <span class="string">&quot;elf64-littleaarch64&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	.text : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(.__image_copy_start)</span><br><span class="line">		CPUDIR/start.o (.text*)</span><br><span class="line">		*(.text*)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(.data*)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_RECOVER_DATA_SECTION</span></span><br><span class="line">	.data_save : &#123;</span><br><span class="line">		*(.__data_save_start)</span><br><span class="line">		. = SIZEOF(.data);</span><br><span class="line">		*(.__data_save_end)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	.u_boot_list : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	.image_copy_end : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(.__image_copy_end)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	.end : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(.__end)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	_image_binary_end = .;</span><br><span class="line"></span><br><span class="line">	.bss_start (NOLOAD) : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		KEEP(*(.__bss_start));</span><br><span class="line">	&#125; &gt;.sdram</span><br><span class="line"></span><br><span class="line">	.bss (NOLOAD) : &#123;</span><br><span class="line">		*(.bss*)</span><br><span class="line">		 . = ALIGN(<span class="number">8</span>);</span><br><span class="line">	&#125; &gt;.sdram</span><br><span class="line"></span><br><span class="line">	.bss_end (NOLOAD) : &#123;</span><br><span class="line">		KEEP(*(.__bss_end));</span><br><span class="line">	&#125; &gt;.sdram</span><br><span class="line"></span><br><span class="line">	/DISCARD/ : &#123; *(.rela*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.dynsym) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.dynstr*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.dynamic*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.plt*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.interp*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.gnu*) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接脚本的开头定义了两段内存空间，分别定义了sram和sdram的起始地址和长度。在i.MX8中，<code>include/config/imx8mp_evk.h</code>, 这两段定义对应于CPU内部的sram和外部的ddr。<br><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/1.png" alt="image"></p>
<p>这里定义了<code>spl-uboot</code>两段空间，一段是从<code>0x920000</code>开始的152K空间，这段空间是内部RAM中的一段。<br>而<code>0x96e000</code>开始的8K空间则是用来存放未初始化的全局变量和未初始化的静态局部变量的BSS数据段，位于外部存储即SDRAM如DDR上，如下图：<br><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/2.png" alt="image"><br><code>bss段</code>存放的是未初始化的全局变量和局部静态变量，<code>.bss</code>不占据实际的文件大小，只在段表中记录大小，在符号表中记录符号。当文件加载运行时，才分配空间以及初始化。所以实际<code>.bss</code>段只会在运行时才分配空间，分配的空间起始地址也就是从<code>.sdram</code>定义的空间里面。此外，一般重定向也是将boot拷贝搬移到外部<code>sdram</code>中去运行，而对于cpu来说这里bss指定的地址本身就已经在sdram中了。这样也说明了，对于 cpu来说，要使用<code>bss</code>的数据，需要将外部sdram初始化后才能使用。<a href="https://www.cnblogs.com/fuzidage/p/12044558.html" title="s3c2440裸机-清bss原理及实现">s3c2440裸机-清bss原理及实现</a>  <a href="https://fuzidage.github.io/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/">s3c2440裸机编程-代码重定位和清bss | Hexo (fuzidage.github.io)</a></p>
<h1><span id="3-u-boot-lds-armv7">3 <code>u-boot.lds</code> (armv7)</span><a href="#3-u-boot-lds-armv7" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf32-littlearm&quot;</span>, <span class="string">&quot;elf32-littlearm&quot;</span>, <span class="string">&quot;elf32-littlearm&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> . = <span class="number">0x00000000</span>;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  *(.vectors)</span><br><span class="line">  arch/arm/cpu/armv7/start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .data : &#123;</span><br><span class="line">  *(.data*)</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> . = .;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .u_boot_list : &#123;</span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .image_copy_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> &#125;</span><br><span class="line"> .rel_dyn_start :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_start)</span><br><span class="line"> &#125;</span><br><span class="line"> .rel.dyn : &#123;</span><br><span class="line">  *(.rel*)</span><br><span class="line"> &#125;</span><br><span class="line"> .rel_dyn_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_end)</span><br><span class="line"> &#125;</span><br><span class="line"> .end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__end)</span><br><span class="line"> &#125;</span><br><span class="line"> _image_binary_end = .;</span><br><span class="line"> . = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> .mmutable : &#123;</span><br><span class="line">  *(.mmutable)</span><br><span class="line"> &#125;</span><br><span class="line"> .bss_start __rel_dyn_start (OVERLAY) : &#123;</span><br><span class="line">  KEEP(*(.__bss_start));</span><br><span class="line">  __bss_base = .;</span><br><span class="line"> &#125;</span><br><span class="line"> .bss __bss_base (OVERLAY) : &#123;</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = ALIGN(<span class="number">4</span>);</span><br><span class="line">   __bss_limit = .;</span><br><span class="line"> &#125;</span><br><span class="line"> .bss_end __bss_limit (OVERLAY) : &#123;</span><br><span class="line">  KEEP(*(.__bss_end));</span><br><span class="line"> &#125;</span><br><span class="line"> .dynsym _image_binary_end : &#123; *(.dynsym) &#125;</span><br><span class="line"> .dynbss : &#123; *(.dynbss) &#125;</span><br><span class="line"> .dynstr : &#123; *(.dynstr*) &#125;</span><br><span class="line"> .dynamic : &#123; *(.dynamic*) &#125;</span><br><span class="line"> .plt : &#123; *(.plt*) &#125;</span><br><span class="line"> .interp : &#123; *(.interp*) &#125;</span><br><span class="line"> .gnu.hash : &#123; *(.gnu.hash) &#125;</span><br><span class="line"> .gnu : &#123; *(.gnu*) &#125;</span><br><span class="line"> .ARM.exidx : &#123; *(.ARM.exidx*) &#125;</span><br><span class="line"> .gnu.linkonce.armexidx : &#123; *(.gnu.linkonce.armexidx.*) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_start </code>在文件<code>arch/arm/lib/vectors.S</code>中有定义,表示代码执行入口，也就是第一条指令要放的位置。注意<code>armv7</code>的入口在<code>vectors.S（armv8在start.s）</code>，中断向量表放在指令入口最开始的位置：可以看到—<code>_start</code>后面就是中断向量表，从图中的:<br><code>.section &quot;.vectors&quot;, &quot;ax”</code><br>可以得到，此代码存放在<code>.vectors </code>段里面。</p>
<p><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/3.png" alt="image"><br>打开<code>u-boot.map</code>如下图：因此代码段的排列顺序为：先放中断向量表，也就是<code>vectors.s</code>，然后再放<code>start.s</code>相关内容，最后放其他的<code>.text段（一大堆built-in.o）</code>。<br><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/4.png" alt="image"><br><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/5.png" alt="image"><br>注意这里为什么<code>uboot.map</code>中<code>_start</code>入口地址为什么是<code>0x8780,0000</code>。   链接脚本指定了程序的运行（链接）地址：<br>程序链接时会指定程序的运行（链接)地址：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o</span><br><span class="line">--start-group  arch/arm/cpu/built-in.o</span><br><span class="line">arch/arm/cpu/armv7/built-in.o</span><br><span class="line">arch/arm/imx-common/built-in.o</span><br><span class="line">arch/arm/lib/built-in.o</span><br><span class="line">board/freescale/common/built-in.o</span><br><span class="line">......</span><br><span class="line">-L /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4</span><br><span class="line">-lgcc -Map u-boot.map</span><br></pre></td></tr></table></figure>

<p>运行地址<code>0x87800000</code>定义在：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">include/configs/mx6_common.h:86:#define CONFIG_SYS_TEXT_BASE    0x87800000</span></span><br></pre></td></tr></table></figure>

<p>可以从<code>u-boot.map</code>获取下面符号的地址：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>数值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>__image_copy_start</code></td>
<td>0x87800000</td>
<td>uboot拷贝的首地址</td>
</tr>
<tr>
<td><code>__image_copy_end</code></td>
<td>0x8785dd54</td>
<td>uboot拷贝的结束地址</td>
</tr>
<tr>
<td><code>__rel_dyn_start</code></td>
<td>0x8785dd54</td>
<td><code>.rel.dyn</code>段起始地址</td>
</tr>
<tr>
<td><code>__rel_dyn_end</code></td>
<td>0x878668f4</td>
<td><code>.rel.dyn</code>段结束地址</td>
</tr>
<tr>
<td><code>_image_binary_end</code></td>
<td>0x878668f4</td>
<td>镜像结束地址</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualbox配置实现PC-虚拟机-开发板互ping</title>
    <url>/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-she-zhi-virtualbox-wang-qia">1 设置virtualbox网卡</a><ul>
<li><a href="#1-1-guan-bi-xu-ni-ji">1.1 关闭虚拟机</a></li>
<li><a href="#1-2-she-zhi-tian-jia-wang-qia">1.2 设置添加网卡</a><ul>
<li><a href="#1-2-1-tian-jia-wang-qia-1-nat-wang-luo">1.2.1 添加网卡1(NAT网络)</a></li>
<li><a href="#1-2-2-tian-jia-wang-qia-2-host-only-wang-luo">1.2.2 添加网卡2(host only网络)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-pei-zhi-windows-he-xu-ni-ji">2 配置windows和虚拟机</a><ul>
<li><a href="#2-1-pei-zhi-window-yi-tai-wang-qia">2.1 配置window以太网卡</a></li>
<li><a href="#2-2-pei-zhi-xu-ni-ji-wang-luo">2.2 配置虚拟机网络</a></li>
</ul>
</li>
<li><a href="#3-ce-shi-shang-wang-zhuang-tai">3 测试上网状态</a></li>
<li><a href="#4-gai-jin-he-you-hua">4 改进和优化</a><ul>
<li><a href="#4-1-windows-ping-xu-ni-ji">4.1 windows ping 虚拟机</a></li>
<li><a href="#4-2-xu-ni-ji-ping-windows">4.2 虚拟机 ping windows</a></li>
<li><a href="#4-3-kai-fa-ban-ping-windows-he-xu-ni-ji">4.3 开发板 ping windows和虚拟机</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-she-zhi-virtualbox-wang-qia">1 设置virtualbox网卡</span><a href="#1-she-zhi-virtualbox-wang-qia" class="header-anchor">#</a></h1><h2><span id="1-1-guan-bi-xu-ni-ji">1.1 关闭虚拟机</span><a href="#1-1-guan-bi-xu-ni-ji" class="header-anchor">#</a></h2><h2><span id="1-2-she-zhi-tian-jia-wang-qia">1.2 设置添加网卡</span><a href="#1-2-she-zhi-tian-jia-wang-qia" class="header-anchor">#</a></h2><p>进入设置-网络</p>
<h3><span id="1-2-1-tian-jia-wang-qia-1-nat-wang-luo">1.2.1 添加网卡1(NAT网络)</span><a href="#1-2-1-tian-jia-wang-qia-1-nat-wang-luo" class="header-anchor">#</a></h3><p>这个网络是主机通过网络地址转换到虚拟机，比如主机用无线网卡WLAN上网，用NAT转换比较合适，这样虚拟机也可以访问外网。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/1.png"></p>
<h3><span id="1-2-2-tian-jia-wang-qia-2-host-only-wang-luo">1.2.2 添加网卡2(host only网络)</span><a href="#1-2-2-tian-jia-wang-qia-2-host-only-wang-luo" class="header-anchor">#</a></h3><p>这个网络是主机通过无线网卡WLAN上外网，但是虚拟机想通过有线网卡和主机、甚至与开发板互相ping通，传输文件。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/2.png"></p>
<p>当然开启host only模式前先确保windows下的virtual host only网卡有开启，如下图：<br><img src="https://img2020.cnblogs.com/blog/1876680/202009/1876680-20200923151634434-1218500133.png"></p>
<p>如果没有请按照下图操作：（这里是添加host only网卡）<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/3.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/4.png"></p>
<h1><span id="2-pei-zhi-windows-he-xu-ni-ji">2 配置windows和虚拟机</span><a href="#2-pei-zhi-windows-he-xu-ni-ji" class="header-anchor">#</a></h1><h2><span id="2-1-pei-zhi-window-yi-tai-wang-qia">2.1 配置window以太网卡</span><a href="#2-1-pei-zhi-window-yi-tai-wang-qia" class="header-anchor">#</a></h2><p>刚添加了虚拟机虚拟virtual host only网卡, 那么我们反正用的WLAN上的外网，为了方便，设置windows下的以太网卡网段和virtual host only网卡保持一致。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/5.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/6.png"></p>
<h2><span id="2-2-pei-zhi-xu-ni-ji-wang-luo">2.2 配置虚拟机网络</span><a href="#2-2-pei-zhi-xu-ni-ji-wang-luo" class="header-anchor">#</a></h2><p>一般默认情况下，虚拟机是通过NAT共享网络给虚拟机用的，那么此时虚拟机也是可以上网的，只是不能和外界开发板进行互相ping, 同时windows主机也不能ping虚拟机。 如下图：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/7.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/8.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/9.png"><br>图中可以看到两块网卡，enp0s3是Ubuntu默认的网卡（NAT），enp0s8是新增的网卡(host only)，可以看到enp0s8还没有分配IP地址，我们需要手工指定一下。sudo vim &#x2F;etc&#x2F;network&#x2F;interfaces将文件内容修改为如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto enp0s8</span><br><span class="line">iface enp0s8 inet static</span><br><span class="line">address 192.168.56.101</span><br><span class="line">netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
<p>再来看下网卡ip信息：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/10.png"></p>
<h1><span id="3-ce-shi-shang-wang-zhuang-tai">3 测试上网状态</span><a href="#3-ce-shi-shang-wang-zhuang-tai" class="header-anchor">#</a></h1><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/11.png"><br>从测试结果上可以看到虚拟机上外网和ping windows主机都是ok的。</p>
<pre><code>  10.80.0.75时无线网卡的ip，
  192.168.56.100是以太网卡的ip,
  192.168.56.101是host only网卡的ip。 
</code></pre>
<p>同理用Windows ping虚拟机也是ok的。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/12.png"></p>
<p>用开发板ping主机和虚拟机发现，只能ping通windows主机，无法ping通虚拟机，如下图。这是为什么呢？<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/13.png"></p>
<p>这是由于我们windows主机和开发板用的网线直连，两个以太网卡在同一网段下，当然能够ping通。但是虚拟机和windows主机用的确是host only网卡（NAT方式用来上外网），这样只能保证虚拟机和Windows主机是互通的，但是却无法被开发板访问，我们的开发板是没有无线网卡的，所以不能用WLAN，因此我们要想让开发板访问到虚拟机还得经过windows的以太网卡。</p>
<p>那么我们虚拟机和windows主机是host only方式，所以我们无法用到以太网卡进行虚拟机和windows主机的交互。所以我们可以采取将host only网卡桥接到以太网卡，进入 网络-更改适配器-同时选中host only网卡和以太网卡，点击右键-选择桥接，如下图所示：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/14.png"></p>
<p>这样我们的虚拟机的host only网卡就可以透过以太网卡和开发板交互了，效果如下：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/15.png"><br>开发板能够ping windows主机和虚拟机。</p>
<h1><span id="4-gai-jin-he-you-hua">4 改进和优化</span><a href="#4-gai-jin-he-you-hua" class="header-anchor">#</a></h1><p>如果不想在windows下进行host only网卡和以太网卡桥接，也可直接把virtualbox的第2路网卡由原来的host only修改成以太网卡桥接模式，如下：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/16.png"></p>
<p>这样需要配置虚拟机的enp0s8网卡和windows主机的以太网卡网段保持一致的。（和前面2.2操作一样）</p>
<h2><span id="4-1-windows-ping-xu-ni-ji">4.1 windows ping 虚拟机</span><a href="#4-1-windows-ping-xu-ni-ji" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/17.png"></p>
<h2><span id="4-2-xu-ni-ji-ping-windows">4.2 虚拟机 ping windows</span><a href="#4-2-xu-ni-ji-ping-windows" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/18.png"></p>
<h2><span id="4-3-kai-fa-ban-ping-windows-he-xu-ni-ji">4.3 开发板 ping windows和虚拟机</span><a href="#4-3-kai-fa-ban-ping-windows-he-xu-ni-ji" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/19.png"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>union和bit_field巧妙进行寄存器位操作</title>
    <url>/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</a></li>
<li><a href="#2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</a><ul>
<li><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</a></li>
<li><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</a></li>
<li><a href="#2-3-du-qu-ji-cun-qi">2.3 读取寄存器</a></li>
<li><a href="#2-4-xie-ji-cun-qi">2.4 写寄存器</a></li>
<li><a href="#2-5-wei-du-qu">2.5 位读取</a></li>
<li><a href="#2-6-wei-xie-ru">2.6 位写入</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</span><a href="#1-union-jie-gou-qu-fen-da-xiao-duan" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> read_bits(stc, field)(&#123;stc.raw = 0x12345678; stc.bits.field;&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> raw;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_a : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_b : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_c : <span class="number">5</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_d : <span class="number">3</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_e : <span class="number">1</span>;</span><br><span class="line">        &#125;bits;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">a</span> <span class="title">num</span>;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%#x, %#x, %#x, %#x, %#x\n&quot;</span>,</span><br><span class="line">        read_bits(num, bit_a),</span><br><span class="line">        read_bits(num, bit_b),</span><br><span class="line">        read_bits(num, bit_c),</span><br><span class="line">        read_bits(num, bit_d),</span><br><span class="line">        read_bits(num, bit_e));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1-1.png" alt="img"></p>
<p>这样的结果，原理如下图:</p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1.png" alt="img"><br>那么从这里可以看出，低地址对应低字节， 因此我们的运行机器是Little Endian。</p>
<p>那么bit_a&#x3D;0x78; bit_b&#x3D;0x56; bit_c等于0x34取低5位，也就是0x14; bit_d 等于0x34取高3位，也就是0x1； bit_e等于0x12取最低位，也就是0。</p>
<p>由于这里的num是union结构，因此对.raw进行操作，那么也就等于对.bits也进行了操作，那么返回bit field是不是和寄存器的位操作很类似。下面详细介绍如何用union和bit field巧妙进行寄存器位操作。</p>
<h1><span id="2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</span><a href="#2-ji-cun-qi-de-wei-cao-zuo" class="header-anchor">#</a></h1><p>举个例子，这是mipi-rx DPHY的寄存器的部分截取：</p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/2.png" alt="img"></p>
<p>那么我们可以对该module进行结构定义如下：(当然如果觉得手动去定义麻烦，网上有专门的python工具可以对excel到寄存器定义的转换)<br><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/3.png" alt="img"></p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/4.png" alt="img"></p>
<p>这里对该module的每个寄存器都定义成union。</p>
<h2><span id="2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</span><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">＃define <span class="title function_">offsetof</span><span class="params">(<span class="type">struct_t</span>,member)</span> <span class="params">( (<span class="type">int</span>)&amp;((<span class="type">struct_t</span> *)<span class="number">0</span>)-&gt;member )</span></span><br></pre></td></tr></table></figure>

<p>(struct_t <em>)0)，可以看到这里*<em>把一个0地址转换成一个指针，它表示一个结构体指针变量，并且是值&#x3D;0的指针</em></em>, 那么访问它的成员，成员的地址自然就会往后递增，因此该成员的地址那么就等于该成员的偏移量。</p>
<p>eg:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么offsetof(struct student, id)就为100 + 4&#x3D;104，同理.name的offsetof为0，.age的offsetof为100，.sex的offsetof为108。</p>
<h2><span id="2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</span><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti" class="header-anchor">#</a></h2><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/5.png" alt="img"></p>
<p>该函数实现位于include&#x2F;linux&#x2F;kernel.h， 源码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;            \</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span>(<span class="params"> ((type *</span>)0)-&gt;member ) *__mptr</span> = (ptr);    \</span><br><span class="line">    (type *)( (<span class="built_in">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>定义一个结构体成员指针mptr指向该成员，</li>
<li>用该成员指针减去该成员在结构体中的偏移量，不就是该结构体的起始地址</li>
</ol>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/6.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>=</span>&#123;.name=<span class="string">&quot;robin&quot;</span>, .age=<span class="number">18</span>, .id=<span class="number">123456</span>, .sex=<span class="string">&#x27;M&#x27;</span>&#125;, *pstu;</span><br><span class="line">pstu = container_of(&amp;stu.sex, <span class="keyword">struct</span> student, sex);</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-du-qu-ji-cun-qi">2.3 读取寄存器</span><a href="#2-3-du-qu-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_read(addr) readl((void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DPHY_BA_ADDR (0x0300b000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OFST(_BLK_T, _REG)       ((uint64_t)&amp;(((struct _BLK_T *)0)-&gt;_REG))//this is same with offsetof</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD_REG(_BA, _BLK_T, _REG) \</span></span><br><span class="line">(_reg_read(_BA+_OFST(_BLK_T, _REG)))</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RD_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08);</span><br></pre></td></tr></table></figure>

<p>这样就表示对该module的REG_08的寄存器进行了read。</p>
<h2><span id="2-4-xie-ji-cun-qi">2.4 写寄存器</span><a href="#2-4-xie-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_write(addr, data) writel(data, (void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR_REG(_BA, _BLK_T, _REG, _V) \</span></span><br><span class="line">                (_reg_write((_BA+_OFST(_BLK_T, _REG)), _V))</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WR_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, <span class="number">0x3333ffff</span>);</span><br></pre></td></tr></table></figure>

<p>这样就表示对该module的REG_08的寄存器进行了write, write的数据为0x3333ffff。</p>
<h2><span id="2-5-wei-du-qu">2.5 位读取</span><a href="#2-5-wei-du-qu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RD_BITS(_BA, _BLK_T, _REG, _FLD) \</span></span><br><span class="line">        (&#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD;\</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RD_BITS</span>(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1);</span><br></pre></td></tr></table></figure>

<p>这里首先是定义了一个module的REG_08的寄存器结构，typeof表示对该成员取数据结构类型，然后把该寄存器里的值读出来，最后返回bit[31:16]。</p>
<h2><span id="2-6-wei-xie-ru">2.6 位写入</span><a href="#2-6-wei-xie-ru" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WR_BITS(_BA, _BLK_T, _REG, _FLD, _V) \</span></span><br><span class="line">        <span class="keyword">do</span> &#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD = _V;\</span><br><span class="line">                _reg_write((_BA+_OFST(_BLK_T, _REG)), _r.raw);\</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">WR_BITS(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1, <span class="number">0x1111</span>);</span><br></pre></td></tr></table></figure>

<p>这里首先是定义了一个module的REG_08的寄存器结构，然后把该寄存器里的值读出来, 再把该寄存器的bit[31:16]写入0x1111。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>卷帘快门RollingShutter与全局快门GlobalShutter</title>
    <url>/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-global-shutter">1 Global Shutter</a></li>
<li><a href="#2-rolling-shutter">2 Rolling Shutter</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-global-shutter">1 Global Shutter</span><a href="#1-global-shutter" class="header-anchor">#</a></h1><p>通过整幅场景在同一时间曝光实现的。Sensor所有像素点同时收集光线，同时曝光。即在曝光开始的时候，Sensor开始收集光线；在曝光结束的时候，光线收集电路被切断。CCD就是Global shutter工作方式。所有像元同时曝光</p>
<h1><span id="2-rolling-shutter">2 Rolling Shutter</span><a href="#2-rolling-shutter" class="header-anchor">#</a></h1><p>与Global shutter不同，它是通过Sensor逐行曝光的方式实现的。在曝光开始的时候，Sensor逐行扫描逐行进行曝光，直至所有像素点都被曝光。</p>
<p>对比优缺点:</p>
<p>Global shutter： 曝光时间更短，但会增加读出噪声；</p>
<p>Rolling shutter：可以达到更高的帧速，噪声小，但是运动场景会产生果冻效应。</p>
<p>卷帘快门与全局快门大致原理如下图：</p>
<p align="left">&nbsp;<img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/1.gif" alt width="292" height="165" loading="lazy"></p>

<p>卷帘快门：</p>
<p><img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/2.gif" alt width="409" height="187" loading="lazy"></p>

<p><strong>适用性：</strong></p>
<table>
<thead>
<tr>
<th><strong>Global shutter</strong></th>
<th><strong>rolling shutter</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>曝光时间短的应用（如</strong><strong>&lt;500μs****）</strong></td>
<td><strong>曝光时间长（如大于<strong><strong>500μs</strong></strong>）的应用可以有更低的噪声和帧速</strong></td>
</tr>
<tr>
<td><strong>快速移动物体拍适合</strong></td>
<td><strong>静止的物体适合</strong></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>mipi图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware双网卡_NAT_桥接</title>
    <url>/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-pei-zhi-xu-ni-ji-net-mo-shi">1 配置虚拟机NET模式</a></li>
<li><a href="#2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo">2 配置虚拟机桥接网络</a><ul>
<li><a href="#2-1-fang-fa-1-shi-yong-usb-wang-qia">2.1 方法1：使用usb网卡</a></li>
<li><a href="#2-1-fang-fa-2-shi-yong-lu-you-qi">2.1 方法2：使用路由器</a><ul>
<li><a href="#2-1-1-tian-jia-qiao-jie-wang-qia">2.1.1 添加桥接网卡</a></li>
<li><a href="#2-1-2-pei-zhi-qiao-jie-wang-qia">2.1.2 配置桥接网卡</a></li>
<li><a href="#2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip">2.1.3 配置虚拟机桥接网卡静态ip</a></li>
<li><a href="#2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip">2.1.4 配置windows主机桥接网卡ip</a></li>
<li><a href="#2-1-5-pei-zhi-kai-fa-ban-ip">2.1.5 配置开发板IP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-pei-zhi-xu-ni-ji-net-mo-shi">1 配置虚拟机NET模式</span><a href="#1-pei-zhi-xu-ni-ji-net-mo-shi" class="header-anchor">#</a></h1><p>vmware安装后默认就会用NAT方式和pc主机共享网络，虚拟机是通过pc主机的网卡数据转换进行上网的，只要windows主机有网，虚拟机就会对应有网络。<br>NAT模式在这里主要目的就是提供给虚拟机进行上网。<br>如果没有可以进行如下配置，打开虚拟机-&gt;编辑虚拟机设置-&gt;网络适配器,网络连接选择NAT模式如下图：</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/1.png" alt="img"></p>
 <span id="more"></span>

<p>启动进入虚拟机，console输入ifconfig</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/2.png" alt="img"></p>
<p> windows进入cmd,输入ipconfig</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/3.png" alt="img"></p>
<p> VMware Network Adapter VMnet8是虚拟机启用NAT模式后多出来的虚拟网卡，可以看到ip为192.168.70.1，和虚拟机的192.168.70.128同一网段。下图可以看到都可以ping通，且都能访问外网。</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/4.png" alt="img"></p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/5.png" alt="img"></p>
<p> windows搜索框输入vmnet,进入虚拟网络编辑器，可以看到虚拟网络信息，有这个VMnet8，模式为NAT</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/6.png" alt="img"></p>
<h1><span id="2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo">2 配置虚拟机桥接网络</span><a href="#2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo" class="header-anchor">#</a></h1><h2><span id="2-1-fang-fa-1-shi-yong-usb-wang-qia">2.1 方法1：使用usb网卡</span><a href="#2-1-fang-fa-1-shi-yong-usb-wang-qia" class="header-anchor">#</a></h2><p>需要买一个usb网卡，连接板子和windows主机。双网卡配置参考如下视频： <a href="https://www.bilibili.com/video/BV1zV411U7H9?p=3">https://www.bilibili.com/video/BV1zV411U7H9?p=3</a></p>
<h2><span id="2-1-fang-fa-2-shi-yong-lu-you-qi">2.1 方法2：使用路由器</span><a href="#2-1-fang-fa-2-shi-yong-lu-you-qi" class="header-anchor">#</a></h2><h3><span id="2-1-1-tian-jia-qiao-jie-wang-qia">2.1.1 添加桥接网卡</span><a href="#2-1-1-tian-jia-qiao-jie-wang-qia" class="header-anchor">#</a></h3><p>桥接网络使用实际的物理网卡进行数据交换，因此需要借助实际的物理网卡，可以是有线网卡，也可以是无线网卡。桥接的目的是为了让虚拟机和主机以及板子能够互相进行收据收发传送。打开虚拟机，配置如下：</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/7.png" alt="img"></p>
<h3><span id="2-1-2-pei-zhi-qiao-jie-wang-qia">2.1.2 配置桥接网卡</span><a href="#2-1-2-pei-zhi-qiao-jie-wang-qia" class="header-anchor">#</a></h3><p>打开vmnet,进入虚拟网络编辑器,在这个里面要把桥接网卡选择成具体的网卡型号，不能设置为自动桥接。注意：这里根据你电脑主机接路由器的网卡，如果你用的无线网卡与路由器通信，那么就要桥接到无线网卡，如果是接网线到路由器，那就要用有线网卡。具体的网卡名字可以进入入网络共享中心-&gt;更改适配器选项或者进入设备管理器来确认清楚。</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/8.png" alt="img"></p>
<p>配置完桥接网卡后，需要配置桥接网卡对应到window主机&#x2F;虚拟机&#x2F;板子的ip.</p>
<h3><span id="2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip">2.1.3 配置虚拟机桥接网卡静态ip</span><a href="#2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip" class="header-anchor">#</a></h3><p>ifconfig查看，发现桥接的网卡在虚拟机中还没有分配ip.</p>
<p> <img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/9.png" alt="img"></p>
<p>进入ubuntu setting-&gt; network， 设置成和路由器同一网段即可。配置ens36 ip为192.168.2.100</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/10.png" alt="img"></p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/11.png" alt="img"></p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/12.png" alt="img"></p>
<h3><span id="2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip">2.1.4 配置windows主机桥接网卡ip</span><a href="#2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip" class="header-anchor">#</a></h3><p>桥接网卡为intel Ethernet Connection I219-V ,ip 192.168.2.6</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/13.png" alt="img"></p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/14.png" alt="img"></p>
<h3><span id="2-1-5-pei-zhi-kai-fa-ban-ip">2.1.5 配置开发板IP</span><a href="#2-1-5-pei-zhi-kai-fa-ban-ip" class="header-anchor">#</a></h3><p><strong>三者互 ping 验证:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows ip: 192.168.2.6</span><br><span class="line">ubuntu ip:  192.168.2.100</span><br><span class="line">开发板 ip:   192.168.2.xxx</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/15.png" alt="img"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码与freetype移植</title>
    <url>/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zi-fu-bian-ma">1 字符编码</a><ul>
<li><a href="#1-1-ascii-bian-ma">1.1 ASCII编码</a></li>
<li><a href="#1-2-ansi">1.2 ANSI</a></li>
<li><a href="#1-3-unicode">1.3 UNICODE</a><ul>
<li><a href="#1-3-1-utf-16-le">1.3.1 UTF-16 LE</a></li>
<li><a href="#1-3-2-utf-16-be">1.3.2 UTF-16 BE</a></li>
</ul>
</li>
<li><a href="#1-4-utf8">1.4 UTF8</a></li>
</ul>
</li>
<li><a href="#2-zhong-wen-zi-ku-yi-zhi">2 中文字库移植</a><ul>
<li><a href="#2-1-finput-charset-fexec-charset-bian-yi-xuan-xiang">2.1 -finput-charset -fexec-charset编译选项</a></li>
<li><a href="#2-2-gb2312-zhuan-wei-utf-8">2.2 GB2312 转为 UTF-8</a></li>
<li><a href="#2-3-utf-8-zhuan-wei-gb2312">2.3 UTF-8 转为 GB2312</a></li>
<li><a href="#2-4-hzk16-zhong-wen-zi-ku">2.4 HZK16中文字库</a></li>
</ul>
</li>
<li><a href="#3-freetype-yi-zhi">3 freetype移植</a><ul>
<li><a href="#3-1-shi-liang-zi-ti">3.1 矢量字体</a></li>
<li><a href="#3-2-xia-zai-freetype">3.2 下载freetype</a></li>
<li><a href="#3-3-bian-yi-freetype">3.3 编译freetype</a><ul>
<li><a href="#3-3-1-she-zhi-gong-ju-lian">3.3.1 设置工具链</a></li>
<li><a href="#3-3-2-bian-yi-zlib">3.3.2 编译zlib</a></li>
<li><a href="#3-3-3-bian-yi-libpng">3.3.3 编译libpng</a></li>
<li><a href="#3-3-4-bian-yi-freetype">3.3.4 编译freetype</a></li>
</ul>
</li>
<li><a href="#3-4-ce-shi">3.4 测试</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zi-fu-bian-ma">1 字符编码</span><a href="#1-zi-fu-bian-ma" class="header-anchor">#</a></h1><h2><span id="1-1-ascii-bian-ma">1.1 ASCII编码</span><a href="#1-1-ascii-bian-ma" class="header-anchor">#</a></h2><p>ascii是“American Standard Code for Information Interchange”的缩写， 美国信息交换标准代码。</p>
<p>电脑毕竟是西方人发明的，他们常用字母就 26 个，区分大小写、加上标点符号也没超过 127 个，每个字符用一个字节来表示就足够了。一个字节的 7 位就可以表示 128 个数值，在 ASCII 码中最高位永远是 0。</p>
<p>linux-4.18.16&#x2F;lib&#x2F;fonts这个目录下就有对应文件。在这里我挑选font_8x16.c</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/1.png" alt="img"></p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/2.png" alt="img"></p>
<h2><span id="1-2-ansi">1.2 ANSI</span><a href="#1-2-ansi" class="header-anchor">#</a></h2><p>ASNI 是 ASCII 的扩展，向下包含 ASCII。对于 ASCII 字符仍以一个字节来表示。</p>
<p>对于非 ASCII 字符则使用 2 字节来表示。并没有固定的 ASNI 编码。</p>
<p>比如在中国大陆地区， ANSI 的默认编码是 GB2312；</p>
<p>在港澳台地区默认编码是 BIG5。以数值“ 0xd0d6”为例，对于 GB2312 编码它表示“中”；对于 BIG5 编码它表示“ 笢”。</p>
<p>用ANSI编码字符’aa中’的16进制数据</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/3.png" alt="img"></p>
<h2><span id="1-3-unicode">1.3 UNICODE</span><a href="#1-3-unicode" class="header-anchor">#</a></h2><p>在 ANSI 标准中，很多种文字都有自己的编码标准，汉字简体字有 GB2312、繁体字有 BIG5，这难免同一个数值对应不同字符。比如数值“ 0xd0d6”，对于GB2312 编码它表示“中”；对于 BIG5 编码它表示“ 笢”。这造成了使用 ANSI 编码保存的文件，不适合跨地区交流。</p>
<p>UNICODE 编码就是解决这类问题：对于地球上任意一个字符，都给它一个唯一的数值。</p>
<ol>
<li>ASCII 编码中使用一个字节来表示一个字符，只用到其中的 7 位，最高位恒为 0；</li>
<li>ANSI 编码中，对于 ASCII 字符仍使用一个字节来表示(BIT7 是 0)，对于非ASCII 字符一般使用 2 个字节来表示，非 ASCII 字符的数值 BIT7 都是 1</li>
</ol>
<h3><span id="1-3-1-utf-16-le">1.3.1 UTF-16 LE</span><a href="#1-3-1-utf-16-le" class="header-anchor">#</a></h3><p>每个 UNICODE 值用 3 字节来表示有点浪费，那只用 2 字节呢？它可以表示2^16&#x3D;65536 个字符，全世界常用的字符都可以表示了。Little endian 表示小字节序，数值中权重低的字节放在前面，比如字符“ A 中”在 TXT 文件中的数值如下，其中的“ A”使用“0x41 0x00”两字节表示；“中”使用“ 0x2d 0x4e”两字节表示。文件开头的“ 0xff 0xfe”表示“UTF-16 LE”。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/4.png" alt="img"></p>
<h3><span id="1-3-2-utf-16-be">1.3.2 UTF-16 BE</span><a href="#1-3-2-utf-16-be" class="header-anchor">#</a></h3><p>Big endian 表示大字节序，数值中权重低的字节放在后面，比如字符“ ab中”在 TXT 文件中的数值如下，其中的“ A”使用“ 0x00 0x41”两字节表示；“中”使用“ 0x4e 0x2d”两字节表示。文件开头的“ 0xfe 0xff”表示“UTF-16 BE”。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/5.png" alt="img"></p>
<h2><span id="1-4-utf8">1.4 UTF8</span><a href="#1-4-utf8" class="header-anchor">#</a></h2><p>UTF8 是一种变长的编码方法，有 2 种 UTF8格式的文件：带有头部、不带头部。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/6.png" alt="img"></p>
<p>对于 ASCII 字符用UTF-16有空间浪费、而且文件中有某个字节丢失，这会使得后面所有字符都因为错位而无法显示。UTF8则不会有这样的问题。0x41表示大写字母’A’，只用了一个字节。上图中的 3 个字节“ 0xe4 0xb8 0xad”表示的数值是 0x4e2d，对应“中”的 UNICODE 码.</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/7.png" alt="img"></p>
<p>上图中， 0xe4 的二进制是“ 11100100”，高位有 3 个 1，表示从当前字节起有 3 字节参与表示 UNICODE；<br>0xb8 的二进制是“10111000”，高位有 1 个 1，表示从当前字节起有 1 字节参与表示 UNICODE；<br>0xad 的二进制是“10101101”，高位有 1 个 1，表示从当前字节起有 1 字节参与表示 UNICODE；<br>除去高位的“ 1110”、“ 10”、“ 10”后，剩下的二进制数组合起来得到“ 01001110001101”，它就是 0x4e2d，即“中”的 UNICODE 值。</p>
<p>使用 UTF8 编码时，即使 TXT 文件中丢失了某些数据，也只会影响到当前字符的显示，后面的字符不受影响。</p>
<h1><span id="2-zhong-wen-zi-ku-yi-zhi">2 中文字库移植</span><a href="#2-zhong-wen-zi-ku-yi-zhi" class="header-anchor">#</a></h1><h2><span id="2-1-finput-charset-fexec-charset-bian-yi-xuan-xiang">2.1 -finput-charset -fexec-charset编译选项</span><a href="#2-1-finput-charset-fexec-charset-bian-yi-xuan-xiang" class="header-anchor">#</a></h2><p>我们编写 C 程序时，可以使用 ANSI 编码，或是 UTF-8 编码；在编译程序时，可以使用以下的选项告诉编译器用什么方式编码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-finput-charset=GB2312</span><br><span class="line">-finput-charset=UTF<span class="number">-8</span></span><br></pre></td></tr></table></figure>

<p>如果不指定<code>-finput-charset</code>， GCC 就会默认 C 程序的编码方式为 UTF8。</p>
<ol>
<li><p>用ANSI格式编写编码，vim浏览显示会乱码，用notepad++采用ANSI编码格式浏览。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/8.png" alt="img"></p>
</li>
</ol>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/9.png" alt="img"></p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/10.png" alt="img"></p>
<p>由于编译器默认用utf8编码，所以看到最终打印是乱码的。可以看到“中”的ANSI码是d6 d0。</p>
<ol start="2">
<li><p>用utf8编写代码</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/11.png" alt="img"></p>
</li>
</ol>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/12.png" alt="img"></p>
<p>最终打印是OK的。可以看到“中”的utf8码是e4 b8 ad。</p>
<h2><span id="2-2-gb2312-zhuan-wei-utf-8">2.2 GB2312 转为 UTF-8</span><a href="#2-2-gb2312-zhuan-wei-utf-8" class="header-anchor">#</a></h2><p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/13.png" alt="img"></p>
<p>从上面的输出信息可以看出来， GB2312 的”0xd6 0xd0”可以转换为 UTF-8的“ 0xe4 0xb8 0xad”。而如果把原本就是 UTF-8 格式的 test_charset_utf8.c当作 GB2312 格式，会引起错误.</p>
<h2><span id="2-3-utf-8-zhuan-wei-gb2312">2.3 UTF-8 转为 GB2312</span><a href="#2-3-utf-8-zhuan-wei-gb2312" class="header-anchor">#</a></h2><p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/14.png" alt="img"></p>
<p>从 上 面 的 输 出 信 息 可 以 看 出 来 ， 如 果 把 原 本 就 是 GB2312 格 式 test_charset_ansi.c 当成UTF-8 格式，会引起错误。而 UTF-8 格式的“中”编码值为“ 0xe4 0xb8 0xad”，可以转换为 GB2312 的“0xd6 0xd0”</p>
<h2><span id="2-4-hzk16-zhong-wen-zi-ku">2.4 HZK16中文字库</span><a href="#2-4-hzk16-zhong-wen-zi-ku" class="header-anchor">#</a></h2><p>HZK16字库里的16×16汉字一共需要256个点来显示，也就是说需要32个字节才能达到显示一个普通汉字的目的。符合GB2312标准。</p>
<p>一个GB2312汉字是由两个字节编码的，范围为A1A1~FEFE。A1-A9为符号区，B0到F7为汉字区。每一个区有94个字符。</p>
<p>HZK16 中是以 GB2312 编码值来查找点阵的，以“中”字为例，它的编码值是“ 0xd6 0xd0”，其中的 0xd6 表示“区码”，表示在哪一个区；其中的 0xd0 表示“位码”，表示它是这个区里的哪一个字符。每一个区有 94 个汉字。区位码从 0xa1 而不是从 0 开始，是为了兼容 ASCII码。</p>
<p>要显示“中”字， 它的 GB2312 编码是 d6d0，它是 HZK16 里第“ (0xd6-0xa1)*94+(0xd0-0xa1)”个字符。(0xd6-0xa1)表示是哪个区，(0xd0-0xa1)表示是哪个位。</p>
<p>如何获取和显示汉字”中“?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd_hzk16 = open(<span class="string">&quot;HZK16&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd_hzk16 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open HZK16\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fstat(fd_hzk16, &amp;hzk_stat))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get fstat\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">hzkmem = (<span class="type">unsigned</span> <span class="type">char</span> *)mmap(<span class="literal">NULL</span> , hzk_stat.st_size, PROT_READ, MAP_SHARED, fd_hzk16, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hzkmem == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap for hzk16\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载HZK16字库，读取并且mmap字库：</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/15.png" alt="img"></p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/16.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该函数在 LCD 的(x,y)位置处显示汉字字符 str， str[0]中保存区码、 str[1]中保存位码。</span><br><span class="line">第 4734 行确定该汉字属于哪个区；第 4735 行确实它是该区中哪一个汉字。</span><br><span class="line">第 4736 行确实它的字库地址（第多少个字节）：每个区中有 94 个汉字，每个汉字在字库中占据 32 字节。</span><br></pre></td></tr></table></figure>

<p>根据下图来理解字库中每个像素点是如何显示的:</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/17.png" alt="img"></p>
<p>总共有十六行，因此需要一个循环 16次的大循环(第 4740 行)。</p>
<p>考虑到一行有两个字节， 在大循环中加入一个 2 次的循环用于区分是哪个字节(第 4741 行)。</p>
<p>最后使用第 3 个循环来处理一个字节中的 8 位(第 4744 行)。对于每一位，它等于 1 时对应的像素被设置为白色，它等于 0 时对应的像素被设置为黑色。需要注意的是根据 x、 y、 i、 j、 b 来计算像素坐标。</p>
<p>测试：</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/18.png" alt="img"></p>
<p>注意：使用上述命令时 show_chinese.c 的编码格式必须是 ANSI(GB2312)，因为HZK16字库是按照GB2312编码的，否则编译时需要指定“ -fexec-charset&#x3D;GB2312”。</p>
<h1><span id="3-freetype-yi-zhi">3 freetype移植</span><a href="#3-freetype-yi-zhi" class="header-anchor">#</a></h1><p>FreeType库是一个完全免费（开源）的、高质量的且可移植的字体引擎。Freetype 是开源的字体引擎库， 它提供统一的接口来访问多种字体格式文件，从而实现矢量字体显示。我们只需要移植这个字体引擎，调用对应的 API 接口，提供字体文件，就可以让 freetype 库帮我们取出关键点、实现闭合曲线， 填充颜色， 达到显示矢量字体的目的。</p>
<p>这里仅移植freetype库，freetype的使用不做具体展开。可以从 <a href="https://www.freetype.org/">https://www.freetype.org/</a> 可 以 下 载 到 “ freetype-doc-2.10.2.tar.xz”。</p>
<h2><span id="3-1-shi-liang-zi-ti">3.1 矢量字体</span><a href="#3-1-shi-liang-zi-ti" class="header-anchor">#</a></h2><p>使用点阵字库显示英文字母、汉字时， 大小固定， 如果放大缩小则会模糊甚至有锯齿出现，为了解决这个问题，引用矢量字体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1步 确定关键点，</span><br><span class="line">第2步 使用数学曲线（ 贝塞尔曲线） 连接头键点，</span><br><span class="line">第3步 填充闭合区线内部空间。</span><br></pre></td></tr></table></figure>

<p>什么是关键点？以字母“ A”为例:</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/19.png" alt="img"></p>
<p>再用数学曲线(比如贝塞尔曲线)将关键点都连接起来， 得到一系列的封闭的曲线:</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/20.png" alt="img"></p>
<p>最后把封闭空间填满颜色，就显示出一个 A 字母:</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/21.png" alt="img"></p>
<p>如果需要放大或者缩小字体，关键点的相对位置是不变的， 只要数学曲线平滑，字体就不会变形。</p>
<h2><span id="3-2-xia-zai-freetype">3.2 下载freetype</span><a href="#3-2-xia-zai-freetype" class="header-anchor">#</a></h2><p><a href="https://freetype.org/download.html">https://freetype.org/download.html</a></p>
<p><a href="https://download.savannah.gnu.org/releases/freetype/">https://download.savannah.gnu.org/releases/freetype/</a></p>
<p>freetype 依赖于 libpng， libpng 又依赖于 zlib，所以我们应该：先编译安装 zlib，再编译安装 libpng，最后编译安装 freetype。 但是，有些工具链里有 zlib, 那就不用编译安装 zlib.</p>
<p>下载安装libpng: <a href="https://www.linuxfromscratch.org/blfs/view/svn/general/libpng.html">https://www.linuxfromscratch.org/blfs/view/svn/general/libpng.html</a></p>
<p>下载安装zlib: <a href="https://www.zlib.net/fossils/">https://www.zlib.net/fossils/</a></p>
<h2><span id="3-3-bian-yi-freetype">3.3 编译freetype</span><a href="#3-3-bian-yi-freetype" class="header-anchor">#</a></h2><h3><span id="3-3-1-she-zhi-gong-ju-lian">3.3.1 设置工具链</span><a href="#3-3-1-she-zhi-gong-ju-lian" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;main()&#123;&#125;&#x27;</span>| arm-buildroot-linux-gnueabihf-gcc -E -v -</span><br></pre></td></tr></table></figure>

<p>得到头文件的系统目录为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/include</span><br><span class="line"></span><br><span class="line">/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/include-fixed</span><br><span class="line"> </span><br><span class="line">/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/../../../../arm-buildroot-linux-gnueabihf/include</span><br><span class="line"></span><br><span class="line">/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/include</span><br></pre></td></tr></table></figure>

<p>库文件系统目录为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COMPILER_PATH=/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../libexec/gcc/arm-buildroot-linux-gnueabihf/7.5.0/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../libexec/gcc/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/../../../../arm-buildroot-linux-gnueabihf/bin/</span><br><span class="line"></span><br><span class="line">LIBRARY_PATH=/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/../../../../arm-buildroot-linux-gnueabihf/lib/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/lib/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/lib/</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-2-bian-yi-zlib">3.3.2 编译zlib</span><a href="#3-3-2-bian-yi-zlib" class="header-anchor">#</a></h3><p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/22.png" alt="img"></p>
<p>编译zlib库时，.&#x2F;configure不允许传入–host参数；不支持的话需要export CC设置为你的arm工具链</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=arm-buildroot-linux-gnueabihf-gcc</span><br><span class="line">./configure --prefix=<span class="variable">$PWD</span>/tmp</span><br><span class="line">make;make install</span><br><span class="line"><span class="built_in">cd</span> tmp/lib;<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>将lib和头文件拷贝到工具链目录(或者不拷贝，到时候编译用-L, -I指定即可，运行时指定LIBRARY_PATH)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cp include<span class="comment">/* -rf /home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/include</span></span><br><span class="line"><span class="comment">cp lib/* -rfd /home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/../../../../arm-buildroot-linux-gnueabihf/lib</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-3-3-bian-yi-libpng">3.3.3 编译libpng</span><a href="#3-3-3-bian-yi-libpng" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host= arm-buildroot-linux-gnueabihf --prefix=<span class="variable">$PWD</span>/tmp</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> tmp/lib;<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/23.png" alt="img"></p>
<p>将lib和头文件拷贝到工具链目录。</p>
<h3><span id="3-3-4-bian-yi-freetype">3.3.4 编译freetype</span><a href="#3-3-4-bian-yi-freetype" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host= arm-buildroot-linux-gnueabihf --prefix=<span class="variable">$PWD</span>/tmp</span><br><span class="line">Make</span><br><span class="line">Make  install</span><br></pre></td></tr></table></figure>

<p>注意：如果你的工具链路径不是 <code>/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot</code>，那么make时会出现类似如下错误。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/24.png" alt="img"></p>
<p>修改自己工具链下的$(TOOLCHAIN)&#x2F;arm-buildroot-linux-gnueabihf&#x2F;sysroot&#x2F;usr&#x2F;lib目录下编辑libfreetype.la, 替换dependency_libs和libdir的路径。来自 &lt; <a href="http://bbs.100ask.net/question/15908%3E">http://bbs.100ask.net/question/15908&gt;</a></p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/25.png" alt="img"></p>
<p>libfreetype库如下：</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/26.png" alt="img"></p>
<p>将lib和头文件拷贝到工具链目录。</p>
<h2><span id="3-4-ce-shi">3.4 测试</span><a href="#3-4-ce-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc freetype_show_font.c -I /media/cvitek/robin.lee/my_test/study/weidongshan/<span class="number">100</span>ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/include/freetype2/ -L /media/cvitek/robin.lee/my_test/study/weidongshan/<span class="number">100</span>ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/lib -lfreetype</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ft2build.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_FREETYPE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_GLYPH_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd_fb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span>        <span class="comment">/* Current var */</span></span><br><span class="line"><span class="type">int</span> screen_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *fbmem;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> line_width;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pixel_width;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * 函数名称： lcd_put_pixel</span></span><br><span class="line"><span class="comment"> * 功能描述： 在LCD指定位置上输出指定颜色（描点）</span></span><br><span class="line"><span class="comment"> * 输入参数： x坐标，y坐标，颜色</span></span><br><span class="line"><span class="comment"> * 输出参数： 无</span></span><br><span class="line"><span class="comment"> * 返 回 值： 会</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pen_8 = fbmem+y*line_width+x*pixel_width;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *pen_16;        </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *pen_32;        </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> red, green, blue;        </span><br><span class="line"></span><br><span class="line">    pen_16 = (<span class="type">unsigned</span> <span class="type">short</span> *)pen_8;</span><br><span class="line">    pen_32 = (<span class="type">unsigned</span> <span class="type">int</span> *)pen_8;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (var.bits_per_pixel) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: &#123;</span><br><span class="line">            *pen_8 = color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>: &#123;</span><br><span class="line">            <span class="comment">/* 565 */</span></span><br><span class="line">            red   = (color &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            green = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            blue  = (color &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            color = ((red &gt;&gt; <span class="number">3</span>) &lt;&lt; <span class="number">11</span>) | ((green &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">5</span>) | (blue &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            *pen_16 = color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">32</span>: &#123;</span><br><span class="line">            *pen_32 = color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t surport %dbpp\n&quot;</span>, var.bits_per_pixel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * 函数名称： draw_bitmap</span></span><br><span class="line"><span class="comment"> * 功能描述： 根据bitmap位图，在LCD指定位置显示汉字</span></span><br><span class="line"><span class="comment"> * 输入参数： x坐标，y坐标，位图指针</span></span><br><span class="line"><span class="comment"> * 输出参数： 无</span></span><br><span class="line"><span class="comment"> * 返 回 值： 无</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_bitmap</span><span class="params">( FT_Bitmap* bitmap, FT_Int x, FT_Int y)</span> &#123;</span><br><span class="line">    FT_Int  i, j, p, q;</span><br><span class="line">    FT_Int  x_max = x + bitmap-&gt;width;</span><br><span class="line">    FT_Int  y_max = y + bitmap-&gt;rows;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;x = %d, y = %d\n&quot;, x, y);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = y, q = <span class="number">0</span>; j &lt; y_max; j++, q++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = x, p = <span class="number">0</span>; i &lt; x_max; i++, p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= var.xres || j &gt;= var.yres)</span><br><span class="line">            	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    		<span class="comment">//image[j][i] |= bitmap-&gt;buffer[q * bitmap-&gt;width + p];</span></span><br><span class="line">    		lcd_put_pixel(i, j, bitmap-&gt;buffer[q * bitmap-&gt;width + p]);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">wchar_t</span> *chinese_str = <span class="string">L&quot;繁&quot;</span>;</span><br><span class="line">    FT_Library          library;</span><br><span class="line">    FT_Face           face;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    FT_Vector     pen;</span><br><span class="line">    FT_GlyphSlot  slot;</span><br><span class="line">    <span class="type">int</span> font_size = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;font_file&gt; [font_size]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">        font_size = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    fd_fb = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd_fb &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/fb0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd_fb, FBIOGET_VSCREENINFO, &amp;var)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get var\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    line_width  = var.xres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    pixel_width = var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    screen_size = var.xres * var.yres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    fbmem = (<span class="type">unsigned</span> <span class="type">char</span> *)mmap(<span class="literal">NULL</span> , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fbmem == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清屏: 全部设为黑色 */</span></span><br><span class="line">    <span class="built_in">memset</span>(fbmem, <span class="number">0</span>, screen_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示矢量字体 */</span></span><br><span class="line">    error = FT_Init_FreeType( &amp;library );                           <span class="comment">/* initialize library */</span></span><br><span class="line">    <span class="comment">/* error handling omitted */</span></span><br><span class="line">    </span><br><span class="line">    error = FT_New_Face( library, argv[<span class="number">1</span>], <span class="number">0</span>, &amp;face ); <span class="comment">/* create face object */</span></span><br><span class="line">    <span class="comment">/* error handling omitted */</span>        </span><br><span class="line">    slot = face-&gt;glyph;</span><br><span class="line"></span><br><span class="line">    FT_Set_Pixel_Sizes(face, font_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确定座标:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//pen.x = 0;</span></span><br><span class="line">    <span class="comment">//pen.y = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set transformation */</span></span><br><span class="line">    <span class="comment">//FT_Set_Transform( face, 0, &amp;pen);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load glyph image into the slot (erase previous one) */</span></span><br><span class="line">    error = FT_Load_Char( face, chinese_str[<span class="number">0</span>], FT_LOAD_RENDER );</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FT_Load_Char error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    draw_bitmap( &amp;slot-&gt;bitmap,</span><br><span class="line">                 var.xres/<span class="number">2</span>,</span><br><span class="line">                 var.yres/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>开源插件</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-1-GPIO驱动LED示例</title>
    <url>/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gpio-ji-cun-qi-de-2-chong-cao-zuo-fang-fa">1 GPIO 寄存器的 2 种操作方法</a></li>
<li><a href="#2-gpio-ji-cun-qi-pei-zhi-liu-cheng">2 GPIO 寄存器配置流程</a><ul>
<li><a href="#2-1-ccm-shi-zhong-she-zhi">2.1 CCM时钟设置</a></li>
<li><a href="#2-2-yin-jiao-mo-shi-dian-qi-shu-xing-she-zhi">2.2 引脚模式电器属性设置</a><ul>
<li><a href="#2-2-1-iomux-gong-neng">2.2.1 IOMUX功能</a></li>
<li><a href="#2-2-2-dian-qi-shu-xing-gong-neng">2.2.2 电器属性功能</a><ul>
<li><a href="#2-2-2-1-gpio-qu-dong-led-de-4-chong-fang-shi">2.2.2.1 GPIO驱动LED的4种方式</a></li>
</ul>
</li>
<li><a href="#2-2-3-gpio-fang-xiang">2.2.3 GPIO方向</a></li>
<li><a href="#2-2-4-gpio-zhi">2.2.4 GPIO值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-zi-fu-she-bei-qu-dong-cheng-xu-kuang-jia">3 字符设备驱动程序框架</a><ul>
<li><a href="#3-1-shi-xian-tong-yong-xing-qu-dong-mo-ban">3.1 实现通用性驱动模板</a><ul>
<li><a href="#3-1-1-led-drv-c">3.1.1 <code>led_drv.c</code></a></li>
</ul>
</li>
<li><a href="#3-2-ju-ti-dan-ban-led-qu-dong">3.2 具体单板led驱动</a><ul>
<li><a href="#3-2-1-led-opr-h">3.2.1 <code>led_opr.h</code></a></li>
<li><a href="#3-2-2-board-100ask-imx6ull-qemu-c-fen-xi">3.2.2 <code>board_100ask_imx6ull-qemu.c分析</code></a><ul>
<li><a href="#3-2-2-1-ccm-shi-zhong-pei-zhi">3.2.2.1 CCM时钟配置</a></li>
<li><a href="#3-2-2-2-iomux-cheng-gpio">3.2.2.2 IOMUX成gpio</a><ul>
<li><a href="#3-2-2-2-1-gpio5-3-jin-xing-iomux">3.2.2.2.1 gpio5_3 进行iomux</a></li>
<li><a href="#3-2-2-2-2-gpio1-3-gpio1-5-gpio1-6-jin-xing-iomux">3.2.2.2.2 gpio1_3&#x2F;gpio1_5&#x2F;gpio1_6 进行iomux</a></li>
</ul>
</li>
<li><a href="#3-2-2-3-gpio-pei-cheng-shu-chu">3.2.2.3 gpio配成输出</a></li>
<li><a href="#3-2-2-4-gpio-zhi-she-zhi">3.2.2.4 gpio值设置</a></li>
<li><a href="#3-2-2-5-board-100ask-imx6ull-qemu-c">3.2.2.5 <code>board_100ask_imx6ull-qemu.c</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-zi-fu-she-bei-qu-dong-ji-chu-gai-nian">4 字符设备驱动基础概念</a><ul>
<li><a href="#4-1-export-symbol">4.1 EXPORT_SYMBOL</a></li>
<li><a href="#4-2-module-info">4.2 MODULE_INFO</a></li>
<li><a href="#4-2-module-param">4.2 module_param</a><ul>
<li><a href="#4-2-1-type">4.2.1 type</a></li>
<li><a href="#4-2-2-perm">4.2.2 perm</a></li>
</ul>
</li>
<li><a href="#4-3-she-bei-jie-dian">4.3 设备节点</a><ul>
<li><a href="#4-3-1-shou-dong-jian-li-she-bei-jie-dian">4.3.1 手动建立设备节点</a></li>
<li><a href="#4-3-2-zi-dong-chuang-jian-she-bei-jie-dian">4.3.2 自动创建设备节点</a><ul>
<li><a href="#4-3-2-1-mdev-ji-zhi">4.3.2.1 mdev机制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-4-she-zhi-wen-jian-si-you-shu-ju">4.4 设置文件私有数据</a></li>
<li><a href="#4-5-she-bei-hao">4.5 设备号</a><ul>
<li><a href="#4-5-1-jing-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao">4.5.1 静态分配和释放一个设备号</a></li>
<li><a href="#4-5-2-dong-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao">4.5.2 动态分配和释放一个设备号</a></li>
</ul>
</li>
<li><a href="#4-6-tian-jia-she-bei-he-lei">4.6 添加设备和类</a></li>
</ul>
</li>
<li><a href="#5-nei-he-yuan-ma-shu-tian-jia-yi-ge-zi-fu-she-bei-qu-dong">5 内核源码树添加一个字符设备驱动</a><ul>
<li><a href="#5-1-zhun-bei-qu-dong-yuan-ma">5.1 准备驱动源码</a></li>
<li><a href="#5-2-makefile">5.2 MakeFile</a></li>
<li><a href="#5-3-kconfig">5.3 Kconfig</a></li>
<li><a href="#5-4-xiu-gai-shang-yi-ji-makefile-he-kconfig">5.4 修改上一级Makefile和Kconfig</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<p>GPIO: <code>General-purpose input/output</code>，通用输入输出接口。下面以<code>IMX6ULL</code>芯片的GPIO寄存器来展开介绍。</p>
<h1><span id="1-gpio-ji-cun-qi-de-2-chong-cao-zuo-fang-fa">1 GPIO 寄存器的 2 种操作方法</span><a href="#1-gpio-ji-cun-qi-de-2-chong-cao-zuo-fang-fa" class="header-anchor">#</a></h1><ol>
<li><strong>直接读写</strong>：读出、修改对应位、写入。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a) 要设置 bit n：</span><br><span class="line">　　val = data_reg;</span><br><span class="line">　　val = val | (<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">　　data_reg = val;</span><br><span class="line">b) 要清除 bit n：</span><br><span class="line">　　val = data_reg;</span><br><span class="line">　　val = val &amp; ~(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">　　data_reg = val;</span><br></pre></td></tr></table></figure></li>
<li><strong>set-and-clear protocol</strong>：(芯片不一定支持）</li>
</ol>
<p>　　<code>set_reg, clr_reg, data_reg </code>三个寄存器对应的是同一个物理寄存器:</p>
<p>　　a) 要设置 bit n：<code>set_reg = (1&lt;&lt;n);</code></p>
<p>　　b) 要清除 bit n：<code>clr_reg = (1&lt;&lt;n);</code></p>
<h1><span id="2-gpio-ji-cun-qi-pei-zhi-liu-cheng">2 GPIO 寄存器配置流程</span><a href="#2-gpio-ji-cun-qi-pei-zhi-liu-cheng" class="header-anchor">#</a></h1><h2><span id="2-1-ccm-shi-zhong-she-zhi">2.1 CCM时钟设置</span><a href="#2-1-ccm-shi-zhong-she-zhi" class="header-anchor">#</a></h2><p>CCM寄存器为GPIO 模块提供时钟：</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/1.png" alt="img"></p>
<p>以IMX6ULL 芯片为列，<code>GPIOn </code>要用 <code>CCM_CCGRx</code> 寄存器中的 2 位来决定该组 GPIO 是否使能。将对应的<code>clk gating enable</code>。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/2.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span>：该 GPIO 模块全程被关闭</span><br><span class="line"><span class="number">01</span>：该 GPIO 模块在 CPU run mode 情况下是使能的；在 WAIT 或 STOP 模式下，关闭</span><br><span class="line"><span class="number">10</span>：保留</span><br><span class="line"><span class="number">11</span>：该 GPIO 模块全程使能</span><br></pre></td></tr></table></figure>

<p>例如：用<code>CCM_CCGR0[bit31:30]</code>使能GPIO2 的时钟：</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/3.png" alt="img"></p>
<p>例如：用<code>CCM_CCGR1[bit31:30]</code>使能GPIO5 的时钟:</p>
<p>例如：用<code>CCM_CCGR1[bit27:26]</code>使能GPIO1 的时钟:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/4.png" alt="img"></p>
<p>例如：用<code>CCM_CCGR2[bit27:26]</code>使能GPIO3的时钟:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/5.png" alt="img"></p>
<p>例如：用<code>CCM_CCGR3[bit13:12]</code>使能GPIO4的时钟:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/6.png" alt="img"></p>
<h2><span id="2-2-yin-jiao-mo-shi-dian-qi-shu-xing-she-zhi">2.2 引脚模式电器属性设置</span><a href="#2-2-yin-jiao-mo-shi-dian-qi-shu-xing-she-zhi" class="header-anchor">#</a></h2><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/7.png" alt="img"></p>
<p><code>MUX seting</code>用来配置pin的模式，比如GPIO。<code>Pad setting</code>用来设置GPIO的电器属性，比如电平，上下拉情况。</p>
<p>对于某个&#x2F;某组引脚，<code>IOMUXC </code>中有 2 个寄存器用来设置它：</p>
<h3><span id="2-2-1-iomux-gong-neng">2.2.1 IOMUX功能</span><a href="#2-2-1-iomux-gong-neng" class="header-anchor">#</a></h3><pre><code> a) `IOMUXC_SW_MUX_CTL_PAD_ &lt;PAD_NAME&gt;`：`Mux pad xxx`，选择某个引脚的功能
</code></pre>
<p> 　b) <code>IOMUXC_SW_MUX_CTL_GRP_&lt;GROUP_NAME&gt;</code>：<code>Mux grp xxx</code>，选择某组引脚的功能</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/8.png" alt="img"></p>
<p>某个引脚，或是某组预设的引脚，都有 8 个可选的模式(<code>alternate (ALT) MUX_MODE</code>)，设成<code>ALT5</code>表示选择GPIO。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/9.png" alt="img"></p>
<h3><span id="2-2-2-dian-qi-shu-xing-gong-neng">2.2.2 电器属性功能</span><a href="#2-2-2-dian-qi-shu-xing-gong-neng" class="header-anchor">#</a></h3><p>a) <code>IOMUXC_SW_PAD_CTL_PAD_&lt;PAD_NAME</code>&gt;：<code>pad pad xxx</code>，设置某个引脚的电器属性</p>
<p>b) <code>IOMUXC_SW_PAD_CTL_GRP_&lt;GROUP_NAME&gt;</code>：<code>pad grp xxx</code>，设 置某组引脚的电器属性</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/10.png" alt="img"></p>
<p>pad参数有很多不只是上下拉，还有很多属性如IO驱动能力。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/11.png" alt="img"></p>
<h4><span id="2-2-2-1-gpio-qu-dong-led-de-4-chong-fang-shi">2.2.2.1 GPIO驱动LED的4种方式</span><a href="#2-2-2-1-gpio-qu-dong-led-de-4-chong-fang-shi" class="header-anchor">#</a></h4><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/12.png" alt="img"></p>
<p>① 使用引脚输出 3.3V 点亮 LED，输出 0V 熄灭 LED。</p>
<p>② 使用引脚拉低到 0V 点亮 LED，输出 3.3V 熄灭 LED。</p>
<p>③有的芯片为了省电等原因，其引脚驱动能力不足，这时可以使用三极管驱动。 使用引脚输出 1.2V 点亮 LED，输出 0V 熄灭 LED。</p>
<p>④使用引脚输出 0V 点亮 LED，输出 1.2V 熄灭 LED</p>
<h3><span id="2-2-3-gpio-fang-xiang">2.2.3 GPIO方向</span><a href="#2-2-3-gpio-fang-xiang" class="header-anchor">#</a></h3><p>当iomux成gpio模式后，就需要配置成gpio输出。</p>
<p><code>GPIOx_GDIR</code>：设置引脚方向，每位对应一个引脚，<code>1-output</code>，<code>0-input</code>.</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/13.png" alt="img"></p>
<p>确定每组gpio基地址如下：加4就对应方向寄存器。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/14.png" alt="img"></p>
<h3><span id="2-2-4-gpio-zhi">2.2.4 GPIO值</span><a href="#2-2-4-gpio-zhi" class="header-anchor">#</a></h3><p><code>GPIOx_DR</code>：(<code>GPIOx的data register</code>)。设置输出引脚的电平，每位对应一个引脚，1-高电平，0-低电平。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/15.png" alt="img"></p>
<p>如果是配成了输入引脚，<code>GPIOx_PSR</code>：读取引脚的电平，每位对应一个引脚，1-高电平，0-低电平:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/16.png" alt="img"></p>
<h1><span id="3-zi-fu-she-bei-qu-dong-cheng-xu-kuang-jia">3 字符设备驱动程序框架</span><a href="#3-zi-fu-she-bei-qu-dong-cheng-xu-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/17.png" alt="img"></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/18.png" alt="img"></p>
<p>字符驱动编写流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 确定主设备号，也可以让内核动态分配.</span></span><br><span class="line"><span class="comment">2. 定义自己的 file_operations 结构体 实现对应的 drv_open/drv_read/drv_write 等函数</span></span><br><span class="line"><span class="comment">填入 file_operations 结构体，把 file_operations 结构体告诉内核。</span></span><br><span class="line"><span class="comment">3. register_chrdev/unregister_chrdev</span></span><br><span class="line"><span class="comment">4. 其他完善：提供设备信息，自动创建设备节点：class_create, device_create</span></span><br><span class="line"><span class="comment">5. 操作硬件：通过 ioremap 映射寄存器的物理地址得到虚拟地址，读写虚拟地址</span></span><br><span class="line"><span class="comment">6. 驱动怎么和 APP 传输数据：通过 copy_to_user、copy_from_user 等操作函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (newchrled.major) &#123; <span class="comment">/* 定义了设备号，静态分配 */</span> </span><br><span class="line">    newchrled.devid = MKDEV(newchrled.major, <span class="number">0</span>); </span><br><span class="line">    register_chrdev_region(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 没有定义设备号，动态分配 */</span> </span><br><span class="line">    alloc_chrdev_region(&amp;newchrled.devid, <span class="number">0</span>, NEWCHRLED_CNT, NEWCHRLED_NAME); <span class="comment">/* 申请设备号 */</span> </span><br><span class="line">    newchrled.major = MAJOR(newchrled.devid); <span class="comment">/* 获取主设备号 */</span> </span><br><span class="line">    newchrled.minor = MINOR(newchrled.devid); <span class="comment">/* 获取次设备号 */</span> </span><br><span class="line">&#125; </span><br><span class="line">printk(<span class="string">&quot;newcheled major=%d,minor=%d\r\n&quot;</span>,newchrled.major, newchrled.minor); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、初始化cdev */</span> </span><br><span class="line">newchrled.cdev.owner = THIS_MODULE; </span><br><span class="line">cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、添加一个cdev */</span> </span><br><span class="line">cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建类 */</span> </span><br><span class="line">newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME); </span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newchrled.class)) </span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(newchrled.class); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、创建设备 */</span></span><br><span class="line">newchrled.device = device_create(newchrled.class, <span class="literal">NULL</span>, newchrled.devid, <span class="literal">NULL</span>, NEWCHRLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newchrled.device))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(newchrled.device);</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-shi-xian-tong-yong-xing-qu-dong-mo-ban">3.1 实现通用性驱动模板</span><a href="#3-1-shi-xian-tong-yong-xing-qu-dong-mo-ban" class="header-anchor">#</a></h2><h3><span id="3-1-1-led-drv-c">3.1.1 <code>led_drv.c</code></span><a href="#3-1-1-led-drv-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 确定主设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> *<span class="title">p_led_opr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"><span class="comment">/* 实现对应的open/read/write等函数，填入file_operations结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* write(fd, &amp;val, 1); */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">char</span> status;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">        <span class="type">int</span> minor = iminor(inode);</span><br><span class="line"> </span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        err = copy_from_user(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 根据次设备号和status控制LED */</span></span><br><span class="line">        p_led_opr-&gt;ctl(minor, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> minor = iminor(node);</span><br><span class="line">         </span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="comment">/* 根据次设备号初始化LED */</span></span><br><span class="line">        p_led_opr-&gt;init(minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 定义自己的file_operations结构体  */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv</span> =</span> &#123;</span><br><span class="line">        .owner         = THIS_MODULE,</span><br><span class="line">        .open    = led_drv_open,</span><br><span class="line">        .read    = led_drv_read,</span><br><span class="line">        .write   = led_drv_write,</span><br><span class="line">        .release = led_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 把file_operations结构体告诉内核：注册驱动程序  */</span></span><br><span class="line"><span class="comment">/* 入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">         </span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_drv);</span><br><span class="line">        led_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line">        err = PTR_ERR(led_class);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(led_class)) &#123;</span><br><span class="line">                printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">                unregister_chrdev(major, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p_led_opr = get_board_led_opr();</span><br><span class="line">        <span class="comment">/* creat device node, eg: /dev/100ask_led0,1,... */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_led_opr-&gt;num; i++)</span><br><span class="line">                device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, i), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, i); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_led_opr-&gt;num; i++)</span><br><span class="line">                device_destroy(led_class, MKDEV(major, i)); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line">        class_destroy(led_class);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>register_chrdev</code>， 如果传入主设备号，则静态注册，传入0则动态注册返回主设备号。</li>
<li><code>class_create</code>创建类<code>/sys/class/100ask_led_class</code>。</li>
<li><code>get_board_led_opr</code>获取具体单板的操作operation函数,后面具体单板实现。</li>
<li>获取到具体单板的led数量后，<code>device_create</code>为每一个led灯都建立设备节点。</li>
</ol>
<p>再来看<code>file_operations中</code>的操作：</p>
<ol>
<li><code>led_drv_open</code>根据次设备号，调用具体单板的<code>init</code>函数，比如gpio 引脚复用，电器属性设置等。</li>
<li><code>led_drv_write</code>就可以根据次设备号, 控制具体单板的led引脚，设置高低电平，从而控制亮灭。</li>
</ol>
<h2><span id="3-2-ju-ti-dan-ban-led-qu-dong">3.2 具体单板led驱动</span><a href="#3-2-ju-ti-dan-ban-led-qu-dong" class="header-anchor">#</a></h2><h3><span id="3-2-1-led-opr-h">3.2.1 <code>led_opr.h</code></span><a href="#3-2-1-led-opr-h" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_OPR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_OPR_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">int</span> (*init) (<span class="type">int</span> which); <span class="comment">/* 初始化LED, which-哪个LED */</span>       </span><br><span class="line">        <span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">char</span> status); <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>定义一个<code>led_operations</code>，<code>num</code>表示有几个led, <code> init</code>表示初始化led(<code>drv_open</code>的时候调用，配置<code>pinmux</code>，<code>io mode</code>, <code>enable pin clk</code>等)。</p>
<h3><span id="3-2-2-board-100ask-imx6ull-qemu-c-fen-xi">3.2.2 <code>board_100ask_imx6ull-qemu.c分析</code></span><a href="#3-2-2-board-100ask-imx6ull-qemu-c-fen-xi" class="header-anchor">#</a></h3><p>现在有一块<code>board_100ask_imx6ull-qemu</code>板子有4个LED，占2组GPIO，分别是<code>GPIO5_3</code>和<code>GPIO1_3, GPIO1_5, GPIO1_6</code>。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/19.png" alt="img"></p>
<h4><span id="3-2-2-1-ccm-shi-zhong-pei-zhi">3.2.2.1 CCM时钟配置</span><a href="#3-2-2-1-ccm-shi-zhong-pei-zhi" class="header-anchor">#</a></h4><p>寄存器配置参考2.1。使能时钟gpio5和gpio1的时钟，<code>CCM_CCGR1[CG13]</code>和<code>CCM_CCGR1[CG15]</code>配置成0x11。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1. enable GPIO1</span></span><br><span class="line"><span class="comment"> * CG13, b[27:26] = 0b11 */</span></span><br><span class="line"> </span><br><span class="line">*CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">       </span><br><span class="line"><span class="comment">/* 1. enable GPIO5</span></span><br><span class="line"><span class="comment"> * CG15, b[31:30] = 0b11 */</span></span><br><span class="line"> *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-2-iomux-cheng-gpio">3.2.2.2 IOMUX成gpio</span><a href="#3-2-2-2-iomux-cheng-gpio" class="header-anchor">#</a></h4><p>iomux配置4个引脚复用成gpio功能。</p>
<h5><span id="3-2-2-2-1-gpio5-3-jin-xing-iomux">3.2.2.2.1 gpio5_3 进行iomux</span><a href="#3-2-2-2-1-gpio5-3-jin-xing-iomux" class="header-anchor">#</a></h5><p>基地址为<code>0x2290014</code>。用ioremap进行映射到虚拟地址，就可以直接操作寄存器地址了。但是一般建议用<code>writel, writeb</code>等函数族。配成5表示gpio模式。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/20.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3=ioremap(<span class="number">0x2290014</span>, <span class="number">4</span>);        </span><br><span class="line"><span class="comment">/* 2. set GPIO5_IO03 as GPIO</span></span><br><span class="line"><span class="comment"> * MUX_MODE, b[3:0] = 0b101 */</span></span><br><span class="line"></span><br><span class="line">*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="3-2-2-2-2-gpio1-3-x2f-gpio1-5-x2f-gpio1-6-jin-xing-iomux">3.2.2.2.2 gpio1_3&#x2F;gpio1_5&#x2F;gpio1_6 进行iomux</span><a href="#3-2-2-2-2-gpio1-3-x2f-gpio1-5-x2f-gpio1-6-jin-xing-iomux" class="header-anchor">#</a></h5><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/21.png" alt="img"></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/22.png" alt="img"></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/23.png" alt="img"></p>
<p>每次映射4个字节太繁琐，干脆对整个gpio的iomux地址进行映射。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iomux</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> unnames[<span class="number">23</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00;  <span class="comment">/* offset 0x5c*/</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO02;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iomux = ioremap(<span class="number">0x20e0000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iomux));</span><br></pre></td></tr></table></figure>

<p>这里偷懒用了一个技巧，<code>unnames[23] </code>占<code>92(0x5c)</code>字节,刚好<code>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00</code>地址就是<code>0x20e0000+0x5c</code>，就不用把所有寄存器都搬进来到<code>struct iomux</code>。</p>
<p>同理<code>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</code>地址就是<code>0x20e0000+0x68</code>, 因此：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* MUX_MODE, b[3:0] = 0b101 */</span></span><br><span class="line">iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 = <span class="number">5</span>;</span><br><span class="line">iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05 = <span class="number">5</span>;</span><br><span class="line">iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-3-gpio-pei-cheng-shu-chu">3.2.2.3 gpio配成输出</span><a href="#3-2-2-3-gpio-pei-cheng-shu-chu" class="header-anchor">#</a></h4><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/24.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> dr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> gdir;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> psr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> imr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> isr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> edge_sel;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* GPIO1 GDIR, b[5] = 0b1*/</span></span><br><span class="line"> gpio1 = ioremap(<span class="number">0x209C000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line"> gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"> gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line"> gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>offset为0表示data register, offset为4表示方向寄存器。以<code>gpio1_3/gpio1_5/gpio1_6</code>举例，<code>gdir</code>的<code>bit_n</code>置1就表示哪个gpio配成输出。</p>
<h4><span id="3-2-2-4-gpio-zhi-she-zhi">3.2.2.4 gpio值设置</span><a href="#3-2-2-4-gpio-zhi-she-zhi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (which == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status)  <span class="comment">/* on : output 0 */</span></span><br><span class="line">        gpio5-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">/* on : output 1 */</span></span><br><span class="line">        gpio5-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status)  <span class="comment">/* on : output 0 */</span></span><br><span class="line">        gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">/* on : output 1 */</span></span><br><span class="line">        gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status)  <span class="comment">/* on : output 0 */</span></span><br><span class="line">        gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">/* on : output 1 */</span></span><br><span class="line">        gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status)  <span class="comment">/* on : output 0 */</span></span><br><span class="line">        gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">/* on : output 1 */</span></span><br><span class="line">        gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理<code>dr</code>就表示数据寄存器。一共4个led：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">which等于0表示gpio5_3</span><br><span class="line">which等于1示gpio1_3</span><br><span class="line">which等于2示gpio1_5</span><br><span class="line">which等于3示gpio1_6</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-5-board-100ask-imx6ull-qemu-c">3.2.2.5 <code>board_100ask_imx6ull-qemu.c</code></span><a href="#3-2-2-5-board-100ask-imx6ull-qemu-c" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iomux</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> unnames[<span class="number">23</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00;  <span class="comment">/* offset 0x5c*/</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO02;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> dr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> gdir;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> psr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> imr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> isr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> edge_sel;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* enable GPIO1,GPIO5 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR1;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">iomux</span> *<span class="title">iomux</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio5</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">    .num  = <span class="number">4</span>,</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_init</span><span class="params">(<span class="type">int</span> which)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!CCM_CCGR1) &#123;</span><br><span class="line">        CCM_CCGR1 = ioremap(<span class="number">0x20C406C</span>, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(<span class="number">0x2290014</span>, <span class="number">4</span>);</span><br><span class="line">        iomux = ioremap(<span class="number">0x20e0000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iomux));</span><br><span class="line">        gpio1 = ioremap(<span class="number">0x209C000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">        gpio5 = ioremap(<span class="number">0x20AC000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>) &#123;</span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">        *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = <span class="number">5</span>;</span><br><span class="line">        gpio5-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">1</span>) &#123;</span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">        iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 = <span class="number">5</span>;</span><br><span class="line">        gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">2</span>) &#123;</span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">        iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05 = <span class="number">5</span>;</span><br><span class="line">        gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">3</span>) &#123;</span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">        iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06 = <span class="number">5</span>;</span><br><span class="line">        gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_ctl</span><span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            gpio5-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            gpio5-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;board_demo_led_opr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open的时候调用<code>get_board_led_opr</code>得到具体单板的操作函数集。进一步调用<code>board_demo_led_init</code>初始化led。</p>
<p>write的时候调用具体单板的操作函数集，进一步调用<code>board_demo_led_ctl</code>操控led。</p>
<h1><span id="4-zi-fu-she-bei-qu-dong-ji-chu-gai-nian">4 字符设备驱动基础概念</span><a href="#4-zi-fu-she-bei-qu-dong-ji-chu-gai-nian" class="header-anchor">#</a></h1><h2><span id="4-1-export-symbol">4.1 EXPORT_SYMBOL</span><a href="#4-1-export-symbol" class="header-anchor">#</a></h2><p><code>EXPORT_SYMBOL</code>:导出函数，让别的module也能使用。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/25.png" alt="image-20240725202519779"></p>
<p><code>EXPORT_SYMBOL_GPL</code>:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/26.png" alt="image-20240725211903017"></p>
<h2><span id="4-2-module-info">4.2 MODULE_INFO</span><a href="#4-2-module-info" class="header-anchor">#</a></h2><p><code>MODULE_INFO(intree, &quot;Y&quot;);</code>的作用是将可加载内核模块标记为<code> in-tree</code>。</p>
<p>加载树外 LKM 会导致内核打印警告:这是从<code>module.c</code>中的检查引起的:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/27.png" alt="img"></p>
<p><code>module: loading out-of-tree module taints kernel.</code></p>
<h2><span id="4-2-module-param">4.2 module_param</span><a href="#4-2-module-param" class="header-anchor">#</a></h2><p><code>module_param(name,type,perm);</code></p>
<p>功能：指定模块参数，用于在加载模块时或者模块加载以后传递参数给模块。</p>
<p><code>module_param_array( name, type, nump, perm);</code></p>
<p>可用sysfs进行查看修改：</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/28.png" alt="img"></p>
<p>讲到<code>module_param</code>,把其他的也一笔带入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Freescale PM rpmsg driver&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Anson Huang &lt;Anson.Huang@nxp.com&gt;&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;v2.0&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-1-type">4.2.1 type</span><a href="#4-2-1-type" class="header-anchor">#</a></h3><p>type: 数据类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool : 布尔型</span><br><span class="line">   inbool : 布尔反值</span><br><span class="line">   charp: 字符指针（相当于char *,不超过1024字节的字符串）</span><br><span class="line">   short: 短整型</span><br><span class="line">   ushort : 无符号短整型</span><br><span class="line">   int : 整型</span><br><span class="line">   uint : 无符号整型</span><br><span class="line">   long : 长整型</span><br><span class="line">   ulong: 无符号长整型</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-2-perm">4.2.2 perm</span><a href="#4-2-2-perm" class="header-anchor">#</a></h3><p>perm表示此参数在sysfs文件系统中所对应的文件节点的属性，其权限在<code>include/linux/stat.h</code>中有定义:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/29.png" alt="image-20240725205237500"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR 00400 <span class="comment">//文件所有者可读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR 00200 <span class="comment">//文件所有者可写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR 00100 <span class="comment">//文件所有者可执行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP 00040 <span class="comment">//与文件所有者同组的用户可读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP 00020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP 00010</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH 00004 <span class="comment">//与文件所有者不同组的用户可读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH 00002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH 00001</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/30.png" alt="image-20240725205907528"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *alg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> u32 type;</span><br><span class="line"><span class="type">static</span> u32 mask;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mode;</span><br><span class="line"></span><br><span class="line">module_param(alg, charp, <span class="number">0</span>);</span><br><span class="line">module_param(type, uint, <span class="number">0</span>);</span><br><span class="line">module_param(mask, uint, <span class="number">0</span>);</span><br><span class="line">module_param(mode, <span class="type">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fish[<span class="number">10</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nr_fish;</span><br><span class="line">module_param_array(fish, <span class="type">int</span>, &amp;nr_fish, <span class="number">0664</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> media[<span class="number">8</span>];</span><br><span class="line">module_param_string(media, media, <span class="keyword">sizeof</span>(media), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>可以用sysfs设置<code>fish</code>数组，或者insmod时伴随设置。</p>
<h2><span id="4-3-she-bei-jie-dian">4.3 设备节点</span><a href="#4-3-she-bei-jie-dian" class="header-anchor">#</a></h2><p><code>cat /proc/devices</code></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/31.png" alt="img"></p>
<h3><span id="4-3-1-shou-dong-jian-li-she-bei-jie-dian">4.3.1 手动建立设备节点</span><a href="#4-3-1-shou-dong-jian-li-she-bei-jie-dian" class="header-anchor">#</a></h3><p>手动建立设备节点命令是<code>mknod</code>, 由于这里的字符设备都是用的misc杂项设备方式，因此主设备号都为10：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/mnt/Athena2_FPGA_SDK_Veriry/demo/workspace/ko <span class="comment"># ls -l /dev/mmcblk0p1</span></span><br><span class="line">brw-rw----    1 root     root      179,   1 Jan  1 00:05 /dev/mmcblk0p1</span><br><span class="line">/mnt/Athena2_FPGA_SDK_Veriry/demo/workspace/ko <span class="comment"># ls -l /dev/mmcblk0</span></span><br><span class="line">brw-rw----    1 root     root      179,   0 Jan  1 00:05 /dev/mmcblk0</span><br><span class="line"></span><br><span class="line">/dev <span class="comment"># ls -l cvi-*</span></span><br><span class="line">crw-rw----    1 root     root       10,   0 Jan  1 00:05 /dev/cvi-base</span><br><span class="line">crw-rw----    1 root     root       10,  61 Jan  1 00:05 /dev/cvi-dwa</span><br><span class="line">crw-rw----    1 root     root       10,  58 Jan  1 00:30 /dev/cvi-ldc</span><br><span class="line">crw-rw----    1 root     root       10,  60 Jan  1 00:04 /dev/cvi-stitch</span><br><span class="line">crw-rw----    1 root     root       10,  62 Jan  1 00:05 /dev/cvi-sys</span><br><span class="line">crw-rw----    1 root     root       10,  59 Jan  1 00:04 /dev/cvi-vpss</span><br><span class="line"></span><br><span class="line"><span class="built_in">mknod</span> /dev/mmcblk0 b 179 0</span><br><span class="line"><span class="built_in">mknod</span> /dev/mmcblk0p1 b 179 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-base c 10 0</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-sys c 10 62</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-dwa c 10 61</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-ldc c 10 58</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-stitch c 10 60</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-vpss c 10 59</span><br><span class="line">crw-rw---- 1 root root 10, 0 Jan 1 00:08 /dev/cvi-base</span><br><span class="line">crw-rw---- 1 root root 10, 61 Jan 1 00:08 /dev/cvi-dwa</span><br><span class="line">crw-rw---- 1 root root 10, 59 Jan 1 00:07 /dev/cvi-ldc</span><br><span class="line">crw-rw---- 1 root root 10, 60 Jan 1 00:07 /dev/cvi-stitch</span><br><span class="line">crw-rw---- 1 root root 10, 62 Jan 1 00:08 /dev/cvi-sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-base c 10 0</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-sys c 10 62</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-dwa c 10 61</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-ldc c 10 59</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-stitch c 10 60</span><br></pre></td></tr></table></figure>

<h3><span id="4-3-2-zi-dong-chuang-jian-she-bei-jie-dian">4.3.2 自动创建设备节点</span><a href="#4-3-2-zi-dong-chuang-jian-she-bei-jie-dian" class="header-anchor">#</a></h3><h4><span id="4-3-2-1-mdev-ji-zhi">4.3.2.1 mdev机制</span><a href="#4-3-2-1-mdev-ji-zhi" class="header-anchor">#</a></h4><p><code>udev</code>是一个用户程序，在 Linux下通过 <code>udev</code>来实现设备文件的创建与删除， <code>udev</code>可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用<code>modprobe</code>命令成功加载驱动模块以后就自动在<code> /dev目录</code>下创建对应的设备节点文件 ,使用<code>rmmod</code>命令卸载驱动模块以后就 删除掉<code> /dev目录</code>下的设备节点文件。 使用<code> busybox</code>构建根文件系统的时候， busybox会创建一个 <code>udev</code>的简化版本<code> mdev</code>，所以在嵌入式 Linux中我们使用<code>mdev</code>来实现设备节点文件的自动创建与删除， Linux系统中的热插拔事件也由 <code>mdev</code>管理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br></pre></td></tr></table></figure>

<h2><span id="4-4-she-zhi-wen-jian-si-you-shu-ju">4.4 设置文件私有数据</span><a href="#4-4-she-zhi-wen-jian-si-you-shu-ju" class="header-anchor">#</a></h2><p>一般<code>open</code>函数里面设置好私有数据以后，在<code> write、 read、 close</code>等函数中直接读取<code> private_data</code>即可得到设备结构体。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/32.png" alt="img"></p>
<h2><span id="4-5-she-bei-hao">4.5 设备号</span><a href="#4-5-she-bei-hao" class="header-anchor">#</a></h2><p><code>include\linux\kdev_t.h</code></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/33.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MINORBITS 表示次设备号位数，一共是 20 位;</span><br><span class="line">MINORMASK 表示次设备号掩码;</span><br><span class="line">MAJOR 用于从 dev_t 中获取主设备号，将 dev_t 右移 20 位即可</span><br><span class="line">MINOR 用于从 dev_t 中获取次设备号，取 dev_t 的低 20 位的值即可</span><br><span class="line">MKDEV 用于将给定的主设备号和次设备号的值组合成 dev_t 类型的设备号</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/34.png" alt="img"></p>
<p>定义了major主设备就用静态注册，否则动态分配设备号注册字符设备。</p>
<h3><span id="4-5-1-jing-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao">4.5.1 静态分配和释放一个设备号</span><a href="#4-5-1-jing-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line">register_chrdev_region()</span><br><span class="line">unregister_chrdev_region()</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MAJOR_NUM 202 <span class="comment">//主设备号</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_dev_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = my_dev_open,</span><br><span class="line">    .release = my_dev_close,</span><br><span class="line">    .unlocked_ioctl = my_dev_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(MY_MAJOR_NUM, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Allocate device numbers */</span></span><br><span class="line">    ret = register_chrdev_region(dev, <span class="number">1</span>, <span class="string">&quot;my_char_device&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;Unable to allocate mayor number %d\n&quot;</span>, MY_MAJOR_NUM);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Initialize the cdev structure and add it to the kernel space */</span></span><br><span class="line">    cdev_init(&amp;my_dev, &amp;my_dev_fops);</span><br><span class="line">    ret= cdev_add(&amp;my_dev, dev, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        unregister_chrdev_region(dev, <span class="number">1</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;Unable to add cdev\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cdev_del(&amp;my_dev);</span><br><span class="line">    unregister_chrdev_region(MKDEV(MY_MAJOR_NUM, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-5-2-dong-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao">4.5.2 动态分配和释放一个设备号</span><a href="#4-5-2-dong-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">alloc_chrdev_region()</span><br><span class="line">unregister_chrdev_region()</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>*  <span class="title">helloClass</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">my_dev</span>;</span></span><br><span class="line"><span class="type">dev_t</span> dev;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> dev_no;</span><br><span class="line">    <span class="type">int</span> Major;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>* <span class="title">helloDevice</span>;</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_no, <span class="number">0</span>, <span class="number">1</span>, DEVICE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;Unable to allocate Mayor number \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Major = MAJOR(dev_no);</span><br><span class="line">    dev = MKDEV(Major,<span class="number">0</span>);</span><br><span class="line">    cdev_init(&amp;my_dev, &amp;my_dev_fops);</span><br><span class="line">    ret = cdev_add(&amp;my_dev, dev, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        unregister_chrdev_region(dev, <span class="number">1</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;Unable to add cdev\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    helloClass = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(helloClass))&#123;</span><br><span class="line">        unregister_chrdev_region(dev, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;my_dev);</span><br><span class="line">        pr_info(<span class="string">&quot;Failed to register device class\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(helloClass);</span><br><span class="line">    &#125;</span><br><span class="line">    helloDevice = device_create(helloClass, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, DEVICE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(helloDevice))&#123;</span><br><span class="line">        class_destroy(helloClass);</span><br><span class="line">        cdev_del(&amp;my_dev);</span><br><span class="line">        unregister_chrdev_region(dev, <span class="number">1</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;Failed to create the device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(helloDevice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    device_destroy(helloClass, dev);     <span class="comment">/* remove the device */</span></span><br><span class="line">    class_destroy(helloClass);           <span class="comment">/* remove the device class */</span></span><br><span class="line">    cdev_del(&amp;my_dev);</span><br><span class="line">    unregister_chrdev_region(dev, <span class="number">1</span>);    <span class="comment">/* unregister the device numbers */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="4-6-tian-jia-she-bei-he-lei">4.6 添加设备和类</span><a href="#4-6-tian-jia-she-bei-he-lei" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct class *class; /* 类 */ </span><br><span class="line">struct device *device; /* 设备 */ </span><br><span class="line">dev_t devid; /* 设备号 */</span><br><span class="line">static int __init led_init(void) &#123; </span><br><span class="line">    class = class_create(THIS_MODULE, &quot;xxx&quot;); </span><br><span class="line">    device = device_create(class, NULL, devid, NULL, &quot;xxx&quot;); </span><br><span class="line">    return 0; </span><br><span class="line">&#125; </span><br><span class="line">static void __exit led_exit(void) &#123; </span><br><span class="line">	device_destroy(newchrled.class, newchrled.devid); </span><br><span class="line">    class_destroy(newchrled.class); </span><br><span class="line">&#125; </span><br><span class="line">module_init(led_init); </span><br><span class="line">module_exit(led_exit);</span><br></pre></td></tr></table></figure>

<h1><span id="5-nei-he-yuan-ma-shu-tian-jia-yi-ge-zi-fu-she-bei-qu-dong">5 内核源码树添加一个字符设备驱动</span><a href="#5-nei-he-yuan-ma-shu-tian-jia-yi-ge-zi-fu-she-bei-qu-dong" class="header-anchor">#</a></h1><h2><span id="5-1-zhun-bei-qu-dong-yuan-ma">5.1 准备驱动源码</span><a href="#5-1-zhun-bei-qu-dong-yuan-ma" class="header-anchor">#</a></h2><p>这里以<code>misc device</code>为例， 进入<code>drivers/misc目录</code>，新建目录<code>hello_drv</code>。放入<code>驱动源码</code>和<code>Makefile</code>和<code>Kconfig</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">hello_cdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = copy_to_user(buf, kernel_buf, min(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> min(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = copy_from_user(kernel_buf, buf, min(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> min(<span class="number">1024</span>, size);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">    .owner     = THIS_MODULE,</span><br><span class="line">    .open    = hello_drv_open,</span><br><span class="line">    .read    = hello_drv_read,</span><br><span class="line">    .write   = hello_drv_write,</span><br><span class="line">    .release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">dev_t</span> devid;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">//major = register_chrdev(0, &quot;hello&quot;, &amp;hello_drv);  /* /dev/hello */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    rc = alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    major = MAJOR(devid);</span><br><span class="line">    cdev_init(&amp;hello_cdev, &amp;hello_drv);</span><br><span class="line">    cdev_add(&amp;hello_cdev, devid, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">    err = PTR_ERR(hello_class);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(hello_class);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">//unregister_chrdev(major, &quot;hello&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cdev_del(&amp;hello_cdev);</span><br><span class="line">    unregister_chrdev_region(MKDEV(major,<span class="number">0</span>), <span class="number">1</span>);   </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2><span id="5-2-makefile">5.2 MakeFile</span><a href="#5-2-makefile" class="header-anchor">#</a></h2><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/35.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">userprogs-always-y += hello_test</span><br><span class="line">userccflags += -I usr/include</span><br></pre></td></tr></table></figure>

<p>这里表示用userspace方式去编译应用程序，hello_test就是用户程序。</p>
<p>假如我们多个文件<code>hello1.c hello2.c</code>, 如何得到<code>hello.o</code>和<code>hello.ko</code>呢？如下参考：</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/36.png" alt="image-20240725223651990"></p>
<h2><span id="5-3-kconfig">5.3 Kconfig</span><a href="#5-3-kconfig" class="header-anchor">#</a></h2><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/37.png" alt="img"></p>
<h2><span id="5-4-xiu-gai-shang-yi-ji-makefile-he-kconfig">5.4 修改上一级Makefile和Kconfig</span><a href="#5-4-xiu-gai-shang-yi-ji-makefile-he-kconfig" class="header-anchor">#</a></h2><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/38.png" alt="img"></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/39.png" alt="img"></p>
<p>让<code>hello_drv</code>目录中的<code>Kconfig</code>也能被内核识别，输入<code>make menuconfig</code>，即可选择将其编译成内核模块还是直接编译进内核镜像，默认<code>default n</code>,也就是<code>CONFIG_HELLO</code>等于n, <code>hello_drv</code>目录是<code>obj-n</code>, 不编译；选择y则表示编译进内核镜像，选择m表示编译成内核模块。</p>
<p> 编译成内核模块，则会在<code>.config</code>中产生<code>CONFIG_HELLO=m</code>的一项配置，编译产生<code>hello.ko</code></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/40.png" alt="img"></p>
<p>编译成内核镜像，则会在<code>.config</code>中产生<code>CONFIG_HELLO=y</code>的一项配置，编译产生<code>built-in.a</code>,最终该 <code>built-in.a</code>会合入vmlinux。</p>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-2-总线模型和平台设备驱动</title>
    <url>/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zong-xian-she-bei-qu-dong-mo-xing">1 总线设备驱动模型</a><ul>
<li><a href="#1-1-zong-xian-ping-tai-she-bei-ping-tai-qu-dong-miao-shu">1.1 总线&#x2F;平台设备&#x2F;平台驱动描述</a><ul>
<li><a href="#1-1-1-struct-bus-type">1.1.1 struct bus_type</a></li>
<li><a href="#1-1-2-struct-platform-driver">1.1.2 struct platform_driver</a></li>
<li><a href="#1-1-3-struct-platform-device">1.1.3 struct platform_device</a></li>
<li><a href="#1-1-4-zong-xian-she-bei-qu-dong-san-zhe-guan-xi">1.1.4 总线&#x2F;设备&#x2F;驱动三者关系</a></li>
</ul>
</li>
<li><a href="#1-2-platform-device-de-zhu-ce-guo-cheng">1.2 platform_device的注册过程</a></li>
<li><a href="#1-3-platform-driver-de-zhu-ce-guo-cheng">1.3 platform_driver的注册过程</a><ul>
<li><a href="#1-3-1-device-he-driver-de-pi-pei-guo-cheng">1.3.1 device和driver的匹配过程</a><ul>
<li><a href="#1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu">1.3.1.1 device和driver的匹配优先级顺序</a><ul>
<li><a href="#1-3-1-1-1-of-match-table">1.3.1.1.1 of_match_table</a></li>
<li><a href="#1-3-1-1-2-id-table">1.3.1.1.2 ID table</a></li>
<li><a href="#1-3-1-1-3-name">1.3.1.1.3 name</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe">1.3.2 匹配成功后执行probe</a></li>
<li><a href="#1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng">1.3.3 总结下<code>platform_driver</code>的注册执行过程</a></li>
</ul>
</li>
<li><a href="#1-4-zong-jie-ping-tai-she-bei-ping-tai-qu-dong-de-zhu-ce-guo-cheng">1.4 总结平台设备&#x2F;平台驱动的注册过程</a></li>
<li><a href="#1-6-ping-tai-she-bei-ping-tai-qu-dong-xiang-guan-api">1.6 平台设备&#x2F;平台驱动相关API</a><ul>
<li><a href="#1-6-1-zhu-ce-fan-zhu-ce">1.6.1 注册&#x2F;反注册</a></li>
<li><a href="#1-6-2-zi-yuan-huo-qu-shi-fang">1.6.2 资源获取释放</a><ul>
<li><a href="#1-6-2-1-io-resource">1.6.2.1 IO resource</a></li>
<li><a href="#1-6-2-2-irq">1.6.2.2 IRQ</a></li>
<li><a href="#1-6-2-3-gpio">1.6.2.3 GPIO</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ping-tai-she-bei-qu-dong-shi-li">2 平台设备驱动示例</a><ul>
<li><a href="#2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia">2.1 通用字符设备驱动框架</a></li>
<li><a href="#2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts">2.2 具体单板资源描述驱动(platform_device暂不使用dts)</a></li>
<li><a href="#2-3-ju-ti-xin-pian-qu-dong-platform-driver">2.3 具体芯片驱动(platform_driver)</a></li>
<li><a href="#2-4-ce-shi">2.4 测试</a><ul>
<li><a href="#2-4-1-makefile">2.4.1 Makefile</a></li>
<li><a href="#2-4-2-ledtest-ce-shi-cheng-xu">2.4.2 ledtest测试程序</a></li>
</ul>
</li>
<li><a href="#2-5-is-err-err-ptr-ptr-err-null-ptr-han-shu-zu">2.5 IS_ERR&#x2F;ERR_PTR&#x2F;PTR_ERR&#x2F;NULL_PTR函数族</a><ul>
<li><a href="#2-5-1-is-err">2.5.1 IS_ERR</a></li>
<li><a href="#2-5-2-is-err-or-null">2.5.2 IS_ERR_OR_NULL</a></li>
<li><a href="#2-5-3-ptr-err">2.5.3 PTR_ERR</a></li>
<li><a href="#2-5-4-err-ptr">2.5.4 ERR_PTR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-yin-ru-sysfs">3 引入sysfs</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zong-xian-she-bei-qu-dong-mo-xing">1 总线设备驱动模型</span><a href="#1-zong-xian-she-bei-qu-dong-mo-xing" class="header-anchor">#</a></h1><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/1.png" alt="img"></p>
<p>设备定义资源，<code>platform_device</code>结构体</p>
<p>驱动定义<code>platform_driver</code>结构体，实现<code>probe, file_operations</code></p>
<p>总线驱动模型优点：</p>
<p>驱动只是一套控制驱动框架，基本不用修改，和单板硬件相关的都在设备代码里面，硬件修改只需要修改设备资源相关的代码，不用关心具体的函数实现和寄存器控制。</p>
<h2><span id="1-1-zong-xian-x2f-ping-tai-she-bei-x2f-ping-tai-qu-dong-miao-shu">1.1 总线&#x2F;平台设备&#x2F;平台驱动描述</span><a href="#1-1-zong-xian-x2f-ping-tai-she-bei-x2f-ping-tai-qu-dong-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-1-1-struct-bus-type">1.1.1 struct bus_type</span><a href="#1-1-1-struct-bus-type" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/2.png" alt="img"></p>
<p>有一个很关键的函数，<code>match</code>函数。当设备与设备枚举过程中match函数会按照规则进行匹配,规则见<code>1.3.1</code>。</p>
<h3><span id="1-1-2-struct-platform-driver">1.1.2 struct platform_driver</span><a href="#1-1-2-struct-platform-driver" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/3.png" alt="img"></p>
<h3><span id="1-1-3-struct-platform-device">1.1.3 struct platform_device</span><a href="#1-1-3-struct-platform-device" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/4.png" alt="img"></p>
<h3><span id="1-1-4-zong-xian-x2f-she-bei-x2f-qu-dong-san-zhe-guan-xi">1.1.4 总线&#x2F;设备&#x2F;驱动三者关系</span><a href="#1-1-4-zong-xian-x2f-she-bei-x2f-qu-dong-san-zhe-guan-xi" class="header-anchor">#</a></h3><ol>
<li><p>系统启动后，会调用<code>buses_init()</code>函数创建<code>/sys/bus</code>文件目录。</p>
</li>
<li><p>接下来就是通过总线注册函数<code>bus_register()</code>进行总线注册，注册完成后，在<code>/sys/bus</code>目录下生成device文件夹和driver文件夹。</p>
</li>
<li><p>最后分别通过<code>device_register()</code>和<code>driver_register()</code>函数注册对应的设备和驱动。<br><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/4_1.png" alt="image-20240727214421349"></p>
</li>
</ol>
<h2><span id="1-2-platform-device-de-zhu-ce-guo-cheng">1.2 platform_device的注册过程</span><a href="#1-2-platform-device-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/5.png" alt="image-20240727164939263"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/6.png" alt="image-20240726004737362"></p>
<ol>
<li>系统初始化时，调用<code>platform_add_devices</code>函数，把所有放置在板级<code>platform_device</code>数组中的<code>platform_device</code>注册到系统中去。</li>
</ol>
<ul>
<li><p>1.1 此函数循环调用<code>platform_device_register</code>函数，来注册每个<code>platform_device</code>。</p>
</li>
<li><p>1.2 而<code>platform_device_register</code>中会调用<code>platform_device_add</code>函数。</p>
</li>
</ul>
<ol start="2">
<li><code>platform_device</code>全部注册到系统之后，便可以通过<code>platform</code>的操作接口，来获取<code>platform_device</code>中的resource资源。</li>
</ol>
<ul>
<li><p>2.1 比如地址、中断号等，以进行<code>request_mem_region</code>、<code>ioremap</code>（将resource分配的物理地址映射到kernel的虚拟空间来）和<code>request_irq</code>操作。</p>
</li>
<li><p>2.2 <code>platform</code>的操作接口包括<code>platform_get_irq</code>、<code>platform_get_irq_byname</code>、<code>platform_get_resource</code>、<code>platform_get_resource_byname</code>等。这个后面设备树专题会专门介绍<a href="https://www.cnblogs.com/fuzidage/p/17369817.html">字符设备驱动-5.设备树函数 - fuzidage - 博客园 (cnblogs.com)</a>。</p>
</li>
</ul>
<h2><span id="1-3-platform-driver-de-zhu-ce-guo-cheng">1.3 platform_driver的注册过程</span><a href="#1-3-platform-driver-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p>当<code>insmod</code>设备驱动的时候会透过<code>module_init</code>调用, 过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">platform_driver_register()</span><br><span class="line">	driver_register()</span><br><span class="line">		bus_add_driver<span class="comment">//加入driver链表</span></span><br><span class="line">			driver_attach()</span><br><span class="line">				bus_for_each_dev()</span><br><span class="line">					__driver_attach()</span><br><span class="line">						driver_match_device<span class="comment">//drvier匹配device成功调用driver的probe</span></span><br><span class="line">							platform_match</span><br><span class="line">    					driver_probe_device<span class="comment">//drvier匹配device成功调用driver的probe</span></span><br><span class="line">    						drv-&gt;probe(dev);</span><br></pre></td></tr></table></figure>

<h3><span id="1-3-1-device-he-driver-de-pi-pei-guo-cheng">1.3.1 device和driver的匹配过程</span><a href="#1-3-1-device-he-driver-de-pi-pei-guo-cheng" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/7.png" alt="image-20240727170404969"></p>
<h4><span id="1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu">1.3.1.1 device和driver的匹配优先级顺序</span><a href="#1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu" class="header-anchor">#</a></h4><p>一个驱动是可以匹配多个设备的，平台总线中的驱动要具有三种匹配信息的能力，基于这种需求，<code>platform_driver</code>中使用不同的成员来进行相应的匹配。系统为platform总线定义了一个<code>bus_type 的实例platform_bus_type</code>, 会不断循环呼叫<code>platform_match函数</code>去遍历所有设备和驱动:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/8.png" alt="img"></p>
<p>匹配优先级顺序实现位于<code>drivers/base/platform.c</code>的platform_match函数，下面按照优先级由高到底的匹配顺序介绍：</p>
<h5><span id="1-3-1-1-1-of-match-table">1.3.1.1.1 of_match_table</span><a href="#1-3-1-1-1-of-match-table" class="header-anchor">#</a></h5><p><code>of_match_table</code>就是从dts中对应node的<code>compatible属性</code>去匹配设备和驱动。</p>
<p><code>compatible</code>属性也叫做<code>“兼容性”</code>属性，是一个字符串列表, 格式如下所示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">“manufacturer,model”</span><br></pre></td></tr></table></figure>

<p><code>manufacturrer</code>表示厂商，<code>model</code>表示驱动名字，该属性用于将设备和驱动绑定起来。</p>
<p><code>platform_device.dev.of_node </code>和 <code>platform_driver.driver.of_match_table</code>介绍：</p>
<p>由设备树节点转换得来的 <code>platform_device </code>中，含有一个结构体：<code>of_node</code>。 它的类型如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/9.png" alt="img"></p>
<p><code>platform_driver.driver.of_match_table </code>类型如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/10.png" alt="img"></p>
<p>一般驱动程序都会有一个<code>of_match_table</code>匹配表，此<code>of_match_table</code>匹配表保存着一些<code>compatible</code>值，如果dts中的<code>compatible</code>属性值和<code>of_match_table</code>匹配表中的有一个值相等，那么就表示设备可以使用这个驱动。</p>
<p>如下图dts定义了一个<code>mipi_rx: cif</code>节点:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/11.png" alt="img"></p>
<p>驱动程序中的定义如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/12.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/13.png" alt="img"></p>
<p>那么这里驱动程序中的<code>.of_match_table</code>和dts能够匹配，那么就说明<code>match</code>成功，匹配成功后调用<code>platform driver</code>的<code>probe</code>函数。一般在驱动程序<code>module int</code>的时候，也就是<code>insmod</code>的时候，会用<code>platform_driver_register</code>来进行match过程。</p>
<h5><span id="1-3-1-1-2-id-table">1.3.1.1.2 ID table</span><a href="#1-3-1-1-2-id-table" class="header-anchor">#</a></h5><p>下面这个例子就是用一个驱动来匹配两个分别叫<code>&quot;demo0&quot;</code>和<code>&quot;demo1&quot;</code>的设备，注意，数组最后的{}是一定要的，这个是内核判断数组已经结束的标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> <span class="title">tbl</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="string">&quot;demo0&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;demo1&quot;</span>&#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(platform, tbl);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/14.png" alt="image-20240727174003803"></p>
<h5><span id="1-3-1-1-3-name">1.3.1.1.3 name</span><a href="#1-3-1-1-3-name" class="header-anchor">#</a></h5><p>假如前面两项匹配规则都不满足，那么最后可以是用name来匹配。例如：上面的<code>mipi_rx: cif</code>节点:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/15.png" alt="image-20240727174511089"></p>
<p>转换后就对应一个<code>platform_device</code>，<code>platform_device</code>中<code>.name= “cif”</code>,利用名字也能匹配上。</p>
<h3><span id="1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe">1.3.2 匹配成功后执行probe</span><a href="#1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/16.png" alt="image-20240727171618120"></p>
<p>drvier匹配device成功调用driver的probe函数。一般平台设备都不需要驱动代码去定义，而是直接放入设备树作为设备树节点，内核启动后遍历设备树节点，将其转换成<code>platform_device</code>。</p>
<h3><span id="1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng">1.3.3 总结下<code>platform_driver</code>的注册执行过程</span><a href="#1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/17.png" alt="image-20240727170620921"></p>
<h2><span id="1-4-zong-jie-ping-tai-she-bei-x2f-ping-tai-qu-dong-de-zhu-ce-guo-cheng">1.4 总结平台设备&#x2F;平台驱动的注册过程</span><a href="#1-4-zong-jie-ping-tai-she-bei-x2f-ping-tai-qu-dong-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/18.png" alt="img"></p>
<h2><span id="1-6-ping-tai-she-bei-x2f-ping-tai-qu-dong-xiang-guan-api">1.6 平台设备&#x2F;平台驱动相关API</span><a href="#1-6-ping-tai-she-bei-x2f-ping-tai-qu-dong-xiang-guan-api" class="header-anchor">#</a></h2><h3><span id="1-6-1-zhu-ce-x2f-fan-zhu-ce">1.6.1 注册&#x2F;反注册</span><a href="#1-6-1-zhu-ce-x2f-fan-zhu-ce" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//\include\linux\platform_device.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">　platform_device_register/ platform_device_unregister</span><br><span class="line">　platform_driver_register/ platform_driver_unregister</span><br><span class="line"></span><br><span class="line">　platform_add_devices <span class="comment">// 注册多个 device</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/19.png" alt="image-20240727175522278"></p>
<h3><span id="1-6-2-zi-yuan-huo-qu-shi-fang">1.6.2 资源获取释放</span><a href="#1-6-2-zi-yuan-huo-qu-shi-fang" class="header-anchor">#</a></h3><h4><span id="1-6-2-1-io-resource">1.6.2.1 IO resource</span><a href="#1-6-2-1-io-resource" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>kernel\include\linux\ioport.h</code>中有<code>resource结构</code>。用来描述hw设备的资源信息, <code>include\linux\ioport.h</code>:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/20.png" alt="img"></p>
<p>flags一般有以下几种：比如中断资源， IO端口资源， IO内存资源， DMA资源</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/21.png" alt="img"></p>
<ul>
<li><code>IORESOURCE_IO</code>：表示IO资源，cpu需要用特殊指令才能访问或需要用特殊访问方式才能访问,不能直接用指针来寻址</li>
<li><code>IORESOURCE_MEM</code>：表示IO内存，可以直接用指针引用来直接寻址操作</li>
</ul>
<p>这里举个例子：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/22.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/23.png" alt="img"></p>
<p>打印如下：那这里的<code>pdev</code>对应dts中的<code>mipi_rx</code>节点。<code>platform_get_resource</code>可以从dts <code>node</code>中找到io内存资源。</p>
<p>那这里循环获取4次，如下所示地址范围和上面的dts节点一致：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/24.png" alt="img"></p>
<h4><span id="1-6-2-2-irq">1.6.2.2 IRQ</span><a href="#1-6-2-2-irq" class="header-anchor">#</a></h4><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/25.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/26.png" alt="img"></p>
<ul>
<li>IORESOURCE_IRQ: 中断irq资源</li>
</ul>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/27.png" alt="img"></p>
<p>中断触发类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include\linux\platform_device.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING 1     <span class="comment">//上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING 2    <span class="comment">//下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING) <span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH 4    <span class="comment">//电平触发-高电平</span></span></span><br></pre></td></tr></table></figure>

<p>这里又要引入新概念GIC: <a href="https://www.cnblogs.com/fuzidage/p/17551724.html">设备驱动-10.中断子系统-3.中断设备树表述与解析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p>Dts中描述到了GIC相关基础知识。(<code>Generic Interrupt Controller</code>)是ARM公司提供的一个通用的中断控制器。</p>
<p>GIC <strong>3要素</strong>：</p>
<ul>
<li><ul>
<li>中断类型</li>
<li>中断号</li>
<li>中断触发方式这三个要素</li>
</ul>
</li>
</ul>
<ol>
<li>GIC的外设中断（除去SGI）类型有两类：</li>
</ol>
<ul>
<li><ul>
<li>SPI，共享外设中断(由GIC内部的<code>distributor</code>来分发到相关CPU)，中断号：<code>32~1019</code></li>
<li>PPI，私有外设中断(指定CPU接收)，中断号：<code>16~31</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li>外设中断号的分配规则如下：</li>
</ol>
<ul>
<li><ul>
<li><code>32~1019</code>给SPI</li>
<li><code>16~31</code>给PPI</li>
</ul>
</li>
</ul>
<ol start="3">
<li>所有外设中断都支持四种触发方式:</li>
</ol>
<ul>
<li><ul>
<li>上升沿触发</li>
<li>下降沿触发</li>
<li>高电平触发</li>
<li>低电平触发</li>
</ul>
</li>
</ul>
<p>所以DTS中接在GIC的<code>device node</code>的<code>interrupts</code>属性也是用这三个要素来描述一个具体的中断。</p>
<p>格式如：<code>interrupts = &lt;interruptType interruptNumber triggerType&gt; </code></p>
<table>
<thead>
<tr>
<th><strong>Interrrupt Types</strong></th>
<th><strong>Interrrupt Number</strong></th>
<th><strong>Trigger Type</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0 &#x3D; SPI,  1 &#x3D; PPI</td>
<td>32… …1019</td>
<td>1 &#x3D; low to high, 2 &#x3D; high to low, 4 &#x3D; high level, 8 &#x3D; low level</td>
</tr>
</tbody></table>
<p><code>sample code</code>如下:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/28.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/29.png" alt="img"></p>
<p>打印结果如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/30.png" alt="img"></p>
<p> 那么最后dts解析的结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out_irq-&gt;np = interrupt-parent = gic node</span><br><span class="line">out_irq-&gt;args[<span class="number">0</span>] = GIC_SPI;</span><br><span class="line">out_irq-&gt;args[<span class="number">1</span>] = 硬件中断号 = <span class="number">155</span></span><br><span class="line">out_irq-&gt;args[<span class="number">2</span>] = 中断触发类型 = IRQ_TYPE_LEVEL_HIGH</span><br><span class="line"></span><br><span class="line">out_irq-&gt;np = interrupt-parent = gic node</span><br><span class="line">out_irq-&gt;args[<span class="number">0</span>] = GIC_SPI;</span><br><span class="line">out_irq-&gt;args[<span class="number">1</span>] = 硬件中断号 = <span class="number">156</span></span><br><span class="line">out_irq-&gt;args[<span class="number">2</span>] = 中断触发类型 = IRQ_TYPE_LEVEL_HIGH</span><br></pre></td></tr></table></figure>

<p><code>platform_get_irq</code>返回一个虚拟中断号，这里对应的是<code>27， 28</code>.</p>
<p><code>devm_request_irq</code>用来申请中断，分配<code>isr中断处理函数</code>。该函数可以在驱动卸载时不用主动调用<code>free_irq</code>显示释放中断请求。</p>
<p>可以看到两次call <code>devm_request_irq</code>却是用的同一个中断服务程序<code>cif_isr</code>，这也是允许的，我们看一下函数原型：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/31.png" alt="image-20240727182250194"></p>
<p><code>devm_request_irq</code>会建立中断号<code>irq_num</code>和中断服务程序<code>isr</code>的绑定，最后一个参数会传给中断服务程序<code>isr</code>.</p>
<p>中断服务程序<code>isr</code>能够根据中断号<code>irq_num</code>和传进的参数进行区分中断源。</p>
<h4><span id="1-6-2-3-gpio">1.6.2.3 GPIO</span><a href="#1-6-2-3-gpio" class="header-anchor">#</a></h4><p><code>of_get_named_gpio_flags</code>获取dts中<code>gpio</code> 编号，并且会找到<code>device_node</code>，找到<code>of_gpio_flags</code>。</p>
<p><code>gpio_request</code>申请<code>gpio</code></p>
<p><code>gpio_direction_output</code>设置成<code>output</code>且<code>set gpio val</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_get_named_gpio_flags</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *list_name,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> index, <span class="keyword">enum</span> of_gpio_flags *flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span>;		    </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">//include\asm-generic\gpio.h</span></span><br><span class="line"><span class="comment">//include\linux\gpio.h</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/32.png" alt="image-20240727183103383"></p>
<p>举个例子：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/33.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_ACTIVE_HIGH 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_ACTIVE_LOW 1</span></span><br><span class="line"><span class="comment">//include\linux\gpio\machine.h</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/34.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/35.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/36.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/37.png" alt="img"></p>
<p>这里的<code>gpio 编号=411 = GPIO_D + offset = 404 + 7 =411</code>(也就是dts中配置的<code>portd 7</code>)，这里由于是<code>of_gpio_flags </code>是<code>OF_GPIO_ACTIVE_LOW =0x01</code>，所以<code>snsr_rst_pol = 1</code>.</p>
<h1><span id="2-ping-tai-she-bei-qu-dong-shi-li">2 平台设备驱动示例</span><a href="#2-ping-tai-she-bei-qu-dong-shi-li" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_OPR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_OPR_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*init) (<span class="type">int</span> which); <span class="comment">/* 初始化LED, which-哪个LED */</span>       </span><br><span class="line">        <span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">char</span> status); <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>①分配&#x2F;设置&#x2F;注册<code>platform_device</code>结构体 在里面定义所用资源，指定设备名字。-<code>Board_A_led.c</code></p>
<p>②分配&#x2F;设置&#x2F;注册 <code>platform_driver </code>结构体 在其中的 probe 函数里，分配&#x2F;设置&#x2F;注册 <code>file_operations </code>结构体， 并从 <code>platform_device </code>中确实所用硬件资源。 指定 <code>platform_driver</code> 的名字。 -<code>Chip_demo_gpio.c</code></p>
<h2><span id="2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia">2.1 通用字符设备驱动框架</span><a href="#2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line">                                                               */</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> *<span class="title">p_led_opr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span> &#123;</span><br><span class="line">        device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, minor); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span> &#123;</span><br><span class="line">        device_destroy(led_class, MKDEV(major, minor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span> &#123;</span><br><span class="line">        p_led_opr = opr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(led_class_create_device);</span><br><span class="line">EXPORT_SYMBOL(led_class_destroy_device);</span><br><span class="line">EXPORT_SYMBOL(register_led_operations);</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* write(fd, &amp;val, 1); */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">char</span> status;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">        <span class="type">int</span> minor = iminor(inode);</span><br><span class="line">        err = copy_from_user(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 根据次设备号和status控制LED */</span></span><br><span class="line">        p_led_opr-&gt;ctl(minor, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">        <span class="type">int</span> minor = iminor(node);</span><br><span class="line">        <span class="comment">/* 根据次设备号初始化LED */</span></span><br><span class="line">        p_led_opr-&gt;init(minor);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv</span> =</span> &#123;</span><br><span class="line">        .owner         = THIS_MODULE,</span><br><span class="line">        .open    = led_drv_open,</span><br><span class="line">        .read    = led_drv_read,</span><br><span class="line">        .write   = led_drv_write,</span><br><span class="line">        .release = led_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_drv);</span><br><span class="line">        led_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line">        err = PTR_ERR(led_class);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(led_class)) &#123;</span><br><span class="line">                printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">                unregister_chrdev(major, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        class_destroy(led_class);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里只实现一个框架, 具体的opr操作函数需要具体单板去实现。先注册字符设备驱动，确定好class和主设备号。</p>
<p>因为暂时还不知道具体led驱动是啥，因此需要外部去注册具体的led驱动，交给<code>platform_driver</code>去建立。</p>
<p>暂时先不建立设备节点，设备节点交给<code>platform_device</code>去建立，因为暂时不知道设备的led资源信息。</p>
<p><code>EXPORT_SYMBOL</code>导出<code>led_class_create_device</code>，<code>led_class_destroy_device</code>， <code>register_led_operations</code>函数。</p>
<h2><span id="2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts">2.2 具体单板资源描述驱动(platform_device暂不使用dts)</span><a href="#2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_RESOURCE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_RESOURCE_H</span></span><br><span class="line"><span class="comment">/* GPIO3_0 */</span></span><br><span class="line"><span class="comment">/* bit[31:16] = group */</span></span><br><span class="line"><span class="comment">/* bit[15:0]  = which pin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP(x) (x&gt;&gt;16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN(x)   (x&amp;0xFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>Board_A_led.c</code>这里实现了单板的资源定义，这里是<code>gpio3_1</code>,<code>gpio5_8</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_dev_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">resources</span>[] =</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .start = GROUP_PIN(<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .start = GROUP_PIN(<span class="number">5</span>,<span class="number">8</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">board_A_led_dev</span> =</span> &#123;</span><br><span class="line">        .name = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">        .num_resources = ARRAY_SIZE(resources),</span><br><span class="line">        .resource = resources,</span><br><span class="line">        .dev = &#123;</span><br><span class="line">                .release = led_dev_release,</span><br><span class="line">         &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_dev_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_device_register(&amp;board_A_led_dev);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_dev_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_device_unregister(&amp;board_A_led_dev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_dev_init);</span><br><span class="line">module_exit(led_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);　</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>如果<code>platform_device</code>中不提供 <code>release </code>函数，如下图所示不提供红框部分的函数:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/38.png" alt="img"></p>
<p>则在调用 <code>platform_device_unregister</code> 时会出现警告，如下图所示, 因此我们可以将<code>release</code>实现为空。</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/39.png" alt="img"></p>
<h2><span id="2-3-ju-ti-xin-pian-qu-dong-platform-driver">2.3 具体芯片驱动(platform_driver)</span><a href="#2-3-ju-ti-xin-pian-qu-dong-platform-driver" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LEDDRV_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LEDDRV_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _LEDDRV_H */</span></span></span><br></pre></td></tr></table></figure>

<p><code>Chip_demo_gpio.c</code>实现opr的gpio控制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leddrv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledpins[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化LED, which-哪个LED */</span>      </span><br><span class="line">&#123;  </span><br><span class="line">    printk(<span class="string">&quot;init gpio: group %d, pin %d\n&quot;</span>, GROUP(g_ledpins[which]), PIN(g_ledpins[which]));</span><br><span class="line">    <span class="keyword">switch</span>(GROUP(g_ledpins[which]))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_ctl</span> <span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;set led %s: group %d, pin %d\n&quot;</span>, status ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>, GROUP(g_ledpins[which]), PIN(g_ledpins[which]));</span><br><span class="line">    <span class="keyword">switch</span>(GROUP(g_ledpins[which]))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        res = platform_get_resource(pdev, IORESOURCE_IRQ, i++);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">        g_ledpins[g_ledcnt] = res-&gt;start;<span class="comment">//获取gpio num</span></span><br><span class="line">        led_class_create_device(g_ledcnt);<span class="comment">//利用EXPORT_SYMBOL导出的函数为每个led创建设备节点</span></span><br><span class="line">        g_ledcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        res = platform_get_resource(pdev, IORESOURCE_IRQ, i);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        led_class_destroy_device(i);</span><br><span class="line">        i++;</span><br><span class="line">        g_ledcnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">chip_demo_gpio_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = chip_demo_gpio_probe,</span><br><span class="line">    .remove     = chip_demo_gpio_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chip_demo_gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;chip_demo_gpio_driver);</span><br><span class="line">    register_led_operations(&amp;board_demo_led_opr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">lchip_demo_gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;chip_demo_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(chip_demo_gpio_drv_init);</span><br><span class="line">module_exit(lchip_demo_gpio_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>platform_device</code>和<code>platform_driver</code>都<code>insmod</code>（注册）后，总线设备驱动模型会进行<code>match</code>匹配，匹配成功调用<code>probe</code>函数，这里使用name进行匹配的。</p>
<ol>
<li><code>chip_demo_gpio_probe</code>中, 获取单板定义的资源信息，依次创建设备节点。</li>
<li><code>register_led_operations</code>注册了具体chip的opr操作函数(寄存器操作不具体展开实现，opr暂定为空)。</li>
</ol>
<p>当用户调用open&#x2F;write时便可操作具体chip的led驱动方法。</p>
<h2><span id="2-4-ce-shi">2.4 测试</span><a href="#2-4-ce-shi" class="header-anchor">#</a></h2><h3><span id="2-4-1-makefile">2.4.1 Makefile</span><a href="#2-4-1-makefile" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span></span><br><span class="line"><span class="comment"># 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="comment"># 2.1 ARCH,          比如: export ARCH=arm64</span></span><br><span class="line"><span class="comment"># 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-</span></span><br><span class="line"><span class="comment"># 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin </span></span><br><span class="line"><span class="comment"># 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span></span><br><span class="line"><span class="comment">#       请参考各开发板的高级用户使用手册</span></span><br><span class="line"> </span><br><span class="line">KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4</span><br><span class="line"> </span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">        <span class="variable">$(CROSS_COMPILE)</span>gcc -o ledtest ledtest.c </span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">        rm -rf modules.order</span><br><span class="line">        rm -f ledtest</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参考内核源码drivers/char/ipmi/Makefile</span></span><br><span class="line"><span class="comment"># 要想把a.c, b.c编译成ab.ko, 可以这样指定:</span></span><br><span class="line"><span class="comment"># ab-y := a.o b.o</span></span><br><span class="line"><span class="comment"># obj-m += ab.o</span></span><br><span class="line"></span><br><span class="line">obj-m += leddrv.o chip_demo_gpio.o board_A_led.o</span><br></pre></td></tr></table></figure>

<p>编译出3个ko，依次insmod <code>leddrv.ko</code> <code>chip_demo_gpio.ko</code> <code>board_A_led.ko</code></p>
<h3><span id="2-4-2-ledtest-ce-shi-cheng-xu">2.4.2 ledtest测试程序</span><a href="#2-4-2-ledtest-ce-shi-cheng-xu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./ledtest /dev/100ask_led0 on</span></span><br><span class="line"><span class="comment"> * ./ledtest /dev/100ask_led0 off</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        <span class="type">char</span> status;</span><br><span class="line">        <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt; &lt;on | off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>))&#123;</span><br><span class="line">                status = <span class="number">1</span>;</span><br><span class="line">                write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                status = <span class="number">0</span>;</span><br><span class="line">                write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/40.png" alt="img"></p>
<h2><span id="2-5-is-err-x2f-err-ptr-x2f-ptr-err-x2f-null-ptr-han-shu-zu">2.5 IS_ERR&#x2F;ERR_PTR&#x2F;PTR_ERR&#x2F;NULL_PTR函数族</span><a href="#2-5-is-err-x2f-err-ptr-x2f-ptr-err-x2f-null-ptr-han-shu-zu" class="header-anchor">#</a></h2><p><code>include\linux\err.h</code>:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/41.png" alt="image-20240727204217358"></p>
<p>内核中的函数常常返回指针，如果出错，也希望能够通过返回的指针体现出来。那么有三种情况：<code>合法指针，NULL指针和非法指针</code>。</p>
<p>1.<code>合法指针</code>：内核函数返回的指针一般是4K对齐，即 ptr &amp; 0xfff &#x3D;&#x3D; 0，也就是0x1000的倍数。其中Linux采用分页机制管理内存，而CPU访问的是线性地址需要通过页表转化成物理地址。所以内核就约定留出最后一页4k（<code>0xfffffffffffff000 ~ 0xffffffffffffffff</code>）用来记录内核空间的错误指针(32位的话就是（<code>0xfffff000 ~ 0xffffffff</code>）).</p>
<p>2.<code>非法指针</code>：一般内核函数地址不会落在<code>（0xfffff000，0xffffffff）</code>之间，而一般内核的出错代码也是一个小负数，在<code>-4095到0</code>之间，转变成<code>unsigned long</code>，正好在<code>（0xfffff000，0xffffffff)</code>之间。因此可以用 <code>(unsigned long)ptr &gt; (unsigned long)-1000L</code></p>
<p><code>-1000L</code>正好是<code>0xfffff000</code>。</p>
<p>3.linux内核中有一个宏<code>MAX_ERRNO = 4095</code>。errno见如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include/<span class="keyword">asm</span>-generic/errno-base.h  <span class="comment">//1-34</span></span><br><span class="line">include\uapi\<span class="keyword">asm</span>-generic\errno.h  <span class="comment">//35-133</span></span><br><span class="line">include\linux\errno.h <span class="comment">//512-530</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-1-is-err">2.5.1 IS_ERR</span><a href="#2-5-1-is-err" class="header-anchor">#</a></h3><p>作用：判断是否无效非法指针。</p>
<p>实现见上面图片，例如一个地址<code>0xfffff,ffaa</code>，那么代入后：很明显返回1,是一个错误非法指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0xfffffffaa</span> &gt; <span class="number">0xfffff000</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-2-is-err-or-null">2.5.2 IS_ERR_OR_NULL</span><a href="#2-5-2-is-err-or-null" class="header-anchor">#</a></h3><p>和IS_ERR基本等同，会先提前判断一下是否空。</p>
<h3><span id="2-5-3-ptr-err">2.5.3 PTR_ERR</span><a href="#2-5-3-ptr-err" class="header-anchor">#</a></h3><p>作用：将非法指针转成错误码返回。</p>
<p>实现见上面图片. 将传入的<code>void *</code>类型指针强转为long类型，并返回</p>
<h3><span id="2-5-4-err-ptr">2.5.4 ERR_PTR</span><a href="#2-5-4-err-ptr" class="header-anchor">#</a></h3><p>将传入的long类型强转为<code>void *</code>类型指针，并返回</p>
<h1><span id="3-yin-ru-sysfs">3 引入sysfs</span><a href="#3-yin-ru-sysfs" class="header-anchor">#</a></h1><p>讲到总线设备驱动模型，那不能少了sysfs。<code>sysfs</code>是一种虚拟文件系统，旨在提供一种访问内核数据结构的方法，从而允许用户空间程序查看和控制系统的设备和资源。</p>
<p>例如<a href="https://www.cnblogs.com/fuzidage/p/18114131">设备驱动-16-Linux 内核LED子系统 - fuzidage - 博客园 (cnblogs.com)</a> 操作led：</p>
<p><code>echo 1 &gt; /sys/class/leds/red/brightness</code></p>
<p>又例如某个驱动修改设置module_param:</p>
<p><code>echo &quot;8&quot; &gt;/sys/module/my_drv/parameters/lg_lv</code></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/42.png" alt="image-20240727220331721"></p>
<p> <code>kobject</code> 和 <code>kset</code> 是构成 <code>/sys</code> 目录下的目录节点和文件节点的核心，也是层次化组织总线、设备、驱动的核心数据结构，<code>kobject、kset </code>数据结构都能表示一个目录或者文件节点。在这个目录下面的每一个子目录，其实都是相同类型的kobject集合。然后不同的kset组织成树状层次的结构，就构成了sysfs子系统。</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/43.png" alt="image-20240727220824743"></p>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-3-GPIO驱动KEY示例</title>
    <url>/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-app-du-qu-an-jian-fang-shi">1 APP 读取按键方式</a><ul>
<li><a href="#1-1-cha-xun-fang-shi">1.1 查询方式</a></li>
<li><a href="#1-2-xiu-mian-huan-xing-fang-shi">1.2 休眠-唤醒方式</a></li>
<li><a href="#1-3-poll-fang-shi">1.3 poll 方式</a></li>
<li><a href="#1-4-yi-bu-tong-zhi-fang-shi">1.4 异步通知方式</a></li>
<li><a href="#1-5-zong-jie-4-chong-du-an-jian-fang-shi">1.5 总结4种读按键方式</a></li>
</ul>
</li>
<li><a href="#2-gpio-an-jian-qu-dong">2 GPIO按键驱动</a><ul>
<li><a href="#2-1-an-jian-qu-dong-kuang-jia">2.1 按键驱动框架</a><ul>
<li><a href="#2-1-1-button-operations-jie-gou-ti">2.1.1 button_operations 结构体</a></li>
<li><a href="#2-1-2-file-operations-jie-gou-ti">2.1.2 file_operations 结构体</a></li>
</ul>
</li>
<li><a href="#2-2-ju-ti-dan-ban-an-jian-qu-dong">2.2 具体单板按键驱动</a><ul>
<li><a href="#2-2-1-ccm-shi-zhong-shi-neng">2.2.1 CCM时钟使能</a></li>
<li><a href="#2-2-2-pei-cheng-gpio-mo-shi">2.2.2 配成GPIO 模式</a></li>
<li><a href="#2-2-3-gpio-pei-cheng-shu-ru">2.2.3 GPIO配成输入</a></li>
<li><a href="#2-2-4-du-qu-gpio-dian-ping">2.2.4 读取gpio电平</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ce-shi">3 测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-app-du-qu-an-jian-fang-shi">1 APP 读取按键方式</span><a href="#1-app-du-qu-an-jian-fang-shi" class="header-anchor">#</a></h1><ol>
<li>查询方式</li>
<li>休眠-唤醒方式</li>
<li>poll 方式</li>
<li>异步通知方式</li>
</ol>
<p>第2、3、4种方法，都涉及中断服务程序。</p>
<h2><span id="1-1-cha-xun-fang-shi">1.1 查询方式</span><a href="#1-1-cha-xun-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/1.png" alt="image"></p>
<p>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置 GPIO 为输入引脚。 APP 调用 read 时，导致驱动中对应的 read 函数被调用，它读取寄存器，把引脚状态直接返回给 APP,APP需要反复read查询引脚电平状态。</p>
<p>很明显，查询方式用的非阻塞IO（<code>O_NONBLOCK</code>）。</p>
<h2><span id="1-2-xiu-mian-huan-xing-fang-shi">1.2 休眠-唤醒方式</span><a href="#1-2-xiu-mian-huan-xing-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/2.png" alt="image"></p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 调用 read 时，导致驱动中对应的 read 函数被调用，如果有按键数据则直接返回给 APP；否则 APP 在内核态read函数中休眠。</li>
<li>当用户按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，read函数被唤醒，执行驱动代码，把按键数据返回给APP(用户空间)。</li>
</ol>
<h2><span id="1-3-poll-fang-shi">1.3 poll 方式</span><a href="#1-3-poll-fang-shi" class="header-anchor">#</a></h2><p>上面的休眠-唤醒方式有个缺点：如果一直没操作按键，那么 APP 就会永远休眠。<br>我们可以给 APP 定个闹钟，这就是 poll 方式。当超时后就直接返回不再休眠。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/3.png" alt="image"></p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 调用 poll 或 select 函数，意图是“查询”是否有数据，这 2 个函数都可以指定一个超时时间，即在这段时间内没有数据的话就返回错误。这会导致驱动中对应的 <code>drv_poll</code> 函数被调用，如果有按键数据则直接返回给 APP；否则 APP 在内核态休眠一段时间。</li>
<li>当按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的 APP。如果用户没按下按键，但是超时时间到了，内核也会唤醒 APP。</li>
</ol>
<p>所以 APP 被唤醒有 2 种原因：用户操作了按键或者超时。被唤醒的 APP 在内核态继续运行，即继续执行驱动代码，把 “状态” 返回给 APP(用户空间)。APP 得到 <code>poll/select </code>函数的返回结果后，如果确认是有数据的，则再调用 read 函数，这会导致驱动中的 read 函数被调用，这时驱动程序中含有数据，会直接返回数据。</p>
<h2><span id="1-4-yi-bu-tong-zhi-fang-shi">1.4 异步通知方式</span><a href="#1-4-yi-bu-tong-zhi-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/4.png" alt="image"><br>异步通知的实现原理是：内核给 APP 发信号。信号有很多种，这里发的是SIGIO。<br>驱动程序中构造、注册一个<code> file_operations</code> 结构体，里面提供有对应的<code>open,read,fasync</code> 函数。</p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 给信号 <code>SIGIO</code> 注册自己的处理函数： <code>my_signal_fun</code>。</li>
<li>APP 调用<code>fcntl</code>函数，把驱动程序的 flag 改为 <code>FASYNC</code>，这会导致驱动程序的<code>fasync</code>函数被调用，它只是简单记录进程 PID。</li>
<li>当用户按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，然后给进程 PID 发送 <code>SIGIO</code> 信号。</li>
<li>APP 收到信号后会被打断，先执行信号处理函数：在信号处理函数中可以去调用 read 函数读取按键值。</li>
<li>信号处理函数返回后， APP 会继续执行原先被打断的代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_sig_func</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get a signal : %d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    signal(SIGIO, my_sig_func);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello, world %d!\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/5.png" alt="image-20240728184640793"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/6.png" alt="image"><br>发送一个SIGIO讯号给进程<code>3581339</code> <code>my_sig_func</code>函数，可以看到打印<code>”get a signal 29“</code>，即为<code>SIGIO</code>信号。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/7.png" alt="image"></p>
<h2><span id="1-5-zong-jie-4-chong-du-an-jian-fang-shi">1.5 总结4种读按键方式</span><a href="#1-5-zong-jie-4-chong-du-an-jian-fang-shi" class="header-anchor">#</a></h2><p>关于这几种方式的具体原理和示例后面会进行深度剖析：</p>
<p>[<a href="https://www.cnblogs.com/fuzidage/p/17369817.html">字符设备驱动-6.POLL底层驱动机制 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17438371.html">字符设备驱动-7.异步通知 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17469849.html">字符设备驱动-8.休眠唤醒机制 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器 - fuzidage - 博客园 (cnblogs.com)</a></p>
<h1><span id="2-gpio-an-jian-qu-dong">2 GPIO按键驱动</span><a href="#2-gpio-an-jian-qu-dong" class="header-anchor">#</a></h1><h2><span id="2-1-an-jian-qu-dong-kuang-jia">2.1 按键驱动框架</span><a href="#2-1-an-jian-qu-dong-kuang-jia" class="header-anchor">#</a></h2><p>按键驱动程序最简单的方法：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/8.png" alt="image"></p>
<p>我们的目的写出一个容易扩展到各种芯片、各种板子的按键驱动程序，所以驱动程序分为<strong>上下两层</strong>：</p>
<ol>
<li><code>button_drv.c</code> 分配&#x2F;设置&#x2F;注册<code> file_operations</code> 结构体起承上启下的作用，向上提供 <code>button_open</code>,<code>button_read </code>供 APP 调用。而这 2 个函数又会调用底层硬件提供的 <code>p_button_opr </code>中的 init、 read 函数操作硬件。</li>
<li><code>board_xxx.c</code> 实现 <code>p_button_opr</code>结构体，这个结构体是我们自己抽象出来的，里面定义<code>单板 xxx</code> 的按键操作函数。这样的结构易于扩展，对于不同的单板，只需要替换<code>board_xxx.c</code>提供自己的 <code>button_operations</code> 结构体即可。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/9.png" alt="image"></li>
</ol>
<h3><span id="2-1-1-button-operations-jie-gou-ti">2.1.1 button_operations 结构体</span><a href="#2-1-1-button-operations-jie-gou-ti" class="header-anchor">#</a></h3><details>
<summary>button_drv.h</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BUTTON_DRV_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BUTTON_DRV_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">void</span> (*init) (<span class="type">int</span> which);</span><br><span class="line">    <span class="type">int</span> (*read) (<span class="type">int</span> which);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_button_operations</span><span class="params">(<span class="keyword">struct</span> button_operations *opr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_button_operations</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>board_xxx.c</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernelcapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">board_xxx_button_init_gpio</span> <span class="params">(<span class="type">int</span> which)</span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d, init gpio for button %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_xxx_button_read_gpio</span> <span class="params">(<span class="type">int</span> which)</span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d, read gpio for button %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> <span class="title">my_buttons_ops</span> =</span>&#123;</span><br><span class="line">    .count = <span class="number">2</span>,</span><br><span class="line">    .init  = board_xxx_button_init_gpio,</span><br><span class="line">    .read  = board_xxx_button_read_gpio,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">board_xxx_button_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    register_button_operations(&amp;my_buttons_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">board_xxx_button_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unregister_button_operations();</span><br><span class="line">&#125;</span><br><span class="line">module_init(board_xxx_button_init);</span><br><span class="line">module_exit(board_xxx_button_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
board_xxx.c里面实现了具体单板的button_operations，当insmod这个驱动时，调用 register_button_operations 函数，把my_buttons_ops这个结构体注册到上层驱动中，这里.init .read函数先不去实现。

<h3><span id="2-1-2-file-operations-jie-gou-ti">2.1.2 file_operations 结构体</span><a href="#2-1-2-file-operations-jie-gou-ti" class="header-anchor">#</a></h3><details>
<summary>button_drv.c</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernelcapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> *<span class="title">p_button_opr</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">button_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">button_open</span> <span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minor = iminor(inode);</span><br><span class="line">    p_button_opr-&gt;init(minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">button_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minor = iminor(file_inode(file));</span><br><span class="line">    <span class="type">char</span> level;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    level = p_button_opr-&gt;read(minor);</span><br><span class="line">    err = copy_to_user(buf, &amp;level, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">button_fops</span> =</span> &#123;</span><br><span class="line">    .open = button_open,</span><br><span class="line">    .read = button_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_button_operations</span><span class="params">(<span class="keyword">struct</span> button_operations *opr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p_button_opr = opr;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; opr-&gt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        device_create(button_class, <span class="literal">NULL</span>, MKDEV(major, i), <span class="literal">NULL</span>, <span class="string">&quot;100ask_button%d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_button_operations</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_button_opr-&gt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        device_destroy(button_class, MKDEV(major, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(register_button_operations);</span><br><span class="line">EXPORT_SYMBOL(unregister_button_operations);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">button_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_button&quot;</span>, &amp;button_fops);</span><br><span class="line">    button_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_button&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(button_class))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">button_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    class_destroy(button_class);</span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;100ask_button&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(button_init);</span><br><span class="line">module_exit(button_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
上层是 `button_drv.c`，按照字符设备驱动标准框架编写，`register_button_operations`实现了将底层具体的`button_operations`对象注册进来，调用`open/read`时便可操作具体的单板，`device_create`为单板的具体按键创建设备节点。注意`insmod`顺序要先安装`button_drv.ko`, 具体单板驱动要后安装，否则`register_button_operations`函数是未定义的。



<h2><span id="2-2-ju-ti-dan-ban-an-jian-qu-dong">2.2 具体单板按键驱动</span><a href="#2-2-ju-ti-dan-ban-an-jian-qu-dong" class="header-anchor">#</a></h2><p>以<code>imx6ull</code>单板为例，按键引脚为 <code>GPIO5_IO01</code>、 <code>GPIO4_IO14</code>，平时按键电平为高，按下按键后电平为低，如下图：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/10.png" alt="image"></p>
<ol>
<li>使能电源&#x2F;时钟控制器</li>
<li>配置引脚模式成gpio</li>
<li>配置引脚方向为输入</li>
<li>读取电平<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/11.png" alt="image"></li>
</ol>
<h3><span id="2-2-1-ccm-shi-zhong-shi-neng">2.2.1 CCM时钟使能</span><a href="#2-2-1-ccm-shi-zhong-shi-neng" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/12.png" alt="image"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/13.png" alt="image"><br>设置<code> CCM_CCGR1[31:30]</code>、<code> CCM_CCGR3[13:12]</code>就可以使能<code> GPIO5</code>、<code>GPIO4</code>，设置为什么值呢？<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/14.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span>：该 GPIO 模块全程被关闭</span><br><span class="line"><span class="number">01</span>：该 GPIO 模块在 CPU run mode 情况下是使能的；在 WAIT 或 STOP 模式下，关闭</span><br><span class="line"><span class="number">10</span>：保留</span><br><span class="line"><span class="number">11</span>：该 GPIO 模块全程使能</span><br></pre></td></tr></table></figure>

<p>那么将<code>CCM_CCGR1[31:30]</code>、 <code>CCM_CCGR3[13:12]</code>设置成<code>0b11</code>即可。</p>
<h3><span id="2-2-2-pei-cheng-gpio-mo-shi">2.2.2 配成GPIO 模式</span><a href="#2-2-2-pei-cheng-gpio-mo-shi" class="header-anchor">#</a></h3><ol>
<li><code>GPIO5_IO01</code> pinmux 成 GPIO:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/15.png" alt="image"><ol start="2">
<li><code>GPIO4_IO14</code> pinmux 成 GPIO:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/16.png" alt="image"></li>
</ol>
</li>
</ol>
<h3><span id="2-2-3-gpio-pei-cheng-shu-ru">2.2.3 GPIO配成输入</span><a href="#2-2-3-gpio-pei-cheng-shu-ru" class="header-anchor">#</a></h3><p><code>GPIO4,GPIO5</code>寄存器地址:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/17.png" alt="image"><br>方向设置寄存器:(<code>offset 04</code>)<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/18.png" alt="image"></p>
<h3><span id="2-2-4-du-qu-gpio-dian-ping">2.2.4 读取gpio电平</span><a href="#2-2-4-du-qu-gpio-dian-ping" class="header-anchor">#</a></h3><p>注意输入模式下，gpio电平状态得从<code>GPIOx_PSR</code>得到（<code>offset 08</code>）<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/19.png" alt="image"></p>
<details>
<summary>button_board_imx6ull.c</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> dr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> gdir;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> psr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> imr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> isr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> edge_sel;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR3; </span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set GPIO5_IO03 as GPIO */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1;</span><br><span class="line"><span class="comment">/* set GPIO4_IO14 as GPIO */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio4</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio5</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">board_imx6ull_button_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化button, which-哪个button */</span>      </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CCM_CCGR1)&#123;</span><br><span class="line">        CCM_CCGR1 = ioremap(<span class="number">0x20C406C</span>, <span class="number">4</span>);</span><br><span class="line">        CCM_CCGR3 = ioremap(<span class="number">0x20C4074</span>, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1 = ioremap(<span class="number">0x229000C</span>, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B        = ioremap(<span class="number">0x20E01B0</span>, <span class="number">4</span>);</span><br><span class="line">        gpio4 = ioremap(<span class="number">0x020A8000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">        gpio5 = ioremap(<span class="number">0x20AC000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* 1. enable GPIO5 </span></span><br><span class="line"><span class="comment">         * CG15, b[31:30] = 0b11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">        <span class="comment">/* 2. set GPIO5_IO01 as GPIO </span></span><br><span class="line"><span class="comment">         * MUX_MODE, b[3:0] = 0b101</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1 = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/* 3. set GPIO5_IO01 as input </span></span><br><span class="line"><span class="comment">         * GPIO5 GDIR, b[1] = 0b0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gpio5-&gt;gdir &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/* 1. enable GPIO4 </span></span><br><span class="line"><span class="comment">         * CG6, b[13:12] = 0b11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *CCM_CCGR3 |= (<span class="number">3</span>&lt;&lt;<span class="number">12</span>);</span><br><span class="line">        <span class="comment">/* 2. set GPIO4_IO14 as GPIO </span></span><br><span class="line"><span class="comment">         * MUX_MODE, b[3:0] = 0b101</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/* 3. set GPIO4_IO14 as input </span></span><br><span class="line"><span class="comment">         * GPIO4 GDIR, b[14] = 0b0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gpio4-&gt;gdir &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_imx6ull_button_read</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 读button, which-哪个 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (gpio5-&gt;psr &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (gpio4-&gt;psr &amp; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> <span class="title">my_buttons_ops</span> =</span> &#123;</span><br><span class="line">    .count = <span class="number">2</span>,</span><br><span class="line">    .init = board_imx6ull_button_init,</span><br><span class="line">    .read = board_imx6ull_button_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">board_imx6ull_button_drv_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    register_button_operations(&amp;my_buttons_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">board_imx6ull_button_drv_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unregister_button_operations();</span><br><span class="line">&#125;</span><br><span class="line">module_init(board_imx6ull_button_drv_init);</span><br><span class="line">module_exit(board_imx6ull_button_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>具体单板驱动insmod会调用<code> register_button_operations</code>把具体的<code>my_buttons_ops</code>注册进去。当用户open,就会进行<code>board_imx6ull_button_init</code>进行按键寄存器配置。当用户read的时候调用<code>board_imx6ull_button_read</code>读取按键值。</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/20.png" alt="image"></p>
<h1><span id="3-ce-shi">3 测试</span><a href="#3-ce-shi" class="header-anchor">#</a></h1><details>
<summary>Makefile</summary>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span></span><br><span class="line"><span class="comment"># 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="comment"># 2.1 ARCH,          比如: export ARCH=arm64</span></span><br><span class="line"><span class="comment"># 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-</span></span><br><span class="line"><span class="comment"># 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin </span></span><br><span class="line"><span class="comment"># 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span></span><br><span class="line"><span class="comment">#       请参考各开发板的高级用户使用手册</span></span><br><span class="line">KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">	<span class="variable">$(CROSS_COMPILE)</span>gcc -o button_test button_test.c </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">	rm -rf modules.order</span><br><span class="line">	rm -f ledtest</span><br><span class="line"><span class="comment"># 参考内核源码drivers/char/ipmi/Makefile</span></span><br><span class="line"><span class="comment"># 要想把a.c, b.c编译成ab.ko, 可以这样指定:</span></span><br><span class="line"><span class="comment"># ab-y := a.o b.o</span></span><br><span class="line"><span class="comment"># obj-m += ab.o</span></span><br><span class="line">obj-m	+= button_drv.o</span><br><span class="line">obj-m	+= board_xxx.o</span><br></pre></td></tr></table></figure>

</details>

<details>
<summary>测试代码</summary>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="comment">/* 1. 判断参数 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 2. 打开文件 */</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 3. 写文件 */</span></span><br><span class="line">	read(fd, &amp;val, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;get button : %d\n&quot;</span>, val);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/21.png" alt="image"></p>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-4-设备树</title>
    <url>/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-yong-she-bei-shu">1 引用设备树</a><ul>
<li><a href="#1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu">1.1 根文件系统中查看设备树</a></li>
</ul>
</li>
<li><a href="#2-she-bei-shu-de-yu-fa">2 设备树的语法</a><ul>
<li><a href="#2-1-dts-wen-jian">2.1 DTS 文件</a><ul>
<li><a href="#2-1-1-dts-wen-jian-de-zong-ti-bu-ju">2.1.1 DTS文件的总体布局</a></li>
<li><a href="#2-1-2-memory-reservations-de-ge-shi">2.1.2 memory reservations的格式</a></li>
<li><a href="#2-1-3-shu-xing-de-ge-shi">2.1.3 属性的格式</a><ul>
<li><a href="#2-1-3-1-you-guan-shu-xing-ming">2.1.3.1 有关属性名</a></li>
<li><a href="#2-1-3-2-you-guan-shu-xing-zhi">2.1.3.2 有关属性值</a></li>
</ul>
</li>
<li><a href="#2-1-4-yi-xie-te-ding-de-shu-xing">2.1.4 一些特定的属性</a><ul>
<li><a href="#2-1-4-1-address-cells">2.1.4.1 #address-cells</a></li>
<li><a href="#2-1-4-2-size-cells">2.1.4.2 #size-cells</a></li>
<li><a href="#2-1-4-3-compatible">2.1.4.3 compatible</a></li>
<li><a href="#2-1-4-4-model">2.1.4.4 model</a></li>
<li><a href="#2-1-4-5-phandle">2.1.4.5 phandle</a></li>
<li><a href="#2-1-4-6-interrupt-controller">2.1.4.6 interrupt-controller</a></li>
<li><a href="#2-1-4-7-interrupt-parent">2.1.4.7 interrupt-parent</a></li>
<li><a href="#2-1-4-8-reg">2.1.4.8 reg</a></li>
<li><a href="#2-1-4-8-status">2.1.4.8 status</a></li>
<li><a href="#2-1-4-9-ranges">2.1.4.9 ranges</a></li>
<li><a href="#2-1-4-10-device-type">2.1.4.10 device_type</a></li>
</ul>
</li>
<li><a href="#2-1-5-jie-dian-de-ge-shi">2.1.5 节点的格式</a><ul>
<li><a href="#2-1-5-1-tui-jian-de-jie-dian-ming">2.1.5.1 推荐的节点名</a></li>
<li><a href="#2-1-5-2-jie-dian-de-lu-jing-ming">2.1.5.2 节点的路径名</a></li>
</ul>
</li>
<li><a href="#2-1-6-yi-xie-te-shu-de-jie-dian">2.1.6 一些特殊的节点</a><ul>
<li><a href="#2-1-6-1-aliases-jie-dian">2.1.6.1 &#x2F;aliases节点</a></li>
<li><a href="#2-1-6-2-chosen-jie-dian">2.1.6.2 &#x2F;chosen节点</a></li>
<li><a href="#2-1-6-3-gen-jie-dian">2.1.6.3 &#x2F;根节点</a></li>
</ul>
</li>
<li><a href="#2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing">2.1.7 必要的节点和必要的属性</a></li>
<li><a href="#2-1-8-label-biao-qian-de-shi-yong">2.1.8 label（标签）的使用</a></li>
<li><a href="#2-1-9-bian-xie-she-bei-shu-wen-jian">2.1.9 编写设备树文件</a><ul>
<li><a href="#2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian">2.1.9.1 在DTS文件中包含其他文件</a></li>
<li><a href="#2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei">2.1.9.2 如何在设备树文件中描述设备</a><ul>
<li><a href="#2-1-9-2-1-documentation-devicetree-bindings">2.1.9.2.1 Documentation&#x2F;devicetree&#x2F;bindings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-dtb-wen-jian">2.2 DTB文件</a><ul>
<li><a href="#2-2-1-struct-ftd-header">2.2.1 struct ftd_header</a></li>
<li><a href="#2-2-2-memory-reservation-block">2.2.2 memory reservation block</a></li>
<li><a href="#2-2-3-structure-block">2.2.3 structure block</a></li>
<li><a href="#2-2-4-strings-block">2.2.4 strings block</a></li>
</ul>
</li>
<li><a href="#2-3-dtb-wen-jian-de-bian-yi">2.3 DTB文件的编译</a><ul>
<li><a href="#2-3-1-zai-nei-he-zhong-zhi-jie-make">2.3.1 在内核中直接 make</a></li>
<li><a href="#2-3-2-shou-gong-bian-yi">2.3.2 手工编译</a></li>
<li><a href="#2-3-3-fan-bian-yi-dtb">2.3.3 反编译dtb</a></li>
</ul>
</li>
<li><a href="#2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng">2.4 内核对设备树的处理过程</a><ul>
<li><a href="#2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti">2.4.1 dtb 中每一个节点都被转换为 device_node 结构体</a></li>
<li><a href="#2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device">2.4.2 哪些设备树节点会被转换为 platform_device</a></li>
<li><a href="#2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device">2.4.3 节点怎么转换为 platform_device</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-wan-zheng-dts-shi-li">3 完整dts示例</a><ul>
<li><a href="#3-1-tian-jia-cpus-jie-dian">3.1 添加 cpus节点</a></li>
<li><a href="#3-2-tian-jia-soc-jie-dian">3.2 添加 soc节点</a><ul>
<li><a href="#3-2-1-tian-jia-ocram-jie-dian">3.2.1 添加 ocram节点</a></li>
<li><a href="#3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian">3.2.2 添加 aips1、 aips2和 aips3节点</a><ul>
<li><a href="#3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian">3.2.2.1 添加 ecspi1、 usbotg1和 rngb节点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-yin-yong-she-bei-shu">1 引用设备树</span><a href="#1-yin-yong-she-bei-shu" class="header-anchor">#</a></h1><p>在内核中，使用同一个芯片的板子，它们所用的外设资源不一样，比如 A 板用 GPIO A，B 板用 GPIO B， 如果用<code>plateform_device</code>定义资源信息，那么每次单板硬件资源变动后，都要改驱动程序源码，重新编译驱动，重新加载驱动，非常麻烦。<br>随着 ARM 芯片的流行，内核中针对这些 ARM 板保存有大量的、没有技术含量的文件。 Linus 大发雷霆：<code>&quot;this whole ARM thing is a f*cking pain in the ass&quot;</code>。于是，Linux 内核开始引入设备树。 设备树并不是重新发明出来的，在 Linux 内核中其他平台如 <code>PowerPC</code>，早就使用设备树来描述硬件了。<br>设备树只是用来给内核里的驱动程序，指定硬件的信息。</p>
<h2><span id="1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu">1.1 根文件系统中查看设备树</span><a href="#1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/1.png" alt="image"></p>
<p>烧录的dtb文件,显然两者是完全相同的。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/2.png" alt="image"></p>
<p>除了原始的dtb文件，根文件系统还以目录结构的方式呈现dtb文件,在<code>devicetree</code>目录下，则有一个<code>base</code>目录，这个base目录，就对应着根节点。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/3.png" alt="image"></p>
<p>base目录下，每一个节点对应一个目录, 每一个属性对应一个文件. 这些属性的值如果是字符串，可以使用 cat 命令把它打印出来。对于数值，可以用 <code>hexdump</code> 把它打印出来。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/4.png" alt="image-20240728192831389"></p>
<p>进入<code>led</code>目录，里面一共有三个文件，除<code>name</code>外，分别对应着led节点的两个属性，cat属性如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/5.png" alt="image"></p>
<p><code>pin</code>属性的值为<code>0x00 05 00 05</code>，也就是<code>GPF5</code>.<br>如果节点没有设置<code>name</code>属性，那么转换为<code>device_node</code>时，会将节点自己的名称作为<code>name</code>属性值。 所以这里<code>name</code>是<code>led</code>.<br>根文件系统下也可以查看<code>platform_device</code>。系统中所有的<code>platform_device</code>，都可以在<code>/sys/devices/platform/</code>路径下查看。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/6.png" alt="image"></p>
<p>另外，系统中所有的<code>platform_device</code>，有来自设备树的，也有来自<code>.c</code>文件中注册的。那么，我们怎么知道哪些<code>platform_device</code>是来自设备树，哪些是来自.c文件中注册的？</p>
<pre><code>答：可以查看该platform_device的相关目录下，是否有of_node，如果有of_node，那么这个platform_device就来自于设备树；否则，来自.c文件。
</code></pre>
<p>以<code>led</code>为例，进入led目录，可以看到有<code>of_node</code>，说明这个<code>platform_device</code>来自设备树。同时，可以看到这个<code>of_node</code>是一个链接文件，指向的是<code>/sys/firmware/devicetree/base/led</code>。也就是说，可以进入 <code>/sys/devices/platform/&lt;设备名&gt;/of_node</code> 查看它的设备树属性。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/7.png" alt="image"></p>
<p>在&#x2F;proc下有一个链接文件<code>device-tree</code>，它指向的是<code>/sys/firmware/devicetree/base</code><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/8.png" alt="image"></p>
<h1><span id="2-she-bei-shu-de-yu-fa">2 设备树的语法</span><a href="#2-she-bei-shu-de-yu-fa" class="header-anchor">#</a></h1><p>设备树文件(<code>dts: device tree source</code>)，它需要编译为<code> dtb(device tree blob)</code>文件，内核使用的是 dtb 文件。</p>
<h2><span id="2-1-dts-wen-jian">2.1 DTS 文件</span><a href="#2-1-dts-wen-jian" class="header-anchor">#</a></h2><h3><span id="2-1-1-dts-wen-jian-de-zong-ti-bu-ju">2.1.1 DTS文件的总体布局</span><a href="#2-1-1-dts-wen-jian-de-zong-ti-bu-ju" class="header-anchor">#</a></h3><p>设备树源文件通常以dts为后缀，其总体布局如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">[memory reservations]</span><br><span class="line">/&#123;</span><br><span class="line">	[property definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上各项的含义分别为：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;dts-v1&#x2F;</td>
<td>设备树文件的版本</td>
</tr>
<tr>
<td>memory reservations</td>
<td>指定保留内存，内核不会使用保留内存</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>根节点（使用花括号括出属于根节点的内容）</td>
</tr>
<tr>
<td>property definitions</td>
<td>根节点的属性，用来描述硬件</td>
</tr>
<tr>
<td>child nodes</td>
<td>孩子节点（使用花括号括出属于孩子节点的内容）</td>
</tr>
</tbody></table>
<h3><span id="2-1-2-memory-reservations-de-ge-shi">2.1.2 memory reservations的格式</span><a href="#2-1-2-memory-reservations-de-ge-shi" class="header-anchor">#</a></h3><p>该项是可选项，如果想要保留一段内存不让内核使用，可用如下格式指定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	address    指定要保留的内存的起始地址</span></span><br><span class="line"><span class="comment">	length     指定要保留的内存的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">/memreserve/&lt;address&gt;&lt;length&gt;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>address</code>和&#96;length都是64位。</p>
<h3><span id="2-1-3-shu-xing-de-ge-shi">2.1.3 属性的格式</span><a href="#2-1-3-shu-xing-de-ge-shi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">• 属性有值 [label:] property-name = value;</span><br><span class="line">• 属性没有值 [label:] property-name;</span><br></pre></td></tr></table></figure>
<p>其中各项的含义：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>label</td>
<td>标签</td>
</tr>
<tr>
<td>property-name</td>
<td>属性名</td>
</tr>
<tr>
<td>value</td>
<td>属性值</td>
</tr>
</tbody></table>
<h4><span id="2-1-3-1-you-guan-shu-xing-ming">2.1.3.1 有关属性名</span><a href="#2-1-3-1-you-guan-shu-xing-ming" class="header-anchor">#</a></h4><p>属性名的长度为<code>1~31</code>个字符，可以自己取，只要能够提供可以解读该属性名的驱动即可。也有一些属性名有着特定的含义，比如<code>compatible</code>用于表示哪个或哪些驱动支持该设备。对于自己命名的属性，并非所有字符均可组成属性名，它需要由以下字符组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/9.png" alt="image"></p>
<h4><span id="2-1-3-2-you-guan-shu-xing-zhi">2.1.3.2 有关属性值</span><a href="#2-1-3-2-you-guan-shu-xing-zhi" class="header-anchor">#</a></h4><p>属性值有以下四种：</p>
<ol>
<li><p><code>array of cells</code> 一个cell就是一个u32类型的数据，一个或多个cell用尖括号括起来，并以空格隔开就可以作为一种合法的属性值，如</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">example = &lt;<span class="number">0x1</span> <span class="number">0x2</span> <span class="number">0x3</span>&gt;;。</span><br></pre></td></tr></table></figure></li>
<li><p>含有结束符的<strong>字符串</strong> 如:</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">example = <span class="string">&quot;example value&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>字节序列</strong> 用方括号括起一个或多个字节，字节之间可用也可不用空格隔开，且字节以两位16进制数表示，如:</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">example = [<span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span>];</span><br></pre></td></tr></table></figure></li>
<li><p><strong>以上三种值的混合</strong>（以逗号隔开） 如:</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">compatible = <span class="string">&quot;fsl,mpc8641&quot;</span>, <span class="string">&quot;ns16550&quot;</span>;</span><br></pre></td></tr></table></figure>
<p> ◆ 文本字符串（包含’\0’结束符）用双引号表示：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>-property=<span class="string">&quot;a string&quot;</span>;</span><br></pre></td></tr></table></figure>
<p> ◆ Cells（32位无符号整数）用尖括号表示：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cell-property = &lt;<span class="number">0xbeef</span> <span class="number">123</span> <span class="number">0xabcd1234</span>&gt;;</span><br></pre></td></tr></table></figure>
<p> ◆ 64bit 数据使用 2 个 cell 来表示：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clock-frequency = &lt;<span class="number">0x00000001</span> <span class="number">0x00000000</span>&gt;; </span><br></pre></td></tr></table></figure>
<p> ◆ 二进制数据用方括号表示：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">binary-property=[<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x45</span> <span class="number">0x67</span>];</span><br></pre></td></tr></table></figure>
<p> ◆ 类型不同的数据的组合也是可以的，但需要用逗号隔开：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mixed-property=<span class="string">&quot;a string&quot;</span>, [<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x45</span> <span class="number">0x67</span>], &lt;<span class="number">0x12345678</span>&gt;;</span><br></pre></td></tr></table></figure>
<p> ◆ 逗号同样用于创建字符串列表：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>-<span class="built_in">list</span> = <span class="string">&quot;red fish&quot;</span>, <span class="string">&quot;blue fish&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">	node1 &#123;</span><br><span class="line">		a-<span class="built_in">string</span>-property = <span class="string">&quot;A string&quot;</span>;</span><br><span class="line">		a-<span class="built_in">string</span>-<span class="built_in">list</span>-property = <span class="string">&quot;first string&quot;</span>, <span class="string">&quot;second string&quot;</span>;</span><br><span class="line">		a-byte-data-property = [<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x34</span> <span class="number">0x56</span>];</span><br><span class="line">		child-node1 &#123;</span><br><span class="line">			first-child-property;</span><br><span class="line">			second-child-property = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">			a-<span class="built_in">string</span>-property = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		child-node2 &#123;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	node2 &#123;</span><br><span class="line">		an-empty-property;</span><br><span class="line">		a-cell-property = &lt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&gt;; <span class="comment">/* each number (cell) is a uint32 */</span></span><br><span class="line">		child-node1 &#123;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-4-yi-xie-te-ding-de-shu-xing">2.1.4 一些特定的属性</span><a href="#2-1-4-yi-xie-te-ding-de-shu-xing" class="header-anchor">#</a></h3><p>设备树文件中有一些特定的属性，他们拥有约定俗成的名称和含义，在<code>devicetree-specification</code>中，这些属性被称为<code>Standard Properties</code>，我们在使用这些属性时，应当遵守相应的约定。这些属性有很多，我将在下文中介绍它们中的一部分。</p>
<h4><span id="2-1-4-1-address-cells">2.1.4.1 #address-cells</span><a href="#2-1-4-1-address-cells" class="header-anchor">#</a></h4><p>该属性的值表示在该节点的子节点的reg属性中，使用使用多少个cell，也即使用多少个u32整数来表示地址（对于32位系统，一个u32整数就够了；而对于64位系统，需要两个u32整数）。</p>
<h4><span id="2-1-4-2-size-cells">2.1.4.2 #size-cells</span><a href="#2-1-4-2-size-cells" class="header-anchor">#</a></h4><p>该属性的值表示在该节点的子节点的reg属性中，使用多少个cell，也即使用多少个u32整数来表示大小（一段地址空间的长度）。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/10.png" alt="image"></p>
<h4><span id="2-1-4-3-compatible">2.1.4.3 compatible</span><a href="#2-1-4-3-compatible" class="header-anchor">#</a></h4><p>其值为一个或多个字符串，用来描述支持该设备的驱动程序。比如，该属性位于根节点时，用于指定内核中哪个<code>machine_desc</code>可以支持本设备，即当前设备与哪些平台兼容。其值的格式一般是<code>&quot;manufacturer, model&quot;</code>，其中<code>manufacturer</code>表示厂家，<code>model</code>表示型号（厂家的哪型产品）。<br>当该属性的值有多个字符串时，从左往右，从最特殊到最一般。举例来说</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">compatible = <span class="string">&quot;samsung,smdk2416&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>&quot;samsung, s3c2416&quot;</code> 作为根节点的属性时，第一个字符串指示了一个具体的开发板型号，而第二个字符串要更一般，只指示了SoC的型号。在linux初始化时，会优先找支持<code>&quot;samsung,smdk2416&quot;</code>的<code>machine_desc</code>用以初始化硬件，找不到时才退而求其次找到<code>&quot;samsung, s3c2416&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">led &#123; </span><br><span class="line">	compatible = “A”, “B”, “C”; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p><code>“compatible”</code>表示“兼容”，对于某个 LED，内核中可能有 A、B、C 三个驱 动都支持它。</p>
<h4><span id="2-1-4-4-model">2.1.4.4 model</span><a href="#2-1-4-4-model" class="header-anchor">#</a></h4><p>其值为一个字符串，用来描述当前设备的型号（单板的名字）。当多个设备的<code>compatible</code>相同时，可以通过model来进一步区分多个设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	compatible = <span class="string">&quot;samsung,smdk2440&quot;</span>, <span class="string">&quot;samsung,mini2440&quot;</span>; </span><br><span class="line">	model = <span class="string">&quot;jz2440_v3&quot;</span>; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>它表示<code>jz2440_v3</code>这个单板，可以兼容内核中的<code>“smdk2440”</code>，也兼容<code>“mini2440”</code>.</p>
<h4><span id="2-1-4-5-phandle">2.1.4.5 phandle</span><a href="#2-1-4-5-phandle" class="header-anchor">#</a></h4><p>该属性可以为节点指定一个全局唯一的数字标识符。这个标识符可以被需要引用该节点的另一个节点使用。举例来说，现有一个中断控制器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	phandle =&lt;<span class="number">1</span>&gt;;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一个可以产生中断的设备，且这个设备的中断信号线连接到了上述中断控制器，为了描述清楚这种关系，该设备的设备节点就需要引用中断控制器的节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;<span class="number">1</span>&gt;;<span class="comment">/* 数字1就唯一标识了节点pic@10000000 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4><span id="2-1-4-6-interrupt-controller">2.1.4.6 interrupt-controller</span><a href="#2-1-4-6-interrupt-controller" class="header-anchor">#</a></h4><p>这是一个没有值的属性，用在中断控制器的设备节点中，以表明这个节点描述的是一个中断控制器。</p>
<h4><span id="2-1-4-7-interrupt-parent">2.1.4.7 interrupt-parent</span><a href="#2-1-4-7-interrupt-parent" class="header-anchor">#</a></h4><p>该属性用于可以产生中断，且中断信号连接到某中断控制器的设备的设备节点，用于表示该设备的中断信号连接到了哪个中断控制器。该属性的值通常是中断控制器设备节点的数字标识（<code>phandle</code>），具体示例在上文已经出现过了。</p>
<h4><span id="2-1-4-8-reg">2.1.4.8 reg</span><a href="#2-1-4-8-reg" class="header-anchor">#</a></h4><p>reg属性描述了设备资源在其父总线定义的地址空间内的地址。通俗的说，该属性使用一对或多对（地址，长度）来描述设备所占的地址空间。至于地址和长度使用多少个cell来表示呢？这取决于上文介绍的<code>#address-cells、#size-cells</code>属性的值。<br>举个例子，当：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#address-cells =<span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells =<span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">reg = &lt;<span class="number">0x3000</span> <span class="number">0x20</span> <span class="number">0xFE00</span> <span class="number">0x100</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>那么<code>reg = &lt;0x3000 0x20 0xFE00 0x100&gt;</code>，表示该属性所属的设备占据了两块内存空间，第一块是以0x3000为起始的32字节内存块；第二块是以0xFE00为起始的256字节内存块。</p>
<h4><span id="2-1-4-8-status">2.1.4.8 status</span><a href="#2-1-4-8-status" class="header-anchor">#</a></h4><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/11.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;uart1 &#123;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4><span id="2-1-4-9-ranges">2.1.4.9 ranges</span><a href="#2-1-4-9-ranges" class="header-anchor">#</a></h4><p><code>ranges</code>属性值可以为空或者按照 (<code>child-bus-address,parent-bus-address,length</code>)格式编写的数字组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">child-bus-address<span class="comment">//子总线地址空间的物理地址，由父节点的 #address-cells确定此物理地址所占用的字长。</span></span><br><span class="line">parent-bus-address<span class="comment">//父总线地址空间的物理地址，同样由父节点的 #address-cells确定此物理地址所占用的字长。</span></span><br><span class="line">length<span class="comment">//子地址空间的长度，由父节点的 #size-cells确定此地址长度所占用的字长。</span></span><br><span class="line"></span><br><span class="line">soc &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	interrupt-parent = &lt;&amp;gpc&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ranges</code>属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">soc &#123; </span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	ranges = &lt;<span class="number">0x0</span> <span class="number">0xe0000000</span> <span class="number">0x00100000</span>&gt;; </span><br><span class="line">	serial &#123; </span><br><span class="line">		device_type = <span class="string">&quot;serial&quot;</span>; </span><br><span class="line">		compatible = <span class="string">&quot;ns16550&quot;</span>; </span><br><span class="line">		reg = &lt;<span class="number">0x4600</span> <span class="number">0x100</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>soc定义的 ranges属性，值为<code> &lt;0x0 0xe0000000 0x00100000&gt;</code>，此属性值指定了一个 <code>1024KB(0x00100000)</code>的地址范围，子地址空间的物理起始地址为 <code>0x0</code>，父地址空间的物理起始地址为<code> 0xe0000000</code>。</p>
<p>serial是串口设备节点， reg属性定义了 serial设备寄存器的起始地址为 <code>0x4600</code>寄存器长度为<code> 0x100</code>。经过地址转换， serial设备可以从 <code>0xe0004600</code>开始进行读写操作，<code>0xe0004600=0x4600+0xe0000000</code>。</p>
<h4><span id="2-1-4-10-device-type">2.1.4.10 device_type</span><a href="#2-1-4-10-device-type" class="header-anchor">#</a></h4><p>此属性也被抛弃了。此属性只能用于 cpu节点或者 memory节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0x0&gt;</span>;</span></span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;0x1&gt;</span>;</span></span><br><span class="line">    A53_0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span>&gt;;</span><br><span class="line">        enable-method = <span class="string">&quot;psci&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        next-level-cache = &lt;&amp;CA53_L2&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-1-5-jie-dian-de-ge-shi">2.1.5 节点的格式</span><a href="#2-1-5-jie-dian-de-ge-shi" class="header-anchor">#</a></h3><p>节点的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[label:]node-name[@unit-address]&#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以uart节点为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	uart0: uart@fe001000 &#123; </span><br><span class="line">		compatible=<span class="string">&quot;ns16550&quot;</span>; </span><br><span class="line">		reg=&lt;<span class="number">0xfe001000</span> <span class="number">0x100</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>节点名(<code>node-name</code>)长为1~31个字符，这些字符可以是：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/12.png" alt="image"></p>
<p>每个设备节点代表一个设备，因此节点名的命名通常要和设备相应，比如以太网控制器，我们可以给其取名<code>ethernet</code>。考虑到一个SoC中可能有多个以太网控制器，为了做区分，我们通常在其<strong>节点名后面加上设备的地址</strong>，也就是上文中出现的可选部分<code>@unit-address</code>。仍以以太网控制器为例，假如两个以太网控制器的寄存器组的首地址分别为<code>0xfe002000</code>和<code>0xfe003000</code>，那么相应的节点名可以取为<code>ethernet@fe002000</code>和<code>ethernet@fe003000</code>。<br>不难看出，设备节点允许嵌套，假设节点b嵌套于节点a中，那么节点a是节点b的父节点。根节点的名字比较特殊，就是一个斜杠&#x2F;，其他的设备节点都是根节点的孩子，或者孩子的孩子…因此，所有的设备节点呈现出一个树状的层次结构（设备树因此得名），下图就是一个例子：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/13.png" alt="image"></p>
<h4><span id="2-1-5-1-tui-jian-de-jie-dian-ming">2.1.5.1 推荐的节点名</span><a href="#2-1-5-1-tui-jian-de-jie-dian-ming" class="header-anchor">#</a></h4><p>关于节点的命名，官方有一些推荐的命名，具体可见<code>devicetree-specification-v0.3</code>的2.2.2节。</p>
<h4><span id="2-1-5-2-jie-dian-de-lu-jing-ming">2.1.5.2 节点的路径名</span><a href="#2-1-5-2-jie-dian-de-lu-jing-ming" class="header-anchor">#</a></h4><p>在文件系统中有个术语叫文件的路径名（<code>pathname</code>），在按照树状结构组织的众多文件中，用以唯一标识某个文件。类似的，节点也有路径名的概念。将根节点类比为根目录，以上图为例，其中cpu0节点的路径名为<code>/cpus/cpu@0</code>。我们在给节点命名时，必须<strong>保证每个节点拥有唯一的路径名</strong>（注意区别于每个节点拥有唯一的节点名）。</p>
<h3><span id="2-1-6-yi-xie-te-shu-de-jie-dian">2.1.6 一些特殊的节点</span><a href="#2-1-6-yi-xie-te-shu-de-jie-dian" class="header-anchor">#</a></h3><p>有一些特殊的节点不代表任何设备，而是有着特定的用途，本节就将介绍一些这样的节点。</p>
<h4><span id="2-1-6-1-x2f-aliases-jie-dian">2.1.6.1 &#x2F;aliases节点</span><a href="#2-1-6-1-x2f-aliases-jie-dian" class="header-anchor">#</a></h4><p><code>/aliases</code>节点应当作为根节点的孩子节点，用于定义一个或多个别名属性，每条别名属性会为一个设备节点的路径名设置一个别名，如下面这个例子所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">	serial0 =<span class="string">&quot;/simple-bus@fe000000/serial@llc500&quot;</span>;</span><br><span class="line">	ethernet0 =<span class="string">&quot;/simple-bus@fe000000/ethernet@31c000&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>别名只能由<code>1~31</code>个下面的字符组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/14.png" alt="image"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/15.png" alt="image"></p>
<p><strong>别名通常以数字结尾</strong>，比如别名为<code>i2c1</code>，设备树的初始化程序在解析别名属性时，会将数字1记录在<code>struct alias_prop</code>结构的<code>id</code>成员中，使用<code>of_alias_get_id</code>可以获得这个数字。因为本文主要介绍设备树文件的格式，因此这里不再深究这部分内容。</p>
<h4><span id="2-1-6-2-x2f-chosen-jie-dian">2.1.6.2 &#x2F;chosen节点</span><a href="#2-1-6-2-x2f-chosen-jie-dian" class="header-anchor">#</a></h4><p><code>/chosen</code>节点应当用作根节点的孩子节点，有以下可选属性：<br>    • <code>bootargs</code><br>    • <code>stdout-path</code><br>    • <code>stdin-path</code><br>顾名思义，该节点可以指定启动参数、标准输出和标准输入，一个例子如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/16.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	......</span><br><span class="line">	chosen &#123;</span><br><span class="line">		bootargs =<span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上图中<code>chosen</code>节点仅仅设置了属性<code>“ stdout-path”</code>，表示标准输出使用 uart0。但是当我们进入到 <code>/proc/device-tree/chosen</code>目录里面，会发现多了<code> bootargs</code>属性，原因如下:<br><code>do_bootm_linux </code>函数会通过一系列复杂的调用，最终通过<code>fdt_chosen </code>函数在<code>chosen </code>节点中加入<br>了<code>bootargs </code>属性。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/17.png" alt="image"></p>
<p><code>do_bootm_linux</code>细节见<a href="https://www.cnblogs.com/fuzidage/p/17960265">uboot-5_bootm&#x2F;bootz启动内核过程 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/">uboot-bootm和bootz启动内核 | Hexo (fuzidage.github.io)</a></p>
<h4><span id="2-1-6-3-x2f-gen-jie-dian">2.1.6.3 &#x2F;根节点</span><a href="#2-1-6-3-x2f-gen-jie-dian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	model = <span class="string">&quot;SMDK24440&quot;</span>; </span><br><span class="line">	compatible = <span class="string">&quot;samsung,smdk2440&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>根节点中必须有这些属性： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#address-cells <span class="comment">// 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述地址(address) </span></span></span><br><span class="line"><span class="meta">#size-cells <span class="comment">// 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述大小(size) </span></span></span><br><span class="line">compatible <span class="comment">// 定义一系列的字符串, 用来指定内核中哪个 machine_desc 可以支持本设备 (即这个板子兼容哪些平台) </span></span><br><span class="line">model <span class="comment">// 咱这个板子是什么</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/18.png" alt="image"><br>Linux内核通过根节点<code> compatible</code>属性找到对应的设备的函数调用过程如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/19.png" alt="image"></p>
<h3><span id="2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing">2.1.7 必要的节点和必要的属性</span><a href="#2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing" class="header-anchor">#</a></h3><p>一个完整的设备树文件（DTS文件），有一些节点是必须要有的，这些必要的节点有：</p>
<table>
<thead>
<tr>
<th>节点名</th>
<th>节点的必要属性</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>#address-cells、#size-cells、model、compatible</td>
</tr>
<tr>
<td>&#x2F;memory</td>
<td>device_type、reg</td>
</tr>
<tr>
<td>&#x2F;cpus</td>
<td>#address-cells、#size-cells</td>
</tr>
<tr>
<td>&#x2F;cpus&#x2F;cpu*</td>
<td>device_type、reg、clock-frequency、timebase-frequency</td>
</tr>
<tr>
<td>&#x2F;cpus&#x2F;cpu*&#x2F;l?-cache</td>
<td>compatible、cache-level</td>
</tr>
</tbody></table>
<h3><span id="2-1-8-label-biao-qian-de-shi-yong">2.1.8 label（标签）的使用</span><a href="#2-1-8-label-biao-qian-de-shi-yong" class="header-anchor">#</a></h3><p>在上文就提到过标签，只是没有细说，这里就介绍一下标签的使用。首先，标签名可由<code>1~31</code>个字符组成，这些字符可以是：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/20.png" alt="image"></p>
<p>接下来仍以中断控制器的例子来说：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	phandle =&lt;<span class="number">1</span>&gt;;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">	&#125;;</span><br><span class="line">......</span><br><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;<span class="number">1</span>&gt;;<span class="comment">/* 数字1就唯一标识了节点pic@10000000 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>如果我们使用phandle来标识设备，当设备多了，数字标识符是比较难记忆的，可读性也差，此时可以使用标签：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PIC:pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;&amp;PIC&gt;;<span class="comment">/* 用标签来引用设备节点 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种常见的标签的用法，当我们需要修改某设备节点的属性，但又不想直接在原地修改（保持原来的内容不被破坏），此时可以在设备树文件的末尾重写该设备节点的相应属性，从而覆盖之前的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	device-node &#123;</span><br><span class="line">		p =<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写device-node的属性p */</span></span><br><span class="line">/&#123;</span><br><span class="line">	device-node &#123;<span class="comment">/* 因此这样写比较麻烦（特别是在路径比较深的时候） */</span></span><br><span class="line">		p =<span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么使用标签的写法就简单很多：标签名DN.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	DN:device-node &#123;</span><br><span class="line">		p =<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写device-node的属性p */</span></span><br><span class="line">&amp;DN&#123;</span><br><span class="line">	p =<span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>修改节点</strong>，节点追加内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i2c0: i2c@<span class="number">29000000</span> &#123;</span><br><span class="line">	 compatible = <span class="string">&quot;snps,designware-i2c&quot;</span>;</span><br><span class="line">	 clocks = &lt;&amp;clk ATHENA2_CLK_I2C0&gt;;</span><br><span class="line">	 reg = &lt;<span class="number">0x0</span> <span class="number">0x29000000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	 clock-frequency = &lt;<span class="number">400000</span>&gt;;</span><br><span class="line">	 <span class="meta">#size-cells = <span class="string">&lt;0x0&gt;</span>;</span></span><br><span class="line">	 <span class="meta">#address-cells = <span class="string">&lt;0x1&gt;</span>;</span></span><br><span class="line">	 resets = &lt;&amp;rst RST_I2C0&gt;;</span><br><span class="line">	 reset-names = <span class="string">&quot;i2c0&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再另一个dts中使用i2c0:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;i2c0 &#123;</span><br><span class="line">		clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123; </span><br><span class="line">			compatible = <span class="string">&quot;fsl,mag3110&quot;</span>; </span><br><span class="line">			reg = &lt;<span class="number">0x0e</span>&gt;; </span><br><span class="line">			position = &lt;<span class="number">2</span>&gt;; </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-9-bian-xie-she-bei-shu-wen-jian">2.1.9 编写设备树文件</span><a href="#2-1-9-bian-xie-she-bei-shu-wen-jian" class="header-anchor">#</a></h3><h4><span id="2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian">2.1.9.1 在DTS文件中包含其他文件</span><a href="#2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian" class="header-anchor">#</a></h4><p>编写设备树文件时，我们通常会把多型设备的共性抽出来，写在<code>DTSI</code>文件（后缀为<code>.dtsi</code>）中，其语法与DTS文件一样。比如，多款使用了<code>am335x</code>的板子，因为使用了同一款SoC，描述设备时肯定会有一些相同的部分，可以把这部分抽出来，写到<code>am335x.dts</code>i中，然后在具体的某型板子的设备树中包含相应的DTSI文件，包含的方式有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/include/ “xxx.dtsi”</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “xxx.dtsi”</span></span><br></pre></td></tr></table></figure>

<p>设备树编译器还支持c语言的头文件，因此，如果有需要可以定义一些宏并在设备树文件中使用。</p>
<h4><span id="2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei">2.1.9.2 如何在设备树文件中描述设备</span><a href="#2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei" class="header-anchor">#</a></h4><h5><span id="2-1-9-2-1-documentation-x2f-devicetree-x2f-bindings">2.1.9.2.1 Documentation&#x2F;devicetree&#x2F;bindings</span><a href="#2-1-9-2-1-documentation-x2f-devicetree-x2f-bindings" class="header-anchor">#</a></h5><p>设备树写出来是给驱动程序看的，也就是说驱动程序怎么写的，相应的设备树就该怎么写；或者反过来，先约定好设备树怎么写，在相应的设计驱动。驱动和设备树有着对应的关系，这种对应关系也被称为<code>bindings</code>。具体的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于上游芯片厂商，应当按照devicetree-specification推荐的设备树写法，遵守各种约定，确定好如何规范的描述设备，并提供相应的驱动程序。devicetree-specification-v0<span class="number">.3</span>的第四章给出了一些推荐的做法。</span><br><span class="line">对于下游产品厂商，当使用芯片厂商的芯片做产品时，芯片厂商通常会提供驱动程序和设备树文件编写的参考文档，这些文档位于linux内核源码树的Documentation/devicetree/bindings目录下。如果芯片厂商没提供相应文档的话，就要读驱动的源码，知道驱动怎么写的，自然也就知道如何写设备树了。</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-dtb-wen-jian">2.2 DTB文件</span><a href="#2-2-dtb-wen-jian" class="header-anchor">#</a></h2><p>DTS文件只是文本文件，需要使用<strong>设备树编译器（DTC）将其编译为DTB文件（二进制文件）</strong>，然后才能传递给内核，内核解析的是DTB文件。dtb文件由四个部分组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/21.png" alt="image"></p>
<h3><span id="2-2-1-struct-ftd-header">2.2.1 struct ftd_header</span><a href="#2-2-1-struct-ftd-header" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/22.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">    <span class="type">fdt32_t</span> magic;           <span class="comment">/* magic word FDT_MAGIC */</span></span><br><span class="line">    <span class="type">fdt32_t</span> totalsize;       <span class="comment">/* total size of DT block */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_dt_struct;       <span class="comment">/* offset to structure */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_dt_strings;      <span class="comment">/* offset to strings */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_mem_rsvmap;      <span class="comment">/* offset to memory reserve map */</span></span><br><span class="line">    <span class="type">fdt32_t</span> version;         <span class="comment">/* format version */</span></span><br><span class="line">    <span class="type">fdt32_t</span> last_comp_version;   <span class="comment">/* last compatible version */</span></span><br><span class="line">    <span class="comment">/* version 2 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> boot_cpuid_phys;     <span class="comment">/* Which physical CPU id we&#x27;re</span></span><br><span class="line"><span class="comment">    booting on */</span></span><br><span class="line">    <span class="comment">/* version 3 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> size_dt_strings;     <span class="comment">/* size of the strings block */</span></span><br><span class="line">    <span class="comment">/* version 17 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> size_dt_struct;      <span class="comment">/* size of the structure block */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>totalsize</strong>:<br>这个设备树的size，也可以理解为所占用的实际内存空间。<br><strong>off_dt_struct</strong>:<br><code>offset to dt_struct</code>，表示整个dtb中<code>structure</code>部分所在内存相对头部的偏移地址<br><strong>off_dt_strings</strong>:<br><code>offset to dt_string</code>，表示整个dtb中<code>string</code>部分所在内存相对头部的偏移地址<br><strong>off_mem_rsvmap</strong>:<br><code>offset to memory reserve map</code>，dtb中<code>memory reserve map</code>所在内存相对头部的偏移地址</p>
<h3><span id="2-2-2-memory-reservation-block">2.2.2 memory reservation block</span><a href="#2-2-2-memory-reservation-block" class="header-anchor">#</a></h3><p>该部分由<code>memory reservations</code>编译得来，由一个或多个表项组成，每一项都描述了一块要保留的内存区域，每项由两个64位数值（起始地址、长度）组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/23.png" alt="image"></p>
<p>reserved memory作用：<a href="https://www.cnblogs.com/fuzidage/p/17664807.html">设备驱动-15.内核kmalloc&#x2F;vmalloc及CMA内存介绍 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/">Linux内核-kmalloc与vmalloc及CMA内存 | Hexo (fuzidage.github.io)</a></p>
<h3><span id="2-2-3-structure-block">2.2.3 structure block</span><a href="#2-2-3-structure-block" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/24.png" alt="image"></p>
<h3><span id="2-2-4-strings-block">2.2.4 strings block</span><a href="#2-2-4-strings-block" class="header-anchor">#</a></h3><p>该部分类似于ELF文件中的字符串表，存储了所有属性名（字符串），考虑到很多节点拥有一些同名的属性，集中存放属性名可以有效的节约DTB文件的空间，存放有属性的<code>structure block</code>部分只需要保存一个32位的偏移值——属性名的起始位置在<code>strings block</code>中的偏移。</p>
<h2><span id="2-3-dtb-wen-jian-de-bian-yi">2.3 DTB文件的编译</span><a href="#2-3-dtb-wen-jian-de-bian-yi" class="header-anchor">#</a></h2><h3><span id="2-3-1-zai-nei-he-zhong-zhi-jie-make">2.3.1 在内核中直接 make</span><a href="#2-3-1-zai-nei-he-zhong-zhi-jie-make" class="header-anchor">#</a></h3><p>进入内核源码的目录，执行如下命令即可编译 dtb 文件。<code>make all</code>命令是编译 Linux源码中的所有东西，包括 <code>zImage，dtb，.ko</code>驱动模块以及设备树，如果只是编译设备树的话建议使用<code>“ make dtbs”</code>命令。</p>
<pre><code>make dtbs V=1
</code></pre>
<h3><span id="2-3-2-shou-gong-bian-yi">2.3.2 手工编译</span><a href="#2-3-2-shou-gong-bian-yi" class="header-anchor">#</a></h3><p>内核目录下 <code>scripts/dtc/dtc</code> 是设备树的编译工具，直接使用它的话，包含其他文件时不能使用<code>“#include”</code>，而必须使用<code>“/incldue”</code>。</p>
<p><strong>编译</strong>、反编译的示例命令如下，<code>“-I”</code>指定输入格式，<code>“-O”</code>指定输出格式，<code>“-o”</code>指定输出文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts <span class="comment">// 编译 dts 为 dtb </span></span><br><span class="line">./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb <span class="comment">// 反编译 dtb 为 dts </span></span><br></pre></td></tr></table></figure>

<p>DTC工具源码在 Linux内核的 <code>scripts/dtc</code>目录下，<code>scripts/dtc/Makefile</code>文件内容如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/25.png" alt="image"></p>
<h3><span id="2-3-3-fan-bian-yi-dtb">2.3.3 反编译dtb</span><a href="#2-3-3-fan-bian-yi-dtb" class="header-anchor">#</a></h3><p>cd 板子所用的内核源码目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dtb -O dts /从板子上/复制出来的/fdt -o tmp.dts</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng">2.4 内核对设备树的处理过程</span><a href="#2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/26.png" alt="image"></p>
<p>① dts 在 PC 机上被编译为 dtb 文件；<br>② u-boot 把 dtb 文件传给内核；<br>③ 内核解析 dtb 文件，把每一个节点都转换为 <code>device_node</code> 结构体；<br>④ 对于某些 <code>device_node</code> 结构体，会被<code>platform_device</code> 结构体获取资源信息<br><strong>dts解析过程:</strong><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/27.png" alt="image"><br>最终实际dts解析的函数为<code>unflatten_dt_node</code>。</p>
<h3><span id="2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti">2.4.1 dtb 中每一个节点都被转换为 device_node 结构体</span><a href="#2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/28.png" alt="image"></p>
<p>根节点被保存在全局变量 <code>of_root</code> 中，从 <code>of_root </code>开始可以访问到任意节点。</p>
<h3><span id="2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device">2.4.2 哪些设备树节点会被转换为 platform_device</span><a href="#2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/&#123; </span><br><span class="line">	mytest &#123;</span><br><span class="line">		compatile = <span class="string">&quot;mytest&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">		mytest@<span class="number">0</span> &#123; </span><br><span class="line">			compatile = <span class="string">&quot;mytest_0&quot;</span>; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	i2c &#123; </span><br><span class="line">		compatile = <span class="string">&quot;samsung,i2c&quot;</span>; </span><br><span class="line">		at24c02 &#123; </span><br><span class="line">			compatile = <span class="string">&quot;at24c02&quot;</span>; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">	spi &#123; </span><br><span class="line">		compatile = <span class="string">&quot;samsung,spi&quot;</span>; </span><br><span class="line">		flash@<span class="number">0</span> &#123; </span><br><span class="line">			compatible = <span class="string">&quot;winbond,w25q32dw&quot;</span>; </span><br><span class="line">			spi-max-frequency = &lt;<span class="number">25000000</span>&gt;; </span><br><span class="line">			reg = &lt;<span class="number">0</span>&gt;; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>①根节点下含有 <code>compatile</code> 属性的子节点<br>②含有特定 <code>compatile</code> 属性的节点的子节点 :</p>
<pre><code>如果一个节点的 compatile 属性，它的值是这 4 者之一：&quot;simple-bus&quot;,&quot;simple-mfd&quot;,&quot;isa&quot;,&quot;arm,amba-bus&quot;, 那 么 它 的 子结点 ( 需 含compatile 属性)也可以转换为 platform_device。 
</code></pre>
<p>③总线 I2C、SPI 节点下的子节点：不转换为<code>platform_device</code><br>    某个总线下到子节点，应该交给对应的总线驱动程序来处理, 它们不应该被转换为<code> platform_device</code>。<br>    比如以下的节点中： </p>
<pre><code>⚫ /mytest 会被转换为 platform_device, 因为它兼容&quot;simple-bus&quot;; 它的子节点/mytest/mytest@0 也会被转换为 platform_device 
⚫ /i2c 节点一般表示 i2c 控制器, 它会被转换为 platform_device, 在内核 中有对应的 platform_driver; 
⚫ /i2c/at24c02 节点不会被转换为 platform_device, 它被如何处理完全由父节点的 platform_driver 决定, 一般是被创建为一个 i2c_client。 
⚫ 类似的也有/spi 节点, 它一般也是用来表示 SPI 控制器, 它会被转换为 platform_device, 在内核中有对应的 platform_driver; 
⚫ /spi/flash@0 节点不会被转换为 platform_device, 它被如何处理完全由 父节点的 platform_driver 决定, 一般是被创建为一个 spi_device。 
</code></pre>
<h3><span id="2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device">2.4.3 节点怎么转换为 platform_device</span><a href="#2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device" class="header-anchor">#</a></h3><pre><code>⚫ platform_device 中含有 resource 数组, 它来自 device_node 的 reg, interrupts 属性; 
⚫ platform_device.dev.of_node 指向 device_node, 可以通过它获得其他属性
</code></pre>
<h1><span id="3-wan-zheng-dts-shi-li">3 完整dts示例</span><a href="#3-wan-zheng-dts-shi-li" class="header-anchor">#</a></h1><p>编写设备树之前要先定义一个设备，我们就以<code> I.MX6ULL</code>这个 SOC为例，我们需要在设备树里面描述的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">①、 I.MX6ULL这个 Cortex-A7架构的 <span class="number">32</span>位 CPU。</span><br><span class="line">②、 I.MX6ULL内部 ocram，起始地址 <span class="number">0x00900000</span>，大小为 <span class="number">128</span>KB(<span class="number">0x20000</span>)。</span><br><span class="line">③、 I.MX6ULL内部 aips1域下的 ecspi1外设控制器，寄存器起始地址为 <span class="number">0x02008000</span>，大小为 <span class="number">0x4000</span>。</span><br><span class="line">④、 I.MX6ULL内部 aips2域下的 usbotg1外设控制器，寄存器起始地址为 <span class="number">0x02184000</span>，大小为 <span class="number">0x4000</span>。</span><br><span class="line">⑤、 I.MX6ULL内部 aips3域下的 rngb外设控制器，寄存器起始地址为 <span class="number">0x02284000</span>，大小为 <span class="number">0x4000</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-1-tian-jia-cpus-jie-dian">3.1 添加 cpus节点</span><a href="#3-1-tian-jia-cpus-jie-dian" class="header-anchor">#</a></h2><p>cpu节点，<code> I.MX6ULL</code>采用<code> Cortex-A7</code>架构，而且只有一个 CPU，因此只有一个cpu0节点，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="string">&quot;fsl,imx6ull&quot;</span>;</span><br><span class="line">	cpus &#123; </span><br><span class="line">		<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>; </span></span><br><span class="line">		<span class="comment">//CPU0节点 </span></span><br><span class="line">		cpu0: cpu@<span class="number">0</span> &#123; </span><br><span class="line">			compatible = <span class="string">&quot;arm,cortex-a7&quot;</span>; </span><br><span class="line">			device_type = <span class="string">&quot;cpu&quot;</span>; </span><br><span class="line">			reg = &lt;<span class="number">0</span>&gt;; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-tian-jia-soc-jie-dian">3.2 添加 soc节点</span><a href="#3-2-tian-jia-soc-jie-dian" class="header-anchor">#</a></h2><p>像<code> uart iic</code>控制器等等这些都属于 SOC内部外设，因此一般会创建一个叫做 <code>soc</code>的父节点来管理这些 SOC内部外设的子节点:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	<span class="comment">//soc节点 </span></span><br><span class="line">	soc &#123; </span><br><span class="line">		<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">		ranges; </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>soc节点设置 <code>#address-cells = &lt;1&gt;</code>，<code>#size-cells = &lt;1&gt;</code>，这样 soc子节点的 reg属性中起始地占用一个字长，地址空间长度也占用一个字长。<code>ranges</code>属性为空，说明子空间和父空间地址范围相同。</p>
<h3><span id="3-2-1-tian-jia-ocram-jie-dian">3.2.1 添加 ocram节点</span><a href="#3-2-1-tian-jia-ocram-jie-dian" class="header-anchor">#</a></h3><p>根据第②点的要求，添加<code> ocram</code>节点，<code> ocram</code>是<code> I.MX6ULL</code>内部 RAM，因此 <code>ocram</code>节点应该是 soc节点的子节点。 <code>ocram</code>起始地址为 <code>0x00900000</code>，大小为<code>128KB(0x20000)</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//soc节点 </span></span><br><span class="line">soc &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	ranges; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//ocram节点 </span></span><br><span class="line">	ocram: sram@<span class="number">00900000</span> &#123; </span><br><span class="line">		compatible = <span class="string">&quot;fsl,lpm-sram&quot;</span>; </span><br><span class="line">		reg = &lt;<span class="number">0x00900000</span> <span class="number">0x20000</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian">3.2.2 添加 aips1、 aips2和 aips3节点</span><a href="#3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian" class="header-anchor">#</a></h3><p><code>IMX6ULL</code>外设控制分为三个域： <code>aips1~3</code>，这三个域分管不同的外设控制器，<code>aips1~3</code>这三个域都属于 soc节点的子节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//aips1节点</span></span><br><span class="line">aips1: aips-bus@<span class="number">02000000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02000000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br><span class="line">aips2: aips-bus@<span class="number">02100000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02100000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br><span class="line">aips3: aips-bus@<span class="number">02200000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02200000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian">3.2.2.1 添加 ecspi1、 usbotg1和 rngb节点</span><a href="#3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian" class="header-anchor">#</a></h4><p>每个域节点下都添加一个外设节点。<code>ecspi1</code>属于 <code>aips1</code>的子节点，<code> usbotg1</code>属于 <code>aips2</code>的子节点， <code>rngb</code>属于 <code>aips3</code>的子节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ecspi1节点 </span></span><br><span class="line">ecspi1: ecspi@<span class="number">02008000</span> &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="string">&quot;fsl,imx51-ecspi&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02008000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usbotg1节点 </span></span><br><span class="line">usbotg1: usb@<span class="number">02184000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-usb&quot;</span>, <span class="string">&quot;fsl,imx27-usb&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02184000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rngb节点 </span></span><br><span class="line">rngb: rngb@<span class="number">02284000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="string">&quot;fsl,imx-rng&quot;</span>, <span class="string">&quot;imx-rng&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02284000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-6-poll底层驱动机制</title>
    <url>/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-qian-yan-yin-ru">1 前言引入</a><ul>
<li><a href="#1-1-zu-sai-yu-fei-zu-sai-io">1.1 阻塞与非阻塞IO</a></li>
<li><a href="#1-2-dai-chao-shi-de-zu-sai-io-poll-select">1.2 带超时的阻塞IO(poll&#x2F;select)</a><ul>
<li><a href="#1-2-1-select">1.2.1 select</a><ul>
<li><a href="#1-2-1-1-select-shi-yong-shi-li">1.2.1.1 select使用示例</a></li>
</ul>
</li>
<li><a href="#1-2-2-poll">1.2.2 poll</a><ul>
<li><a href="#1-2-2-1-polls-shi-yong-shi-li">1.2.2.1 polls使用示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-xiu-mian-huan-xing">1.3 休眠唤醒</a><ul>
<li><a href="#1-3-1-deng-dai-dui-lie">1.3.1 等待队列</a></li>
<li><a href="#1-3-2-deng-dai-dui-lie-xiang">1.3.2 等待队列项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-poll-ji-zhi-qu-dong-di-ceng-yuan-li">3 poll机制驱动底层原理</a><ul>
<li><a href="#3-1-wo-men-qi-wang-de-poll-liu-cheng">3.1 我们期望的poll流程</a></li>
<li><a href="#3-2-linux-nei-he-shi-ji-de-poll-ji-zhi">3.2 Linux内核实际的poll机制</a></li>
</ul>
</li>
<li><a href="#4-poll-qu-dong-bian-cheng-shi-li-gpio-key-wei-li">4 poll驱动编程实例（gpio key为例）</a><ul>
<li><a href="#4-1-probe-han-shu-fen-xi">4.1 probe函数分析</a></li>
<li><a href="#4-2-drv-poll-han-shu-fen-xi">4.2 drv_poll函数分析</a></li>
<li><a href="#4-3-drv-read-han-shu-fen-xi">4.3 drv_read函数分析</a></li>
<li><a href="#4-4-an-jian-zhong-duan-fu-wu-han-shu-fen-xi">4.4 按键中断服务函数分析</a></li>
<li><a href="#4-5-ce-shi">4.5 测试</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-qian-yan-yin-ru">1 前言引入</span><a href="#1-qian-yan-yin-ru" class="header-anchor">#</a></h1><p>前面<a href="https://fuzidage.github.io/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/">字符设备驱动-3-GPIO驱动KEY示例 | Hexo (fuzidage.github.io)</a> </p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17080773.html">字符设备驱动-3.gpio驱动(按键) - fuzidage - 博客园 (cnblogs.com)</a></p>
<p>就引入了poll机制，那么底层驱动的poll机制实现原理到底是什么呢？</p>
<h2><span id="1-1-zu-sai-yu-fei-zu-sai-io">1.1 阻塞与非阻塞IO</span><a href="#1-1-zu-sai-yu-fei-zu-sai-io" class="header-anchor">#</a></h2><p>APP 调用 open 函数时，不要传入<code>“ O_NONBLOCK”</code>。APP  调用 read 函数读取数据时,为<code>阻塞io</code>。<br>APP 调用 open 函数时，传入<code>“ O_NONBLOCK”</code>表示<code>“非阻塞”</code>。APP 调用 read 函数读取数据时，如果驱动程序中有数据，那么 APP 的 read函数会返回数据，否则也会立刻返回错误。这种需要APP反复主动去”轮询”设备，否则无法及时响应。<br>注意：对于普通文件、块设备文件，<code>O_NONBLOCK</code>不起作用。<br>注意：对于字符设备文件，<code>O_NONBLOCK </code>起作用的前提是驱动程序针对<code>O_NONBLOCK</code>做了处理<br>只能在 open 时表明 <code>O_NONBLOCK </code>吗？<br>在 open 之后，也可以通过 fcntl 修改为阻塞或非阻塞：<br>⚫ open 时设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(“/dev/xxx”, O_RDWR | O_NONBLOCK); <span class="comment">/* 非阻塞方式 */</span></span><br><span class="line"><span class="type">int</span> fd = open(“/dev/xxx”, O_RDWR ); <span class="comment">/* 阻塞方式 */</span></span><br></pre></td></tr></table></figure>
<p>⚫ open 之后设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK); <span class="comment">/* 非阻塞方式 */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK); <span class="comment">/* 阻塞方式 */</span></span><br></pre></td></tr></table></figure>

<p>驱动<code>O_NONBLOCK </code>flag的话，如果没有数据read函数立即返回。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/1.png" alt="image"></p>
<h2><span id="1-2-dai-chao-shi-de-zu-sai-io-poll-x2f-select">1.2 带超时的阻塞IO(poll&#x2F;select)</span><a href="#1-2-dai-chao-shi-de-zu-sai-io-poll-x2f-select" class="header-anchor">#</a></h2><p><code>POLL </code>机制、<code>SELECT</code>机制是完全一样的，只是 APP 接口函数不一样。简单地说，它们就是 <code>“定个闹钟” </code>：在调用 poll、 select 函数时可以传入<code>“超时时间”</code>。在这段时间内，条件合适时(比如有数据可读、有空间可写)就会立刻返回，否则等到“超时时间”结束时返回错误。<br>使用 poll 时，如果传入的超时时间不为 0，这种访问方法也是阻塞的。<br>使用 poll 时，可以设置超时时间为 0，这样即使没有数据它也会立刻返回，这就是非阻塞方式。</p>
<h3><span id="1-2-1-select">1.2.1 select</span><a href="#1-2-1-select" class="header-anchor">#</a></h3><p>select会循环遍历它所监测的<code>fd_set</code>内的所有文件描述符对应的驱动程序的poll函数。select通过每个设备文件对应的poll函数提供的信息判断当前是否有资源可用(如可读或写)，如果有的话则返回可用资源的文件描述符个数，没有的话则睡眠，等待有资源变为可用时再被唤醒继续执行。</p>
<p>那么select会有2个结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, 查询到资源，返回查询到的fd总数。</span><br><span class="line"><span class="number">2</span>，没查到，则睡眠</span><br><span class="line">	①带timeout参数，timeout后，唤醒退出，此时fd总数为<span class="number">0</span></span><br><span class="line">	②不带timeout, 阻塞且睡眠中，直到有资源可用才唤醒</span><br></pre></td></tr></table></figure>

<p>fd_set结构体就是一个可用资源文件描述符的集合。</p>
<h4><span id="1-2-1-1-select-shi-yong-shi-li">1.2.1.1 select使用示例</span><a href="#1-2-1-1-select-shi-yong-shi-li" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);       <span class="comment">//将fd加入set集合</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);       <span class="comment">//将fd从set集合中清除</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset);     <span class="comment">//检测fd是否在set集合中，不在则返回0</span></span><br><span class="line">FD_ZERO(fd_set *fdset);              <span class="comment">//将set清零使集合中不含任何fd</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<p>该示例假如传入200us的timeout，表示200us内有被驱动唤醒就可以检测到fd在set集合中，从而调用read读取数据。假如不传入timeout，那么select查询会立即返回。</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD_ZERO(&amp;wfds);</span><br><span class="line">FD_SET(fd, &amp;wfds);</span><br><span class="line">tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">tv.tv_usec = <span class="number">100</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line"></span><br><span class="line">ret = select(fd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;wfds, <span class="literal">NULL</span>, &amp;tv)) == <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;select error(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;select timeout\n&quot;</span>);</span><br><span class="line">	ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(fd, &amp;wfds)) &#123;</span><br><span class="line">	<span class="comment">//start write data to drv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>该示例传入100ms的timeout，表示100ms内有被驱动唤醒就可以检测到fd在set集合中，从而<code>start write data to drv</code>, 否则<code>select timeout</code>.</p>
<h3><span id="1-2-2-poll">1.2.2 poll</span><a href="#1-2-2-poll" class="header-anchor">#</a></h3><p>使用休眠唤醒机制，实现简单。比如前面所讲的一个按键字符设备驱动中，read函数中进行等待队列<code>wait_event</code>, 然后当按键按下，中断服务程序进行唤醒等待队列wake_up，read函数将会从休眠中唤醒返回数据给用户。</p>
<p>但是这种有一个缺点，如果要等很久，那么这种方式明显不好。 如果按键一直不去按下，read函数将会一直休眠，应用程序用户线程被一直阻塞。</p>
<pre><code>1. 那么poll机制就是给它加一个超时机制，防止一直休眠和用户线程被阻塞。
2. APP 不知道驱动程序中是否有数据，可以先调用 poll 函数查询一下， poll 函数可以传入超时时间；
3. APP 进入内核态，调用到驱动程序的 poll 函数
    3.1 如果发现没有数据时就休眠一段时间；当超时时间到了之后，内核也会唤醒 APP；
    3.2 当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、唤醒 APP；
4. APP 根据 poll 函数的返回值就可以知道是否有数据，如果有数据就调用read 得到数据
</code></pre>
<h4><span id="1-2-2-1-polls-shi-yong-shi-li">1.2.2.1 polls使用示例</span><a href="#1-2-2-1-polls-shi-yong-shi-li" class="header-anchor">#</a></h4><p>poll&#x2F;select 监测的事件<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/3.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line"><span class="type">nfds_t</span> nfds = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">	fds[<span class="number">0</span>].events  = POLLIN;</span><br><span class="line">	fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">	ret = poll(fds, nfds, <span class="number">5000</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fds[<span class="number">0</span>].revents == POLLIN) &#123;</span><br><span class="line">			<span class="keyword">while</span> (read(fd, &amp;event, <span class="keyword">sizeof</span>(event)) == <span class="keyword">sizeof</span>(event)) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\n&quot;</span>, event.type, event.code, event.value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;time out\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;poll err\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>打开设备文件。</li>
<li>设置 pollfd 结构体：<br>   想查询哪个文件(fd)？<br>   想查询什么事件(POLLIN)？<br>   先清除 “返回的事件” (revents)。<br>   使用 poll 函数查询事件，指定超时时间为 5000(ms)。</li>
</ol>
<h2><span id="1-3-xiu-mian-huan-xing">1.3 休眠唤醒</span><a href="#1-3-xiu-mian-huan-xing" class="header-anchor">#</a></h2><p>这里由于poll底层机制提前用到了一个休眠唤醒机制，也就是<code>等待队列wait_queue</code>。先提前引入概念，</p>
<p><a href="https://fuzidage.github.io/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/">字符设备驱动-6-pre-休眠唤醒机制 | Hexo (fuzidage.github.io)</a></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17469849.html">字符设备驱动-8.休眠唤醒机制 - fuzidage - 博客园 (cnblogs.com)</a> 有展开细讲。</p>
<h3><span id="1-3-1-deng-dai-dui-lie">1.3.1 等待队列</span><a href="#1-3-1-deng-dai-dui-lie" class="header-anchor">#</a></h3><p><strong>wait_event_interruptible_timeout:</strong><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_waitqueue_head</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_interruptible</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span></span><br><span class="line"><span class="title function_">wait_event</span><span class="params">(wq, condition)</span>;</span><br><span class="line">wait_event_timeout(wq, condition, timeout);</span><br><span class="line">wait_event_interruptible(wq, condition);</span><br><span class="line">wait_event_interruptible_timeout(wq, condition, timeout);</span><br></pre></td></tr></table></figure>

<h3><span id="1-3-2-deng-dai-dui-lie-xiang">1.3.2 等待队列项</span><a href="#1-3-2-deng-dai-dui-lie-xiang" class="header-anchor">#</a></h3><p>利用等待队列项来实现read函数的阻塞式访问，底层驱动去进行状态切换。下图把wait_event的方式换成等待队列项。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/6.png" alt="image"></p>
<h1><span id="3-poll-ji-zhi-qu-dong-di-ceng-yuan-li">3 poll机制驱动底层原理</span><a href="#3-poll-ji-zhi-qu-dong-di-ceng-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-wo-men-qi-wang-de-poll-liu-cheng">3.1 我们期望的poll流程</span><a href="#3-1-wo-men-qi-wang-de-poll-liu-cheng" class="header-anchor">#</a></h2><p>我们期望的大致流程如下：<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/7.png" alt="image"></p>
<pre><code>1. app进行open, drv进行drv_open，注册好中断服务
2. app进行poll , drv进行drv_poll
3. 第一次如果没有数据到来，那么会执行else进行休眠，加入等待队列。
    要么被中断服务程序唤醒，进入for循环此时有数据到来返回；
    要么超时，也会从等待队列唤醒回来，进入for循环此时返回超时
</code></pre>
<p>可以看到会查询判断2次，但实际上内核做的更好，我们drv_poll中只需要（这些流程内核帮我们已经做好了）：</p>
<pre><code>1.把线程放入wq等待队列，并不会调用休眠
2.返回event状态
</code></pre>
<h2><span id="3-2-linux-nei-he-shi-ji-de-poll-ji-zhi">3.2 Linux内核实际的poll机制</span><a href="#3-2-linux-nei-he-shi-ji-de-poll-ji-zhi" class="header-anchor">#</a></h2><p>实际内核中poll函数流程如下：内核把poll抽出去了，调用<code>sys_poll</code><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<pre><code>1. app进行open, drv进行drv_open，注册好中断服务
2. app进行poll , 内核文件系统进行sys_poll
3. 调用驱动开发者实现的drv_poll
    调用poll_wait,把线程加入wq，但是不会进入休眠
    而是直接返回event状态
4. drv_poll返回后，sys_poll中进行数据判断（如果第一次进入没有数据到来，执行else, 将线程休眠（可以看到休眠是drv_poll上层sys_poll已经帮我们做好了），如果有数据则直接返回,那么就只会进入一次drv_poll）
   sys_poll函数执行else休眠的过程中，会被event唤醒or被超时唤醒
   第2进入for循环执行drv_poll，如果被event唤醒了，则返回数据，否则说明是超时唤醒，返回超时
5.最终内核文件系统sys_poll返回，唤醒userspace线程
</code></pre>
<p>可以看到当用户调用poll函数，在底层drv下可能会调用2次<code>drv_poll</code>。用户线程不会被一直阻塞休眠，要么有数据时中断的<code>event</code>唤醒，要么超时唤醒。我们只要实现<code>drv_poll</code>的部分，也就是紫色绿色的提示部分。</p>
<h1><span id="4-poll-qu-dong-bian-cheng-shi-li-gpio-key-wei-li">4 poll驱动编程实例（gpio key为例）</span><a href="#4-poll-qu-dong-bian-cheng-shi-li-gpio-key-wei-li" class="header-anchor">#</a></h1><p>使用 poll 机制时，驱动程序的核心就是提供对应的 drv_poll 函数。在drv_poll 函数中要做 2 件事：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 把当前线程挂入队列 wq： poll_wait</span><br><span class="line">	a) APP 调用一次 poll，可能会 drv_poll 被调用 2 次，但是我们并不需要把当前线程挂入队列 2 次。</span><br><span class="line">	b) 可以使用内核的函数 poll_wait 把线程挂入队列，如果线程已经在队列里了，它就不会再次挂入。</span><br><span class="line">2. 返回设备状态：</span><br><span class="line">	APP 调用 poll 函数时，有可能是查询“有没有数据可以读”： POLLIN</span><br><span class="line">	也有可能是查询“你有没有空间给我写数据”： POLLOUT。</span><br><span class="line">	所以 drv_poll 要返回自己的当前状态： (POLLIN | POLLRDNORM) 或 (POLLOUT | POLLWRNORM)。</span><br><span class="line">a) POLLRDNORM 等同于 POLLIN，为了兼容某些 APP 把它们一起返回。</span><br><span class="line">b) POLLWRNORM 等同于 POLLOUT ，为了兼容某些 APP 把它们一起返回。</span><br></pre></td></tr></table></figure>
<p>APP 调用 poll 后，很有可能会休眠。对应的，在中断服务程序中，也要有唤醒操作。<br>完整驱动代码如下：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty()) &#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123; <span class="comment">/* 非阻塞访问 */</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="type">atomic_read</span>(&amp;dev-&gt;releasekey) == <span class="number">0</span>) <span class="comment">/* 没有按键按下 */</span></span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">		key = get_key();</span><br><span class="line">		err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, 			&amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);</span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);<span class="comment">/* /sys/class/100ask_gpio_key_class */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="4-1-probe-han-shu-fen-xi">4.1 probe函数分析</span><a href="#4-1-probe-han-shu-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/9.png" alt="image"></p>
<p>定义gpio_key:<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/10.png" alt="image"><br>先确保dts中含有<code>gpio_key</code>设备树节点，才能通过<code>.compatible = &quot;100ask,gpio_key&quot;</code>匹配<code>plateform_device</code>和<code>platform_driver</code>, 当<code>insmod ko</code>时probe函数被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;<span class="comment">//可以从platform_device获取到device_node</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/11.png" alt="image"><br><code>of_gpio_count</code>可以根据设备树节点获取到gpio的数量。</p>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/12.png" alt="image"><br><code>of_get_gpio_flags</code>可以根据设备树节点获取到gpio编号和<code>gpio flags</code></p>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/13.png" alt="image"><br>获取gpio描述子和gpio中断号</p>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/14.png" alt="image"><br>注册中断服务程序<code>gpio_key_isr</code>，当按键按下会触发gpio中断，执行<code>gpio_key_isr</code>.</p>
<h2><span id="4-2-drv-poll-han-shu-fen-xi">4.2 drv_poll函数分析</span><a href="#4-2-drv-poll-han-shu-fen-xi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br></pre></td></tr></table></figure>
<p>这里先定义并初始化一个<code>wait_queue gpio_key_wait</code>,也就是等待队列。（等待队列使用详见kernel下include\linux\wait.h）<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/15.png" alt="image"></p>
<ol>
<li><p><code>drv_poll</code>函数中call <code>poll_wait</code>将线程加入等待队列，并返回<code>event</code>。 </p>
<ol>
<li>可以看到如果有数据，返回<code>POLLIN | POLLRDNORM</code>(那么<code>drv_poll</code>只会被调用1次)； 回到<code>sys_poll</code></li>
<li>如果没有数据则返回0, 也回到<code>sys_poll</code></li>
</ol>
</li>
<li><p>回到<code>sys_poll</code>后发现:</p>
</li>
<li><p>如果有数据，直接返回</p>
</li>
<li><p>如果没有数据则进入休眠，当超时或者被<code>event</code>唤醒后，<code>sys_poll</code>又会再次进入<code>drv_poll</code>，此时判断<code>is_key_buf_empty</code>，如果是按键按下触发中断响应，那么就有数据，返回<code>POLLIN | POLLRDNORM</code>，否则无数据表示是被超时唤醒，event为0。这种就是<code>sys_poll</code>调用2次。</p>
</li>
</ol>
<pre><code>3.`sys_poll`最终返回，回到`userspace`线程
</code></pre>
<h2><span id="4-3-drv-read-han-shu-fen-xi">4.3 drv_read函数分析</span><a href="#4-3-drv-read-han-shu-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/16.png" alt="image"><br>当userspace得知驱动有数据时，调用read函数，进入<code>drv_read</code>中调用<code>wait_event_interruptible</code><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/17.png" alt="image"><br>这里是利用等待队列，等待队列<code>gpio_key_wait</code>的<code>event</code>为true后，<code>wait_event_interruptible</code>该函数会返回。那么在对应的中断处理函数中，需要call <code>wake_up</code>函数来唤醒等待队列，并且把<code>event</code>设置成true，也就是把<code>wait_event_interruptible</code>的<code>condition</code>设置成true.</p>
<h2><span id="4-4-an-jian-zhong-duan-fu-wu-han-shu-fen-xi">4.4 按键中断服务函数分析</span><a href="#4-4-an-jian-zhong-duan-fu-wu-han-shu-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/18.png" alt="image"><br><code>put_key</code>是将<code>event</code>设置成true,这样表示有数据了，<code>is_key_buf_empty</code>非空了。调用<code>wake_up_interrptible</code>函数唤醒等待队列<code>gpio_key_wait</code>，因此<code>drv_read</code>函数就能立马返回数据。</p>
<h2><span id="4-5-ce-shi">4.5 测试</span><a href="#4-5-ce-shi" class="header-anchor">#</a></h2><p>测试demo用户态程序如下：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_gpio_key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">	fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		ret = poll(fds, <span class="number">1</span>, timeout_ms);</span><br><span class="line">		<span class="keyword">if</span> ((ret == <span class="number">1</span>) &amp;&amp; (fds[<span class="number">0</span>].revents &amp; POLLIN))&#123;</span><br><span class="line">			read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-6-pre-休眠唤醒机制</title>
    <url>/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xiu-mian-yu-huan-xing">1 休眠与唤醒</a><ul>
<li><a href="#1-0-yin-ru-shang-xia-wen-gai-nian">1.0 引入上下文概念</a><ul>
<li><a href="#1-0-1-jin-cheng-shang-xia-wen">1.0.1 进程上下文</a></li>
<li><a href="#1-0-1-zhong-duan-shang-xia-wen">1.0.1 中断上下文</a></li>
</ul>
</li>
<li><a href="#1-1-xiu-mian-han-shu">1.1 休眠函数</a></li>
<li><a href="#1-2-huan-xing-han-shu">1.2 唤醒函数</a></li>
<li><a href="#1-3-shi-yong">1.3 使用</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xiu-mian-yu-huan-xing">1 休眠与唤醒</span><a href="#1-xiu-mian-yu-huan-xing" class="header-anchor">#</a></h1><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/1.png" alt="image"></p>
<pre><code>1.APP 调用 read 等函数试图读取数据，比如读取按键；
2.APP 进入内核态，也就是调用驱动中的对应函数，发现有数据则复制到用户空间并马上返回；
3.如果 APP 在内核态，也就是在驱动程序中发现没有数据，则 APP 休眠；
4.当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、唤醒 APP；
5.APP 继续运行它的内核态代码，也就是驱动程序中的函数，复制数据到用户空间并马上返回
</code></pre>
<p>drv_read函数当没有数据时需要休眠等待有数据唤醒。当按下按键，驱动程序中的中断服务程序被调用，它会记录数据，并唤醒 APP的read函数。</p>
<h2><span id="1-0-yin-ru-shang-xia-wen-gai-nian">1.0 引入上下文概念</span><a href="#1-0-yin-ru-shang-xia-wen-gai-nian" class="header-anchor">#</a></h2><p>app执行整个过程如下图，可以把它看作被拆分成2段：被叫做<code>“上下文”</code>。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<h3><span id="1-0-1-jin-cheng-shang-xia-wen">1.0.1 进程上下文</span><a href="#1-0-1-jin-cheng-shang-xia-wen" class="header-anchor">#</a></h3><p>或者这样说：红实线所涉及的代码，都是APP调用的，被叫做<code>进程上下文</code>，drv_read中有数据直接返回数据，没有数据的话让出CPU休眠等待。</p>
<h3><span id="1-0-1-zhong-duan-shang-xia-wen">1.0.1 中断上下文</span><a href="#1-0-1-zhong-duan-shang-xia-wen" class="header-anchor">#</a></h3><p>但是按键的中断服务程序，不属于APP的 <code>“上下文”</code>，这是突如其来的，当中断发生时，APP1 正在休眠呢。在 APP 的<code>“上下文”</code>，也就是在 APP的执行过程中，它是可以休眠的。<br>在中断的处理过程中，也就是<code>gpio_key_irq</code>的执行过程中，它不能休眠：<code>“中断”</code>怎么能休眠？<code>“中断”</code>休眠了，谁来调度其他 APP 啊？<br>所以<strong>：在中断处理函数中，不能休眠，也就不能调用会导致休眠的函数</strong>, 被叫做<code>中断上下文</code>。</p>
<h2><span id="1-1-xiu-mian-han-shu">1.1 休眠函数</span><a href="#1-1-xiu-mian-han-shu" class="header-anchor">#</a></h2><p>内核源码：<code>include\linux\wait.h</code><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/3.png" alt="image"><br>参数1：<code>wq:</code> <code>waitqueue</code>等待队列<br>用来等待条件值，<code>condition</code>不为0则立即返回<br>参数2：<code>condition</code><br>这可以是一个变量，也可以是任何表达式。表示“一直等待，直到 <code>condition</code>为真</p>
<h2><span id="1-2-huan-xing-han-shu">1.2 唤醒函数</span><a href="#1-2-huan-xing-han-shu" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<h2><span id="1-3-shi-yong">1.3 使用</span><a href="#1-3-shi-yong" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<p>1.read函数中进行<code>wait_event_interruptible</code>，因此需要初始化一个<code>wq</code>, 用<code>init_waitqueue_head</code>函数进行初始化等待队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> job_done_wq;</span><br><span class="line">init_waitqueue_head(&amp;job-&gt;job_done_wq);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/6.png" alt="image"><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/7.png" alt="image"><br>或者用<code>DECLARE_WAIT_QUEUE_HEAD</code>声明定义初始化一起。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br></pre></td></tr></table></figure>
<p>read函数判断是否有key，有key则直接返回，否则<code>wait_event_interruptible</code>休眠。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/9.png" alt="image"></p>
<pre><code>wait_event_interruptible(gpio_key_wait, g_key);
</code></pre>
<p>2.如果按键按下了，中断isr进行响应，调用<code>wake_up_interruptible</code>,并且设置<code>condition</code>为true.驱动的read函数将会被唤醒。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/10.png" alt="image"></p>
<details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_key = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	wait_event_interruptible(gpio_key_wait, g_key);</span><br><span class="line">	err = copy_to_user(buf, &amp;g_key, <span class="number">4</span>);</span><br><span class="line">	g_key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	g_key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, 			&amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>驱动代码2(使用环形buf存放键值)</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, 		&amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/gpio_key */</span></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>app代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-5-设备树函数</title>
    <url>/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-she-bei-shu-xiang-guan-de-tou-wen-jian">1.设备树相关的头文件</a></li>
<li><a href="#2-she-bei-shu-xiang-guan-de-han-shu">2.设备树相关的函数</a><ul>
<li><a href="#2-1-zhao-res-shu-xing-he-platform-device">2.1 找res属性和platform device</a></li>
<li><a href="#2-2-zhao-jie-dian">2.2 找节点</a></li>
<li><a href="#2-3-zhao-dao-shu-xing">2.3 找到属性</a><ul>
<li><a href="#2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian">2.3.1 找到属性所指向的节点</a></li>
<li><a href="#2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi">2.3.2 设备节点找到资源信息</a></li>
</ul>
</li>
<li><a href="#2-4-huo-qu-shu-xing-de-zhi">2.4 获取属性的值</a></li>
<li><a href="#2-5-du-zheng-shu-u32-u64">2.5 读整数 u32&#x2F;u64</a></li>
<li><a href="#2-6-du-shu-zu">2.6 读数组</a></li>
<li><a href="#2-7-du-zi-fu-chuan">2.7 读字符串</a></li>
<li><a href="#2-8-qi-ta-of-han-shu">2.8 其他of函数</a></li>
</ul>
</li>
<li><a href="#3-shi-yong-she-bei-shu-shi-li">3 使用设备树示例</a><ul>
<li><a href="#3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian">3.1 led灯驱动设备树方式实现</a></li>
<li><a href="#3-2-qu-dong-cheng-xu">3.2 驱动程序</a></li>
</ul>
</li>
<li><a href="#4-gen-she-bei-shu-sao-miao-liu-cheng">4 根设备树扫描流程</a><ul>
<li><a href="#4-1-jie-xi-root-dts-zong-lan">4.1 解析root dts总览</a><ul>
<li><a href="#4-1-1-setup-machine-fdt">4.1.1 setup_machine_fdt</a></li>
<li><a href="#4-1-2-arm-memblock-init">4.1.2 arm_memblock_init</a></li>
<li><a href="#4-1-3-unflatten-device-tree">4.1.3 unflatten_device_tree</a><ul>
<li><a href="#4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian">4.1.3.1 unflatten_dt_nodes遍历子节点</a><ul>
<li><a href="#4-1-3-1-1-populate-node">4.1.3.1.1 populate_node</a></li>
</ul>
</li>
<li><a href="#4-1-3-2-of-alias-scan">4.1.3.2 of_alias_scan</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-device-node-zhuan-huan-cheng-platform-device">5 device_node转换成platform_device</a><ul>
<li><a href="#5-0-zhuan-huan-guo-cheng-zong-lan">5.0 转换过程总览</a></li>
<li><a href="#5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian">5.1 device_node转换到platform_device的条件</a></li>
<li><a href="#5-2-zhuan-huan-guo-cheng-jie-xi">5.2 转换过程解析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-she-bei-shu-xiang-guan-de-tou-wen-jian">1.设备树相关的头文件</span><a href="#1-she-bei-shu-xiang-guan-de-tou-wen-jian" class="header-anchor">#</a></h1><p>1.处理 <code>DTB</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">of_fdt.h <span class="comment">// dtb 文件的相关操作函数, 我们一般用不到,</span></span><br><span class="line"><span class="comment">// 因为 dtb 文件在内核中已经被转换为 device_node 树(它更易于使用)</span></span><br></pre></td></tr></table></figure>
<p>2.处理 <code>device_node</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">of.h <span class="comment">// 提供设备树的一般处理函数,</span></span><br><span class="line"><span class="comment">// 比如 of_property_read_u32(读取某个属性的 u32 值),</span></span><br><span class="line"><span class="comment">// of_get_child_count(获取某个 device_node 的子节点数)</span></span><br><span class="line">of_address.h <span class="comment">// 地址相关的函数,</span></span><br><span class="line"><span class="comment">// 比如 of_get_address(获得 reg 属性中的 addr, size 值)</span></span><br><span class="line"><span class="comment">// of_match_device (从 matches 数组中取出与当前设备最匹配的一项)</span></span><br><span class="line">of_dma.h <span class="comment">// 设备树中 DMA 相关属性的函数</span></span><br><span class="line">of_gpio.h <span class="comment">// GPIO 相关的函数</span></span><br><span class="line">of_graph.h <span class="comment">// GPU 相关驱动中用到的函数, 从设备树中获得 GPU 信息</span></span><br><span class="line">of_iommu.h <span class="comment">// 很少用到</span></span><br><span class="line">of_irq.h <span class="comment">// 中断相关的函数</span></span><br><span class="line">of_mdio.h <span class="comment">// MDIO (Ethernet PHY) API</span></span><br><span class="line">of_net.h <span class="comment">// OF helpers for network devices.</span></span><br><span class="line">of_pci.h <span class="comment">// PCI 相关函数</span></span><br><span class="line">of_pdt.h <span class="comment">// 很少用到</span></span><br><span class="line">of_reserved_mem.h <span class="comment">// reserved_mem 的相关函数</span></span><br></pre></td></tr></table></figure>
<p>3.处理<code> platform_device</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">of_platform.h <span class="comment">// 把 device_node 转换为 platform_device 时用到的函数,</span></span><br><span class="line"><span class="comment">// 比如 of_device_alloc(根据 device_node 分配设置 platform_device),</span></span><br><span class="line"><span class="comment">// of_find_device_by_node (根据 device_node 查找到 platform_device),</span></span><br><span class="line"><span class="comment">// of_platform_bus_probe (处理 device_node 及它的子节点)</span></span><br><span class="line">of_device.h <span class="comment">// 设备相关的函数, 比如 of_match_device</span></span><br></pre></td></tr></table></figure>
<h1><span id="2-she-bei-shu-xiang-guan-de-han-shu">2.设备树相关的函数</span><a href="#2-she-bei-shu-xiang-guan-de-han-shu" class="header-anchor">#</a></h1><h2><span id="2-1-zhao-res-shu-xing-he-platform-device">2.1 找res属性和platform device</span><a href="#2-1-zhao-res-shu-xing-he-platform-device" class="header-anchor">#</a></h2><p><strong>of_find_device_by_node</strong><br>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_find_device_by_node</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span>;</span><br></pre></td></tr></table></figure>
<p>设备树中的每一个节点，在内核里都有一个 <code>device_node</code>；你可以使用device_node 去找到对应的 <code>platform_device</code>。</p>
<p><strong>platform_get_resource</strong><br>这 个 函 数 跟 设 备 树 没 什 么 关 系 ， 但 是 设 备 树 中 的 节 点 被 转 换 为<code> platform_device</code> 后，设备树中的<code> reg 属性、interrupts 属性</code>也会被转换为<code>“resource”</code>。 这时，你可以使用这个函数取出这些资源。<br>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* platform_get_resource - get a resource for a device</span></span><br><span class="line"><span class="comment">* @dev: platform device</span></span><br><span class="line"><span class="comment">* @type: resource type // 取哪类资源？IORESOURCE_MEM、IORESOURCE_REG</span></span><br><span class="line"><span class="comment">* // IORESOURCE_IRQ 等</span></span><br><span class="line"><span class="comment">* @num: resource index // 这类资源中的哪一个？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>
<p>对于设备树节点中的 reg 属性，它对应 <code>IORESOURCE_MEM</code> 类型的资源； 对于设备树节点中的 interrupts 属性，它对应 <code>IORESOURCE_IRQ</code> 类型的资源。</p>
<h2><span id="2-2-zhao-jie-dian">2.2 找节点</span><a href="#2-2-zhao-jie-dian" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/1.png" alt="image"></p>
<p><strong>of_find_node_by_path</strong><br>根据路径找到节点，比如<code>“/”</code>就对应根节点，<code>“/memory”</code>对应 memory 节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;c</span><br></pre></td></tr></table></figure>

<p><strong>of_find_node_by_name</strong><br>根据名字找到节点，节点如果定义了 name 属性，那我们可以根据名字找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *from,<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。 但是在设备树的官方规范中不建议使用<code>“name”</code>属性，所以这函数也不建议 使用。<br><strong>of_find_node_by_type</strong><br>根据类型找到节点，节点如果定义了 device_type 属性，那我们可以根据类型找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_type</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br></pre></td></tr></table></figure>
<p>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。 但是在设备树的官方规范中不建议使用<code>“device_type”</code>属性，所以这函数也不建议使用。<br><strong>of_find_compatible_node</strong><br>根据<code> device_type</code>和<code>compatible</code> 找到节点，节点如果定义了 <code>compatible</code> 属性，那我们可以根据 <code>compatible </code>属性找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *compat)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 <code>from </code>表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
<li>参数 <code>compat </code>是一个字符串，用来指定 <code>compatible </code>属性的值；</li>
<li>参数<code>type </code>是一个字符串，用来指定 <code>device_type</code> 属性的值，可以传入 NULL。</li>
</ul>
<p><strong>of_find_node_by_phandle</strong><br>根据 <code>phandle </code>找到节点。<code>dts</code> 文件被编译为 <code>dtb </code>文件时，每一个节点都有一个数字 ID，这些数字 ID 彼此不同。可以使用数字 ID 来找到 <code>device_node</code>。 这些数字 ID 就是<code> phandle</code>。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_phandle</span><span class="params">(phandle handle)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>of_find_matching_node_and_match</strong><br>通过<code> of_device_id</code> 匹配表来查找指定的节点.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</span></span><br><span class="line"><span class="comment">//matches：of_device_id 匹配表，也就是在此匹配表里面查找节点。</span></span><br><span class="line"><span class="comment">//match：找到的匹配的 of_device_id。</span></span><br><span class="line"><span class="comment">//返回值：找到的节点，如果为 NULL 表示查找失败</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_matching_node_and_match</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> of_device_id **match)</span></span><br></pre></td></tr></table></figure>

<p><strong>of_get_parent</strong><br>找到 <code>device_node</code> 的父节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_parent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
</ul>
<p><strong>of_get_next_parent</strong><br>这个函数名比较奇怪，怎么可能有<code>“next parent”</code>？<br>它实际上也是找到 device_node 的父节点，跟<code> of_get_parent</code> 的返回结果是一样的。差别在于它多调用下列函数，把 node 节点的引用计数减少了 1。这意味着 调用<code> of_get_next_parent</code> 之后，你不再需要调用<code> of_node_put</code> 释放 node 节点。<br><code>of_node_put(node);</code><br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_parent</span><span class="params">(<span class="keyword">struct</span> device_node *node)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
</ul>
<p><strong>of_get_next_child</strong><br>取出下一个子节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *prev)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>prev 表示上一个子节点，设为 NULL 时表示想找到第 1 个子节点。</li>
</ul>
<p>不断调用 <code>of_get_next_child </code>时，不断更新<code>pre</code>参数，就可以得到所有的子节点。<br><strong>of_get_next_available_child</strong><br>取出下一个 “可用” 的子节点，有些节点的 status 是<code>“disabled”</code>，那就会跳过这些节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_available_child</span><span class="params">( <span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *prev)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>prev 表示上一个子节点，设为 NULL 时表示想找到第 1 个子节点。</li>
</ul>
<p><strong>of_get_child_by_name</strong><br>根据名字取出子节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_child_by_name</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>name 表示子节点的名字。</li>
</ul>
<h2><span id="2-3-zhao-dao-shu-xing">2.3 找到属性</span><a href="#2-3-zhao-dao-shu-xing" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/2.png" alt="image"></p>
<p><strong>of_find_property</strong><br>内核源码 <code>incldue/linux/of.h </code>中声明了 device_node 的操作函数，当然也包括属性的操作函数：<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> property *<span class="title function_">of_find_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span>;</span><br><span class="line"><span class="comment">//eg: proper = of_find_property(dtsled.nd, &quot;compatible&quot;, NULL);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数np表示节点，我们要在这个节点中找到名为 name 的属性。</li>
<li>lenp 用来保存这个属性的长度，即它的值的长度。</li>
</ul>
<h3><span id="2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian">2.3.1 找到属性所指向的节点</span><a href="#2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ion_heap0: heap_carveout@<span class="number">0</span> &#123;</span><br><span class="line">	memory-region = &lt;&amp;ion_for_npu&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_parse_phandle</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> *phandle_name, <span class="type">int</span> index)</span>；</span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="comment">// get reserved memory-region</span></span><br><span class="line">res_node = of_parse_phandle(np, <span class="string">&quot;memory-region&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!res_node) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to get memory region node\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">ret = of_address_to_resource(res_node, <span class="number">0</span>, res);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to get reserved region address\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi">2.3.2 设备节点找到资源信息</span><a href="#2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> resource *r)</span>；</span><br></pre></td></tr></table></figure>
<h2><span id="2-4-huo-qu-shu-xing-de-zhi">2.4 获取属性的值</span><a href="#2-4-huo-qu-shu-xing-de-zhi" class="header-anchor">#</a></h2><p><strong>of_get_property</strong><br>根据名字找到节点的属性，并且返回它的值。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Find a property with a given name for a given node</span></span><br><span class="line"><span class="comment">* and return the value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">of_get_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span>;</span><br><span class="line"><span class="comment">//eg: of_find_property(dtsled.nd, &quot;compatible&quot;, NULL);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数 np 表示节点，我们要在这个节点中找到名为 name 的属性，然后返回它的值。</li>
<li>lenp 用来保存这个属性的长度，即它的值的长度。</li>
</ul>
<p><strong>of_property_count_elems_of_size</strong><br>根据名字找到节点的属性，确定它的值有多少个元素(elem)。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* of_property_count_elems_of_size - Count the number of elements in a property</span><br><span class="line">*</span><br><span class="line">* @np:</span><br><span class="line">* device node from which the property value is to be read.</span><br><span class="line">* @propname: name of the property to be searched.</span><br><span class="line">* @elem_size: size of the individual element</span><br><span class="line">*</span><br><span class="line">* Search <span class="keyword">for</span> a property in a device node and count the number of elements of</span><br><span class="line">* size elem_size in it. Returns number of elements on sucess, -EINVAL <span class="keyword">if</span> the</span><br><span class="line">* property does not exist or its length does not match a multiple of elem_size</span><br><span class="line">* and -ENODATA <span class="keyword">if</span> the property does not have a value.</span><br><span class="line">*/</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_count_elems_of_size</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">int</span> elem_size)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数 np 表示节点，我们要在这个节点中找到名为 propname 的属性，然后返回下列结果：<br>  <code>return prop-&gt;length / elem_size;</code><br>  在设备树中，节点大概是这样：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	xxx_pp_name = &lt;<span class="number">0x50000000</span> <span class="number">1024</span>&gt; &lt;<span class="number">0x60000000</span> <span class="number">2048</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>of_property_count_elems_of_size(np, “xxx_pp_name”, 8)</code>时，返回值是 2；</p>
</li>
<li><p>调用<code> of_property_count_elems_of_size(np, “xxx_pp_name”, 4)</code>时，返回值是 4。</p>
</li>
</ul>
<h2><span id="2-5-du-zheng-shu-u32-x2f-u64">2.5 读整数 u32&#x2F;u64</span><a href="#2-5-du-zheng-shu-u32-x2f-u64" class="header-anchor">#</a></h2><p><strong>of_property_read_u32</strong><br><strong>of_property_read_u64</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">of_property_read_u32</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 *out_value)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">of_property_read_u64</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u64 *out_value)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name1 = &lt;<span class="number">0x50000000</span>&gt;;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000000</span> <span class="number">0x60000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>of_property_read_u32 (np, “name1”, &amp;val)</code>时，val 将得到值 0x50000000；</li>
<li>调用 <code>of_property_read_u64 (np, “name2”, &amp;val)</code>时，val 将得到值 0x6000000050000000。</li>
</ul>
<p><strong>读某个整数 u32&#x2F;u64</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">of_property_read_u32_index</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 index, u32 *out_value)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000000</span> <span class="number">0x60000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>of_property_read_u32 (np, “name2”, 1, &amp;val)</code>时，val 将得到值 0x60000000。</li>
</ul>
<h2><span id="2-6-du-shu-zu">2.6 读数组</span><a href="#2-6-du-shu-zu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u8_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u8 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u16_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u16 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u32_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u64_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u64 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000012</span> <span class="number">0x60000034</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述例子中属性 name2 的值，长度为 8。</p>
<ul>
<li>调用 <code>of_property_read_variable_u8_array (np, “name2”, out_values, 1, 10)</code>时， out_values 中将会保存这 8 个字节： <code>0x12,0x00,0x00,0x50,0x34,0x00,0x00,0x60</code>。</li>
<li>调用 <code>of_property_read_variable_u16_array (np, “name2”, out_values, 1, 10)</code>时， out_values 中将会保存这 4 个 16 位数值： <code>0x0012, 0x5000,0x0034,0x6000</code>。<br>总之，这些函数要么能取到全部的数值，要么一个数值都取不到；</li>
<li>如果值的长度在 <code>sz_min</code> 和 <code>sz_max</code> 之间，就返回全部的数值；</li>
<li>否则一个数值都不返回。</li>
</ul>
<h2><span id="2-7-du-zi-fu-chuan">2.7 读字符串</span><a href="#2-7-du-zi-fu-chuan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_string</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">const</span> <span class="type">char</span> **out_string)</span>;</span><br><span class="line"><span class="comment">// eg:of_property_read_string(dtsled.nd, &quot;status&quot;, &amp;str);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回节点 np 的属性(名为 <code>propname</code>)的值; </li>
<li><code>(*out_string)</code>指向这个值，把它当作字符串</li>
</ul>
<h2><span id="2-8-qi-ta-of-han-shu">2.8 其他of函数</span><a href="#2-8-qi-ta-of-han-shu" class="header-anchor">#</a></h2><p><strong>of_device_is_compatible</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_device_is_compatible</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">	device_node *device, <span class="type">const</span> <span class="type">char</span> *compat)</span>;</span><br></pre></td></tr></table></figure>
<p>检查设备节点的兼容性, 用于查看节点的 <code>compatible</code>属性是否有包含 <code>compat</code>指定的字符。</p>
<p><strong>of_translate_address</strong><br>函数负责将从设备树读取到的地址转换为物理地址，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64 <span class="title function_">of_translate_address</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> __be32 *addr)</span>；</span><br></pre></td></tr></table></figure>

<p><strong>of_address_to_resource</strong><br>根据设备节点转成资源信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index, <span class="keyword">struct</span> resource *r)</span>;</span><br><span class="line"><span class="comment">//dev：设备节点。</span></span><br><span class="line"><span class="comment">//index：地址资源标号。</span></span><br><span class="line"><span class="comment">//r：得到的 resource 类型的资源值。</span></span><br><span class="line"><span class="comment">//返回值：0，成功；负值，失败。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/2-1.png" alt="image"><br><code>IIC、 SPI、 GPIO</code>等这些外设都有对应的寄存器，这些寄存器其实就是一组内存 空间， Linux内核使用 resource结构体来描述一段内存空间。<br>对于 32位的 SOC来说，<code> resource_size_t</code>是 u32类型的。其中 start表示开始地址， end表示结束地址， name是这个资源的名字， flags是资源标志位，一般表示资源类型，可选的资源标志定义在文件 <code>include/linux/ioport.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM          0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_REG          0x00000300      <span class="comment">/* Register offsets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IRQ          0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_DMA          0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_BUS          0x00001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_PREFETCH     0x00002000      <span class="comment">/* No side effects */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_READONLY     0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_CACHEABLE    0x00008000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_RANGELENGTH  0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SHADOWABLE   0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SIZEALIGN    0x00040000      <span class="comment">/* size indicates alignment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_STARTALIGN   0x00080000      <span class="comment">/* start field is alignment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM_64       0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_WINDOW       0x00200000      <span class="comment">/* forwarded by bridge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MUXED        0x00400000      <span class="comment">/* Resource is software muxed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_EXT_TYPE_BITS 0x01000000     <span class="comment">/* Resource extended types */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM       0x01000000      <span class="comment">/* System RAM (modifier) */</span></span></span><br><span class="line"><span class="comment">/* IORESOURCE_SYSRAM specific bits. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM_DRIVER_MANAGED        0x02000000 <span class="comment">/* Always detected via a driver. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM_MERGEABLE             0x04000000 <span class="comment">/* Resource can be merged. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_EXCLUSIVE    0x08000000      <span class="comment">/* Userland may not map this resource */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_DISABLED     0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_UNSET        0x20000000      <span class="comment">/* No address assigned yet */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_AUTO         0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_BUSY         0x80000000      <span class="comment">/* Driver has marked this resource busy */</span></span></span><br></pre></td></tr></table></figure>

<p>常 见 的 资 源 标 志 就 是<code> IORESOURCE_MEM 、 IORESOURCE_REG 和IORESOURCE_IRQ</code>。</p>
<p><strong>of_iomap</strong><br>以前我们会通过<code>ioremap</code>函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过<code> of_iomap</code> 函数来获取内存地址所对应的虚拟地址，不需要使用 <code>ioremap</code> 函数。<br><code>of_iomap </code>函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __iomem *<span class="title function_">of_iomap</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<h1><span id="3-shi-yong-she-bei-shu-shi-li">3 使用设备树示例</span><a href="#3-shi-yong-she-bei-shu-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian">3.1 led灯驱动设备树方式实现</span><a href="#3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian" class="header-anchor">#</a></h2><p>led灯dts定义在根节点下,作为根节点子节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">alphaled &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;atkalpha-led&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	reg = &lt; <span class="number">0X020C406C</span> <span class="number">0X04</span> <span class="comment">/* CCM_CCGR1_BASE */</span></span><br><span class="line">	<span class="number">0X020E0068</span> <span class="number">0X04</span> <span class="comment">/* SW_MUX_GPIO1_IO03_BASE */</span></span><br><span class="line">	<span class="number">0X020E02F4</span> <span class="number">0X04</span> <span class="comment">/* SW_PAD_GPIO1_IO03_BASE */</span></span><br><span class="line">	<span class="number">0X0209C000</span> <span class="number">0X04</span> <span class="comment">/* GPIO1_DR_BASE */</span></span><br><span class="line">	<span class="number">0X0209C004</span> <span class="number">0X04</span> &gt;; <span class="comment">/* GPIO1_GDIR_BASE */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-qu-dong-cheng-xu">3.2 驱动程序</span><a href="#3-2-qu-dong-cheng-xu" class="header-anchor">#</a></h2><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTSLED_CNT			1		  	<span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTSLED_NAME			<span class="string">&quot;dtsled&quot;</span>	<span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 					0			<span class="comment">/* 关灯 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 					1			<span class="comment">/* 开灯 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 映射后的寄存器虚拟地址指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *IMX6U_CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>		<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span> <span class="title">dtsled</span>;</span>	<span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(sta == LEDON) &#123;</span><br><span class="line">		val = readl(GPIO1_DR);</span><br><span class="line">		val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">		writel(val, GPIO1_DR);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta == LEDOFF) &#123;</span><br><span class="line">		val = readl(GPIO1_DR);</span><br><span class="line">		val|= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">		writel(val, GPIO1_DR);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;dtsled; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ledstat = databuf[<span class="number">0</span>];		<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ledstat == LEDON) &#123;	</span><br><span class="line">		led_switch(LEDON);		<span class="comment">/* 打开LED灯 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">		led_switch(LEDOFF);	<span class="comment">/* 关闭LED灯 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">dtsled_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = led_open,</span><br><span class="line">	.read = led_read,</span><br><span class="line">	.write = led_write,</span><br><span class="line">	.release = 	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 val = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	u32 regdata[<span class="number">14</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">proper</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取设备树中的属性数据 */</span></span><br><span class="line">	<span class="comment">/* 1、获取设备节点：alphaled */</span></span><br><span class="line">	dtsled.nd = of_find_node_by_path(<span class="string">&quot;/alphaled&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(dtsled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;alphaled node nost find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;alphaled node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、获取compatible属性内容 */</span></span><br><span class="line">	proper = of_find_property(dtsled.nd, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(proper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;compatible property find failed\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;compatible = %s\r\n&quot;</span>, (<span class="type">char</span>*)proper-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、获取status属性内容 */</span></span><br><span class="line">	ret = of_property_read_string(dtsled.nd, <span class="string">&quot;status&quot;</span>, &amp;str);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;status read failed!\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;status = %s\r\n&quot;</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、获取reg属性内容 */</span></span><br><span class="line">	ret = of_property_read_u32_array(dtsled.nd, <span class="string">&quot;reg&quot;</span>, regdata, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;reg property read failed!\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u8 i = <span class="number">0</span>;</span><br><span class="line">		printk(<span class="string">&quot;reg data:\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">			printk(<span class="string">&quot;%#X &quot;</span>, regdata[i]);</span><br><span class="line">		printk(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化LED */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 1、寄存器地址映射 */</span></span><br><span class="line">	IMX6U_CCM_CCGR1 = ioremap(regdata[<span class="number">0</span>], regdata[<span class="number">1</span>]);</span><br><span class="line">	SW_MUX_GPIO1_IO03 = ioremap(regdata[<span class="number">2</span>], regdata[<span class="number">3</span>]);</span><br><span class="line">  	SW_PAD_GPIO1_IO03 = ioremap(regdata[<span class="number">4</span>], regdata[<span class="number">5</span>]);</span><br><span class="line">	GPIO1_DR = ioremap(regdata[<span class="number">6</span>], regdata[<span class="number">7</span>]);</span><br><span class="line">	GPIO1_GDIR = ioremap(regdata[<span class="number">8</span>], regdata[<span class="number">9</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	IMX6U_CCM_CCGR1 = of_iomap(dtsled.nd, <span class="number">0</span>);</span><br><span class="line">	SW_MUX_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">1</span>);</span><br><span class="line">  	SW_PAD_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">2</span>);</span><br><span class="line">	GPIO1_DR = of_iomap(dtsled.nd, <span class="number">3</span>);</span><br><span class="line">	GPIO1_GDIR = of_iomap(dtsled.nd, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、使能GPIO1时钟 */</span></span><br><span class="line">	val = readl(IMX6U_CCM_CCGR1);</span><br><span class="line">	val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);	<span class="comment">/* 清楚以前的设置 */</span></span><br><span class="line">	val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);	<span class="comment">/* 设置新值 */</span></span><br><span class="line">	writel(val, IMX6U_CCM_CCGR1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、设置GPIO1_IO03的复用功能，将其复用为</span></span><br><span class="line"><span class="comment">	 *    GPIO1_IO03，最后设置IO属性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	writel(<span class="number">5</span>, SW_MUX_GPIO1_IO03);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*寄存器SW_PAD_GPIO1_IO03设置IO属性</span></span><br><span class="line"><span class="comment">	 *bit 16:0 HYS关闭</span></span><br><span class="line"><span class="comment">	 *bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment">     *bit [13]: 0 kepper功能</span></span><br><span class="line"><span class="comment">     *bit [12]: 1 pull/keeper使能</span></span><br><span class="line"><span class="comment">     *bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment">     *bit [7:6]: 10 速度100Mhz</span></span><br><span class="line"><span class="comment">     *bit [5:3]: 110 R0/6驱动能力</span></span><br><span class="line"><span class="comment">     *bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、设置GPIO1_IO03为输出功能 */</span></span><br><span class="line">	val = readl(GPIO1_GDIR);</span><br><span class="line">	val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	<span class="comment">/* 清除以前的设置 */</span></span><br><span class="line">	val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	<span class="comment">/* 设置为输出 */</span></span><br><span class="line">	writel(val, GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5、默认关闭LED */</span></span><br><span class="line">	val = readl(GPIO1_DR);</span><br><span class="line">	val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">	writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">	<span class="comment">/* 1、创建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (dtsled.major) &#123;		<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">		dtsled.devid = MKDEV(dtsled.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(dtsled.devid, DTSLED_CNT, DTSLED_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">		alloc_chrdev_region(&amp;dtsled.devid, <span class="number">0</span>, DTSLED_CNT, DTSLED_NAME);	<span class="comment">/* 申请设备号 */</span></span><br><span class="line">		dtsled.major = MAJOR(dtsled.devid);	<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">		dtsled.minor = MINOR(dtsled.devid);	<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;dtsled major=%d,minor=%d\r\n&quot;</span>,dtsled.major, dtsled.minor);	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、初始化cdev */</span></span><br><span class="line">	dtsled.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、添加一个cdev */</span></span><br><span class="line">	cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_CNT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、创建类 */</span></span><br><span class="line">	dtsled.class = class_create(THIS_MODULE, DTSLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dtsled.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dtsled.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5、创建设备 */</span></span><br><span class="line">	dtsled.device = device_create(dtsled.class, <span class="literal">NULL</span>, dtsled.devid, <span class="literal">NULL</span>, DTSLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dtsled.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dtsled.device);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 取消映射 */</span></span><br><span class="line">	iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">	iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">	iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">	iounmap(GPIO1_DR);</span><br><span class="line">	iounmap(GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">	cdev_del(&amp;dtsled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">	unregister_chrdev_region(dtsled.devid, DTSLED_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">	device_destroy(dtsled.class, dtsled.devid);</span><br><span class="line">	class_destroy(dtsled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="4-gen-she-bei-shu-sao-miao-liu-cheng">4 根设备树扫描流程</span><a href="#4-gen-she-bei-shu-sao-miao-liu-cheng" class="header-anchor">#</a></h1><h2><span id="4-1-jie-xi-root-dts-zong-lan">4.1 解析root dts总览</span><a href="#4-1-jie-xi-root-dts-zong-lan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span>;</span></span><br><span class="line">    mdesc = setup_machine_fdt(__atags_pointer);</span><br><span class="line">    ...</span><br><span class="line">    arm_memblock_init(mdesc);</span><br><span class="line">    ...</span><br><span class="line">    unflatten_device_tree();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup_machine_fdt() </code>根据传入的设备树dtb的首地址完成一些初始化操作。<br><code>arm_memblock_init()</code> 主要是内存相关，为设备树保留相应的内存空间，保证设备树dtb本身存在于内存中而不被覆盖。<br><code>unflatten_device_tree()</code>对设备树具体的解析，将设备树各节点转换成相应的struct device_node结构体.</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/3.png" alt="image-20240728203202947"></p>
<h3><span id="4-1-1-setup-machine-fdt">4.1.1 setup_machine_fdt</span><a href="#4-1-1-setup-machine-fdt" class="header-anchor">#</a></h3><p>参数<code>__atags_pointer</code>就是 r2 的寄存器值，是设备树在内存中的起始地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">machine_desc</span> * <span class="function">__init <span class="title">setup_machine_fdt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> dt_phys)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">machine_desc</span> *mdesc, *mdesc_best = <span class="literal">NULL</span>;                    </span><br><span class="line">    <span class="keyword">if</span> (!dt_phys || !<span class="built_in">early_init_dt_verify</span>(<span class="built_in">phys_to_virt</span>(dt_phys)))           ——————part <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mdesc = <span class="built_in">of_flat_dt_match_machine</span>(mdesc_best, arch_get_next_mach);       ——————part <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">early_init_dt_scan_nodes</span>();                                             ——————part <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一部分先将设备树在内存中的物理地址转换为虚拟地址，uboot 传递给内核的设备树地址为物理地址，因为设备树被放置在内存的线性映射区，因此可以简单地通过偏移计算得出其对应的虚拟地址，然后再<code>early_init_dt_verify</code>检查该地址上是否有设备树的魔数(<code>magic</code>)。检查设备树是否匹配成功。最后将设备树地址赋值给全局变量 <code>initial_boot_params</code>。</p>
</li>
<li><p><code>of_flat_dt_match_machine(mdesc_best, arch_get_next_mach)</code>，逐一读取dts根目录下的 compatible 属性, 返回<code>machine_desc</code>结构体。</p>
</li>
<li><p>第三部分就是扫描设备树中的各节点:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">early_init_dt_scan_nodes</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line">    <span class="comment">//boot_command_line是一个静态数组，存放着启动参数,</span></span><br><span class="line">    <span class="comment">//而of_scan_flat_dt()函数的作用就是扫描设备树中的节点，然后对各节点分别调用传入的回调函数。</span></span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这3个函数分别是处理<code>chosen</code>节点、root节点中除子节点外的属性信息、memory节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __init <span class="title">early_init_dt_scan_chosen</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    p = <span class="built_in">of_get_flat_dt_prop</span>(node, <span class="string">&quot;bootargs&quot;</span>, &amp;l);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; l &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">strlcpy</span>(data, p, <span class="built_in">min</span>((<span class="type">int</span>)l, COMMAND_LINE_SIZE));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>获取<code> bootargs</code>，然后将<code>bootargs</code>放入<code>boot_command_line</code>中，作为启动参数，而并非处理整个chosen节点。</p>
<p>再看第二个函数调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">early_init_dt_scan_root</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;</span><br><span class="line">    dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;</span><br><span class="line">    prop = of_get_flat_dt_prop(node, <span class="string">&quot;#size-cells&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (prop)</span><br><span class="line">   		dt_root_size_cells = be32_to_cpup(prop);</span><br><span class="line">    prop = of_get_flat_dt_prop(node, <span class="string">&quot;#address-cells&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (prop)</span><br><span class="line">    	dt_root_addr_cells = be32_to_cpup(prop);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 root 节点中的<code>#size-cells</code>和 <code>#address-cells</code>属性提取出来，并非获取root节点中所有的属性，放到全局变量<code>dt_root_size_cells</code>和<code>dt_root_addr_cells</code>中。</p>
<p>接下来看第三个函数调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">early_init_dt_scan_memory</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!IS_ENABLED(CONFIG_PPC32) || depth != <span class="number">1</span> || <span class="built_in">strcmp</span>(uname, <span class="string">&quot;memory@0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    reg = of_get_flat_dt_prop(node, <span class="string">&quot;reg&quot;</span>, &amp;l);</span><br><span class="line">    endp = reg + (l / <span class="keyword">sizeof</span>(__be32));</span><br><span class="line">    <span class="keyword">while</span> ((endp - reg) &gt;= (dt_root_addr_cells + dt_root_size_cells)) &#123;</span><br><span class="line">    base = dt_mem_next_cell(dt_root_addr_cells, &amp;reg);</span><br><span class="line">    size = dt_mem_next_cell(dt_root_size_cells, &amp;reg);</span><br><span class="line">    early_init_dt_add_memory_arch(base, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数先判断节点的<code>uname</code>是<code>memory@0</code>,如果不是，则返回。然后将所有memory相关的reg属性取出来，根据<code>address-cell</code>和<code>size-cell</code>的值进行解析，然后调用<code>early_init_dt_add_memory_arch()</code>来申请相应的内存空间。</p>
<p>到这里，<code>setup_machine_fdt()</code>函数对于设备树的第一次扫描解析就完成了，主要是获取了一些设备树提供的总览信息。</p>
<h3><span id="4-1-2-arm-memblock-init">4.1.2 arm_memblock_init</span><a href="#4-1-2-arm-memblock-init" class="header-anchor">#</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __init <span class="title">arm_memblock_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> machine_desc *mdesc)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">early_init_fdt_reserve_self</span>();</span><br><span class="line">    <span class="built_in">early_init_fdt_scan_reserved_mem</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扫描设备树节点中的<code>&quot;reserved-memory&quot;</code>节点，为其分配保留空间。</p>
<h3><span id="4-1-3-unflatten-device-tree">4.1.3 unflatten_device_tree</span><a href="#4-1-3-unflatten-device-tree" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/4.png" alt="image"></p>
<p>第一步是<code>__unflatten_device_tree</code>函数：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/5.png" alt="image"></p>
<p><code>unflatten_dt_nodes</code>被调用两次，第一次是扫描得出设备树转换成device node需要的空间，然后系统申请内存空间，第二次就进行真正的解析工作。</p>
<h4><span id="4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian">4.1.3.1 unflatten_dt_nodes遍历子节点</span><a href="#4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian" class="header-anchor">#</a></h4><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/6.png" alt="image"></p>
<p>从根节点开始，对子节点依次调用<code>populate_node()</code>，从函数命名上来看，这个函数就是填充节点，为节点分配内存。</p>
<h5><span id="4-1-3-1-1-populate-node">4.1.3.1.1 populate_node</span><a href="#4-1-3-1-1-populate-node" class="header-anchor">#</a></h5><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/7.png" alt="image"></p>
<p>为当前节点申请内存空间，使用<code>of_node_init() </code>函数对node进行初始化，<code>populate_properties</code>设置node属性。<code>populate_properties</code>设置节点的属性。</p>
<h4><span id="4-1-3-2-of-alias-scan">4.1.3.2 of_alias_scan</span><a href="#4-1-3-2-of-alias-scan" class="header-anchor">#</a></h4><p><code>/* Get pointer to &quot;/chosen&quot; and &quot;/aliases&quot; nodes for use everywhere */</code>。</p>
<p>这句就能看出它是用来处理<code>aliases，chosen</code>等特殊节点的。处理带有别名的节点，函数实现细节如下：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/8.png" alt="image"></p>
<p>1.先处理<code>chosen</code>节点中的<code>&quot;stdout-path&quot;</code>或者<code>&quot;stdout&quot;</code>属性(两者最多存在其一)，然后将<code>stdout</code>指定的path赋值给全局变量<code>of_stdout_options</code>，并将返回的全局struct device_node类型数据赋值给<code>of_stdout</code>，指定系统启动时的log输出。</p>
<p>2.接下来为<code>aliases</code>节点申请内存空间，如果一个节点中同时没有 <code>name/phandle/linux,phandle</code>，则被定义为特殊节点，对于这些特殊节点将不会申请内存空间。</p>
<p>3.<code>of_alias_add</code>添加到alias链表。</p>
<h1><span id="5-device-node-zhuan-huan-cheng-platform-device">5 device_node转换成platform_device</span><a href="#5-device-node-zhuan-huan-cheng-platform-device" class="header-anchor">#</a></h1><h2><span id="5-0-zhuan-huan-guo-cheng-zong-lan">5.0 转换过程总览</span><a href="#5-0-zhuan-huan-guo-cheng-zong-lan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">of_platform_default_populate_init()</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_default_populate();</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_populate();</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_bus_create()</span><br><span class="line">                    _____________________|_________________</span><br><span class="line">                    |                                      |</span><br><span class="line">            of_platform_device_create_pdata()       of_platform_bus_create()</span><br><span class="line">            _________________|____________________</span><br><span class="line">           |                                      |</span><br><span class="line">     of_device_alloc()                        of_device_add()</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian">5.1 device_node转换到platform_device的条件</span><a href="#5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian" class="header-anchor">#</a></h2><ul>
<li>一般情况下，只对设备树中根的一级子节点进行转换，也就是子节点的子节点并不处理。但是存在一种特殊情况，就是当某个根子节点的<code>compatible</code>属性为<code>&quot;simple-bus&quot;、&quot;simple-mfd&quot;、&quot;isa&quot;、&quot;arm,amba-bus&quot;</code>时，当前节点中的子节点将会被转换成platform_device节点。</li>
<li>节点中必须有<code>compatible</code>属性。</li>
</ul>
<p>设备树节点的<code>reg</code>和 <code>interrupts </code>资源将会被转换成 platform_device 内的 <code>struct resources </code>资源。</p>
<h2><span id="5-2-zhuan-huan-guo-cheng-jie-xi">5.2 转换过程解析</span><a href="#5-2-zhuan-huan-guo-cheng-jie-xi" class="header-anchor">#</a></h2><p>展开<code>of_platform_device_create_pdata</code>:</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/9.png" alt="image"></p>
<p>调用<code>of_device_alloc</code>，可以看到为设备树节点分配了一个<code>dev(struct platform_device)</code>，展开<code>of_device_alloc</code>函数：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/10.png" alt="image"></p>
<p>可以看到把设备树节点的属性转成platform_device的<code>io，irq等资源</code>信息。同时将<code>device_node *np</code>指针记录到<code>dev-&gt;dev.of_node</code>。这样就建立了设备树节点到platform_device的转换关系。</p>
<p>然后调用<code>of_device_add</code>注册到系统device中去。</p>
<p>最后调用<code>of_platform_bus_create</code>在用户空间创建相应的访问节点。</p>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-8-内核定时器</title>
    <url>/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-ding-shi-qi">1 引入定时器</a><ul>
<li><a href="#1-0-ding-shi-qi-timer-list-jie-gou">1.0 定时器timer_list结构</a></li>
<li><a href="#1-1-timer-nei-he-han-shu">1.1 timer内核函数</a></li>
<li><a href="#1-2-ding-shi-qi-shi-jian-dan-wei">1.2 定时器时间单位</a><ul>
<li><a href="#1-2-1-jiffies-yu-miao-de-zhuan-huan">1.2.1 jiffies与秒的转换</a></li>
<li><a href="#1-2-2-nei-he-shi-jian-huo-qu">1.2.2 内核时间获取</a><ul>
<li><a href="#1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan">1.2.2.1 秒-毫秒-微秒-纳秒和jiffies兑换</a></li>
<li><a href="#1-2-2-2-usleep-range">1.2.2.2 usleep_range</a></li>
</ul>
</li>
<li><a href="#1-2-3-clock-monotonic-yu-clock-realtime">1.2.3 CLOCK_MONOTONIC与CLOCK_REALTIME</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-nei-he-ding-shi-qi-shi-li">2 内核定时器实例</a><ul>
<li><a href="#2-2-shi-li-yuan-ma-fen-xi">2.2 实例源码分析</a></li>
</ul>
</li>
<li><a href="#3-shen-ru-li-jie-ding-shi-qi-zhong-duan">3 深入理解定时器中断</a><ul>
<li><a href="#3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan">3.1 提前引入硬件中断和软件中断</a></li>
<li><a href="#3-2-ding-shi-qi-di-ceng-yuan-li">3.2 定时器底层原理</a></li>
<li><a href="#3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies">3.3 找到自己芯片的时钟滴答数-jiffies</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-ding-shi-qi">1 引入定时器</span><a href="#1-yin-ru-ding-shi-qi" class="header-anchor">#</a></h1><p>前面的<code>阻塞非阻塞IO, 休眠唤醒，poll查询，异步通知</code>小结内容都是针对按键驱动为例进行的演示。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17469849.html">字符设备驱动-8.休眠唤醒机制</a></p>
<p><a href="https://fuzidage.github.io/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/">字符设备驱动-6-pre-休眠唤醒机制 | Hexo (fuzidage.github.io)</a>引入了中断，当按键按下会记录按键信息，理想状况是按下一次按键记录一组数据，但实际上按下机械振动导致电平反复跳动最后才稳定，按下一次gpio irq会触发多次，这个被叫做<strong>“抖动”</strong>，那么可以利用定时器进行<strong>“去抖”</strong>。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/1.png" alt="image"></p>
<h2><span id="1-0-ding-shi-qi-timer-list-jie-gou">1.0 定时器timer_list结构</span><a href="#1-0-ding-shi-qi-timer-list-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/2.png" alt="image"></p>
<p>到<code>linux_5.10</code>版本<code>struct timer_list</code>变成了<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">//设定的超时的值</span></span><br><span class="line"><span class="type">void</span>(*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">//超时处理函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">//超时处理函数参数</span></span><br></pre></td></tr></table></figure>
<h2><span id="1-1-timer-nei-he-han-shu">1.1 timer内核函数</span><a href="#1-1-timer-nei-he-han-shu" class="header-anchor">#</a></h2><p>在内核中使用定时器很简单，涉及这些函数(参考内核源码<code>include\linux\timer.h</code>)</p>
<ol>
<li><code>setup_timer(timer, fn, data)</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/4.png" alt="image"></li>
</ol>
<p>到<code>linux_5.10</code>版本变成了<code>timer_setup</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/5.png" alt="image"></p>
<p>设置定时器，主要是初始化<code> timer_list</code> 结构体，设置其中的函数、参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//还有一种用宏DEFINE_TIMER去定义和初始化一个timer_list</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function, _expires, _data)     \</span></span><br><span class="line"><span class="meta">    struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">        TIMER_INITIALIZER(_function, _expires, _data)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_INITIALIZER(_function, _expires, _data, _flags) &#123; \</span></span><br><span class="line"><span class="meta">		.entry = &#123; .next = TIMER_ENTRY_STATIC &#125;,	\</span></span><br><span class="line"><span class="meta">		.function = (_function),			\</span></span><br><span class="line"><span class="meta">		.expires = (_expires),				\</span></span><br><span class="line"><span class="meta">		.data = (_data),				\</span></span><br><span class="line"><span class="meta">		.flags = (_flags),				\</span></span><br><span class="line"><span class="meta">		__TIMER_LOCKDEP_MAP_INITIALIZER(		\</span></span><br><span class="line"><span class="meta">			__FILE__ <span class="string">&quot;:&quot;</span> __stringify(__LINE__))	\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p><code> void add_timer(struct timer_list *timer)</code><br> <img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/6.png" alt="image"><br> 向内核添加定时器。<code>timer-&gt;expires</code>表示超时时间。<br> 当超时时间到达 ， 就会调用这个函数 ：<code>timer-&gt;function(timer-&gt;data)</code>。</p>
</li>
<li><p><code>int mod_timer(struct timer_list *timer, unsigned long expires)</code><br> <img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/7.png" alt="image"></p>
<p> 修改定时器的超时时间:<br> 它等同于： </p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">del_timer(timer);</span><br><span class="line">timer-&gt;expires = expires;</span><br><span class="line">add_timer(timer);</span><br></pre></td></tr></table></figure>
<p> 但是更加高效。</p>
</li>
<li><p><code>int del_timer(struct timer_list *timer)</code><br>删除定时器。</p>
</li>
</ol>
<h2><span id="1-2-ding-shi-qi-shi-jian-dan-wei">1.2 定时器时间单位</span><a href="#1-2-ding-shi-qi-shi-jian-dan-wei" class="header-anchor">#</a></h2><p>可以在内核源码根目录下用<code>“ ls -a”</code>看到一个隐藏文件<code>.config</code>, 可以看到如下这项：会被内核转换成<code>include/generated/autoconf.h</code>，<code>HZ</code>定义头文件<code>uapi/asm-generic/param.h</code>和<code>include/asm-generic/param.h</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/8.png" alt="image"></p>
<p><code>CONFIG_HZ=100</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/9.png" alt="image"><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/10.png" alt="image"></p>
<p>这表示内核<strong>每秒中会发生 100 次系统滴答中断(tick)<strong>，这就像人类的心跳一样，这是 Linux 系统的心跳。</strong>每发生一次 tick 中断，全局变量 jiffies 就会累加 1</strong>。<br><code>CONFIG_HZ=100</code> 表示每个滴答是 10ms。<br>定时器的时间就是基于<code>jiffies</code>的，我们修改超时时间时，一般使用这 2 种方法：</p>
<ol>
<li><code>add_timer</code> 之前，直接修改：<br><code>imer.expires = jiffies + xxx; // xxx 表示多少个滴答后超时，也就是 xxx*10ms</code><br><code>imer.expires = jiffies + 2*HZ; // HZ 等于 CONFIG_HZ， 2*HZ HZ是100个10ms, 就相当于 2 秒</code></li>
<li><code>add_timer</code> 之后，使用 <code>mod_timer</code> 修改：<br> <code>mod_timer(&amp;timer, jiffies + xxx); // xxx 表示多少个滴答后超时，也就是 xxx*10ms</code><br> <code>mod_timer(&amp;timer, jiffies + 2*HZ); // HZ 等于 CONFIG_HZ， 2*HZ 就相当于 2 秒</code></li>
</ol>
<h3><span id="1-2-1-jiffies-yu-miao-de-zhuan-huan">1.2.1 jiffies与秒的转换</span><a href="#1-2-1-jiffies-yu-miao-de-zhuan-huan" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">将 jiffies转换为秒，可采用公式：(jiffies/HZ) 计算。</span><br><span class="line">将秒转换为jiffies，可采用公式：(seconds*HZ) 计算。</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-2-nei-he-shi-jian-huo-qu">1.2.2 内核时间获取</span><a href="#1-2-2-nei-he-shi-jian-huo-qu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ktime_t</span> curTime = <span class="number">0</span>;</span><br><span class="line">curTime = ktime_get();<span class="comment">//不包含了设备进入休眠的时间</span></span><br><span class="line">printk(<span class="string">&quot;ktime_get:%lld ns&quot;</span>, curTime);</span><br><span class="line"><span class="comment">//结果：ktime_get:492257307974640 ns</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ktime_t</span> curTime = <span class="number">0</span>;</span><br><span class="line">curTime = ktime_get_boottime();<span class="comment">//包含了设备进入休眠的时间</span></span><br><span class="line">printk(<span class="string">&quot;ktime_get_boottime:%lld ns&quot;</span>, curTime);</span><br><span class="line"><span class="comment">//结果： ktime_get_boottime:581660801601637 ns</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ktime_get_ts64</span><span class="params">(<span class="keyword">struct</span> timespec64 *ts)</span>; <span class="comment">//这也是一种</span></span><br><span class="line"></span><br><span class="line"><span class="type">ktime_t</span> start, end, elapsed;</span><br><span class="line">start = ktime_get_boottime();</span><br><span class="line">...</span><br><span class="line">end = ktime_get_boottime();</span><br><span class="line">elapsed = ktime_sub(end, start);</span><br><span class="line">elapsed_msecs = ktime_to_ms(elapsed);</span><br><span class="line">printk(<span class="string">&quot;%d.%03d seconds&quot;</span>, elapsed_msecs / <span class="number">1000</span>,elapsed_msecs % <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan">1.2.2.1 秒-毫秒-微秒-纳秒和jiffies兑换</span><a href="#1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jiffies_to_msecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">jiffies_to_usecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line">u64 <span class="title function_">jiffies_to_nsecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">msecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> m)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">usecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> u)</span>;<span class="comment">//jiffies.h</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">nsecs_to_jiffies</span><span class="params">(u64 n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_us</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;<span class="comment">//ktime.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_ms</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_ns</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-2-usleep-range">1.2.2.2 usleep_range</span><a href="#1-2-2-2-usleep-range" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __sched <span class="title function_">usleep_range</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> min, <span class="type">unsigned</span> <span class="type">long</span> max)</span>；</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-clock-monotonic-yu-clock-realtime">1.2.3 CLOCK_MONOTONIC与CLOCK_REALTIME</span><a href="#1-2-3-clock-monotonic-yu-clock-realtime" class="header-anchor">#</a></h3><p><strong>CLOCK_MONOTONIC</strong>(即<code>monotonic time</code>)<br><code>CLOCK_MONOTONIC</code>：以绝对时间为准，获取的时间为系统重启到现在的时间，更改系统时间对它没有影响。<br>字面意义：单调时间，表示系统启动后流逝的时间，由变量jiffies来记录的。<br>系统每次启动时，<code>jiffies</code>初始化为0。每来一个<code>timer interrupt</code>，<code>jiffies</code>加1，即它代表系统启动后流逝的<code>tick</code>数。<br><code>jiffies</code>一定是单调递增的，因为时间不可逆。</p>
<p><strong>CLOCK_REALTIME</strong>(即<code>wall time</code>)<br><code>CLOCK_REALTIME</code>：相对时间，从<code>1970.1.1</code>到目前的时间。更改系统时间会更改获取的值。它以系统时间为坐标。<br>字面意思: <code>wall time</code>挂钟时间，表示现实的时间，由变量<code>xtime</code>来记录的。<br><strong>一些题外话</strong>：<br>一些应用软件可能就是用到了这个<code>wall time</code>。比如以前用<code>vmware workstation</code>，一启动提示试用期已过，但是只要把系统时间调整一下提前一年，再启动就不会有提示了。这很可能就是因为它启动时，用<code>gettimeofday</code>去读<code>wall time</code>，然后判断是否过期，只要将<code>wall time</code>改一下，就可以欺骗过去了。</p>
<h1><span id="2-nei-he-ding-shi-qi-shi-li">2 内核定时器实例</span><a href="#2-nei-he-ding-shi-qi-shi-li" class="header-anchor">#</a></h1><p>就前面讲到的gpio按键中断来举例，每次发生gpio 中断，irq中我们都去调用一次<code>mod_timer</code>函数判断是不是抖动带来的垃圾数据。如果是抖动，那么irq会一直触发，一直调用<code>mod_timer</code>，一直推迟定时器中断函数的触发。<br>当按下按键键值稳定下来后机械振动没了，电平数据趋于稳定了，那么gpio irq就不会一直响应了，也就是<code>mod_timer</code>函数不会一直调用了，那么等到timer超时，上报数据，整个流程如下图所示：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/11.png" alt="image"></p>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/12.png" alt="image"><br>按键为下降沿触发，因此会在<code>t1、t2 和 t3</code> 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，但是 <code>t1~t2 </code>和<code>t2~t3</code>这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理。</p>
<details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf</span></span><br><span class="line"><span class="params">	, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_isr key %d irq happened\n&quot;</span>, gpio_key-&gt;gpio);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span></span><br><span class="line">               , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span></span><br><span class="line">                   , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line"></span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer</span><br><span class="line">                    , key_timer_expire</span><br><span class="line">                    , &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">			, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">			, <span class="string">&quot;100ask_gpio_key&quot;</span></span><br><span class="line">			, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span></span><br><span class="line">			, &amp;gpio_key_drv);  <span class="comment">/* /dev/gpio_key */</span></span><br><span class="line"></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class</span><br><span class="line">				, <span class="literal">NULL</span></span><br><span class="line">				, MKDEV(major, <span class="number">0</span>)</span><br><span class="line">				, <span class="literal">NULL</span></span><br><span class="line">				, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-2-shi-li-yuan-ma-fen-xi">2.2 实例源码分析</span><a href="#2-2-shi-li-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/13.png" alt="image"></p>
<p><code>linux_5.10</code>内核版本用法<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/14.png" alt="image"></p>
<p>probe函数进行初始化定时器，这里<code>add_timer</code>前修改<code>expires</code>，为了防止定时器中断提前触发（按键还没按下就触发了定时器中断），因此修改<code>expires</code>为一个最大值。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/15.png" alt="image"><br>当按下按键gpio_irq按键中断服务程序响应后，调用<code>mod_timer</code>进行修改定时器超时时间，用来去除 “抖动”。<code>jiffies + HZ/5</code>表示延时20个tick时钟滴答，也就是<code>20*10ms</code>，如果这个时间内有多次电平跳动，那么不会去上报数据，而是继续修改定时器超时时间，直到按键数据稳定后，也就是200ms已经到了但是没有人去修改定时器超时时间，那么将会触发定时器中断，上报按键数据。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/16.png" alt="image"><br><code>linux_5.10</code>内核版本用法:<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/17.png" alt="image"></p>
<h1><span id="3-shen-ru-li-jie-ding-shi-qi-zhong-duan">3 深入理解定时器中断</span><a href="#3-shen-ru-li-jie-ding-shi-qi-zhong-duan" class="header-anchor">#</a></h1><h2><span id="3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan">3.1 提前引入硬件中断和软件中断</span><a href="#3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan" class="header-anchor">#</a></h2><p>《后面中断子系统会专门介绍》<a href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入</a></p>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/18.png" alt="image"></p>
<ol>
<li>硬件中断包含gpio，网卡，外围电路IP等等，<code>tick</code>（产生一次tick系统滴答中断，<code>jiffies加1</code>）</li>
<li>软件中断包含<code>TIMER</code> 表示定时中断、RCU 表示 RCU 锁中断、<code>SCHED </code>表示内核调度中断</li>
</ol>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/19.png" alt="image"></p>
<p><strong>区别：</strong><br>上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；<br>下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行</p>
<p><code>cat /proc/softirqs</code>可以看软件中断信息</p>
<p><code>cat /proc/interrupts</code>可以看硬件中断</p>
<h2><span id="3-2-ding-shi-qi-di-ceng-yuan-li">3.2 定时器底层原理</span><a href="#3-2-ding-shi-qi-di-ceng-yuan-li" class="header-anchor">#</a></h2><p>定时器就是通过<code>软件中断</code>来实现的，它属于 <code>TIMER_SOFTIRQ </code>软中断<br>对于<code> TIMER_SOFTIRQ</code> 软中断，内核启动时会调用<code>start_kernel</code>初始化<code>init_timers();</code> 代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">init_timers</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	init_timer_cpus();</span><br><span class="line">	init_timer_stats();</span><br><span class="line">	open_softirq(TIMER_SOFTIRQ, run_timer_softirq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生硬件中断时，硬件中断处理完后，内核会调用软件中断的处理函数。<br>对于<code> TIMER_SOFTIRQ</code>，会调用<code> run_timer_softirq</code>，它的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">run_timer_softirq</span><br><span class="line">	__run_timers(base);</span><br><span class="line">    <span class="keyword">while</span> (time_after_eq(jiffies, base-&gt;clk)) &#123;</span><br><span class="line">    ……</span><br><span class="line">    expire_timers(base, heads + levels);</span><br><span class="line">        fn = timer-&gt;function;</span><br><span class="line">        data = timer-&gt;data;</span><br><span class="line">        call_timer_fn(timer, fn, data);</span><br><span class="line">			fn(data);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/20.png" alt="image-20240804152644572"></p>
<p>简单地说， <code>add_timer</code> 函数会把 timer 放入内核里某个链表；在 <code>TIMER_SOFTIRQ</code> 的处理函数<code>run_timer_softirq</code>中，会从链表中把这些超时的 timer 取出来，<br>执行其中的函数。怎么判断是否超时？ <code>jiffies</code> 大于或等于 <code>timer-&gt;expires </code>时， timer 就超时，执行超时处理函数。</p>
<h2><span id="3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies">3.3 找到自己芯片的时钟滴答数-jiffies</span><a href="#3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies" class="header-anchor">#</a></h2><p>在开发板执行以下命令，可以看到 CPU0 下有一个数值变化特别快，它就是<code>滴答中断tick</code>，<code>jiffies</code>也叫做系统节拍数。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/21.png" alt="image"></p>
<p>以 <code>100ASK_IMX6ULL </code>为做，滴答中断名字就是<code>“ i.MX Timer Tick”</code>。在 Linux内核源码目录下执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;i.MX Timer Tick&quot;</span> * -nr</span><br><span class="line">drivers/clocksource/timer-imx-gpt.c:<span class="number">319</span>: act-&gt;name = <span class="string">&quot;i.MX Timer Tick&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>⚫ 打开 <code>timer-imx-gpt.c</code> <code>319 行</code>左右，可得如下源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">act-&gt;name = <span class="string">&quot;i.MX Timer Tick&quot;</span>;</span><br><span class="line">act-&gt;flags = IRQF_TIMER | IRQF_IRQPOLL;</span><br><span class="line">act-&gt;handler = mxc_timer_interrupt;</span><br><span class="line">act-&gt;dev_id = ced;</span><br><span class="line"><span class="keyword">return</span> setup_irq(imxtm-&gt;irq, act);</span><br></pre></td></tr></table></figure>
<p>⚫ <code>mxc_timer_interrupt</code> 应该就是滴答中断的处理函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">mxc_timer_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span> *<span class="title">ced</span> =</span> dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_timer</span> *<span class="title">imxtm</span> =</span> to_imx_timer(ced);</span><br><span class="line">	<span class="type">uint32_t</span> tstat;</span><br><span class="line">	tstat = readl_relaxed(imxtm-&gt;base + imxtm-&gt;gpt-&gt;reg_tstat);<span class="number">472</span> / <span class="number">573</span></span><br><span class="line">	imxtm-&gt;gpt-&gt;gpt_irq_acknowledge(imxtm);</span><br><span class="line">	ced-&gt;event_handler(ced);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看<code>ced-&gt;event_handler(ced);</code>调用：</p>
<p><code>ced-&gt;event_handler(ced)</code>是哪一个函数？不太好找，使用 <code>QEMU</code> 来调试内核，在 <code>mxc_timer_interrupt</code> 中打断点跟踪代码发现它对应 <code>tick_handle_periodic</code>。<br><code>tick_handle_periodic</code> 位于 <code>kernel\time\tick-common.c </code>中，它里面的调用关系如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tick_handle_periodic</span><br><span class="line">	<span class="title function_">tick_periodic</span><span class="params">(cpu)</span>;</span><br><span class="line">		do_timer(<span class="number">1</span>);</span><br><span class="line">		jiffies_64 += ticks; <span class="comment">// jiffies 就是 jiffies_64</span></span><br></pre></td></tr></table></figure>
<p>为何说<code>jiffies</code>就是<code> jiffies_64</code>？在 <code>arch\arm\kernel\vmlinux.lds.S</code> 有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ARMEB__</span></span><br><span class="line">jiffies = jiffies_64;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">jiffies = jiffies_64 + <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上述代码说明了，对于大字节序的 CPU， <code>jiffies</code> 指向<code> jiffies_64</code> 的高 4字节；对于小字节序的 CPU，<code> jiffies</code> 指向 <code>jiffies_64 </code>的低 4 字节。对<code> jiffies_64</code> 的累加操作，就是对 <code>jiffies </code>的累加操作。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/22.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 __cacheline_aligned_in_smp jiffies_64; <span class="comment">//include/linux/jiffies.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __cacheline_aligned_in_smp __jiffy_arch_data jiffies;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-7-异步通知</title>
    <url>/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yi-bu-tong-zhi-gai-shu">1.异步通知概述</a><ul>
<li><a href="#1-1-sigaction-han-shu">1.1 sigaction函数</a></li>
<li><a href="#1-2-signal-han-shu">1.2 signal函数</a><ul>
<li><a href="#1-2-1-shi-li-1">1.2.1 示例1</a></li>
<li><a href="#1-2-2-shi-li-2">1.2.2 示例2</a></li>
<li><a href="#1-1-3-shi-li-3">1.1.3 示例3</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-yi-bu-tong-zhi-de-shi-xian-yuan-li-liu-cheng">2 异步通知的实现原理流程</a><ul>
<li><a href="#2-1-yi-bu-tong-zhi-de-xin-hao-liu-cheng">2.1. 异步通知的信号流程</a></li>
</ul>
</li>
<li><a href="#3-qu-dong-dai-ma-bian-xie">3.驱动代码编写</a><ul>
<li><a href="#3-1-kai-qi-async">3.1 开启async</a></li>
<li><a href="#3-2-fa-sigio-xin-hao">3.2 发SIGIO信号</a></li>
</ul>
</li>
<li><a href="#4-ying-yong-bian-xie">4.应用编写</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yi-bu-tong-zhi-gai-shu">1.异步通知概述</span><a href="#1-yi-bu-tong-zhi-gai-shu" class="header-anchor">#</a></h1><p>前面讲到<a href="https://www.cnblogs.com/fuzidage/p/17080773.html">APP 读取按键方式</a>里面包含4种方式：1.查询方式，2.休眠唤醒，3，poll机制的休眠唤醒，4.异步通知<br><a href="https://fuzidage.github.io/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/#1-app-du-qu-an-jian-fang-shi">字符设备驱动-3-GPIO驱动KEY示例 | Hexo (fuzidage.github.io)</a><br>什么是异步通知？<br>你去买奶茶：<br>◼ 你在旁边等着，眼睛盯着店员，生怕别人插队，他一做好你就知道：你是主动等待他做好，这叫 “同步”。<br>◼ 你付钱后就去玩手机了，店员做好后他会打电话告诉你：你是被动获得结果，这叫“异步”。<br>同理，还是以<code>gpio_key</code>的例子，app想要判断按键是否有按下，无需去查询或者休眠，只需要注册<code>SIGIO信号</code>给driver, 当按键按下，driver中会自己主动通知app，给app发送<code>SIGIO信号</code>，app上层收到<code>信号SIGIO</code>会执行事先注册的<code>信号处理函数</code>。</p>
<p>异步通知使用信号来实现。在 Linux 内核源文件 <code>include\uapi\asmgeneric\signal.h</code> 中:<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/1.png" alt="image"></p>
<h2><span id="1-1-sigaction-han-shu">1.1 sigaction函数</span><a href="#1-1-sigaction-han-shu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第一个参数为信号的值， 可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号。</span><br><span class="line">第二个参数是指向结构体sigaction的一个实例的指针， 在结构体sigaction的实例中， </span><br><span class="line">    指定了对特定信号的处理函数， 若为空， 则进程会以缺省方式对信号处理；</span><br><span class="line">第三个参数oldact指向的对象用来保存原来对相应信号的处理函数， 可指定oldact为<span class="literal">NULL</span>。</span><br><span class="line">    如果把第二、 第三个参数都设为<span class="literal">NULL</span>， 那么该函数可用于检查信号的有效性。</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum,<span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">	<span class="type">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="type">int</span> sa_flags;</span><br><span class="line">	<span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sa_flags：用来设置信号处理的其他相关操作，下列的数值可用：</span></span><br><span class="line"><span class="comment">        1.SA RESETHAND：当调用信号处理函数时，将信号的处理函数重置为缺省值；</span></span><br><span class="line"><span class="comment">        2.SIG DFLSA RESTART：如果信号中断了进程的某个系统调用，</span></span><br><span class="line"><span class="comment">        	则系统自动启动该系统调用；</span></span><br><span class="line"><span class="comment">        3.SA NODEFER：当信号处理函数运行时，内核将阻塞该给定信号。</span></span><br><span class="line"><span class="comment">        	但是如果设置了 SA NODEFER标记， 那么在该信号处理函数运行*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _SAMPLE_PLAT_SYS_HandleSig(<span class="type">int</span> nSignal, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *arg) &#123;</span><br><span class="line">        _SAMPLE_PLAT_ERR_Exit();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">sa.sa_sigaction = _SAMPLE_PLAT_SYS_HandleSig;</span><br><span class="line">sa.sa_flags = SA_SIGINFO|SA_RESETHAND;  <span class="comment">// Reset signal handler to</span></span><br><span class="line"><span class="comment">//system default after signal triggered</span></span><br><span class="line">sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">sigaction(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h2><span id="1-2-signal-han-shu">1.2 signal函数</span><a href="#1-2-signal-han-shu" class="header-anchor">#</a></h2><h3><span id="1-2-1-shi-li-1">1.2.1 示例1</span><a href="#1-2-1-shi-li-1" class="header-anchor">#</a></h3><p>按下<code>“Ctrl+C”</code>将向其发出<code>SIGINT</code>信号， 正在运行kill的进程将向其发出<code>SIGTERM</code>信号， 以下代码的进程可捕获这两个信号并输出信号值：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigterm_handler</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Have caught sig N.O. %d\n&quot;</span>,signo);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        signal(SIGINT,sigterm_handler);</span><br><span class="line">        signal(SIGTERM,sigterm_handler);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>可以看到对应<code>SIGINT</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/2.png" alt="image"><br>输入<code>kill [pid]</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/3.png" alt="image"><br>可以看到对应<code>SIGTERM</code>信号<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/4.png" alt="image"></p>
<h3><span id="1-2-2-shi-li-2">1.2.2 示例2</span><a href="#1-2-2-shi-li-2" class="header-anchor">#</a></h3><p>通过<code>signal(SIGIO, input_handler);</code> 对标准输入文件描述符<code>STDIN_FILENO</code>启动信号机制.用户输入后， 应用程序将接收到<code>SIGIO</code>信号， 其处理函数<code>input_handler()</code>将被调用.</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_handler</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data[MAX_LEN];</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="comment">/* 读取并输出STDIN_FILENO上的输入 */</span></span><br><span class="line">	len = read(STDIN_FILENO, &amp;data, MAX_LEN);</span><br><span class="line">	data[len] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;input available:%s\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> oflags;</span><br><span class="line">	<span class="comment">/* 启动信号驱动机制 */</span></span><br><span class="line">	<span class="comment">/*为SIGIO信号安装input_handler()作为处理函数*/</span></span><br><span class="line">	signal(SIGIO, input_handler);</span><br><span class="line">	<span class="comment">/*设置本进程为STDIN_FILENO文件的拥有者，</span></span><br><span class="line"><span class="comment">	没有这一步，内核不会知道应该将信号发给哪个进程*/</span></span><br><span class="line">	fcntl(STDIN_FILENO, F_SETOWN, getpid());</span><br><span class="line">	<span class="comment">/*而为了启用异步通知机制， 还需对设备设置FASYNC标志，下面两行行代码可实现此目的。 */</span></span><br><span class="line">	oflags = fcntl(STDIN_FILENO, F_GETFL);</span><br><span class="line">	fcntl(STDIN_FILENO, F_SETFL, oflags | FASYNC);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/5.png" alt="image"></p>
<h3><span id="1-1-3-shi-li-3">1.1.3 示例3</span><a href="#1-1-3-shi-li-3" class="header-anchor">#</a></h3><p>手动对app进程发送<code>SIGIO</code>信号</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_sig_func</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get a signal : %d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    signal(SIGIO, my_sig_func);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello, world %d!\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>发送<code>SIGIO</code>信号给进程，也就是<code>kill -29 [pid]</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/6.png" alt="image"><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/7.png" alt="image"></p>
<h1><span id="2-yi-bu-tong-zhi-de-shi-xian-yuan-li-liu-cheng">2 异步通知的实现原理流程</span><a href="#2-yi-bu-tong-zhi-de-shi-xian-yuan-li-liu-cheng" class="header-anchor">#</a></h1><p>驱动程序怎么通知 APP：发信号，这只有 3 个字，却可以引发很多问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 谁发：驱动程序发</span><br><span class="line"><span class="number">2.</span> 发什么：信号</span><br><span class="line"><span class="number">3.</span> 发什么信号：SIGIO</span><br><span class="line"><span class="number">4.</span> 怎么发：内核里提供有函数</span><br><span class="line"><span class="number">5.</span> 发给谁：APP，APP 要把自己告诉驱动</span><br><span class="line"><span class="number">6.</span> APP 收到后做什么：执行信号处理函数</span><br><span class="line"><span class="number">7.</span> 信号处理函数和信号，之间怎么挂钩：APP 注册信号处理函数</span><br></pre></td></tr></table></figure>
<p>Linux系统中也有很多信号，内核源文件<code>include\uapi\asmgeneric\signal.h</code>中，有很多信号的宏定义：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/8.png" alt="image"><br>就APP而言，你想处理 <code>SIGIO </code>信息，那么需要提供信号处理函数，并且要跟<code>SIGIO </code>挂钩。这可以通过一个 signal 函数来 “给某个信号注册处理函数”，用法如下：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/9.png" alt="image"><br>APP 还要做什么事？想想这几个问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a) 内核里有那么多驱动，你想让哪一个驱动给你发 SIGIO 信号？APP 要打开驱动程序的设备节点。</span><br><span class="line">b) 驱动程序怎么知道要发信号给你而不是别人？APP 要把自己的进程 ID 告诉驱动程序。</span><br><span class="line">c) APP 有时候想收到信号，有时候又不想收到信号应该可以把 APP 的意愿告诉驱动。</span><br></pre></td></tr></table></figure>
<p>驱动程序要做什么？发信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a) APP 设置进程 ID 时，驱动程序要记录下进程 ID；</span><br><span class="line">b) APP 还要使能驱动程序的异步通知功能，驱动中有对应的函数：APP 打开驱动程序时，</span><br><span class="line">    内核会创建对应的 file 结构体，file 中有 f_flags；</span><br><span class="line">c) FASYNC 位:</span><br><span class="line">flags 中有一个 FASYNC 位，它被设置为 <span class="number">1</span> 时表示使能异步通知功能。</span><br><span class="line">    当 f_flags 中的 FASYNC 位发生变化时，驱动程序的 fasync 函数被调用;</span><br><span class="line">d) 发生中断时，有数据时，驱动程序调用内核辅助函数发信号。这个辅助函数名为 kill_fasync.</span><br></pre></td></tr></table></figure>


<h2><span id="2-1-yi-bu-tong-zhi-de-xin-hao-liu-cheng">2.1. 异步通知的信号流程</span><a href="#2-1-yi-bu-tong-zhi-de-xin-hao-liu-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/10.png" alt="image"><br>① APP open，在drv中调用<code>drv_open</code>，进行注册按键中断服务函数<code>gpio_key_irq</code>;<br>② APP 给<code>SIGIO</code>信号注册<code>信号处理函数func</code>, 以后 APP 收到 <code>SIGIO</code>信号时，这个函数会被自动调用;<br>③ APP 调用<code>fcntl</code>, 把PID(进程 ID)告诉驱动程序，这个调用不涉及驱动程序，只是在内核的文件系统层次<code>sys_cntl</code>,记录 PID在<code>filp</code>中（<code>sys_call</code>会建立<code>filp</code>结构)；<br>④ APP 调用<code>fcntl</code>, 读取驱动程序文件 Flag；<br>⑤ 设置 Flag 里面的<code>FASYNC</code>位为 1：当 <code>FASYNC</code> 位发生变化时，会导致驱动程序的<code>fasync</code>被调用；<br>⑥⑦ 调 用<code> faync_helper</code> ， 它 会 根 据<code>FAYSNC</code>的值决定是否设置<code>button_async-&gt;fa_file = 驱动文件filp</code>：<br>驱动文件<code>filp</code>结构体里面含有之前设置的 PID。<br>⑧ APP 可以做其他事；<br>⑨⑩ 按下按键，发生中断，驱动程序的中断服务程序被调用，里面调用<code>kill_fasync</code> 发信号；<br>⑪⑫⑬ APP 收到信号后，它的信号处理函数被自动调用，可以在里面调用read 函数读取按键。</p>
<h1><span id="3-qu-dong-dai-ma-bian-xie">3.驱动代码编写</span><a href="#3-qu-dong-dai-ma-bian-xie" class="header-anchor">#</a></h1><p>先修改<code>Linux-4.9.88/arch/arm/boot/dts/100ask_imx6ull-14x14.dts</code>建立dts节点，<code>“100ask，gpio_key”</code>和<code>platform drvier</code>中保持一致。这里将<code>goio-keys</code> <code>disabled</code>掉是为了drv去匹配新添加的这个节点。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/11.png" alt="image"></p>
<p>使用异步通知时，驱动程序的核心有2个：<br>① 提供对应的<code>drv_fasync</code>函数；<br>② 并在合适的时机发信号。</p>
<h2><span id="3-1-kai-qi-async">3.1 开启async</span><a href="#3-1-kai-qi-async" class="header-anchor">#</a></h2><p><code>drv_fasync</code> 函数很简单，调用 <strong><code>fasync_helper</code></strong> 函数就可以，如下：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/12.png" alt="image"><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/13.png" alt="image"><br><code>fasync_helper</code> 函 数 会 分 配 、 构 造 一 个 <code>fasync_struct</code> 结构体<code>button_async</code>：<br>⚫ 驱动文件的 flag 被设置为 <code>FAYNC 时</code>：<br><code>button_async-&gt;fa_file = filp; // filp 表示驱动程序文件，里面含有之前设置的 PID</code><br>⚫ 驱动文件被设置为非<code>FASYNC</code> 时：<br><code>button_async-&gt;fa_file = NULL;</code><br>以后想发送信号时，使用 <code>button_async</code> 作为参数就可以，它里面 “可能” 含有 PID。</p>
<h2><span id="3-2-fa-sigio-xin-hao">3.2 发SIGIO信号</span><a href="#3-2-fa-sigio-xin-hao" class="header-anchor">#</a></h2><p>什么时候发信号呢？在本例中，在 GPIO 中断服务程序中发信号。<br>怎么发信号呢？代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kill_fasync(&amp;button_async, SIGIO, POLL_IN);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/14.png" alt="image"><br>第 1 个参数：<code>button_async-&gt;fa_file</code> 非空时，可以从中得到 PID，表示发给哪一个 APP；<br>第 2 个参数表示发什么信号：<code>SIGIO</code>；<br>第 3 个参数表示为什么发信号：<code>POLL_IN</code>，有数据可以读了。(APP 用不到这个参数)</p>
<details>
<summary>点击查看完整驱动代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, </span></span><br><span class="line"><span class="params">                                  <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span></span><br><span class="line">               , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span></span><br><span class="line">                   , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">                          , IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">                          ,<span class="string">&quot;100ask_gpio_key&quot;</span></span><br><span class="line">                          ,&amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);</span><br><span class="line"></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span></span><br><span class="line">                  , MKDEV(major, <span class="number">0</span>)</span><br><span class="line">                  , <span class="literal">NULL</span></span><br><span class="line">                  , <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="4-ying-yong-bian-xie">4.应用编写</span><a href="#4-ying-yong-bian-xie" class="header-anchor">#</a></h1><p>应用程序要做的事情有这几件：</p>
<ol>
<li><p>编写信号处理函数：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_func</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册信号处理函数：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGIO, sig_func);</span><br></pre></td></tr></table></figure></li>
<li><p>打开驱动：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(argv[<span class="number">1</span>], O_RDWR);<span class="comment">//./aout /dev/100ask_gpio_key</span></span><br></pre></td></tr></table></figure></li>
<li><p>把进程 ID 告诉驱动：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fcntl(fd, F_SETOWN, getpid());</span><br></pre></td></tr></table></figure>
<p> 使能驱动的 FASYNC 功能：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC);</span><br></pre></td></tr></table></figure></li>
</ol>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_func</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span>	flags;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	signal(SIGIO, sig_func);</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fcntl(fd, F_SETOWN, getpid());</span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags | FASYNC);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;www.100ask.net \n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-9-中断子系统-中断下半部-tasklet</title>
    <url>/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-tasklet-yin-ru">1 tasklet引入</a></li>
<li><a href="#2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen">2 tasklet是如何从从上半部调度到下半部分</a></li>
<li><a href="#3-tasklet-shi-yong">3 tasklet使用</a><ul>
<li><a href="#3-1-chu-shi-hua-tasklet">3.1 初始化tasklet</a><ul>
<li><a href="#3-1-0-tasklet-jie-gou-ti">3.1.0 tasklet结构体</a></li>
<li><a href="#3-1-1-tasklet-lian-biao">3.1.1 tasklet链表</a></li>
<li><a href="#3-1-2-tasklet-init">3.1.2 tasklet_init</a></li>
<li><a href="#3-1-3-declare-tasklet">3.1.3 DECLARE_TASKLET</a></li>
</ul>
</li>
<li><a href="#3-2-shi-neng-jin-zhi-tasklet">3.2 使能&#x2F;禁止 tasklet</a></li>
<li><a href="#3-3-diao-du-tasklet">3.3 调度tasklet</a></li>
<li><a href="#3-4-zhi-xing-tasklet">3.4 执行tasklet</a></li>
<li><a href="#3-5-tasklet-kill">3.5 tasklet_kill</a></li>
</ul>
</li>
<li><a href="#4-tasklet-dai-ma-shi-li-jie-xi">4 tasklet代码示例解析</a><ul>
<li><a href="#4-1-tasklet-shi-yong-qu-dong-yuan-ma">4.1 tasklet使用驱动源码</a></li>
<li><a href="#4-2-fen-xi">4.2 分析</a></li>
</ul>
</li>
<li><a href="#5-tasklet-nei-bu-ji-zhi-pou-xi">5 tasklet内部机制剖析</a><ul>
<li><a href="#5-1-tasklet-action-de-zhi-xing-guo-cheng">5.1 tasklet_action的执行过程</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-tasklet-yin-ru">1 tasklet引入</span><a href="#1-tasklet-yin-ru" class="header-anchor">#</a></h1><p><a href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入 | Hexo (fuzidage.github.io)</a></p>
<p>介绍了硬件中断和软件中断，硬件中断有gpio中断，网卡，外部电路IP引起的中断，而软件中断则有定时器，tasklet这些为软件中断。cpu会先处理硬件中断，然后处理软件中断。</p>
<p>简单说可以认为内核中有一个数组softirq[], 里面有很多项，某一项对应timer，某一项表示tasklet, 每一项中都有一个<code>.action</code>函数，当内核处理完某一个硬件中断之后，处理软件中断时会找到对应的项，找到<code>.action</code>函数执行。</p>
<p>对于<code>tasklet</code>软件中断，它的<code>.action</code>函数对应<code>tasklet_action</code>,这个函数会从链表里取出每一个<code>tasklet</code>结构，执行里面的<code>.func</code>函数。</p>
<p>内核处理硬件中断的过程叫做中断上半部，处理软件中断的过程叫做中断下半部。上半部执行过程中，中断是禁止的，这里防止中断嵌套，也就是说来了更紧急的硬件中断，也要等这个上半部分处理完，上半部一般处理重要紧急事情。下半部执行过程中，中断是使能的，因此在下半部的处理过程它是可以响应其他中断。因此如果有不紧急但是耗时的事情放在下半部来处理，比如用tasklet。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/1.png" alt="image"></p>
<h1><span id="2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen">2 tasklet是如何从从上半部调度到下半部分</span><a href="#2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen" class="header-anchor">#</a></h1><p>如何使能或者说调度tasklet呢？它其实就是把一个tasklet放入到内核tasklet链表中，假如硬件中断服务函数func_A(), 软件中断中也就是下半部放入tasklet中断的服务函数为func_B(), 那么可以想象看A和B被调度的次数因该是多对1的关系，应为软件中断由于是使能中断的，因此func_A()对应的硬件又可能会产生硬件中断。</p>
<h1><span id="3-tasklet-shi-yong">3 tasklet使用</span><a href="#3-tasklet-shi-yong" class="header-anchor">#</a></h1><h2><span id="3-1-chu-shi-hua-tasklet">3.1 初始化tasklet</span><a href="#3-1-chu-shi-hua-tasklet" class="header-anchor">#</a></h2><h3><span id="3-1-0-tasklet-jie-gou-ti">3.1.0 tasklet结构体</span><a href="#3-1-0-tasklet-jie-gou-ti" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span><span class="comment">//tasklet链表</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> state;<span class="comment">//RUN表示正在运行，SCHED表示已被调度</span></span><br><span class="line">	<span class="type">atomic_t</span> count;<span class="comment">//0表示处于激活状态，不为0表示该tasklet禁止，不允许执行</span></span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">//处理函数，等效softirq的action函数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>\include\linux\interrupt.h</code><br>state 有 2 位：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">◼ bit0 表示 TASKLET_STATE_SCHED</span><br><span class="line">等于 <span class="number">1</span> 时表示已经执行了 tasklet_schedule 把该 tasklet 放入队列了；(等于<span class="number">1</span>表示放入队列就绪了)</span><br><span class="line">tasklet_schedule 会判断该位，如果已经等于 <span class="number">1</span> 那么它就不会再次把tasklet 放入队列。</span><br><span class="line">◼ bit1 表示 TASKLET_STATE_RUN</span><br><span class="line">等于 <span class="number">1</span> 时，表示正在运行 tasklet 中的 func 函数；函数执行完后内核会把该位清 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p>count 表示该 tasklet 是否使能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">等于 <span class="number">0</span> 表示使能了，非 <span class="number">0</span> 表示被禁止了。对于 count 非 <span class="number">0</span> 的 tasklet，里面的 func 函数不会被执行</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-tasklet-lian-biao">3.1.1 tasklet链表</span><a href="#3-1-1-tasklet-lian-biao" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> &#123;</span>                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_vec)</span>; <span class="comment">//kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_hi_vec)</span>;</span><br><span class="line"><span class="comment">//对应softirq的TASKLET_SOFTIRQ和HI_SOFTIRQ， 优先级分别为6和0</span></span><br></pre></td></tr></table></figure>

<p>tasklet执行过程<code> TASKLET_SOFTIRQ</code>对应执行函数为<code>tasklet_action</code>，<code>HI_SOFTIRQ</code>为<code>tasklet_hi_action</code>。</p>
<h3><span id="3-1-2-tasklet-init">3.1.2 tasklet_init</span><a href="#3-1-2-tasklet-init" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t, <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-declare-tasklet">3.1.3 DECLARE_TASKLET</span><a href="#3-1-3-declare-tasklet" class="header-anchor">#</a></h3><p><code>DECLARE_TASKLET</code>和<code>DECLARE_TASKLET_DISABLED</code>可以定义一个tasklet结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 DECLARE_TASKLET 定义的 tasklet 结构体，它是使能的；</span></span><br><span class="line"><span class="comment">//使用 DECLARE_TASKLET_DISABLED 定义的 tasklet 结构体，它是禁止的；使用之前要先调用 tasklet_enable 使能它。</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-shi-neng-x2f-jin-zhi-tasklet">3.2 使能&#x2F;禁止 tasklet</span><a href="#3-2-shi-neng-x2f-jin-zhi-tasklet" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_enable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_disable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/5.png" alt="image"></p>
<h2><span id="3-3-diao-du-tasklet">3.3 调度tasklet</span><a href="#3-3-diao-du-tasklet" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/6.png" alt="image"><br>把 <code>tasklet</code> 放入链表，并且设置它的 <code>TASKLET_STATE_SCHED </code>状态为1。<code>tasklet_schedule</code> 只是把 tasklet 放入内核队列，它的 <code>func</code> 函数会在软件中断的执行过程中被调用。</p>
<h2><span id="3-4-zhi-xing-tasklet">3.4 执行tasklet</span><a href="#3-4-zhi-xing-tasklet" class="header-anchor">#</a></h2><p>对于 <code>TASKLET_SOFTIRQ</code> 类型的 <code>softirq</code>，其handler是 <code>tasklet_action</code>，可以看到软中断执行，硬件中断是使能的。执行对应的<code>func</code>函数。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/7.png" alt="image-20240810224518977"></p>
<h2><span id="3-5-tasklet-kill">3.5 tasklet_kill</span><a href="#3-5-tasklet-kill" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果一个 tasklet 未被调度， tasklet_kill 会把它的TASKLET_STATE_SCHED 状态清 0；</span></span><br><span class="line"><span class="comment">//如果一个 tasklet 已被调度，tasklet_kill 会等待它执行完华，再把它的TASKLET_STATE_SCHED 状态清 0。</span></span><br></pre></td></tr></table></figure>

<p>通常在卸载驱动程序时调用 <code>tasklet_kill</code>。</p>
<h1><span id="4-tasklet-dai-ma-shi-li-jie-xi">4 tasklet代码示例解析</span><a href="#4-tasklet-dai-ma-shi-li-jie-xi" class="header-anchor">#</a></h1><h2><span id="4-1-tasklet-shi-yong-qu-dong-yuan-ma">4.1 tasklet使用驱动源码</span><a href="#4-1-tasklet-shi-yong-qu-dong-yuan-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="comment">/* data ==&gt; gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="comment">/* data ==&gt; gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line"></span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line"></span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">		, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv); </span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>用户态测试代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;while get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h2><span id="4-2-fen-xi">4.2 分析</span><a href="#4-2-fen-xi" class="header-anchor">#</a></h2><p>probe函数中为每一个gpio按键都创建一个<code>tasklet</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/9.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/10.png" alt="image"><br>当按键按下，中断服务执行，那么此时需要调度tasklet去完成中断下半部的事情，每当一个按键按下，就会执行一次tasklet里面的函数，也就是<code>key_tasklet_func</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/11.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/12.png" alt="image"><br>根据不同的gpio带来不同的data，这里<code>key_tasklet_func</code>下半部分只是简单打印出对应哪一个gpio，输出什么电平。<br>最终驱动卸载时调用<code>tasklet_kill</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/13.png" alt="image"></p>
<h1><span id="5-tasklet-nei-bu-ji-zhi-pou-xi">5 tasklet内部机制剖析</span><a href="#5-tasklet-nei-bu-ji-zhi-pou-xi" class="header-anchor">#</a></h1><h2><span id="5-1-tasklet-action-de-zhi-xing-guo-cheng">5.1 tasklet_action的执行过程</span><a href="#5-1-tasklet-action-de-zhi-xing-guo-cheng" class="header-anchor">#</a></h2><p><code>tasklet</code>属于<code>TASKLET_SOFTIRQ</code>软件中断，入口函数为<code>tasklet_action</code>，这在内核<code> kernel\softirq.c</code> 中设置:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/14.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/15.png" alt="image"></p>
<p>当驱动程序调用<code> tasklet_schedule</code> 时，会设置 tasklet 的<code>state</code>为<code>TASKLET_STATE_SCHED</code>，并把它放入内核<code>tasklet链表</code>:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/16.png" alt="image"><br>触发<code>TASKLET_SOFTIRQ </code>软件中断，会调用 <code>tasklet_action </code>函数，遍历<code>tasklet </code>链表，进行状态判断后执行<code> .func</code><br>函数，从队列中删除 <code>tasklet</code>。<br>可以看出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>tasklet_schedule 调度 tasklet 时，其中的函数并不会立刻执行，而只是把tasklet 放入队列</span><br><span class="line"><span class="number">2.</span>调用一次 tasklet_schedule，只会导致 tasklet 的函数被执行一次；如果 tasklet 的函数尚未执行</span><br><span class="line">    ，多次调用 tasklet_schedule 也是无效的，只会放入队列一次，TASKLET_STATE_SCHED状态会自行判断。</span><br></pre></td></tr></table></figure>
<p>最终tasklet中的<code>func</code>执行要看<code>tasklet_action</code>的过程分析：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/17.png" alt="image"><br>首先从链表中取出每一项<code>tasklet</code>, 读取<code>count</code>, 如果等于0表示有使能该<code>tasklet</code>, 清除<code>TASKLET_STATE_SCHED</code>位，并且执行<code>t-&gt;func</code>，执行完该task中的<code>func</code>后从链表取出并且删除掉。</p>
]]></content>
      <tags>
        <tag>中断体系</tag>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-9-中断子系统-中断引入</title>
    <url>/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zhong-duan-yu-yi-chang-chong-lei">1 中断与异常种类</a></li>
<li><a href="#2-zhong-duan-de-chu-li-liu-cheng">2 中断的处理流程</a><ul>
<li><a href="#2-1-yi-chang-xiang-liang-biao">2.1 异常向量表</a><ul>
<li><a href="#2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base">2.1.1 中断向量表偏移(vector base)</a></li>
</ul>
</li>
<li><a href="#2-2-gic-gai-shu">2.2 GIC概述</a></li>
<li><a href="#2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan">2.3 保护现场，恢复现场的核心：栈</a><ul>
<li><a href="#2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng">2.3.1 ARM 处理器程序运行的过程</a></li>
<li><a href="#2-3-2-ru-zhan-bao-hu-xian-chang-chu-zhan-hui-fu-xian-chang">2.3.2 入栈保护现场&#x2F;出栈恢复现场</a></li>
</ul>
</li>
<li><a href="#2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan">2.4 硬件中断、软件中断</a><ul>
<li><a href="#2-4-1-ying-zhong-duan">2.4.1 硬中断</a></li>
<li><a href="#2-4-2-ruan-zhong-duan">2.4.2 软中断</a><ul>
<li><a href="#2-4-2-1-ruan-zhong-duan-de-lei-xing">2.4.2.1 软中断的类型</a></li>
<li><a href="#2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong">2.4.2.2 软件中断的API使用</a><ul>
<li><a href="#2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq">2.4.2.2.1 注册软中断-open_softirq</a></li>
<li><a href="#2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq">2.4.2.2.2 使能软中断-raise_softirq</a></li>
<li><a href="#2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq">2.4.2.2.3 执行软中断-do_softirq</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie">2.4.3 硬件中断和软中断区别</a></li>
</ul>
</li>
<li><a href="#2-5-zhong-duan-chu-li-yuan-ze">2.5 中断处理原则</a><ul>
<li><a href="#2-5-1-yuan-ze-1-bu-neng-qian-tao">2.5.1 原则 1:不能嵌套</a></li>
<li><a href="#2-5-2-yuan-ze-2-yue-kuai-yue-hao">2.5.2 原则 2:越快越好</a></li>
<li><a href="#2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu">2.5.3 原则 3:耗时久的中断操作切分为中断上半部、下半部</a></li>
<li><a href="#2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian">2.5.4 原则 4:上半部和下半部均不能休眠</a></li>
</ul>
</li>
<li><a href="#2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa">2.6 中断下半部处理方法</a><ul>
<li><a href="#2-6-1-xiao-ren-wu-tasklet">2.6.1 小任务tasklet</a></li>
<li><a href="#2-6-2-gong-zuo-dui-lie-workqueue">2.6.2 工作队列workqueue</a></li>
<li><a href="#2-6-3-threaded-irq">2.6.3 threaded irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zhong-duan-yu-yi-chang-chong-lei">1 中断与异常种类</span><a href="#1-zhong-duan-yu-yi-chang-chong-lei" class="header-anchor">#</a></h1><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/1.png" alt="image"><br>CPU 在运行的过程中，也会被各种<code>“异常”</code>打断。这些<code>“异常”</code>有：</p>
<ol>
<li>指令未定义</li>
<li>Reset复位</li>
<li>指令、数据访问有问题</li>
<li>SWI(软中断)</li>
<li>快中断</li>
<li>IRQ中断</li>
</ol>
<p>IRQ中断只是一种（一类）异常而已。导致中断发生的情况有很多，比如：</p>
<ol>
<li>按键</li>
<li>定时器</li>
<li>ADC 转换完成</li>
<li>UART 发送完数据、收到数据</li>
</ol>
<p>这些众多的<code>“中断源”</code>，汇集到<code>“中断控制器”</code>，由<code>“中断控制器”</code>选择优先级最高的中断并通知 CPU。如上图所示：</p>
<h1><span id="2-zhong-duan-de-chu-li-liu-cheng">2 中断的处理流程</span><a href="#2-zhong-duan-de-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>arm 对异常(中断)处理过程：</p>
<ol>
<li>初始化：<br> a) 设置<strong>中断源</strong>，让它可以产生中断<br> b) 设置<strong>中断控制器</strong>(可以屏蔽某个中断，优先级)<br> c) 设置 <strong>CPU 总开关(使能中断)</strong></li>
<li>执行其他程序：正常程序</li>
<li>产生中断：比如按下按键（中断源发出中断请求）—&gt;中断控制器—&gt;CPU</li>
<li>CPU 每执行完一条指令都会检查有无中断&#x2F;异常产生</li>
<li>CPU 发现有中断&#x2F;异常产生，开始处理。</li>
</ol>
<p>对于不同的异常，跳去不同的地址执行程序。这地址上，只是一条跳转指令，跳去执行某个函数(地址)，这个就是异常向量。③④⑤都是硬件做的。③是中断源来做，④⑤是cpu来做</p>
<p>综上5个过程，软件要做的事情:<br>a) 保存现场(各种寄存器)<br>b) 处理异常(中断): 从<strong>异常向量表</strong>跳到不同的异常向量去执行，分辨中断源，再调用不同的处理函数<br>c) 恢复现场</p>
<h2><span id="2-1-yi-chang-xiang-liang-biao">2.1 异常向量表</span><a href="#2-1-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p>可以参考我之前写的<a href="https://www.cnblogs.com/fuzidage/p/12066599.html" title="异常向量表">s3c2440裸机-异常中断（一. 异常、中断的原理与流程）</a> 介绍了异常向量表。<br>uboot中就有大量类似这种的异常向量表，不同系列芯片每个异常的偏移地址会有所不同。下图以s3c2440芯片为例：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/2.png" alt="image"><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/3.png" alt="image"></p>
<table>
<thead>
<tr>
<th>向量地址</th>
<th>中断类型</th>
<th>中断模式</th>
</tr>
</thead>
<tbody><tr>
<td>0X00</td>
<td>复位中断(Rest)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X04</td>
<td>未定义指令中断(Undefined Instruction)</td>
<td>未定义指令中止模式(Undef)</td>
</tr>
<tr>
<td>0X08</td>
<td>软中断(Software Interrupt,SWI)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X0C</td>
<td>指令预取中止中断(Prefetch Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X10</td>
<td>数据访问中止中断(Data Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X14</td>
<td>未使用(Not Used)</td>
<td>未使用</td>
</tr>
<tr>
<td>0X18</td>
<td>IRQ</td>
<td>中断(IRQ Interrupt)</td>
</tr>
<tr>
<td>0X1C</td>
<td>FIQ</td>
<td>中断(FIQ Interrupt)</td>
</tr>
</tbody></table>
<p>这就是异常向量表，每一条指令对应一种异常。<br>发生复位时，CPU 就去 执行第 1 条指令：<code>b reset</code>。<br>发生中断时，CPU 就去执行<code>“ldr pc, _irq”</code>这条指令。这些指令存放的位置是固定的，比如对于ARM9芯片中断向量的地址是<code>0x18</code>。当发生中断时，CPU 就强制跳去执行 <code>0x18 </code>处的代码。</p>
<h3><span id="2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base">2.1.1 中断向量表偏移(vector base)</span><a href="#2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base" class="header-anchor">#</a></h3><p>在向量表里，一般都是放置一条跳转指令，发生该异常时，CPU 就会执行向量表中的跳转指令，去调用更复杂的函数。当然，向量表的位置并不总是从 0 地址开始，很多芯片可以设置某个 <code>vector base </code>寄存器，指定向量表在其他位置，比如imx6ull芯片设置 <code>vector base </code>为 <code>0x80000000</code>，指定为 DDR 的某个地址。但是表中的各个异常向量的偏移地址，是固定的：复位向量偏移地址是 0，中断是 0x18。</p>
<h2><span id="2-2-gic-gai-shu">2.2 GIC概述</span><a href="#2-2-gic-gai-shu" class="header-anchor">#</a></h2><p>对于 ARM 的中断控制器，述语上称之为<code> GIC (Generic Interrupt Controller)</code>，到目前已经更新到 v4 版本了。在STM32叫做<code>NVIC</code>(内嵌向量中断控制器 <code>Nested Vectored Interrupt Controller</code>)<br>简单地说，<code>GIC v3/v4</code> 用于 <code>ARMv8</code> 架构，即 64 位 ARM 芯片。<br>而 <code>GIC v2</code> 用于<code> ARMv7</code> 和其他更低的32位架构。v2架构下一节：<a href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析</a> 会展开细说。</p>
<p>v8架构是在32位ARM架构上进行开发的，将被首先用于对扩展虚拟地址和64位数据处理技术有更高要求的产品领域，如企业应用、高档消费电子产品。<code>ARMv8</code>架构包含两个执行状态：<code>AArch64</code>和<code>AArch32</code>。<code>AArch64</code>执行状态针对64位处理技术，引入了一个全新指令集A64；而<code>AArch32</code>执行状态将支持现有的ARM指令集。</p>
<h2><span id="2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan">2.3 保护现场，恢复现场的核心：栈</span><a href="#2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan" class="header-anchor">#</a></h2><p>中断当前正在运行的进程、线程。进程、线程是什么？内核如何切换进程、线程、中断？要理解这些概念，必须理解栈的作用。</p>
<p>进程是资源分配的基本单位，线程是调度的基本单位。<br>    比如全局变量a, 对不同线程它是共享的，但是这个资源a是属于该进程独立的资源，对其他进程是不可见的。<br>    一个进程可以包含多个线程，线程有自己的栈空间，也就是局部变量。</p>
<h3><span id="2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng">2.3.1 ARM 处理器程序运行的过程</span><a href="#2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng" class="header-anchor">#</a></h3><p>ARM 芯片属于精简指令集计算机(<code>RISC：Reduced Instruction Set  Computing</code>)，它所用的指令比较简单，有如下特点：</p>
<pre><code>对内存只有读、写指令
对于数据的运算是在 CPU 内部实现
使用 RISC 指令的 CPU 复杂度小一点，易于设计
</code></pre>
<p>比如对于<code>a=a+b</code>这样的算式，需要经过下面 4 个步骤才可以实现：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/4.png" alt="image"><br>我们先忽略各种 CPU 模式(系统模式、用户模式等等)。详细过程如下：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/5.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R0, [a]</span><br><span class="line">LDR R1, [b]</span><br><span class="line">ADD R0, R0, R1</span><br><span class="line">STR R0, [a]</span><br><span class="line">/*翻译如下：</span><br><span class="line">把内存 a 的值读入 CPU 寄存器 R0</span><br><span class="line">把内存 b 的值读入 CPU 寄存器 R1</span><br><span class="line">把 R0、R1 累加，存入 R0</span><br><span class="line">把 R0 的值写入内存 a*/</span><br></pre></td></tr></table></figure>

<h3><span id="2-3-2-ru-zhan-bao-hu-xian-chang-x2f-chu-zhan-hui-fu-xian-chang">2.3.2 入栈保护现场&#x2F;出栈恢复现场</span><a href="#2-3-2-ru-zhan-bao-hu-xian-chang-x2f-chu-zhan-hui-fu-xian-chang" class="header-anchor">#</a></h3><p>当进行函数调用跳转到下一个函数，又或者中断一个程序，就需要把这些寄存器的值保存下来：这就称为<strong>保存现场</strong>。保存的寄存器那块内存就称为栈空间。<br>当跳转的函数执行完成，就需要从栈中恢复那些 CPU 内部寄存器的值，这一出栈的过程也被叫做<strong>“恢复现场”</strong>。</p>
<p><strong>①函数调用：</strong></p>
<pre><code>1.在函数 A 里调用函数 B，实际就是中断函数 A 的执行。
2.那么需要把函数 A 调用 B 之前瞬间的 CPU 寄存器的值，保存到栈里
</code></pre>
<p><strong>②中断处理：</strong></p>
<pre><code>a) 进程 A 正在执行，这时候发生了中断。
b) CPU 强制跳到中断异常向量地址去执行，
c) 这时就需要保存进程 A 被中断瞬间的 CPU 寄存器值，
d) 可以保存在进程 A 的内核态栈，也可以保存在进程 A 的内核结构体中。
e) 中断处理完毕，要继续运行进程 A 之前，恢复这些值
</code></pre>
<p><strong>③进程切换：</strong><br>进程 A 的时间用完了，就切换到进程 B。怎么切换？切换过程是发生在内核态里的，跟中断的处理类似。<br>a) 进程 A 被切换瞬间的 CPU 寄存器值保存在某个地方；<br>b) 恢复进程 B 之前保存的 CPU 寄存器值，这样就可以运行进程 B 了。<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/6.png" alt="image"><br>总结有3种场景会要用到栈去保存和恢复现场：</p>
<p>①函数调用，②进程切换，③中断过程。<strong>进程调度核心就是靠定时器中断来实现</strong>。</p>
<h2><span id="2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan">2.4 硬件中断、软件中断</span><a href="#2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan" class="header-anchor">#</a></h2><h3><span id="2-4-1-ying-zhong-duan">2.4.1 硬中断</span><a href="#2-4-1-ying-zhong-duan" class="header-anchor">#</a></h3><p>硬件产生的中断，称之为<code>“硬件中断”</code>(<code>hard irq</code>)。每个硬件中断都有对应的处理函数，比如按键中断、网卡中断，定时器中断的处理函数肯定不一样。<br>为方便理解，可以先认为对硬件中断的处理是用数组来实现的，数组里存放的是函数指针：一个中断号对应一个中断服务函数<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/7.png" alt="image"></p>
<h3><span id="2-4-2-ruan-zhong-duan">2.4.2 软中断</span><a href="#2-4-2-ruan-zhong-duan" class="header-anchor">#</a></h3><p>相对的，还可以人为地制造中断：软件中断(<code>soft irq</code>)，如下图所示：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/8.png" alt="image"></p>
<ol>
<li>软件中断何时生产？<br> 由软件决定，对于 X 号软件中断，只需要把它的 flag 设置为 1 就表示发生了该中断。</li>
<li>软件中断何时处理？<br> 软件中断嘛，并不是那么十万火急，有空再处理它好了,因此一般软件中断是硬件中断处理完后，顺便来处理软件中断。</li>
<li>有哪些软件中断？</li>
</ol>
<h4><span id="2-4-2-1-ruan-zhong-duan-de-lei-xing">2.4.2.1 软中断的类型</span><a href="#2-4-2-1-ruan-zhong-duan-de-lei-xing" class="header-anchor">#</a></h4><p>查内核源码<code> include/linux/interrupt.h</code><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/9.png" alt="image"><br>怎么设置使用软中断，比如<code>tasklet </code>（后面会讲中断上半部分， 和中断下半部分）就是使用软件中断实现的。还有<a href="https://fuzidage.github.io/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器</a>   <a href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器</a>也是利用软中断实现的。</p>
<p>总结使用软中断的类型有:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">优先级为<span class="number">0</span>，HI_SOFTIRQ，高优先级的tasklet</span><br><span class="line">优先级为<span class="number">1</span>，定时器软中断</span><br><span class="line">发送网络数据包的软中断</span><br><span class="line">接受网络数据包的软中断</span><br><span class="line">块设备的软中断</span><br><span class="line">优先级为<span class="number">0</span>，tasklet，低优先级的tasklet</span><br><span class="line">进程调度和负载均衡</span><br><span class="line">高进度定时器</span><br><span class="line">RCU</span><br></pre></td></tr></table></figure>

<h4><span id="2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong">2.4.2.2 软件中断的API使用</span><a href="#2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong" class="header-anchor">#</a></h4><h5><span id="2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq">2.4.2.2.1 注册软中断-open_softirq</span><a href="#2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq" class="header-anchor">#</a></h5><p>  <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/10.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>&#123;</span><br><span class="line">	softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如网络发包对应类型为<code>NET_TX_SOFTIRQ</code>的处理函数<code>net_tx_action</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/core/dev.c</span></span><br><span class="line">open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq">2.4.2.2.2 使能软中断-raise_softirq</span><a href="#2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq" class="header-anchor">#</a></h5><p>  <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11.png" alt="image"><br>  最核心的函数是 <code>raise_softirq</code>，简单地理解就是设置<code> softirq_veq[nr]</code>的标记位，设置后表示使能该软中断号。</p>
<h5><span id="2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq">2.4.2.2.3 执行软中断-do_softirq</span><a href="#2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq" class="header-anchor">#</a></h5><p>每个 CPU 上会初始化一个 <code>ksoftirqd</code> 内核线程，负责处理各种类型的 <code>softirq </code>中断事件:</p>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11-1.png" alt="image-20240810221847189"></p>
<p>当注册软中断使能后，<code>ksoftirqd</code> 线程，执行<code>pending</code>的软中断。<code>ksoftirqd</code> 里面会进一步调用到 <code>__do_softirq</code>。</p>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11-2.png" alt="image-20240810223529233"></p>
<p>可以看到软中断执行，硬件中断是使能的。遍历使能的<code>softlrq</code>,执行对应的<code>action</code>函数。</p>
<h3><span id="2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie">2.4.3 硬件中断和软中断区别</span><a href="#2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie" class="header-anchor">#</a></h3><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/12.png" alt="image"></p>
<ol>
<li>硬件中断包含gpio，网卡，外围电路IP等等，<code>tick</code>（产生一次tick系统滴答中断，<code>jiffies加1</code>）</li>
<li>软件中断包含<code>TIMER</code> 表示定时中断、RCU 表示 RCU 锁中断、<code>SCHED </code>表示内核调度中断</li>
</ol>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/13.png" alt="image"></p>
<p><strong>区别：</strong><br>上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；<br>下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行</p>
<p><code>cat /proc/softirqs</code>可以看软件中断信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                  CPU0     CPU1  ...    CPU46    CPU47</span><br><span class="line">          HI:        2        0  ...        0        1</span><br><span class="line">       TIMER:   443727   467971  ...   313696   270110</span><br><span class="line">      NET_TX:    57919    65998  ...    42287    54840</span><br><span class="line">      NET_RX:    28728  5262341  ...    81106    55244</span><br><span class="line">       BLOCK:      261     1564  ...   268986   463918</span><br><span class="line">    IRQ_POLL:        0        0  ...        0        0</span><br><span class="line">     TASKLET:       98      207  ...      129      122</span><br><span class="line">       SCHED:  1854427  1124268  ...  5154804  5332269</span><br><span class="line">     HRTIMER:    12224    68926  ...    25497    24272</span><br><span class="line">         RCU:  1469356   972856  ...  5961737  5917455</span><br></pre></td></tr></table></figure>

<p><code>cat /proc/interrupts</code>可以看硬件中断</p>
<h2><span id="2-5-zhong-duan-chu-li-yuan-ze">2.5 中断处理原则</span><a href="#2-5-zhong-duan-chu-li-yuan-ze" class="header-anchor">#</a></h2><h3><span id="2-5-1-yuan-ze-1-bu-neng-qian-tao">2.5.1 原则 1:不能嵌套</span><a href="#2-5-1-yuan-ze-1-bu-neng-qian-tao" class="header-anchor">#</a></h3><p>中断 A 正在处理的过程中，假设又发生了中断 B，那么在栈里要保存 A 的现场，然后处理 B。在处理 B 的过程中又发生了中断 C，那么在栈里要保存 B 的现场，然后处理C。<br>如果中断嵌套突然暴发，那么栈将越来越大，栈终将耗尽。<br>为了防止这种情况发生，也是为了简单化中断的处理，在 Linux 系统上规定中断无法嵌套：即当前中断 A 没处理完之前，不会响应另一个中断 B(即使它的优先级更高)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">local_irq_disable();</span><br></pre></td></tr></table></figure>
<h3><span id="2-5-2-yuan-ze-2-yue-kuai-yue-hao">2.5.2 原则 2:越快越好</span><a href="#2-5-2-yuan-ze-2-yue-kuai-yue-hao" class="header-anchor">#</a></h3><p>在单核心芯片系统中，假设中断处理很慢，那应用程序在这段时间内就无法执行：系统显得很迟顿。</p>
<h3><span id="2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu">2.5.3 原则 3:耗时久的中断操作切分为中断上半部、下半部</span><a href="#2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu" class="header-anchor">#</a></h3><p>当处理某个中断要做的事情就是很多，没办法加快。比如对于按键中断，我们需要等待几十毫秒消除机械抖动。难道要在<code>irq_handler</code> 中等待吗？对于计算机来说，这可是一个段很长的时间。又比如图像处理中，当一个硬件IP处理完成一张图像的操作，那么对这张图像的后处理操作难道要放在中断服务中来操作嘛，显然这个耗时是非常久的。<br>那么中断操作切分为中断上半部、下半部。上半部分关中断，清中断执行关键紧急的事情，下半部分去处理耗时久的事情，如下图：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/14.png" alt="image"><br>中断下半部的实现有很多种方法： ①<code>tasklet</code>(小任务)、②<code>work queue</code>(工作队列)， ③<code>threaded irq</code>等。</p>
<h3><span id="2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian">2.5.4 原则 4:上半部和下半部均不能休眠</span><a href="#2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian" class="header-anchor">#</a></h3><p>中断上半部、下半部的执行过程中，不能休眠：中断休眠的话，以后谁来调度进程啊？</p>
<h2><span id="2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa">2.6 中断下半部处理方法</span><a href="#2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa" class="header-anchor">#</a></h2><h3><span id="2-6-1-xiao-ren-wu-tasklet">2.6.1 小任务tasklet</span><a href="#2-6-1-xiao-ren-wu-tasklet" class="header-anchor">#</a></h3><p><code>tasklet</code> 是使用软中断来实现的：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/15.png" alt="image"><br><strong>中断上半部和下半部的处理流程：</strong><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/16.png" alt="image"><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/17.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 中断源产生中断，执行irq_enter(), 最开始preempt_count=<span class="number">0</span>，preempt_count++后为<span class="number">1</span>, </span><br><span class="line">	generic_handle_irq中会找到该中断源对应的中断服务程序</span><br><span class="line"><span class="number">2.</span> 执行irq函数，执行中断上半部，（注意执行上半部分时是无法被中断的，调用了local_irq_disable()）</span><br><span class="line"><span class="number">3.</span> irq_exit(),preempt_count-- 后为<span class="number">0</span>，</span><br><span class="line"><span class="number">4.</span> 判断preempt_count是否等于<span class="number">0</span>，此时等于<span class="number">0</span>，也就是执行下半部分，也叫做软中断流程</span><br><span class="line"><span class="number">5.</span> 下半部过程中会对preempt_count++，开始软件中断</span><br><span class="line"><span class="number">6.</span> 由于是软件中断，开总中断，允许其他的硬件中断响应local_irq_enable();</span><br><span class="line"><span class="number">7.</span> 根据软中断号找到服务函数，执行所谓的中断下半部分（可以进行耗时的一些操作，因为有使能中断）</span><br><span class="line"><span class="number">8.</span> 下半部分执行完后，local_irq_disable()</span><br><span class="line"><span class="number">9.</span> preempt_count--，preempt_count又回到<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上半部中断（硬件中断）有<code>local_irq_disable()</code>，中断是不允许被另一个中断打断的。而下半部（软件中断）时中断是开的，它可以被其他中断打断<code>local_irq_enable()</code>。</p>
<p>那么软中断（下半部）A还没有执行到<code>⑨preempt_count--</code>，当被其他中断B打断时，又执行<code>①preempt_count++</code>，等于2，又进入了下一个硬件中断B流程。当下一个硬件中断B流程执行完后，<code>preempt_count--</code>，等于1，此时不会进入软总断流程直接结束，然后恢复A中断的下半部，继续执行完A中断下半部分的代码。<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/18.png" alt="image"><br>那这样B的下半部怎么执行呢？难道不要了吗？注意：<code>步骤7</code>中的中断下半部处理过程中，它处理的是所有中断的下半部分，处理完A的下半部后会继续处理B中断的下半部。所以，多个中断的下半部，是汇集在一起处理的。<br>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.中断的处理可以分为上半部，下半部</span><br><span class="line">2.中断上半部，用来处理紧急的事，它是在关中断的状态下执行的</span><br><span class="line">3.中断下半部，用来处理耗时的、不那么紧急的事，它是在开中断的状态下执行的.</span><br><span class="line">   	中断下半部执行时，有可能会被其他硬件中断打断</span><br><span class="line">4.中断上半部、下半部的执行过程中，不能休眠</span><br></pre></td></tr></table></figure>
<h3><span id="2-6-2-gong-zuo-dui-lie-workqueue">2.6.2 工作队列workqueue</span><a href="#2-6-2-gong-zuo-dui-lie-workqueue" class="header-anchor">#</a></h3><p>如果下半部要做的事情太多，那么<code>tasklet</code>就有点不太符合需求了，我们希望建立一个线程来专门执行中断后处理，用内核线程来做：在中断上半部唤醒内核线程。<br>在linux操作系统中，有一个内核线程**<code>kworker</code>** 线程，是系统帮我们创建的。内核中有很多这样的线程：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/19.png" alt="image"><br><code>kworker</code> 线程要去<code>“工作队列”(work queue)</code>上取出一个一个<code>“工作”(work)</code>，来执行它里面的函数。</p>
<p>1.创建 <code>work</code><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/20.png" alt="image"></p>
<p>2.要执行这个函数时，把<code> work</code> 提交给 <code>work queue </code>就可以了<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/21.png" alt="image"><br>上述函数会把 <code>work</code> 提供给**<code>系统默认的 work queue：system_wq</code>**，它是一个队列。<code>schedule_work</code> 函数不仅仅是把 <code>work </code>放入队列，还会把<code>kworker </code>线程唤醒。</p>
<p>3.什么时候把 <code>work </code>提交给 <code>work queue</code>？<br>在中断场景中，可以在中断上半部调用 <code>schedule_work</code> 函数。<br>因此耗时久的中断下半部分，应该利用线程化处理方式，比如使用工作队列<code>workqueue</code>，上半部调用<code>schedule_work </code>函数，触发<code> work</code> 的处理。</p>
<h3><span id="2-6-3-threaded-irq">2.6.3 threaded irq</span><a href="#2-6-3-threaded-irq" class="header-anchor">#</a></h3><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/22.png" alt="image"><br><code>threaded_irq</code>：下半部也是利用线程化处理。前面的<code>workqueue</code>处理使用方法太麻烦，需要在上半部进行<code>work</code>定义，<code>schedule_work</code>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数handler:上半部分可以为空</span><br><span class="line">参数：thread_fn，系统会为这个函数创建一个内核线程。发生中断时，内核线程就会执行这个函数</span><br></pre></td></tr></table></figure>
<p>以前用 <code>work </code>来线程化地处理中断，一个 <code>worker </code>线程只能由一个 CPU 执行，多个中断的 <code>work</code> 都由同一个<code> worker</code> 线程来处理，在单 CPU 系统中也只能忍着了。但是在 SMP 系统中，明明有那么多 CPU 空着，你偏偏让多个中断挤在这个CPU 上？<br>新技术 <code>threaded irq</code>，为每一个中断都创建一个内核线程；多个中断的内核线程可以分配到多个 CPU 上执行，这提高了效率。</p>
]]></content>
      <tags>
        <tag>中断体系</tag>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-9-中断子系统-GICv2架构解析</title>
    <url>/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-armv7-32-wei-gicv2-jie-shao">1 armv7 32位GICv2介绍</a><ul>
<li><a href="#1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan">1.0 分发器端和 CPU 接口端</a></li>
<li><a href="#1-1-gic-lei-xing">1.1 GIC 类型</a></li>
<li><a href="#1-2-zhong-duan-id">1.2 中断 ID</a></li>
<li><a href="#1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu">1.3 中断配置(1.7有详细描述)</a><ul>
<li><a href="#1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng">1.3.1 IRQ 和 FIQ 总中断使能</a></li>
<li><a href="#1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi">1.3.2 <code>ID0~ID1019</code> 中断使能和禁止</a></li>
<li><a href="#1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr">1.3.3 中断优先级数量 GICC_PMR</a></li>
<li><a href="#1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr">1.3.4 中断抢占优先级和子优先级位数 GICC_BPR</a></li>
<li><a href="#1-3-5-zhong-duan-priority-d-ipriorityr">1.3.5 中断priority D_IPRIORITYR</a></li>
</ul>
</li>
<li><a href="#1-4-zhong-duan-zhuang-tai-ji">1.4 中断状态机</a></li>
<li><a href="#1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3">1.5 GIC初始化硬件流程（软件流程见3.3）</a></li>
<li><a href="#1-6-gic-zhong-duan-chu-li">1.6 GIC中断处理</a></li>
<li><a href="#1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao">1.7 GIC控制器寄存器介绍</a><ul>
<li><a href="#1-7-1-gic-de-nei-cun-ying-she">1.7.1 GIC的内存映射</a><ul>
<li><a href="#1-7-1-1-fen-fa-qi-ji-cun-qi">1.7.1.1 分发器寄存器</a><ul>
<li><a href="#1-7-1-1-1-gicd-ctlr-distributor-control-register">1.7.1.1.1 GICD_CTLR(Distributor Control Register)</a></li>
<li><a href="#1-7-1-1-2-gicd-typer-controller-type-register">1.7.1.1.2 GICD_TYPER(Controller Type Register)</a></li>
<li><a href="#1-7-1-1-3-gicd-iidr-implementer-identification-register">1.7.1.1.3 GICD_IIDR(Implementer Identification Register)</a></li>
<li><a href="#1-7-1-1-4-gicd-igrouprn-group-registers">1.7.1.1.4 GICD_IGROUPRn(Group Registers)</a></li>
<li><a href="#1-7-1-1-5-gicd-isenablern-set-enable-registers">1.7.1.1.5 GICD_ISENABLERn(Set-Enable Registers)</a></li>
<li><a href="#1-7-1-1-6-gicd-icenablern-clear-enable-registers">1.7.1.1.6 GICD_ICENABLERn(Clear-Enable Registers)</a></li>
<li><a href="#1-7-1-1-7-gicd-isactivern-set-active-registers">1.7.1.1.7 GICD_ISACTIVERn(Set-Active Registers)</a></li>
<li><a href="#1-7-1-1-8-gicd-icactivern-clear-active-registers">1.7.1.1.8 GICD_ICACTIVERn(Clear-Active Registers)</a></li>
<li><a href="#1-7-1-1-9-gicd-ipriorityrn-priority-registers">1.7.1.1.9 GICD_IPRIORITYRn(Priority Registers)</a></li>
<li><a href="#1-7-1-1-10-gicd-itargetsrn-processor-targets-registers">1.7.1.1.10 GICD_ITARGETSRn(Processor Targets Registers)</a></li>
<li><a href="#1-7-1-1-11-gicd-icfgrn-configuration-registers">1.7.1.1.11 GICD_ICFGRn(Configuration Registers)</a></li>
<li><a href="#1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register">1.7.1.1.12 ICPIDR2(Identification registers: Peripheral ID2 Register)</a></li>
</ul>
</li>
<li><a href="#1-7-1-2-cpu-jie-kou-duan-ji-cun-qi">1.7.1.2 cpu接口端寄存器</a><ul>
<li><a href="#1-7-1-2-1-gicc-ctlr-cpu-interface-control-register">1.7.1.2.1 GICC_CTLR(CPU Interface Control Register)</a></li>
<li><a href="#1-7-1-2-2-gicc-pmr-priority-mask-register">1.7.1.2.2 GICC_PMR(Priority Mask Register)</a></li>
<li><a href="#1-7-1-2-3-gicc-bpr-binary-point-register">1.7.1.2.3 GICC_BPR(Binary Point Register)</a></li>
<li><a href="#1-7-1-2-4-gicc-iar-acknowledge-register">1.7.1.2.4 GICC_IAR(Acknowledge Register)</a></li>
<li><a href="#1-7-1-2-5-gicc-eoir-interrupt-register">1.7.1.2.5 GICC_EOIR(Interrupt Register)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-zhong-duan-shi-li-start-s-fen-xi">2. 中断示例start.s分析</a><ul>
<li><a href="#2-1-start-s-qi-dong-liu-cheng">2.1 start.s启动流程</a></li>
</ul>
</li>
<li><a href="#3-gic-zhong-duan-chu-li-liu-cheng">3 GIC中断处理流程</a><ul>
<li><a href="#3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.1 一级中断控制器流程</a></li>
<li><a href="#3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.2 多级中断控制器流程</a></li>
<li><a href="#3-3-gic-ruan-jian-chu-shi-hua-guo-cheng">3.3 GIC软件初始化过程</a><ul>
<li><a href="#3-3-1-gic-qu-dong-zhu-ce">3.3.1 gic驱动注册</a><ul>
<li><a href="#3-3-1-1-dts-pi-pei">3.3.1.1 dts匹配</a></li>
<li><a href="#3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou">3.3.1.2 gic_of_init(GIC驱动初始化入口)</a></li>
<li><a href="#3-3-1-3-shen-qing-gic-zhong-duan">3.3.1.3 申请GIC中断</a><ul>
<li><a href="#3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan">3.3.1.3.1 在设备树里指定中断</a></li>
<li><a href="#3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li">3.3.1.3.2 对设备树中断的处理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-gic-zhong-duan-chu-guo-cheng">3.4 GIC中断处过程</a><ul>
<li><a href="#3-4-1-handle-arch-irq-ru-kou">3.4.1 handle_arch_irq入口</a><ul>
<li><a href="#3-4-1-1-gic-handle-irq">3.4.1.1 gic_handle_irq</a><ul>
<li><a href="#3-4-1-1-1-handle-domain-irq">3.4.1.1.1 handle_domain_irq</a><ul>
<li><a href="#3-4-1-1-1-1-generic-handle-irq">3.4.1.1.1.1 generic_handle_irq</a></li>
</ul>
</li>
<li><a href="#3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing">3.4.1.1.2 总结request_irq的函数如何被执行</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu">4 中断控制器GIC的设备树描述</a><ul>
<li><a href="#4-1-huo-qu-zhong-duan-hao-han-shu">4.1 获取中断号函数</a></li>
<li><a href="#4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan">4.2 gic使用示例-按键gpio中断</a><ul>
<li><a href="#4-2-1-dts-miao-shu">4.2.1 dts描述</a></li>
<li><a href="#4-2-2-qu-dong-dai-ma-yu-fen-xi">4.2.2 驱动代码与分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-armv7-32-wei-gicv2-jie-shao">1 armv7 32位GICv2介绍</span><a href="#1-armv7-32-wei-gicv2-jie-shao" class="header-anchor">#</a></h1><p>armv7 32位 gic采用v2版本，参考手册 <a href="https://developer.arm.com/documentation/ihi0048/bb/?lang=en">https://developer.arm.com/documentation/ihi0048/bb/?lang=en</a></p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/1.png" alt="image"><br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/1-2.png" alt="image"></p>
<p> <code>GIC400 </code>就是v2版本的中断控制器 IP 核，当 GIC 接收到外部中断信号以后就会报给 ARM 内核。框架如下：<br> <img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/2.png" alt="image"></p>
<p>GIC 架构分为了两个逻辑块：<code>Distributor</code> 和 <code>CPU Interface</code>，也就是分发器端和 CPU 接口端。</p>
<h2><span id="1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan">1.0 分发器端和 CPU 接口端</span><a href="#1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan" class="header-anchor">#</a></h2><ol>
<li><p>分发器用来全局中断使能控制，每一个中断使能开关，中断优先级，外部中断触发方式（边沿触发、电平触发）等。外设-&gt;分发器会设置成<code>pending</code>（或者<code>active and pending</code>状态），这时分发器传递优先级最高的pending中断给cpu 接收端。</p>
</li>
<li><p>cpu接收端用来接收中断信号汇报给cpu, 如：应答中断，通知中断处理完成，定义抢占策略，设置优先级掩码，当多个中断到来选择最高优先级的中断号。</p>
<p> 例如：I.MX6U给了一个<code> core_ca7.h</code>定义了GIC的所有寄存器。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* GIC 寄存器描述结构体，</span></span><br><span class="line"><span class="comment">* GIC 分为分发器端和 CPU 接口端</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="comment">/* 分发器端寄存器 */</span></span><br><span class="line">      <span class="type">int32_t</span> RESERVED0[<span class="number">1024</span>];</span><br><span class="line">      _IOM <span class="type">uint32_t</span> D_CTLR; <span class="comment">/* Offset: 0x1000 (R/W) */</span></span><br><span class="line">      _IM <span class="type">uint32_t</span> D_TYPER; <span class="comment">/* Offset: 0x1004 (R/ ) */</span></span><br><span class="line">      _IM <span class="type">uint32_t</span> D_IIDR; <span class="comment">/* Offset: 0x1008 (R/ ) */</span></span><br><span class="line">      <span class="type">int32_t</span> RESERVED1[<span class="number">29</span>];</span><br><span class="line">      _IOM <span class="type">uint32_t</span> D_IGROUPR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1080 - 0x0BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED2[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISENABLER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1100 - 0x13C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED3[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICENABLER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1180 - 0x1BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED4[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISPENDR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1200 - 0x23C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED5[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICPENDR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1280 - 0x2BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED6[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISACTIVER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1300 - 0x33C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED7[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICACTIVER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1380 - 0x3BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED8[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_IPRIORITYR[<span class="number">512</span>];<span class="comment">/* Offset: 0x1400 - 0x5FC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED9[<span class="number">128</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_ITARGETSR[<span class="number">512</span>];<span class="comment">/* Offset: 0x1800 - 0x9FC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED10[<span class="number">128</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICFGR[<span class="number">32</span>]; <span class="comment">/* Offset: 0x1C00 - 0xC7C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED11[<span class="number">32</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PPISR; <span class="comment">/* Offset: 0x1D00 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_SPISR[<span class="number">15</span>]; <span class="comment">/* Offset: 0x1D04 - 0xD3C (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED12[<span class="number">112</span>];</span><br><span class="line">      __OM <span class="type">uint32_t</span> D_SGIR; <span class="comment">/* Offset: 0x1F00 ( /W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED13[<span class="number">3</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_CPENDSGIR[<span class="number">16</span>];<span class="comment">/* Offset: 0x1F10 - 0xF1C (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_SPENDSGIR[<span class="number">16</span>];<span class="comment">/* Offset: 0x1F20 - 0xF2C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED14[<span class="number">40</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR4; <span class="comment">/* Offset: 0x1FD0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR5; <span class="comment">/* Offset: 0x1FD4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR6; <span class="comment">/* Offset: 0x1FD8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR7; <span class="comment">/* Offset: 0x1FDC (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR0; <span class="comment">/* Offset: 0x1FE0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR1; <span class="comment">/* Offset: 0x1FE4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR2; <span class="comment">/* Offset: 0x1FE8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR3; <span class="comment">/* Offset: 0x1FEC (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR0; <span class="comment">/* Offset: 0x1FF0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR1; <span class="comment">/* Offset: 0x1FF4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR2; <span class="comment">/* Offset: 0x1FF8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR3; <span class="comment">/* Offset: 0x1FFC (R/ ) */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* CPU 接口端寄存器 */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_CTLR; <span class="comment">/* Offset: 0x2000 (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_PMR; <span class="comment">/* Offset: 0x2004 (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_BPR; <span class="comment">/* Offset: 0x2008 (R/W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_IAR; <span class="comment">/* Offset: 0x200C (R/ ) */</span></span><br><span class="line">      __OM <span class="type">uint32_t</span> C_EOIR; <span class="comment">/* Offset: 0x2010 ( /W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_RPR; <span class="comment">/* Offset: 0x2014 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_HPPIR; <span class="comment">/* Offset: 0x2018 (R/ ) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_ABPR; <span class="comment">/* Offset: 0x201C (R/W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_AIAR; <span class="comment">/* Offset: 0x2020 (R/ ) */</span></span><br><span class="line">      __OM <span class="type">uint32_t</span> C_AEOIR; <span class="comment">/* Offset: 0x2024 ( /W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_AHPPIR; <span class="comment">/* Offset: 0x2028 (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED15[<span class="number">41</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_APR0; <span class="comment">/* Offset: 0x20D0 (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED16[<span class="number">3</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_NSAPR0; <span class="comment">/* Offset: 0x20E0 (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED17[<span class="number">6</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> C_IIDR; <span class="comment">/* Offset: 0x20FC (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED18[<span class="number">960</span>];</span><br><span class="line">      __OM <span class="type">uint32_t</span> C_DIR; <span class="comment">/* Offset: 0x3000 ( /W) */</span></span><br><span class="line">  &#125; GIC_Type;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="1-1-gic-lei-xing">1.1 GIC 类型</span><a href="#1-1-gic-lei-xing" class="header-anchor">#</a></h2><p>GIC 将众多的中断源分为分为三类：<br>①、<code>SPI</code>(<code>Shared Peripheral Interrupt</code>),共享中断，顾名思义，所有 Core 共享的中断，这个是最常见的，那些外部中断都属于 SPI 中断 。<br>②、<code>PPI</code>(<code>Private Peripheral Interrupt)</code>，私有中断，我们说了 GIC 是支持多核的，每个核肯定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。<br>③、<code>SGI</code>(<code>Software-generated Interrupt</code>)，软件中断，由软件触发引起的中断，通过向寄存器<code>GICD_SGIR</code> 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。</p>
<h2><span id="1-2-zhong-duan-id">1.2 中断 ID</span><a href="#1-2-zhong-duan-id" class="header-anchor">#</a></h2><p>为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是中断 ID。每一个 CPU 最多支持 1020 个中断 ID，<code>ID0~ID1019</code> 中断使能和禁止。这 1020 个 ID 包含了 PPI、SPI 和 SGI。</p>
<pre><code>ID0~ID15：这 16 个 ID 分配给 SGI。
ID16~ID31：这 16 个 ID 分配给 PPI。
ID32~ID1019：这 988 个 ID 分配给 SPI。
</code></pre>
<p>例如：I.MX6U 的总共使用了 128 个中断 ID，加上前面属于 PPI 和 SGI 的 32 个 ID，I.MX6U 的中断源共有 <code>128+32=160</code>，那么irq为0的中断ID即为32。<br>个。NXP 官方 SDK中的文件 <code>MCIMX6Y2C.h</code>定义了160个中断ID。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_OF_INT_VECTORS 160 <span class="comment">/* 中断源 160 个，SGI+PPI+SPI*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">IRQn</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Auxiliary constants */</span></span><br><span class="line">	otAvail_IRQn = <span class="number">-128</span>,</span><br><span class="line">	<span class="comment">/* Core interrupts */</span></span><br><span class="line">	oftware0_IRQn = <span class="number">0</span>, </span><br><span class="line">	oftware1_IRQn = <span class="number">1</span>, </span><br><span class="line">	Software2_IRQn = <span class="number">2</span>, </span><br><span class="line">	Software3_IRQn = <span class="number">3</span>, </span><br><span class="line">	Software4_IRQn = <span class="number">4</span>, </span><br><span class="line">	Software5_IRQn = <span class="number">5</span>, </span><br><span class="line">	Software6_IRQn = <span class="number">6</span>, </span><br><span class="line">	Software7_IRQn = <span class="number">7</span>, </span><br><span class="line">	Software8_IRQn = <span class="number">8</span>, </span><br><span class="line">	Software9_IRQn = <span class="number">9</span>, </span><br><span class="line">	Software10_IRQn = <span class="number">10</span>, </span><br><span class="line">	Software11_IRQn = <span class="number">11</span>, </span><br><span class="line">	Software12_IRQn = <span class="number">12</span>, </span><br><span class="line">	Software13_IRQn = <span class="number">13</span>, </span><br><span class="line">	Software14_IRQn = <span class="number">14</span>, </span><br><span class="line">	Software15_IRQn = <span class="number">15</span>, </span><br><span class="line">	VirtualMaintenance_IRQn = <span class="number">25</span>, </span><br><span class="line">	HypervisorTimer_IRQn = <span class="number">26</span>, </span><br><span class="line">	VirtualTimer_IRQn = <span class="number">27</span>, </span><br><span class="line">	LegacyFastInt_IRQn = <span class="number">28</span>, </span><br><span class="line">	SecurePhyTimer_IRQn = <span class="number">29</span>, </span><br><span class="line">	NonSecurePhyTimer_IRQn = <span class="number">30</span>, </span><br><span class="line">	LegacyIRQ_IRQn = <span class="number">31</span>, </span><br><span class="line">	<span class="comment">/* Device specific interrupts */</span></span><br><span class="line">	IOMUXC_IRQn = <span class="number">32</span>, </span><br><span class="line">	DAP_IRQn = <span class="number">33</span>, </span><br><span class="line">	SDMA_IRQn = <span class="number">34</span>, </span><br><span class="line">	TSC_IRQn = <span class="number">35</span>, </span><br><span class="line">	SNVS_IRQn = <span class="number">36</span>, </span><br><span class="line">	...... ...... </span><br><span class="line">&#125; IRQn_Type;</span><br></pre></td></tr></table></figure>



<h2><span id="1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu">1.3 中断配置(1.7有详细描述)</span><a href="#1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng">1.3.1 IRQ 和 FIQ 总中断使能</span><a href="#1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng" class="header-anchor">#</a></h3><p>“<strong>CPSR程序状态寄存器</strong>”已经讲过了，寄存器 CPSR 的 I&#x3D;1 禁止 IRQ，当 I&#x3D;0 使<br>能 IRQ；F&#x3D;1 禁止 FIQ，F&#x3D;0 使能 FIQ。我们还有更简单的指令来完成 IRQ 或者 FIQ 的使能和<br>禁止:</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cpsid i</td>
<td>禁止 IRQ 中断。</td>
</tr>
<tr>
<td>cpsie i</td>
<td>使能 IRQ 中断。</td>
</tr>
<tr>
<td>cpsid f</td>
<td>禁止 FIQ 中断。</td>
</tr>
<tr>
<td>cpsie f</td>
<td>使能 FIQ 中断。</td>
</tr>
</tbody></table>
<h3><span id="1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi">1.3.2 <code>ID0~ID1019</code> 中断使能和禁止</span><a href="#1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi" class="header-anchor">#</a></h3><p>前面讲到中断ID有<code> ID0~ID1019</code>， GIC 寄存器 <code>GICD_ISENABLERn </code>和 <code>GICD_ ICENABLERn </code>用来完成外部中断的使能和禁止，对于 Cortex-A7 内核来说中断 ID 只使用了 512 个。<br>一共16组<code>GICD_ISENABLER</code>和<code>GICD_ISENABLER</code>，其中<code>GICD_ISENABLER0 </code>的 <code>bit[15:0]</code>对应<code>ID15~0</code> 的 SGI 中断，<code>GICD_ISENABLER0 </code>的 <code>bit[31:16]</code>对应<code>ID31~16</code>的 PPI 中断。剩下的<code>GICD_ISENABLER1~GICD_ISENABLER15 </code>就是控制 SPI 中断的。</p>
<h3><span id="1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr">1.3.3 中断优先级数量 GICC_PMR</span><a href="#1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr" class="header-anchor">#</a></h3><p>Cortex-A7 GIC 控制器最多可以支持 256 个优先级，数字越小，优先级越高！Cortex-A7 选择了 32 个优先级，<code>GICC_PMR</code> 寄存器，此寄存器用来决定使用几级优先级,<code>GICC_PMR</code> 寄存器只有低 8 位有效，这 8 位最多可以设置 256 个优先级:<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/4.png" alt="image"><br>I.MX6U 为例 Cortex-A7内核，所以支持 32 个优先级，因此 GICC_PMR 要设置为<code> 0b11111000</code>。</p>
<h3><span id="1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr">1.3.4 中断抢占优先级和子优先级位数 GICC_BPR</span><a href="#1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr" class="header-anchor">#</a></h3><p>寄存器 <code>GICC_BPR </code>只有低 3 位有效，其值不同，抢占优先级和子优先级占用的位数也不同：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/5.png" alt="image"><br>比如 I.MX6U 的优先级位数为 5(32 个优先级)，所以可以设置 Binary point 为 2，表示 5 个优先级位全部为抢占优先级。</p>
<h3><span id="1-3-5-zhong-duan-priority-d-ipriorityr">1.3.5 中断priority D_IPRIORITYR</span><a href="#1-3-5-zhong-duan-priority-d-ipriorityr" class="header-anchor">#</a></h3><p>Cortex-A7 使用了 512 个中断 ID，每个中断 ID 配有一个优先级寄存器，所以一共有 512 个 <code>D_IPRIORITYR </code>寄存器。如果优先级个数为 32 的话，使用寄存器 <code>D_IPRIORITYR 的 bit7:4 </code>来设置优先级，也就是说实际的优先级要左移 3 位。比如要设置ID40 中断的优先级为 5，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GICD_IPRIORITYR[<span class="number">40</span>] = <span class="number">5</span> &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="1-4-zhong-duan-zhuang-tai-ji">1.4 中断状态机</span><a href="#1-4-zhong-duan-zhuang-tai-ji" class="header-anchor">#</a></h2><p>① <strong>非活动状态（Inactive）</strong>：这意味着该中断未触发。 </p>
<p>② <strong>挂起（Pending）</strong>：这意味着中断源已被触发，但正在等待CPU核处理。待处理的中断要通过转发到CPU接口单元，然后再由CPU接口单元转发到内核。</p>
<p>③ <strong>活动（Active）</strong>：描述了一个已被内核接收并正在处理的中断。 </p>
<p>④ <strong>活动和挂起（Active and pending）</strong>：描述了一种情况，其中CPU核正在为中断服务，而GIC又收到来自同一源的中断。</p>
<h2><span id="1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3">1.5 GIC初始化硬件流程（软件流程见3.3）</span><a href="#1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/6.png" alt="image"></p>
<h2><span id="1-6-gic-zhong-duan-chu-li">1.6 GIC中断处理</span><a href="#1-6-gic-zhong-duan-chu-li" class="header-anchor">#</a></h2><p>当CPU核接收到中断时，<code>cpu interface</code>中有<code>Interrupt Acknowledge Register</code>可以读，获取中断ID。并且标记为active状态。</p>
<p>当对应的中断服务程序执行完，会将中断ID写入<code>CPU interface</code>模块中的<code>End of Interrupt register</code>。标记为<code>inactive</code>或<code>pending</code>（如果状态为<code>inactive and pending</code>）。</p>
<h2><span id="1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao">1.7 GIC控制器寄存器介绍</span><a href="#1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao" class="header-anchor">#</a></h2><p>前面讲了GIC 架构分为了两个逻辑块：<code>Distributor </code>和<code> CPU Interface</code>，也就是分发器端和 CPU 接口端。</p>
<h3><span id="1-7-1-gic-de-nei-cun-ying-she">1.7.1 GIC的内存映射</span><a href="#1-7-1-gic-de-nei-cun-ying-she" class="header-anchor">#</a></h3><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/7.png" alt="image"><br>GIC基地址偏移0x1000是分发器 block, 偏移0x2000是CPU 接口端 block。</p>
<h4><span id="1-7-1-1-fen-fa-qi-ji-cun-qi">1.7.1.1 分发器寄存器</span><a href="#1-7-1-1-fen-fa-qi-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/8.png" alt="image"></p>
<h5><span id="1-7-1-1-1-gicd-ctlr-distributor-control-register">1.7.1.1.1 GICD_CTLR(Distributor Control Register)</span><a href="#1-7-1-1-1-gicd-ctlr-distributor-control-register" class="header-anchor">#</a></h5><p><code>Distributor Control Register</code>，分发器控制寄存器。</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/9.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">EnableGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">用于将pending Group 1中断从Distributor转发到CPU interfaces 0：group 1中断不转发 1：根据优先级规则转发Group 1中断</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">EnableGrp0</td>
<td align="left">R&#x2F;W</td>
<td align="left">用于将pending Group 0中断从Distributor转发到CPU interfaces 0：group 0中断不转发 1：根据优先级规则转发Group 0中断</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-2-gicd-typer-controller-type-register">1.7.1.1.2 GICD_TYPER(Controller Type Register)</span><a href="#1-7-1-1-2-gicd-typer-controller-type-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/10.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">15:11</td>
<td align="left">LSPI</td>
<td align="left">R</td>
<td align="left">如果GIC实现了安全扩展，则此字段的值是已实现的可锁定SPI的最大数量，范围为0（0b00000）到31（0b11111）。 如果此字段为0b00000，则GIC不会实现配置锁定。 如果GIC没有实现安全扩展，则保留该字段。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">SecurityExtn</td>
<td align="left">R</td>
<td align="left">表示GIC是否实施安全扩展： 0未实施安全扩展； 1实施了安全扩展</td>
</tr>
<tr>
<td align="left">7:5</td>
<td align="left">CPUNumber</td>
<td align="left">R</td>
<td align="left">表示已实现的CPU interfaces的数量。 已实现的CPU interfaces数量比该字段的值大1。 例如，如果此字段为0b011，则有四个CPU interfaces。</td>
</tr>
<tr>
<td align="left">4:0</td>
<td align="left">ITLinesNumber</td>
<td align="left">R</td>
<td align="left">表示GIC支持的最大中断数。 如果ITLinesNumber &#x3D; N，则最大中断数为32*(N+1)。 中断ID的范围是0到（ID的数量– 1）。 例如：0b00011最多128条中断线，中断ID 0-127。 中断的最大数量为1020（0b11111）。 无论此字段定义的中断ID的范围如何，都将中断ID 1020-1023保留用于特殊目的</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-3-gicd-iidr-implementer-identification-register">1.7.1.1.3 GICD_IIDR(Implementer Identification Register)</span><a href="#1-7-1-1-3-gicd-iidr-implementer-identification-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/11.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:24</td>
<td align="left">ProductID</td>
<td align="left">R</td>
<td align="left">产品标识ID</td>
</tr>
<tr>
<td align="left">23:20</td>
<td align="left">保留</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">19:16</td>
<td align="left">Variant</td>
<td align="left">R</td>
<td align="left">通常是产品的主要版本号</td>
</tr>
<tr>
<td align="left">15:12</td>
<td align="left">Revision</td>
<td align="left">R</td>
<td align="left">通常此字段用于区分产品的次版本号</td>
</tr>
<tr>
<td align="left">11:0</td>
<td align="left">Implementer</td>
<td align="left">R</td>
<td align="left">含有实现这个GIC的公司的JEP106代码； [11:8]：JEP106 continuation code，对于ARM实现，此字段为0x4； [7]：始终为0； [6:0]：实现者的JEP106code，对于ARM实现，此字段为0x3B</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-4-gicd-igrouprn-group-registers">1.7.1.1.4 GICD_IGROUPRn(Group Registers)</span><a href="#1-7-1-1-4-gicd-igrouprn-group-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/12.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Group status bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">组状态位，对于每个位： 0：相应的中断为Group 0； 1：相应的中断为Group 1。</td>
</tr>
</tbody></table>
<p>对于一个中断，如何设置它的Group ？首先找到对应的<code>GICD_IGROUPRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一位。</p>
<p>对于<code>interrtups ID m</code>，如下计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = m DIV <span class="number">32</span>，GICD_IGROUPRn里的n就确定了；</span><br><span class="line">GICD_IGROUPRn在GIC内部的偏移地址是多少？<span class="number">0x080</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_IPRIORITYRn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-5-gicd-isenablern-set-enable-registers">1.7.1.1.5 GICD_ISENABLERn(Set-Enable Registers)</span><a href="#1-7-1-1-5-gicd-isenablern-set-enable-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/13.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Set-enable bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于SPI和PPI类型的中断，每一位控制对应中断的转发行为：从Distributor转发到CPU interface： 读： 0：表示当前是禁止转发的； 1：表示当前是使能转发的； 写： 0：无效 1：使能转发</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ISENABLERn</code>并确定相应的位？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">32</span>，GICD_ISENABLERn里的n就确定了；</span><br><span class="line">GICD_ISENABLERn在GIC内部的偏移地址是多少？<span class="number">0x100</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_ISENABLERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-6-gicd-icenablern-clear-enable-registers">1.7.1.1.6 GICD_ICENABLERn(Clear-Enable Registers)</span><a href="#1-7-1-1-6-gicd-icenablern-clear-enable-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/14.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Clear-enable bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于SPI和PPI类型的中断，每一位控制对应中断的转发行为：从Distributor转发到CPU interface： 读： 0：表示当前是禁止转发的； 1：表示当前是使能转发的； 写： 0：无效 1：禁止转发</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ICENABLERn</code>并确定相应的位？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">32</span>，GICD_ISENABLERn里的n就确定了；</span><br><span class="line">GICD_ISENABLERn在GIC内部的偏移地址是多少？<span class="number">0x100</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_ISENABLERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-7-gicd-isactivern-set-active-registers">1.7.1.1.7 GICD_ISACTIVERn(Set-Active Registers)</span><a href="#1-7-1-1-7-gicd-isactivern-set-active-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/15.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Set-active bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">读： 0：表示相应中断不是active状态； 1：表示相应中断是active状态； 写： 0：无效 1：把相应中断设置为active状态，如果中断已处于Active状态，则写入无效</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ISACTIVERn</code>并确定相应的位？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 32，GICD_ISACTIVERn里的n就确定了；</span><br><span class="line">GICD_ISACTIVERn在GIC内部的偏移地址是多少？0x300+(4*n)</span><br><span class="line">使用GICD_ISACTIVERn 中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod 32。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-8-gicd-icactivern-clear-active-registers">1.7.1.1.8 GICD_ICACTIVERn(Clear-Active Registers)</span><a href="#1-7-1-1-8-gicd-icactivern-clear-active-registers" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Clear-active bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">读： 0：表示相应中断不是active状态； 1：表示相应中断是active状态； 写： 0：无效 1：把相应中断设置为deactive状态，如果中断已处于dective状态，则写入无效</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ICACTIVERn</code>并确定相应的位？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 32，GICD_ICACTIVERn里的n就确定了；</span><br><span class="line">GICD_ICACTIVERn 在GIC内部的偏移地址是多少？0x380+(4*n)</span><br><span class="line">使用GICD_ICACTIVERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod 32。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-9-gicd-ipriorityrn-priority-registers">1.7.1.1.9 GICD_IPRIORITYRn(Priority Registers)</span><a href="#1-7-1-1-9-gicd-ipriorityrn-priority-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/16.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">位域</td>
<td align="left">名</td>
<td align="left">读写</td>
<td align="left">描述</td>
</tr>
<tr>
<td align="left">31:24</td>
<td align="left">Priority, byte offset 3</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的8位数据用来描述：它的优先级。 每个优先级字段都对应一个优先级值，值越小，相应中断的优先级越高</td>
</tr>
<tr>
<td align="left">23:16</td>
<td align="left">Priority, byte offset 2</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">15:8</td>
<td align="left">Priority, byte offset 1</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7:0</td>
<td align="left">Priority, byte offset 0</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>如何设置它的优先级(<code>Priority</code>)，首先找到对应的<code>GICD_IPRIORITYRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">4</span>，GICD_IPRIORITYRn里的n就确定了；</span><br><span class="line">GICD_IPRIORITYRn在GIC内部的偏移地址是多少？<span class="number">0x400</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_IPRIORITYRn中<span class="number">4</span>个字节中的哪一个来表示interrtups ID m的优先级？</span><br><span class="line">byte offset = m mod <span class="number">4</span>。</span><br><span class="line">byte offset <span class="number">0</span>对应寄存器里的[<span class="number">7</span>:<span class="number">0</span>]；</span><br><span class="line">byte offset <span class="number">1</span>对应寄存器里的[<span class="number">15</span>:<span class="number">8</span>]；</span><br><span class="line">byte offset <span class="number">2</span>对应寄存器里的[<span class="number">23</span>:<span class="number">16</span>]；</span><br><span class="line">byte offset <span class="number">3</span>对应寄存器里的[<span class="number">31</span>:<span class="number">24</span>]。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-10-gicd-itargetsrn-processor-targets-registers">1.7.1.1.10 GICD_ITARGETSRn(Processor Targets Registers)</span><a href="#1-7-1-1-10-gicd-itargetsrn-processor-targets-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/17.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">位域</td>
<td align="left">名</td>
<td align="left">读写</td>
<td align="left">描述</td>
</tr>
<tr>
<td align="left">31:24</td>
<td align="left">CPU targets, byte offset 3</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的8位数据用来描述：这个中断可以发给哪些CPU。 处理器编号从0开始，8位数里每个位均指代相应的处理器。 例如，值0x3表示将中断发送到处理器0和1。 当读取GICD_ITARGETSR0～GICD_ITARGETSR7时，读取里面任意字节，返回的都是执行这个读操作的CPU的编号。</td>
</tr>
<tr>
<td align="left">23:16</td>
<td align="left">CPU targets, byte offset 2</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">15:8</td>
<td align="left">CPU targets, byte offset 1</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7:0</td>
<td align="left">CPU targets, byte offset 0</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>如何设置它的目杯CPU？优先级(<code>Priority</code>)，首先找到对应的<code>GICD_ITARGETSRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 4，GICD_ITARGETSRn里的n就确定了；</span><br><span class="line">GICD_ITARGETSRn在GIC内部的偏移地址是多少？0x800+(4*n)</span><br><span class="line">使用GICD_ITARGETSRn中4个字节中的哪一个来表示interrtups ID m的目标CPU？</span><br><span class="line">byte offset = m mod 4。</span><br><span class="line">byte offset 0对应寄存器里的[7:0]；</span><br><span class="line">byte offset 1对应寄存器里的[15:8]；</span><br><span class="line">byte offset 2对应寄存器里的[23:16]；</span><br><span class="line">byte offset 3对应寄存器里的[31:24]。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-11-gicd-icfgrn-configuration-registers">1.7.1.1.11 GICD_ICFGRn(Configuration Registers)</span><a href="#1-7-1-1-11-gicd-icfgrn-configuration-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/18.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[2F+1:2F]</td>
<td align="left">Int_config, field F</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的2位数据用来描述：它的边沿触发，还是电平触发。 对于Int_config [1]，即高位[2F + 1]，含义为： 0：相应的中断是电平触发； 1：相应的中断是边沿触发。 对于Int_config [0]，即低位[2F]，是保留位。</td>
</tr>
</tbody></table>
<p>如何找到<code>GICD_ICFGRn</code>并确定相应的位域F？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">16</span>，GICD_ICFGRn里的n就确定了；</span><br><span class="line">GICD_ICACTIVERn 在GIC内部的偏移地址是多少？<span class="number">0xC00</span>+(<span class="number">4</span>*n)</span><br><span class="line">F = m mod <span class="number">16</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register">1.7.1.1.12 ICPIDR2(Identification registers: Peripheral ID2 Register)</span><a href="#1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/19.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">由实现定义</td>
</tr>
<tr>
<td align="left">[7:4]</td>
<td align="left">ArchRev</td>
<td align="left">R</td>
<td align="left">该字段的值取决于GIC架构版本： 0x1：GICv1； 0x2：GICv2。</td>
</tr>
<tr>
<td align="left">[3:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">由实现定义</td>
</tr>
</tbody></table>
<h4><span id="1-7-1-2-cpu-jie-kou-duan-ji-cun-qi">1.7.1.2 cpu接口端寄存器</span><a href="#1-7-1-2-cpu-jie-kou-duan-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/20.png" alt="image"></p>
<h5><span id="1-7-1-2-1-gicc-ctlr-cpu-interface-control-register">1.7.1.2.1 GICC_CTLR(CPU Interface Control Register)</span><a href="#1-7-1-2-1-gicc-ctlr-cpu-interface-control-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/21.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:10]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[9]</td>
<td align="left">EOImodeNS</td>
<td align="left">R&#x2F;W</td>
<td align="left">控制对GICC_EOIR和GICC_DIR寄存器的非安全访问： 0：GICC_EOIR具有降低优先级和deactivate中断的功能； 对GICC_DIR的访问是未定义的。 1：GICC_EOIR仅具有降低优先级功能； GICC_DIR寄存器具有deactivate中断功能。</td>
</tr>
<tr>
<td align="left">[8:7]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[6]</td>
<td align="left">IRQBypDisGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">当CPU interface的IRQ信号被禁用时，该位控制是否向处理器发送bypass IRQ信号： 0：将bypass IRQ信号发送给处理器； 1：将bypass IRQ信号不发送到处理器。</td>
</tr>
<tr>
<td align="left">[5]</td>
<td align="left">FIQBypDisGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">当CPU interface的FIQ信号被禁用时，该位控制是否向处理器发送bypass FIQ信号： 0：将bypass FIQ信号发送给处理器； 1：旁路FIQ信号不发送到处理器</td>
</tr>
<tr>
<td align="left">[4:1]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">使能CPU interface向连接的处理器发出的组1中断的信号: 0：禁用中断信号 1：使能中断信号</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-2-gicc-pmr-priority-mask-register">1.7.1.2.2 GICC_PMR(Priority Mask Register)</span><a href="#1-7-1-2-2-gicc-pmr-priority-mask-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/22.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:8]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[7:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">优先级高于这个值的中断，才会发送给CPU</td>
</tr>
</tbody></table>
<p><code>[7:0]</code>共8位，可以表示256个优先级。但是某些芯片里的GIC支持的优先级少于256个，则某些位为RAZ &#x2F; WI，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果有128个级别，则寄存器中bit[0] = 0b0，即使用[7:1]来表示优先级；</span><br><span class="line">如果有64个级别，则寄存器中bit[1:0] = 0b00，即使用[7:2]来表示优先级；</span><br><span class="line">如果有32个级别，则寄存器中bit[2:0] = 0b000，即使用[7:3]来表示优先级；</span><br><span class="line">如果有16个级别，则寄存器中bit[3:0] = 0b0000，即使用[7:4]来表示优先级；</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-2-3-gicc-bpr-binary-point-register">1.7.1.2.3 GICC_BPR(Binary Point Register)</span><a href="#1-7-1-2-3-gicc-bpr-binary-point-register" class="header-anchor">#</a></h5><p>此寄存器用来把8位的优先级字段拆分为组优先级和子优先级，组优先级用来决定中断抢占。</p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:3]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[2:0]</td>
<td align="left">Binary point</td>
<td align="left">R&#x2F;W</td>
<td align="left">此字段的值控制如何将8bit中断优先级字段拆分为组优先级和子优先级，组优先级用来决定中断抢占。 更多信息还得看看GIC手册。</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-4-gicc-iar-acknowledge-register">1.7.1.2.4 GICC_IAR(Acknowledge Register)</span><a href="#1-7-1-2-4-gicc-iar-acknowledge-register" class="header-anchor">#</a></h5><p>读此寄存器，获得当前中断的<code>interrtup ID</code>。</p>
<p><code>GICC_IAR</code>寄存器描述来自<code>《ARM Generic Interrupt Controller Architecture Specification.pdf》</code>,它用来表示中断ID号。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/23.png" alt="image"><br>处理完具体的中断处理函数，需要将<code>GICC_IAR</code>寄存器的值写入<code>GICC_EOIR</code>寄存器中。</p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:13]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[12:10]</td>
<td align="left">CPUID</td>
<td align="left">R</td>
<td align="left">对于SGI类中断，它表示谁发出了中断。例如，值为3表示该请求是通过对CPU interface 3上的GICD_SGIR的写操作生成的。</td>
</tr>
<tr>
<td align="left">[9:0]</td>
<td align="left">Interrupt ID</td>
<td align="left">R</td>
<td align="left">中断ID</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-5-gicc-eoir-interrupt-register">1.7.1.2.5 GICC_EOIR(Interrupt Register)</span><a href="#1-7-1-2-5-gicc-eoir-interrupt-register" class="header-anchor">#</a></h5><p> 写此寄存器，表示某中断已经处理完毕。<code>GICC_IAR</code>的值表示当前在处理的中断，把<code>GICC_IAR</code>的值写入<code>GICC_EOIR</code>就表示中断处理完了。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/24.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:13]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[12:10]</td>
<td align="left">CPUID</td>
<td align="left">W</td>
<td align="left">对于SGI类中断，它的值跟GICD_IAR. CPUID的相同。</td>
</tr>
<tr>
<td align="left">[9:0]</td>
<td align="left">EOIINTID</td>
<td align="left">W</td>
<td align="left">中断ID，它的值跟GICD_IAR里的中断ID相同</td>
</tr>
</tbody></table>
<h1><span id="2-zhong-duan-shi-li-start-s-fen-xi">2. 中断示例start.s分析</span><a href="#2-zhong-duan-shi-li-start-s-fen-xi" class="header-anchor">#</a></h1><p>以nxp的IMX6UL为例，SDK中<code>core_ca7.h</code>定了了GIC相关函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GIC_Init</td>
<td>初始化 GIC。</td>
</tr>
<tr>
<td>GIC_EnableIRQ</td>
<td>使能指定的外设中断。</td>
</tr>
<tr>
<td>GIC_DisableIRQ</td>
<td>关闭指定的外设中断。</td>
</tr>
<tr>
<td>GIC_AcknowledgeIRQ</td>
<td>返回中断号。</td>
</tr>
<tr>
<td>GIC_DeactivateIRQ</td>
<td>无效化指定中断。</td>
</tr>
<tr>
<td>GIC_GetRunningPriority</td>
<td>获取当前正在运行的中断优先级。</td>
</tr>
<tr>
<td>GIC_SetPriorityGrouping</td>
<td>设置抢占优先级位数。</td>
</tr>
<tr>
<td>GIC_GetPriorityGrouping</td>
<td>获取抢占优先级位数。</td>
</tr>
<tr>
<td>GIC_SetPriority</td>
<td>设置指定中断的优先级。</td>
</tr>
<tr>
<td>GIC_GetPriority</td>
<td>获取指定中断的优先级。</td>
</tr>
</tbody></table>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start  				<span class="comment">/* 全局标号 */</span></span><br><span class="line">_start:</span><br><span class="line">	ldr pc, =Reset_Handler		<span class="comment">/* 复位中断 					*/</span>	</span><br><span class="line">	ldr pc, =Undefined_Handler	<span class="comment">/* 未定义中断 					*/</span></span><br><span class="line">	ldr pc, =SVC_Handler		<span class="comment">/* SVC(Supervisor)中断 		*/</span></span><br><span class="line">	ldr pc, =PrefAbort_Handler	<span class="comment">/* 预取终止中断 					*/</span></span><br><span class="line">	ldr pc, =DataAbort_Handler	<span class="comment">/* 数据终止中断 					*/</span></span><br><span class="line">	ldr	pc, =NotUsed_Handler	<span class="comment">/* 未使用中断					*/</span></span><br><span class="line">	ldr pc, =IRQ_Handler		<span class="comment">/* IRQ中断 					*/</span></span><br><span class="line">	ldr pc, =FIQ_Handler		<span class="comment">/* FIQ(快速中断)未定义中断 			*/</span></span><br><span class="line"><span class="comment">/* 复位中断 */</span>	</span><br><span class="line">Reset_Handler:</span><br><span class="line">	cpsid i						<span class="comment">/* 关闭全局中断 */</span></span><br><span class="line">	<span class="comment">/* 关闭I,DCache和MMU </span></span><br><span class="line"><span class="comment">	 * 采取读-改-写的方式。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mrc     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 读取CP15的C1寄存器到R0中       		        	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">12</span>)     <span class="comment">/* 清除C1寄存器的bit12位(I位)，关闭I Cache            	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt;  <span class="number">2</span>)     <span class="comment">/* 清除C1寄存器的bit2(C位)，关闭D Cache    				*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x2</span>             <span class="comment">/* 清除C1寄存器的bit1(A位)，关闭对齐						*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">11</span>)     <span class="comment">/* 清除C1寄存器的bit11(Z位)，关闭分支预测					*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x1</span>             <span class="comment">/* 清除C1寄存器的bit0(M位)，关闭MMU				       	*/</span></span><br><span class="line">    mcr     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 将r0寄存器中的值写入到CP15的C1寄存器中	 				*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 汇编版本设置中断向量表偏移 */</span></span><br><span class="line">	ldr r0, =<span class="number">0X87800000</span></span><br><span class="line"></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	mcr p15, <span class="number">0</span>, r0, c12, c0, <span class="number">0</span></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 设置各个模式下的栈指针，</span></span><br><span class="line"><span class="comment">	 * 注意：IMX6UL的堆栈是向下增长的！</span></span><br><span class="line"><span class="comment">	 * 堆栈指针地址一定要是4字节地址对齐的！！！</span></span><br><span class="line"><span class="comment">	 * DDR范围:0X80000000~0X9FFFFFFF</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x12</span> 	<span class="comment">/* r0或上0x13,表示使用IRQ模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80600000</span>	<span class="comment">/* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */</span></span><br><span class="line">	<span class="comment">/* 进入SYS模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* r0或上0x13,表示使用SYS模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80400000</span>	<span class="comment">/* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */</span></span><br><span class="line">	<span class="comment">/* 进入SVC模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x13</span> 	<span class="comment">/* r0或上0x13,表示使用SVC模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0X80200000</span>	<span class="comment">/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */</span></span><br><span class="line">	cpsie i				<span class="comment">/* 打开全局中断 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 使能IRQ中断 */</span></span><br><span class="line">	mrs r0, cpsr		<span class="comment">/* 读取cpsr寄存器值到r0中 			*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0x80</span>	<span class="comment">/* 将r0寄存器中bit7清零，也就是CPSR中的I位清零，表示允许IRQ中断 */</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0重新写入到cpsr中 			*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	b main				<span class="comment">/* 跳转到main函数 			 	*/</span></span><br><span class="line"><span class="comment">/* 未定义中断 */</span></span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, =Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* SVC中断 */</span></span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 预取终止中断 */</span></span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler	</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 数据终止中断 */</span></span><br><span class="line">DataAbort_Handler:</span><br><span class="line">	ldr r0, =DataAbort_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 未使用的中断 */</span></span><br><span class="line">NotUsed_Handler:</span><br><span class="line">	ldr r0, =NotUsed_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IRQ中断！重点！！！！！ */</span></span><br><span class="line">IRQ_Handler:</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存lr地址 */</span></span><br><span class="line">	push &#123;r0-r3, r12&#125;			<span class="comment">/* 保存r0-r3，r12寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrs r0, spsr				<span class="comment">/* 读取spsr寄存器 */</span></span><br><span class="line">	push &#123;r0&#125;					<span class="comment">/* 保存spsr寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrc p15, <span class="number">4</span>, r1, c15, c0, <span class="number">0</span> <span class="comment">/* 从CP15的C0寄存器内的值到R1寄存器中</span></span><br><span class="line"><span class="comment">								* 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49</span></span><br><span class="line"><span class="comment">								* Cortex-A7 Technical ReferenceManua.pdf P68 P138</span></span><br><span class="line"><span class="comment">								*/</span>							</span><br><span class="line">	add r1, r1, #<span class="number">0X2000</span>			<span class="comment">/* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */</span></span><br><span class="line">	ldr r0, [r1, #<span class="number">0XC</span>]			<span class="comment">/* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，</span></span><br><span class="line"><span class="comment">								 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据</span></span><br><span class="line"><span class="comment">								 * 这个中断号来绝对调用哪个中断服务函数</span></span><br><span class="line"><span class="comment">								 */</span></span><br><span class="line">	push &#123;r0, r1&#125;				<span class="comment">/* 保存r0,r1 */</span></span><br><span class="line">	</span><br><span class="line">	cps #<span class="number">0x13</span>					<span class="comment">/* 进入SVC模式，允许其他中断再次进去 */</span></span><br><span class="line">	</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存SVC模式的lr寄存器 */</span></span><br><span class="line">	ldr r2, =system_irqhandler	<span class="comment">/* 加载C语言中断处理函数到r2寄存器中*/</span></span><br><span class="line">	blx r2						<span class="comment">/* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* 执行完C语言中断服务函数，lr出栈 */</span></span><br><span class="line">	cps #<span class="number">0x12</span>					<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	pop &#123;r0, r1&#125;				</span><br><span class="line">	str r0, [r1, #<span class="number">0X10</span>]			<span class="comment">/* 中断执行完成，写EOIR */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0&#125;						</span><br><span class="line">	msr spsr_cxsf, r0			<span class="comment">/* 恢复spsr */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0-r3, r12&#125;			<span class="comment">/* r0-r3,r12出栈 */</span></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* lr出栈 */</span></span><br><span class="line">	subs pc, lr, #<span class="number">4</span>				<span class="comment">/* 将lr-4赋给pc */</span></span><br><span class="line"><span class="comment">/* FIQ中断 */</span></span><br><span class="line">FIQ_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =FIQ_Handler	</span><br><span class="line">	bx r0</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-1-start-s-qi-dong-liu-cheng">2.1 start.s启动流程</span><a href="#2-1-start-s-qi-dong-liu-cheng" class="header-anchor">#</a></h2><ol>
<li>进入<code>_start</code>,初始化异常向量表。进入复位中断，初始化时钟，关闭看门狗，关闭<code>MMU</code>和<code>ICACHE</code> <code>DCACHE</code>,关闭总中断</li>
<li>设置各个模式的<code>SP</code>指针</li>
<li>代码段重定位到DDR上并且清bss段</li>
<li>开启总中断</li>
<li>跳转到C语言main函数执行</li>
</ol>
<p>这里很多流程如代码重定位，清除bss，关闭看门狗等没有列举出来。</p>
<h1><span id="3-gic-zhong-duan-chu-li-liu-cheng">3 GIC中断处理流程</span><a href="#3-gic-zhong-duan-chu-li-liu-cheng" class="header-anchor">#</a></h1><h2><span id="3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.1 一级中断控制器流程</span><a href="#3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/25.png" alt="image"></p>
<ul>
<li>假设GIC可以向CPU发出<code>16-1019</code>号中断，这些数字被称为<code>hwirq</code>。<code>0-15</code>用于Process之间通信，比较特殊。</li>
<li>假设要使用UART模块，它发出的中断连接到GIC的32号中断，分配的<code>irq_desc</code>序号为16</li>
<li>在<code>GIC domain</code>中会记录<code>(32, 16)</code></li>
<li>那么注册中断时就是：<code>request_irq(16, ...)</code></li>
<li>发生UART中断时    <ul>
<li>程序从GIC中读取寄存器知道发生了32号中断，通过GIC <code>irq_domain</code>可以知道<code>virq</code>为16</li>
<li>调用<code>irq_desc[16]</code>中的<code>handleA</code>函数，它的作用是调用action链表中用户注册的函数.</li>
</ul>
</li>
</ul>
<h2><span id="3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.2 多级中断控制器流程</span><a href="#3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/26.png" alt="img"></p>
<ul>
<li>假设GPIO模块下有4个引脚，都可以产生中断，都连接到GIC的33号中断</li>
<li><strong>GPIO也可以看作一个中断控制器</strong>，对于它的4个中断</li>
<li>对于GPIO模块中<code>0~3</code>这四个<code>hwirq</code>，一般都会一下子分配四个<code>irq_desc</code></li>
<li>假设这4个<code>irq_desc</code>的序号为<code>100~103</code>，在<code>GPIO domain</code>中记录<code>(0,100) (1,101)(2,102) (3,103)</code></li>
<li>对于KEY，注册中断时就是：<code>request_irq(102, ...)</code></li>
<li>按下KEY时：    <ul>
<li>程序从GIC中读取寄存器知道发生了33号中断，通过<code>GIC irq_domain</code>可以知道virq为16.</li>
<li>调用<code>irq_desc[16]</code>中的<code>handleB</code>函数      <ul>
<li><code>handleB</code>读取GPIO寄存器，确定是GPIO里2号引脚发生中断</li>
<li>通过GPIO<code> irq_domain</code>可以知道<code>virq</code>为102</li>
<li>调用<code>irq_desc[102]</code>中的<code>handleA</code>函数，它的作用是调用<code>action</code>链表中用户注册的函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="3-3-gic-ruan-jian-chu-shi-hua-guo-cheng">3.3 GIC软件初始化过程</span><a href="#3-3-gic-ruan-jian-chu-shi-hua-guo-cheng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_kernel (init\main.c)</span><br><span class="line">    init_IRQ (arch\arm\kernel\irq.c)</span><br><span class="line">    	irqchip_init (drivers\irqchip\irqchip.c)</span><br><span class="line">    		of_irq_init (drivers\of\irq.c)<span class="comment">//gic子系统</span></span><br><span class="line">    			desc-&gt;irq_init_cb = match-&gt;data;</span><br><span class="line">                ret = desc-&gt;irq_init_cb(desc-&gt;dev,</span><br><span class="line">                            desc-&gt;interrupt_parent);</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-1-gic-qu-dong-zhu-ce">3.3.1 gic驱动注册</span><a href="#3-3-1-gic-qu-dong-zhu-ce" class="header-anchor">#</a></h3><p>内核支持多种GIC, 在内核为每一类GIC定义一个结构体<code>of_device_id</code>，并放在一个段里：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// drivers\irqchip\irq-gic.c</span></span><br><span class="line">IRQCHIP_DECLARE(gic_400, <span class="string">&quot;arm,gic-400&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(arm11mp_gic, <span class="string">&quot;arm,arm11mp-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(arm1176jzf_dc_gic, <span class="string">&quot;arm,arm1176jzf-devchip-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a15_gic, <span class="string">&quot;arm,cortex-a15-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a9_gic, <span class="string">&quot;arm,cortex-a9-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a7_gic, <span class="string">&quot;arm,cortex-a7-gic&quot;</span>, gic_of_init);<span class="comment">//imx6ull对应gic类型</span></span><br><span class="line">IRQCHIP_DECLARE(msm_8660_qgic, <span class="string">&quot;qcom,msm-8660-qgic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(msm_qgic2, <span class="string">&quot;qcom,msm-qgic2&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(pl390, <span class="string">&quot;arm,pl390&quot;</span>, gic_of_init);</span><br></pre></td></tr></table></figure>

<p><code> IRQCHIP_DECLARE</code>宏进行展开：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include\linux\irqchip.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQCHIP_DECLARE(name, compat, fn) OF_DECLARE_2(irqchip, name, compat, fn)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_DECLARE_2(table, name, compat, fn) \</span></span><br><span class="line"><span class="meta">		_OF_DECLARE(table, name, compat, fn, of_init_fn_2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)			\</span></span><br><span class="line"><span class="meta">	static const struct of_device_id __of_table_##name		\</span></span><br><span class="line"><span class="meta">		__used __section(__irqchip_of_table)			\</span></span><br><span class="line"><span class="meta">		 = &#123; .compatible = compat,				\</span></span><br><span class="line"><span class="meta">		     .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：<code>IRQCHIP_DECLARE(cortex_a7_gic, &quot;arm,cortex-a7-gic&quot;, gic_of_init);</code>展开后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_cortex_a7_gic</span>		\</span></span><br><span class="line"><span class="class">	__<span class="title">used</span> __<span class="title">section</span>(__<span class="title">irqchip_of_table</span>)			\</span></span><br><span class="line"><span class="class">	 =</span> &#123; .compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>,				\</span><br><span class="line">		 .data = gic_of_init  &#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-1-1-dts-pi-pei">3.3.1.1 dts匹配</span><a href="#3-3-1-1-dts-pi-pei" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/27.png" alt="在这里插入图片描述"></p>
<p>根据dts匹配调用<code>IRQCHIP_DECLARE(cortex_a7_gic, &quot;arm,cortex-a7-gic&quot;, gic_of_init);</code>, 对<code>irq chip driver</code> 的声明。</p>
<p>定义 <code>IRQCHIP_DECLARE </code>之后，相应的内容会保存到 <code>__irqchip_of_table </code>里。<code>__irqchip_of_table </code>在链接脚本 <code>vmlinux.lds </code>里，被放到了<code>__irqchip_begin</code>和 <code>__irqchip_of_end</code> 之间，该段用于存放中断控制器信息。</p>
<h4><span id="3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou">3.3.1.2 gic_of_init(GIC驱动初始化入口)</span><a href="#3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou" class="header-anchor">#</a></h4><p><code>gic_of_init</code>内容太多，大致就是对中断控制器初始化：</p>
<ol>
<li><p>初始化<code>GICD</code>(分发器寄存器)</p>
</li>
<li><p>初始化<code>GICC</code>(cpu接口端寄存器)</p>
</li>
<li><p>调用<code>gic_init_bases</code> 流程</p>
<ol>
<li><p>调用<code>set_handle_irq</code>注册<code>gic_handle_irq</code>,异常处理的入口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">set_handle_irq</span><span class="params">(<span class="type">void</span> (*handle_irq)(<span class="keyword">struct</span> pt_regs *))</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (handle_arch_irq)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> handle_arch_irq = handle_irq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gic_init_bases</span><span class="params">(<span class="type">void</span> __iomem *dist_base,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> redist_region *rdist_regs,</span></span><br><span class="line"><span class="params">     u32 nr_redist_regions,</span></span><br><span class="line"><span class="params">     u64 redist_stride,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> fwnode_handle *handle)</span> &#123;</span><br><span class="line"> set_handle_irq(gic_handle_irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4><span id="3-3-1-3-shen-qing-gic-zhong-duan">3.3.1.3 申请GIC中断</span><a href="#3-3-1-3-shen-qing-gic-zhong-duan" class="header-anchor">#</a></h4><h5><span id="3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan">3.3.1.3.1 在设备树里指定中断</span><a href="#3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/28.png" alt="image-20240809003246767"></p>
<h5><span id="3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li">3.3.1.3.2 对设备树中断的处理</span><a href="#3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/29.png" alt="在这里插入图片描述"></p>
<h2><span id="3-4-gic-zhong-duan-chu-guo-cheng">3.4 GIC中断处过程</span><a href="#3-4-gic-zhong-duan-chu-guo-cheng" class="header-anchor">#</a></h2><ol>
<li>进入中断栈<code>irq_stack_entry</code></li>
<li>执行中断控制器的中断入口<code>handle_arch_irq</code></li>
<li>退出中断栈<code>irq_stack_exit</code></li>
</ol>
<p>中断栈用来保存中断的上下文，中断发生和退出的时候调用 <code>irq_stack_entry </code>和 <code>irq_stack_exit </code>来进入和退出中断栈。</p>
<h3><span id="3-4-1-handle-arch-irq-ru-kou">3.4.1 handle_arch_irq入口</span><a href="#3-4-1-handle-arch-irq-ru-kou" class="header-anchor">#</a></h3><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/30.png" alt="image-20240810150555648"></p>
<h4><span id="3-4-1-1-gic-handle-irq">3.4.1.1 gic_handle_irq</span><a href="#3-4-1-1-gic-handle-irq" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> asmlinkage <span class="type">void</span> __exception_irq_entry <span class="title function_">gic_handle_irq</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span>&#123;</span><br><span class="line"> u32 irqnr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  irqnr = gic_read_iar();                                     ------(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (likely(irqnr &gt; <span class="number">15</span> &amp;&amp; irqnr &lt; <span class="number">1020</span>) || irqnr &gt;= <span class="number">8192</span>) &#123;  ------(<span class="number">2</span>)</span><br><span class="line">   <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate))</span><br><span class="line">    gic_write_eoir(irqnr);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    isb();</span><br><span class="line"></span><br><span class="line">   err = handle_domain_irq(gic_data.domain, irqnr, regs);    ------(<span class="number">3</span>)</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;Unexpected interrupt received!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate)) &#123;</span><br><span class="line">     <span class="keyword">if</span> (irqnr &lt; <span class="number">8192</span>)</span><br><span class="line">      gic_write_dir(irqnr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     gic_write_eoir(irqnr);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (irqnr &lt; <span class="number">16</span>) &#123;                                          ------(<span class="number">4</span>)</span><br><span class="line">   gic_write_eoir(irqnr);</span><br><span class="line">   <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate))</span><br><span class="line">    gic_write_dir(irqnr);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Unlike GICv2, we don&#x27;t need an smp_rmb() here.</span></span><br><span class="line"><span class="comment">    * The control dependency from gic_read_iar to</span></span><br><span class="line"><span class="comment">    * the ISB in gic_write_eoir is enough to ensure</span></span><br><span class="line"><span class="comment">    * that any shared data read by handle_IPI will</span></span><br><span class="line"><span class="comment">    * be read after the ACK.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   handle_IPI(irqnr, regs);                                ------(<span class="number">5</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;Unexpected SGI received!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">while</span> (irqnr != ICC_IAR1_EL1_SPURIOUS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>读取中断控制器的寄存器<code>GICC_IAR</code>，并获取 <code>hwirq</code></li>
<li>外设触发的中断。硬件中断号<code>0-15</code>表示 <code>SGI (软件中断)</code>类型的中断，<code>15-1020 </code>表示外设中断（SPI或PPI共享中断类型），<code>8192-MAX </code>表示 LPI 类型的中断</li>
<li>中断控制器中断处理的主体</li>
<li>软件触发的中断</li>
<li>核间交互触发的中断</li>
</ol>
<h5><span id="3-4-1-1-1-handle-domain-irq">3.4.1.1.1 handle_domain_irq</span><a href="#3-4-1-1-1-handle-domain-irq" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/31.png" alt="image-20240810151815454"></p>
<ol>
<li>进入中断上下文</li>
<li>根据 <code>hwirq</code> 去查找 linux 中断号</li>
<li>通过中断号找到全局中断描述符数组<code>irq_desc[NR_IRQS]</code>中的一项，然后调用<code> generic_handle_irq_desc</code>，执行该 irq 号注册的<code> action</code></li>
<li>退出中断上下文</li>
</ol>
<h6><span id="3-4-1-1-1-1-generic-handle-irq">3.4.1.1.1.1 generic_handle_irq</span><a href="#3-4-1-1-1-1-generic-handle-irq" class="header-anchor">#</a></h6><p>把<code>generic_handle_irq</code>展开：</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/32.png" alt="image-20240810151917713"></p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/32-1.png" alt="image-20240810152019303"></p>
<p>调用 <code>desc-&gt;handle_irq </code>指向的回调函数。</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/33.png" alt="image-20240810152332559"></p>
<p><code>irq_domain_set_info</code> 根据硬件中断号的范围设置 <code>irq_desc-&gt;handle_irq </code>的指针，共享中断入口为<code> handle_fasteoi_irq</code>，私有中断入口为 <code>handle_percpu_devid_irq</code>。</p>
<ul>
<li><code>handle_percpu_devid_irq</code>：处理私有中断处理，在这个过程中会分别调用中断控制器的处理函数进行硬件操作，该函数调用 <code>action-&gt;handler()</code> 来进行中断处理</li>
<li><code>handle_fasteoi_irq</code>：处理共享中断，并且遍历 <code>irqaction</code> 链表，逐个调用 <code>action-&gt;handler() </code>函数，这个函数正是设备驱动程序调用 <code>request_irq/request_threaded_irq </code>接口注册的中断处理函数，此外如果中断线程化处理的话，还会调用<code>__irq_wake_thread</code>唤醒内核线程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> __handle_irq_event_percpu(<span class="keyword">struct</span> irq_desc *desc, <span class="type">unsigned</span> <span class="type">int</span> *flags) &#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">    for_each_action_of_desc(desc, action) &#123;            </span><br><span class="line">        <span class="type">irqreturn_t</span> res;</span><br><span class="line">        res = action-&gt;handler(irq, action-&gt;dev_id);<span class="comment">//requst_irq注册的函数</span></span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">            __irq_wake_thread(desc, action);          </span><br><span class="line">        <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">            *flags |= action-&gt;flags;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing">3.4.1.1.2 总结request_irq的函数如何被执行</span><a href="#3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/34.png" alt="image-20240810152452686"></p>
<h1><span id="4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu">4 中断控制器GIC的设备树描述</span><a href="#4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu" class="header-anchor">#</a></h1><p>中断控制器而言 ，设备树绑定信息参考文档<code>Documentation/devicetree/bindings/arm/gic.txt</code>。以nxp的<code>imx6ull.dtsi</code>为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line">	&lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ol>
<li><code>compatible</code> 属性值为<code>“arm,cortex-a7-gic”</code>在 Linux 内核源码中搜索<code>“arm,cortex-a7-gic”</code>即可找到 GIC 中断控制器驱动文件， GIC 中断控制器驱是架构通用的，在<code>drivers/irqchip/irq-gic.c</code></li>
<li><code>interrupt-cells </code>和<code>#address-cells、#size-cells </code>一样。<br> 2.1 每个 cells 都是 32 位整形值，对于 ARM 处理的GIC 来说，一共有 3 个 cells，这三个 cells 的含义如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第一个 cells：中断类型，<span class="number">0</span> 表示 SPI(共享) 中断，<span class="number">1</span> 表示 PPI（私有） 中断。</span><br><span class="line">第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 <span class="number">0</span>~<span class="number">987</span>，对于PPI</span><br><span class="line">       中断来说中断号的范围为 <span class="number">0</span>~<span class="number">15</span>。</span><br><span class="line">第三个 cells：标志，bit[<span class="number">3</span>:<span class="number">0</span>]表示中断触发类型，为 <span class="number">1</span> 的时候表示上升沿触发，</span><br><span class="line">       为 <span class="number">2</span> 的时候表示下降沿触发，为 <span class="number">4</span> 的时候表示高电平触发，为 <span class="number">8</span> 的时候表示低</span><br><span class="line">       电平触发。bit[<span class="number">15</span>:<span class="number">8</span>]为 PPI 中断的 CPU 掩码。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>interrupt-controller</code>表示该节点中断控制器</li>
</ol>
<p>对于gpio来说也可以作为中断控制器，如imx6ull的<code>gpio5</code>：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/35.png" alt="image"><br>对于 gpio5 来说一共有两条信息，中断类型都是 SPI，<br>触发电平都是<code> IRQ_TYPE_LEVEL_HIGH</code>。不同之处在于中断源，一个是 74，一个是 75，打开可以打开《IMX6ULL 参考手册》的<code>“Chapter 3 Interrupts and DMA Events”</code>章节：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/36.png" alt="image"><br>GPIO5 一共用了 2 个中断号，一个是 74，一个是 75。其中 74 对应<code>GPIO5_IO00~GPIO5_IO15</code>这低 16 个 IO，75 对应 <code>GPIO5_IO16~GPIOI5_IO31 </code>这高 16 位 IO。</p>
<p>使用者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,fxls8471&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	position = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">	interrupt-parent = &lt;&amp;gpio5&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">0</span> <span class="number">8</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>fxls8471</code> 有一个中断引脚链接到了 I.MX6ULL 的<code>SNVS_TAMPER0</code>因脚上，这个引脚可以复用为<code>GPIO5_IO00 interrupts</code>设置中断信息，0 表示 <code>GPIO5_IO00</code>，8 表示低电平触发。</p>
<h2><span id="4-1-huo-qu-zhong-duan-hao-han-shu">4.1 获取中断号函数</span><a href="#4-1-huo-qu-zhong-duan-hao-han-shu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_of_parse_and_map</span><span class="params">(<span class="keyword">struct</span> device_node *dev,<span class="type">int</span> index)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_to_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gpio)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_create_mapping</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">				<span class="type">irq_hw_number_t</span> hwirq)</span>;</span><br></pre></td></tr></table></figure>

<p><code>irq_of_parse_and_map </code>函数从 interupts 属性中提取到对应的设备号，<br>dev：设备节点。<br>index：索引号，interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息。<br>返回值：中断号。</p>
<h2><span id="4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan">4.2 gic使用示例-按键gpio中断</span><a href="#4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan" class="header-anchor">#</a></h2><h3><span id="4-2-1-dts-miao-shu">4.2.1 dts描述</span><a href="#4-2-1-dts-miao-shu" class="header-anchor">#</a></h3><p>我们驱动一个按键，采用中断的方式，并且采用定时器来实现按键消抖，应用程序读取按键值并且通过终端打印出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">key &#123;</span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;atkalpha-key&quot;</span>;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_key&gt;;</span><br><span class="line">	key-gpio = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;; <span class="comment">/* KEY0 */</span></span><br><span class="line">	interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">18</span> IRQ_TYPE_EDGE_BOTH&gt;; <span class="comment">/* FALLING RISING */</span></span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到key使用<code>key-gpio</code>使用<code>GPIO1_IO18</code>, 可以看到也用到了gpio中断源interrupts，<code>IRQ_TYPE_EDGE_BOTH</code>定义在<code>include/linux/irq.h：</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	IRQ_TYPE_NONE = <span class="number">0x00000000</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_RISING = <span class="number">0x00000001</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_FALLING = <span class="number">0x00000002</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_BOTH = (IRQ_TYPE_EDGE_FALLING |</span><br><span class="line">		IRQ_TYPE_EDGE_RISING),</span><br><span class="line">	IRQ_TYPE_LEVEL_HIGH = <span class="number">0x00000004</span>,</span><br><span class="line">	IRQ_TYPE_LEVEL_LOW = <span class="number">0x00000008</span>,</span><br><span class="line">	IRQ_TYPE_LEVEL_MASK = (IRQ_TYPE_LEVEL_LOW |</span><br><span class="line">		IRQ_TYPE_LEVEL_HIGH),</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-2-qu-dong-dai-ma-yu-fen-xi">4.2.2 驱动代码与分析</span><a href="#4-2-2-qu-dong-dai-ma-yu-fen-xi" class="header-anchor">#</a></h3><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_NAME		<span class="string">&quot;imx6uirq&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断IO描述结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;								<span class="comment">/* gpio */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* imx6uirq设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">atomic_t</span> keyvalue;		<span class="comment">/* 有效的按键键值 */</span></span><br><span class="line">	<span class="type">atomic_t</span> releasekey;	<span class="comment">/* 标记是否完成一次完成的按键，包括按下和释放 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> <span class="title">imx6uirq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="type">long</span>)dev_id;</span><br><span class="line">	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">10</span>));	<span class="comment">/* 10ms定时 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)arg;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; 									<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="number">0x80</span> | keydesc-&gt;value);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">1</span>);	<span class="comment">/* 标记松开按键，即完成一次完整的按键过程 */</span>			</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	imx6uirq.nd = of_find_node_by_path(<span class="string">&quot;/key&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (imx6uirq.nd== <span class="literal">NULL</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;key node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd ,<span class="string">&quot;key-gpio&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;can&#x27;t get key%d\r\n&quot;</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));	<span class="comment">/* 缓冲区清零 */</span></span><br><span class="line">		<span class="built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="string">&quot;KEY%d&quot;</span>, i);		<span class="comment">/* 组合名字 */</span></span><br><span class="line">		gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);</span><br><span class="line">		gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);	</span><br><span class="line">		imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(imx6uirq.nd, i);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">		imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		printk(<span class="string">&quot;key%d:gpio=%d, irqnum=%d\r\n&quot;</span>,i, imx6uirq.irqkeydesc[i].gpio,</span><br><span class="line">                                         imx6uirq.irqkeydesc[i].irqnum);</span><br><span class="line">	&#125;</span><br><span class="line">	imx6uirq.irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	imx6uirq.irqkeydesc[<span class="number">0</span>].value = KEY0VALUE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		ret = request_irq(imx6uirq.irqkeydesc[i].irqnum, imx6uirq.irqkeydesc[i].handler, </span><br><span class="line">		                 IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;irq %d request failed!\r\n&quot;</span>, imx6uirq.irqkeydesc[i].irqnum);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	init_timer(&amp;imx6uirq.timer);</span><br><span class="line">	imx6uirq.timer.function = timer_function;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;imx6uirq;	<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">imx6uirq_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> keyvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> releasekey = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	keyvalue = <span class="type">atomic_read</span>(&amp;dev-&gt;keyvalue);</span><br><span class="line">	releasekey = <span class="type">atomic_read</span>(&amp;dev-&gt;releasekey);</span><br><span class="line">	<span class="keyword">if</span> (releasekey) &#123; <span class="comment">/* 有按键按下 */</span></span><br><span class="line">		<span class="keyword">if</span> (keyvalue &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">			keyvalue &amp;= ~<span class="number">0x80</span>;</span><br><span class="line">			ret = copy_to_user(buf, &amp;keyvalue, <span class="keyword">sizeof</span>(keyvalue));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">goto</span> data_error;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);<span class="comment">/* 按下标志清零 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> data_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">data_error:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">imx6uirq_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = imx6uirq_open,</span><br><span class="line">	.read = imx6uirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">imx6uirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (imx6uirq.major) &#123;</span><br><span class="line">		imx6uirq.devid = MKDEV(imx6uirq.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(imx6uirq.devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;imx6uirq.devid, <span class="number">0</span>, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">		imx6uirq.major = MAJOR(imx6uirq.devid);</span><br><span class="line">		imx6uirq.minor = MINOR(imx6uirq.devid);</span><br><span class="line">	&#125;</span><br><span class="line">	cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);</span><br><span class="line">	cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, IMX6UIRQ_CNT);</span><br><span class="line">	imx6uirq.class = class_create(THIS_MODULE, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(imx6uirq.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(imx6uirq.class);</span><br><span class="line">	&#125;</span><br><span class="line">	imx6uirq.device = device_create(imx6uirq.class, <span class="literal">NULL</span>, imx6uirq.devid, <span class="literal">NULL</span>, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(imx6uirq.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(imx6uirq.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="number">0</span>);</span><br><span class="line">	keyio_init();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">imx6uirq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	del_timer_sync(&amp;imx6uirq.timer);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);</span><br><span class="line">		gpio_free(imx6uirq.irqkeydesc[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line">	cdev_del(&amp;imx6uirq.cdev);</span><br><span class="line">	unregister_chrdev_region(imx6uirq.devid, IMX6UIRQ_CNT);</span><br><span class="line">	device_destroy(imx6uirq.class, imx6uirq.devid);</span><br><span class="line">	class_destroy(imx6uirq.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
分析：
![image](字符设备驱动-9-中断子系统-GICv2架构解析/37.png)
从key节点取出key-gpio,得到gpio编号
调用gpio请求配置函数，配成input模式
根据key节点信息解析出中断号，或者gpio编号转成中断号.（这里用到一个函数`irq_of_parse_and_map`)
注册中断
创建定时器用来消抖

<p>中断响应过程：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/38.png" alt="image"><br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/39.png" alt="image"><br>按键按下或松开，中断产生调用<code>key0_handler</code>，修改定时器超时10ms, 如果是抖动那么，定时器中断那么不会触发（原理请参考[<a href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器 - fuzidage - 博客园 (cnblogs.com)</a>]</p>
<p><a href="https://fuzidage.github.io/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器 | Hexo (fuzidage.github.io)</a>，只有当不是抖动真正按下或松开，定时器中断触发进行读取按键，原子操作设置键值。releasekey置1表示一次完整的按下松开。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/40.png" alt="image"><br>最后用户调用read, 返回键值。可见releasekey很好的控制着按键按下和read的次数，比如当连续read 2次但是只按了一次，则读取失败。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/41.png" alt="image"></p>
<p>硬中断和虚拟中断号的映射关系可以用 <code>/proc/interrupts </code>查看：</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/42.png" alt="img"></p>
<p>通过 ps 命令可以查看系统中的中断线程，注意这些线程是实时线程 <code>SCHED_FIFO</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ps -A | grep &quot;irq/&quot;</span><br><span class="line">root          1749     2       0      0 irq_thread          0 S [irq/433-imx_drm]</span><br><span class="line">root          1750     2       0      0 irq_thread          0 S [irq/439-imx_drm]</span><br><span class="line">root          1751     2       0      0 irq_thread          0 S [irq/445-imx_drm]</span><br><span class="line">root          1752     2       0      0 irq_thread          0 S [irq/451-imx_drm]</span><br><span class="line">root          2044     2       0      0 irq_thread          0 S [irq/279-isl2902]</span><br><span class="line">root          2192     2       0      0 irq_thread          0 S [irq/114-mmc0]</span><br><span class="line">root          2199     2       0      0 irq_thread          0 S [irq/115-mmc1]</span><br><span class="line">root          2203     2       0      0 irq_thread          0 S [irq/322-5b02000]</span><br><span class="line">root          2361     2       0      0 irq_thread          0 S [irq/294-4-0051]</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>中断体系</tag>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-9-中断子系统-中断线程化-threaded_irq</title>
    <url>/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-threaded-irq-yin-ru">1 threaded_irq引入</a></li>
<li><a href="#2-threaded-irq-shi-yong">2 threaded_irq使用</a></li>
<li><a href="#3-threaded-irq-shi-li">3 threaded_irq实例</a><ul>
<li><a href="#3-1-qu-dong-yuan-ma-bian-xie">3.1 驱动源码编写</a></li>
<li><a href="#3-2-app-dai-ma-bian-xie">3.2 app代码编写</a></li>
<li><a href="#3-3-qu-dong-dai-ma-jie-xi">3.3 驱动代码解析</a></li>
</ul>
</li>
<li><a href="#4-threaded-irq-nei-he-ji-zhi">4 threaded_irq内核机制</a><ul>
<li><a href="#4-1-request-threaded-irq-guo-cheng">4.1 request_threaded_irq过程</a><ul>
<li><a href="#4-1-1-setup-irq">4.1.1 <code>__setup_irq</code></a><ul>
<li><a href="#4-1-1-1-setup-irq-thread">4.1.1.1 setup_irq_thread</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de">4.2 中断后处理<code>thread_fn</code>是怎么被执行的</a><ul>
<li><a href="#4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng">4.2.1 上半部硬件中断的调用过程</a></li>
<li><a href="#4-2-2-thread-fn-de-diao-yong-guo-cheng">4.2.2 <code>thread_fn</code>的调用过程</a><ul>
<li><a href="#4-2-2-1-irq-wake-thread-fen-xi">4.2.2.1 <code>__irq_wake_thread</code>分析</a></li>
<li><a href="#4-2-2-2-irq-thread-han-shu-fen-xi">4.2.2.2 irq_thread函数分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-threaded-irq-yin-ru">1 threaded_irq引入</span><a href="#1-threaded-irq-yin-ru" class="header-anchor">#</a></h1><p>工作队列用起来挺简单，但是它有一个缺点：工作队列中有多个 work，前一个 work 没处理完会影响后面的 work执行，导致后面的work没法快速响应。那么可以再内核自己创建一个线程来单独处理，不跟别的 work 凑在一块了。比如在 Linux 系统中，对于存储设备比如 SD&#x2F;TF 卡，它的驱动程序就是这样做的，它有自己的内核线程。用<code>kthread_creat</code>创建内核线程。<br>对于中断处理，还有另一种方法：<code>threaded irq</code>，线程化的中断处理。中断的处理仍然可以认为分为上半部、下半部。上半部用来处理紧急的事情，下半部用一个内核线程来处理，这个内核线程专用于这个中断。</p>
<h1><span id="2-threaded-irq-shi-yong">2 threaded_irq使用</span><a href="#2-threaded-irq-shi-yong" class="header-anchor">#</a></h1><p><a href="https://www.cnblogs.com/fuzidage/p/17517136.html" title="1异常中断引入">1异常中断引入</a> </p>
<p><a href="https://fuzidage.github.io/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入 | Hexo (fuzidage.github.io)</a>前面已经提到了<code>threaded_irq</code>。</p>
<ol>
<li>你可以只提供 <code>thread_fn</code>，内核会提供默认的上半部处理函数<code>irq_default_primary_handler</code>,该函数只是返回一个<strong>IRQ_WAKE_THREAD</strong>。发生中断时，系统会立刻调用 handler 函数，然后唤醒某个内核线程，内核线程再来执行<code>thread_fn</code> 函数。</li>
<li>你也可以既提供<code>handler</code>函数，也提供<code>thread_fn</code>函数。等硬件中断到来，先执行<code>handler</code>函数，handler函数中返回<strong>IRQ_WAKE_THREAD</strong>去唤醒中断线程函数<code>thread_fn</code>。</li>
</ol>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/1.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">devm_request_threaded_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">			  <span class="type">irq_handler_t</span> handler, <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname,</span></span><br><span class="line"><span class="params">			  <span class="type">void</span> *dev_id)</span>;</span><br><span class="line"><span class="comment">//include\linux\interrupt.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">devm_request_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> devm_request_threaded_irq(dev, irq, handler, <span class="literal">NULL</span>, irqflags,</span><br><span class="line">					 devname, dev_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">		     <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">		     <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure>
<h1><span id="3-threaded-irq-shi-li">3 threaded_irq实例</span><a href="#3-threaded-irq-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-qu-dong-yuan-ma-bian-xie">3.1 驱动源码编写</span><a href="#3-1-qu-dong-yuan-ma-bian-xie" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> container_of(work, <span class="keyword">struct</span> gpio_key, work);</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_work_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;key_work_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="comment">//printk(&quot;gpio_key_isr key %d irq happened\n&quot;, gpio_key-&gt;gpio);</span></span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	schedule_work(&amp;gpio_key-&gt;work);</span><br><span class="line">	<span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_thread_func</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line">		</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>,</span><br><span class="line">               __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>,</span><br><span class="line">                   __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		<span class="comment">//err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span></span><br><span class="line">        <span class="comment">//, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span></span><br><span class="line">        <span class="comment">//, &quot;100ask_gpio_key&quot;, &amp;gpio_keys_100ask[i]);</span></span><br><span class="line">		err = request_threaded_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">        						   , gpio_key_thread_func,</span><br><span class="line">                                   IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">                                   , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv); </span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-2-app-dai-ma-bian-xie">3.2 app代码编写</span><a href="#3-2-app-dai-ma-bian-xie" class="header-anchor">#</a></h2><details>
<summary>app代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;while get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-3-qu-dong-dai-ma-jie-xi">3.3 驱动代码解析</span><a href="#3-3-qu-dong-dai-ma-jie-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/2.png" alt="image"><br>为每个按键注册中断服务</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/3.png" alt="image"><br>硬件中断上半部irq中做完重要事情如：清中断，然后返回<strong>IRQ_WAKE_THREAD</strong></p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/4.png" alt="image"><br>返回后，内核线程开始调度<code>gpio_key_thread_func</code>，中断线程化的处理函数<code>gpio_key_thread_func</code>做完后返回<code>IRQ_HANDLED</code>;</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/5.png" alt="image"><br>最后卸载驱动时取消irq注册.</p>
<h1><span id="4-threaded-irq-nei-he-ji-zhi">4 threaded_irq内核机制</span><a href="#4-threaded-irq-nei-he-ji-zhi" class="header-anchor">#</a></h1><p>前面<a href="https://www.cnblogs.com/fuzidage/p/17532830.html" title="中断相关结构体">中断相关结构体</a></p>
<p><a href="https://fuzidage.github.io/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/">字符设备驱动-9-中断子系统-中断结构体 | Hexo (fuzidage.github.io)</a>讲过<code>struct irq_desc</code>结构：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/6.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 当发生中断时，handler函数被调用，如果返回IRQ_HANDLED,表示中断处理完毕，如果返回IRQ_WAKE_THREAD表示要唤醒thread_fn.</span><br><span class="line"><span class="number">2.</span> 内核线程唤醒后，执行thread_fn</span><br></pre></td></tr></table></figure>

<h2><span id="4-1-request-threaded-irq-guo-cheng">4.1 request_threaded_irq过程</span><a href="#4-1-request-threaded-irq-guo-cheng" class="header-anchor">#</a></h2><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	desc = irq_to_desc(irq);  <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;   <span class="comment">//2</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chip_bus_lock(desc);</span><br><span class="line">	retval = __setup_irq(irq, desc, action); <span class="comment">//3</span></span><br><span class="line">	chip_bus_sync_unlock(desc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * It&#x27;s a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment">		 * to happen immediately, so let&#x27;s make sure....</span></span><br><span class="line"><span class="comment">		 * We disable the irq to make sure that a &#x27;real&#x27; IRQ doesn&#x27;t</span></span><br><span class="line"><span class="comment">		 * run in parallel with our fake.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/7.png" alt="image"></p>
<ol>
<li><p>首先根据<code>irq num</code>获取到<code>struct irq_desc</code>信息。</p>
</li>
<li><p>然后分配、设置一个<code> irqaction</code> 结构体。设置中断相关参数</p>
</li>
<li><p>然后进入<code>__setup_irq</code>，<code>__setup_irq </code>函数核心代码如下：</p>
</li>
</ol>
<h3><span id="4-1-1-setup-irq">4.1.1 <code>__setup_irq</code></span><a href="#4-1-1-setup-irq" class="header-anchor">#</a></h3><h4><span id="4-1-1-1-setup-irq-thread">4.1.1.1 setup_irq_thread</span><a href="#4-1-1-1-setup-irq-thread" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (new-&gt;thread_fn &amp;&amp; !nested) &#123;</span><br><span class="line">	ret = setup_irq_thread(new, irq, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//setup_irq_thread函数核心代码如下：</span></span><br><span class="line"><span class="keyword">if</span> (!secondary) &#123;</span><br><span class="line">	t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-%s&quot;</span>, irq,</span><br><span class="line">	 new-&gt;name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-s-%s&quot;</span>, irq,</span><br><span class="line">	 new-&gt;name);</span><br><span class="line">	param.sched_priority -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">new-&gt;thread = t;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/8.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/9.png" alt="image"><br>①可以看到创建了<code>irq_thread</code>这个内核线程。线程名字为<code>“irq/pid-中断名字”</code>。</p>
<p><code>kthread_create()</code>只是创建一个内核线程，但并没有启动，需要调用<code>wake_up_process()</code>来启动线程，所以内核又帮我们定义了一个宏<code>kthread_run</code>来帮我们搞定. 来看kthread相关API:</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/10.png" alt="image-20240811233308139"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_create(threadfn, data, namefmt, arg...) \</span></span><br><span class="line"><span class="meta">	kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create_on_cpu</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">					  <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">					  <span class="type">unsigned</span> <span class="type">int</span> cpu,</span></span><br><span class="line"><span class="params">					  <span class="type">const</span> <span class="type">char</span> *namefmt)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kthread_run - create and wake a thread.</span></span><br><span class="line"><span class="comment"> * @threadfn: the function to run until signal_pending(current).</span></span><br><span class="line"><span class="comment"> * @data: data ptr for @threadfn.</span></span><br><span class="line"><span class="comment"> * @namefmt: printf-style name for the thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description: Convenient wrapper for kthread_create() followed by</span></span><br><span class="line"><span class="comment"> * wake_up_process().  Returns the kthread or ERR_PTR(-ENOMEM).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)			   \</span></span><br><span class="line"><span class="meta">(&#123;									   \</span></span><br><span class="line"><span class="meta">	struct task_struct *__k						   \</span></span><br><span class="line"><span class="meta">		= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (!IS_ERR(__k))						   \</span></span><br><span class="line"><span class="meta">		wake_up_process(__k);					   \</span></span><br><span class="line"><span class="meta">	__k;								   \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span>;</span><br></pre></td></tr></table></figure>

<p>②然后将创建内核线程返回的<code>task_strcut</code>给到<code>irqaction</code>.(<code>new-&gt;trhead = t;这句</code>)<br>我们知道<code>irqaction</code>就包含了<code>thread_fn</code>和<code>handler</code>。</p>
<h2><span id="4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de">4.2 中断后处理<code>thread_fn</code>是怎么被执行的</span><a href="#4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de" class="header-anchor">#</a></h2><h3><span id="4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng">4.2.1 上半部硬件中断的调用过程</span><a href="#4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng" class="header-anchor">#</a></h3><p>无论是中断的上半部的<code>handler</code>, 还是后处理的<code>thread_fn</code>前面的<a href="https://fuzidage.github.io/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/#3-4-gic-zhong-duan-chu-guo-cheng">字符设备驱动-9-中断子系统-GICv2架构解析 | Hexo (fuzidage.github.io)</a></p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析 - fuzidage - 博客园 (cnblogs.com)</a>有引入介绍。</p>
<p>当中断产生时，用gdb看看gic驱动框架调用关系：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Breakpoint <span class="number">1</span>, gpio_keys_gpio_isr (irq=<span class="number">200</span>, dev_id=<span class="number">0x863e6930</span>) at drivers/input/keybo</span><br><span class="line">ard/gpio_keys.c:<span class="number">393</span></span><br><span class="line"><span class="number">393</span> &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#0 gpio_keys_gpio_isr (irq=200, dev_id=0x863e6930) at drivers/input/keyboard/gpio_k</span></span><br><span class="line">eys.c:<span class="number">393</span></span><br><span class="line"><span class="meta">#1 0x80270528 in __handle_irq_event_percpu (desc=0x8616e300, flags=0x86517edc) at ke</span></span><br><span class="line">rnel/irq/handle.c:<span class="number">145</span></span><br><span class="line"><span class="meta">#2 0x802705cc in handle_irq_event_percpu (desc=0x8616e300) at kernel/irq/handle.c:18</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">#3 0x80270640 in handle_irq_event (desc=0x8616e300) at kernel/irq/handle.c:202</span></span><br><span class="line"><span class="meta">#4 0x802738e8 in handle_level_irq (desc=0x8616e300) at kernel/irq/chip.c:518</span></span><br><span class="line"><span class="meta">#5 0x8026f7f8 in generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/i</span></span><br><span class="line">rqdesc.h:<span class="number">150</span></span><br><span class="line"><span class="meta">#6 generic_handle_irq (irq=&lt;optimized out&gt;) at kernel/irq/irqdesc.c:590</span></span><br><span class="line"><span class="meta">#7 0x805005e0 in mxc_gpio_irq_handler (port=0xc8, irq_stat=2252237104) at drivers/gp</span></span><br><span class="line">io/gpio-mxc.c:<span class="number">274</span></span><br><span class="line"><span class="meta">#8 0x805006fc in mx3_gpio_irq_handler (desc=&lt;optimized out&gt;) at drivers/gpio/gpio-mx</span></span><br><span class="line">c.c:<span class="number">291</span></span><br><span class="line"><span class="meta">#9 0x8026f7f8 in generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/i</span></span><br><span class="line">rqdesc.h:<span class="number">150</span></span><br><span class="line"><span class="meta">#10 generic_handle_irq (irq=&lt;optimized out&gt;) at kernel/irq/irqdesc.c:590</span></span><br><span class="line"><span class="meta">#11 0x8026fd0c in __handle_domain_irq (domain=0x86006000, hwirq=32, lookup=true, regs</span></span><br><span class="line">=<span class="number">0x86517fb0</span>) at kernel/irq/irqdesc.c:<span class="number">627</span></span><br><span class="line"><span class="meta">#12 0x80201484 in handle_domain_irq (regs=&lt;optimized out&gt;, hwirq=&lt;optimized out&gt;, dom</span></span><br><span class="line">ain=&lt;optimized <span class="keyword">out</span>&gt;) at ./include/linux/irqdesc.h:<span class="number">168</span></span><br><span class="line"><span class="meta">#13 gic_handle_irq (regs=0xc8) at drivers/irqchip/irq-gic.c:364</span></span><br><span class="line"><span class="meta">#14 0x8020b704 in __irq_usr () at arch/arm/kernel/entry-armv.S:464</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/11.png" alt="image"></p>
<p>从打印可以看出注册的上半部硬件中断<code>handler</code>的调用流程。</p>
<h3><span id="4-2-2-thread-fn-de-diao-yong-guo-cheng">4.2.2 <code>thread_fn</code>的调用过程</span><a href="#4-2-2-thread-fn-de-diao-yong-guo-cheng" class="header-anchor">#</a></h3><p>来看<code>gpio_keys_gpio_isr</code>是如何一层层调用上来的。从<code>__handle_irq_event_percpu</code>开始分析：（它在<code>kernel\irq\handle.c</code>中）<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/12.png" alt="image"><br>执行上半部提供的的<code>handler</code>函数。判断上半部返回值如果是<code>IRQ_WAKE_THREAD</code>，就调用<code>__irq_wake_thread</code>唤醒中断线程处理函数。</p>
<p>如果上半部返回值是<code>IRQ_HANDLED</code>,表示该中断无需线程化处理，直接退出。</p>
<h4><span id="4-2-2-1-irq-wake-thread-fen-xi">4.2.2.1 <code>__irq_wake_thread</code>分析</span><a href="#4-2-2-1-irq-wake-thread-fen-xi" class="header-anchor">#</a></h4><p>它在<code>kernel\irq\handle.c</code>中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __irq_wake_thread(<span class="keyword">struct</span> irq_desc *desc, <span class="keyword">struct</span> irqaction *action)&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;desc-&gt;threads_active);</span><br><span class="line">	wake_up_process(action-&gt;thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒的是谁，就是<code>action-&gt;thread</code>，也就是对应前面<code>kthread_create</code>出来的<code>irq_thread</code>，再次贴图如下：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/13.png" alt="image"></p>
<h4><span id="4-2-2-2-irq-thread-han-shu-fen-xi">4.2.2.2 irq_thread函数分析</span><a href="#4-2-2-2-irq-thread-han-shu-fen-xi" class="header-anchor">#</a></h4><p>在<code>kernel\irq\manage.c</code>，平时<code>irq_thread</code>是处于休眠idle状态，不占用cpu资源。</p>
<p>当被唤醒后，<code>irq_thread</code>进入唤醒状态调用<code>handler_fn</code>，也就是最终使用者预先设定的<code>action-&gt;thread_fn</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupt handler thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">irq_thread</span><span class="params">(<span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> <span class="title">on_exit_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span> =</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(action-&gt;irq);</span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler_fn)(<span class="keyword">struct</span> irq_desc *desc,</span><br><span class="line">			<span class="keyword">struct</span> irqaction *action);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (force_irqthreads &amp;&amp; test_bit(IRQTF_FORCED_THREAD,</span><br><span class="line">					&amp;action-&gt;thread_flags))</span><br><span class="line">		handler_fn = irq_forced_thread_fn;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		handler_fn = irq_thread_fn;</span><br><span class="line"></span><br><span class="line">	init_task_work(&amp;on_exit_work, irq_thread_dtor);</span><br><span class="line">	task_work_add(current, &amp;on_exit_work, <span class="literal">false</span>);</span><br><span class="line">	irq_thread_check_affinity(desc, action);</span><br><span class="line">	<span class="keyword">while</span> (!irq_wait_for_interrupt(action)) &#123;</span><br><span class="line">		<span class="type">irqreturn_t</span> action_ret;</span><br><span class="line">		irq_thread_check_affinity(desc, action);</span><br><span class="line">		action_ret = handler_fn(desc, action);<span class="comment">//调用irq_thread_fn</span></span><br><span class="line">		<span class="keyword">if</span> (action_ret == IRQ_HANDLED)</span><br><span class="line">			<span class="type">atomic_inc</span>(&amp;desc-&gt;threads_handled);</span><br><span class="line">		<span class="keyword">if</span> (action_ret == IRQ_WAKE_THREAD)</span><br><span class="line">			irq_wake_secondary(desc, action);</span><br><span class="line">		wake_threads_waitq(desc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts explicitly requested as threaded interrupts want to be</span></span><br><span class="line"><span class="comment"> * preemtible - many of them need to sleep and wait for slow busses to</span></span><br><span class="line"><span class="comment"> * complete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">irq_thread_fn</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> irqaction *action)</span>&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> ret;</span><br><span class="line">	ret = action-&gt;thread_fn(action-&gt;irq, action-&gt;dev_id);<span class="comment">//调用使用者预先设定的action-&gt;thread_fn</span></span><br><span class="line">	irq_finalize_oneshot(desc, action);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/14.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/15.png" alt="image"></p>
]]></content>
      <tags>
        <tag>中断体系</tag>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-9-中断子系统-中断线程化-workqueue</title>
    <url>/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gong-zuo-dui-lie-workqueue-yin-ru">1工作队列workqueue引入</a><ul>
<li><a href="#1-1-work-struct-miao-shu">1.1 work_struct描述</a><ul>
<li><a href="#1-1-1-ding-yi-yi-ge-work">1.1.1 定义一个work</a></li>
<li><a href="#1-1-2-shi-yong-work">1.1.2 使用work</a></li>
<li><a href="#1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu">1.1.3 工作队列相关函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bian-xie-dai-ma-ji-jie-xi">2 编写代码及解析</a><ul>
<li><a href="#2-1-workqueue-yong-li-qu-dong-yuan-ma">2.1 workqueue用例驱动源码</a></li>
<li><a href="#2-2-fen-xi">2.2 分析</a></li>
</ul>
</li>
<li><a href="#3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li">3 工作队列内部机制原理</a><ul>
<li><a href="#3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.1 Linux 2.x 的工作队列创建过程</a></li>
<li><a href="#3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.2 Linux 4.x 的工作队列创建过程</a></li>
<li><a href="#3-3-schedule-work">3.3 schedule_work</a><ul>
<li><a href="#3-3-1-queue-work">3.3.1 <code>__queue_work</code></a><ul>
<li><a href="#3-3-1-1-insert-work">3.3.1.1 insert_work</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-worker-thread-diao-du">3.4 worker_thread调度</a></li>
<li><a href="#3-5-linux5-1-x-ban-ben-de-workqueue-bug">3.5 linux5.1.x版本的workqueue bug</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gong-zuo-dui-lie-workqueue-yin-ru">1工作队列workqueue引入</span><a href="#1-gong-zuo-dui-lie-workqueue-yin-ru" class="header-anchor">#</a></h1><p>定时器、<code> tasklet</code>，它们都是在中断上下文中执行（<code>softirq</code>中完成的），它们无法休眠。那么如果一旦中断要处理耗时复杂的操作，就会显得很卡。那么使用内核线程来处理这些耗时的工作，那就可以解决系统卡顿的问题。<br>Linux内核中<code>工作队列workqueue</code>就是线程化处理的一种方式，<code>“工作队列”(workqueue)</code>, 它是内核自带的<code>内核线程</code>。要使用<code>“工作队列”</code>，只需要把<code>“工作”</code>放入<code>“工作队列&quot;</code>中，对应的内核线程就会取出 <code>“工作”</code>，执行里面的函数。</p>
<p>工作队列的应用场合：<br>要做的事情比较耗时，甚至可能需要休眠，那么可以使用工作队列。<br>缺点：多个工作(函数)是在某个内核线程中依序执行的，前面函数执行很慢，就会影响到后面的函数。<br>在多 CPU 的系统下，一个工作队列可以有多个内核线程，可以在一定程度上缓解这个问题。</p>
<p>工队队列的源码机制在<code>Linux-4.9.88\kernel\workqueue.c</code>，头文件在<code>Linux-4.9.88\include\linux\workqueue.h</code></p>
<h2><span id="1-1-work-struct-miao-shu">1.1 work_struct描述</span><a href="#1-1-work-struct-miao-shu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/1.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/2.png" alt="image"><br>表示一个work结构，一个任务或者叫做一个工作，里面的<code>.func</code>表示是要执行的任务函数，类型定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">work_func_t</span>)</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-ding-yi-yi-ge-work">1.1.1 定义一个work</span><a href="#1-1-1-ding-yi-yi-ge-work" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WORK(n, f) \</span></span><br><span class="line"><span class="meta">struct work_struct n = __WORK_INITIALIZER(n, f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_DELAYED_WORK(n, f) \</span></span><br><span class="line"><span class="meta">struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第 1 个宏是用来定义一个 work_struct 结构体，要指定它的函数。</span></span><br><span class="line"><span class="comment">//第 2 个宏用来定义一个 delayed_work 结构体，也要指定它的函数。所以“delayed”</span></span><br><span class="line">   <span class="comment">// ，意思就是说要让它运行时，可以指定：某段时间之后你再执行</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/3.png" alt="image"><br>定义一个work为<code>n</code>, 并且初始化函数<code>f</code>.</p>
<p>如果代码中定义好了一个work_struct结构体，那么可以用<code>INIT_WORK</code>函数来初始化：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/4.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_WORK(_work, _func)						\</span></span><br><span class="line"><span class="meta">	__INIT_WORK((_work), (_func), 0)</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-shi-yong-work">1.1.2 使用work</span><a href="#1-1-2-shi-yong-work" class="header-anchor">#</a></h3><p>初始化完work后，调用<strong>schedule_work</strong>即可调度工作队列进行处理当前任务。<br>调用 <code>schedule_work </code>时，就会把<code>work_struct</code> 结构体放入队列<code>system_wq</code>中，并唤醒对应的内核线程。内核线程就会从队列里把 work_struct 结构体取出来，执行里面的函数。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/6.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * schedule_work - put work task in global workqueue</span></span><br><span class="line"><span class="comment"> * @work: job to be done</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns %false if @work was already on the kernel-global workqueue and</span></span><br><span class="line"><span class="comment"> * %true otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This puts a job in the kernel-global workqueue if it was not already</span></span><br><span class="line"><span class="comment"> * queued and leaves it in the same position on the kernel-global</span></span><br><span class="line"><span class="comment"> * workqueue otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>system_wq</code>是内核自带的队列，结构属性为<code>struct workqueue_struct</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/7.png" alt="image"><br>如果不想用内核自带的<strong>system_wq</strong>来调度我们的work, 那么可以调用<strong>create_workqueue</strong>函数自行创建工队队列。然后用<strong>queue_work</strong>函数使能.</p>
<h3><span id="1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu">1.1.3 工作队列相关函数</span><a href="#1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>create_workqueue</td>
<td>在 Linux 系统中已经有了现成的 system_wq 等工作队列，你当然也可以自己调用 create_workqueue 创建工作队列，对于 SMP 系统，这个工作队列会有多个内核线程与它对应，创建工作队列时，内核会帮这个工作队列创建多个内核线程</td>
</tr>
<tr>
<td>create_singlethread_workqueue</td>
<td>如果想只有一个内核线程与工作队列对应，可以用本函数创建工作队列，创建工作队列时，内核会帮这个工作队列创建一个内核线程</td>
</tr>
<tr>
<td>destroy_workqueue</td>
<td>销毁工作队列</td>
</tr>
<tr>
<td>schedule_work</td>
<td>调度执行一个具体的 work，执行的 work 将会被挂入 Linux 系统提供的工作队列</td>
</tr>
<tr>
<td>schedule_delayed_work</td>
<td>延迟一定时间去执行一个具体的任务，功能与 schedule_work 类似，多了一个延迟时间</td>
</tr>
<tr>
<td>queue_work</td>
<td>跟 schedule_work 类似，schedule_work 是在系统默认的工作队列上执行一个work，queue_work 需要自己指定工作队列</td>
</tr>
<tr>
<td>queue_delayed_work</td>
<td>跟 schedule_delayed_work 类似，schedule_delayed_work 是在系统默认的工作队列上执行一个 work，queue_delayed_work 需要自己指定工作队列</td>
</tr>
<tr>
<td>flush_work</td>
<td>等待一个 work 执行完毕，如果这个 work 已经被放入队列，那么本函数等它执行完毕，并且返回 true；如果这个 work 已经执行完华才调用本函数，那么直接返回 false</td>
</tr>
<tr>
<td>flush_delayed_work</td>
<td>等待一个 delayed_work 执行完毕，如果这个 delayed_work 已经被放入队列，那么本函数等它执行完毕，并且返回 true；如果这个 delayed_work 已经执行完华才调用本函数，那么直接返回 false</td>
</tr>
</tbody></table>
<h1><span id="2-bian-xie-dai-ma-ji-jie-xi">2 编写代码及解析</span><a href="#2-bian-xie-dai-ma-ji-jie-xi" class="header-anchor">#</a></h1><h2><span id="2-1-workqueue-yong-li-qu-dong-yuan-ma">2.1 workqueue用例驱动源码</span><a href="#2-1-workqueue-yong-li-qu-dong-yuan-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> container_of(work, <span class="keyword">struct</span> gpio_key, work);</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_work_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;key_work_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="comment">//printk(&quot;gpio_key_isr key %d irq happened\n&quot;, gpio_key-&gt;gpio);</span></span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	schedule_work(&amp;gpio_key-&gt;work);</span><br><span class="line">	<span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_thread_func</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		<span class="comment">/*err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, </span></span><br><span class="line"><span class="comment">        IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span></span><br><span class="line"><span class="comment">        &quot;100ask_gpio_key&quot;, &amp;gpio_keys_100ask[i]);*/</span></span><br><span class="line">		err = request_threaded_irq(gpio_keys_100ask[i].irq</span><br><span class="line">              , gpio_key_isr, gpio_key_thread_func</span><br><span class="line">              , IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">              , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);</span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-2-fen-xi">2.2 分析</span><a href="#2-2-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/8.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/9.png" alt="image"><br>为每一个按键都建立一个work_struct，并且初始化work。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br></pre></td></tr></table></figure>
<p><code>key_work_func</code>是work里面函数，参数为该work自身。该函数只是简单打印该work的自身属性（work名字，work进程id），然后输出按键值。通过<code>container_of</code>找到父亲结构体<code>gpio_key</code>。<br>注意：current是Linux内核自带的一个变量，外部驱动要引用它只需要包含头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/10.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/11.png" alt="image"></p>
<p>中断到来后，这时候上半部完成清中断等一些列重要操作，使能workqueue工作队列，调用函数<strong>schedule_work</strong>。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/12.png" alt="image"><br>内核从系统工作队列<code>system_wq</code>从取出该work，执行里面的函数<code>（key_work_func)</code>。</p>
<p>可以看到<code>current</code>信息：<code>pid为428</code>，内核线程名字为<code>[kworker/0:1]</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/12-1.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/13.png" alt="image"></p>
<h1><span id="3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li">3 工作队列内部机制原理</span><a href="#3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.1 Linux 2.x 的工作队列创建过程</span><a href="#3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng" class="header-anchor">#</a></h2><p>代码在<code>kernel\workqueue.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init_workqueues<span class="comment">//函数主体如下</span></span><br><span class="line">keventd_wq = create_workqueue(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"> __create_workqueue((name), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"> for_each_possible_cpu(cpu) &#123;</span><br><span class="line"> err = create_workqueue_thread(cwq, cpu);</span><br><span class="line"> p = kthread_create(worker_thread, cwq, fmt, wq-&gt;name, cpu); </span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/14.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/15.png" alt="image"></p>
<p>会先分配一个workqueue结构创建一个<code>system_wq</code>工作队列，为每一个 CPU，都创建一个名为<code>“events/X”</code>的内核线程，X 从 0 开始。在创建 workqueue 的同时创建内核线程。</p>
<h2><span id="3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.2 Linux 4.x 的工作队列创建过程</span><a href="#3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng" class="header-anchor">#</a></h2><p>Linux4.x 中，内核线程和工作队列是分开创建的。先创建内核线程，在 <code>kernel\workqueue.c </code>中<br>对每一个cpu，都会创建2个<code>work_pool</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init_workqueues <span class="comment">//函数主体如下：</span></span><br><span class="line"><span class="comment">/* initialize CPU pools */</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"> for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line"> <span class="comment">/* 对每一个 CPU 都创建 2 个 worker_pool 结构体，它是含有 ID 的 */</span></span><br><span class="line"> <span class="comment">/* 一个 worker_pool 对应普通优先级的 work，第 2 个对应高优先级的 work */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* create the initial worker */</span></span><br><span class="line">for_each_online_cpu(cpu) &#123;</span><br><span class="line"> for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line"> <span class="comment">/* 对每一个 CPU 的每一个 worker_pool，创建一个 worker */</span></span><br><span class="line"><span class="comment">/* 每一个 worker 对应一个内核线程 */</span></span><br><span class="line"> BUG_ON(!create_worker(pool));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/16.png" alt="image"><br><code>create_worker </code>函数代码如下：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/17.png" alt="image"></p>
<p>创建好内核线程后，再创建<code> workqueue</code>：这里<code>workqueue</code>会和普通优先级的<code>work_pool</code>建立联系，以后给<code>workqueue</code>添加work的时候会放入<code>work_pool</code>中，执行对应<code>work</code>的时候唤醒相对应的<code>work</code>线程，比如<code>kwork/0:1</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/18.png" alt="image"></p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/19.png" alt="image"></p>
<h2><span id="3-3-schedule-work">3.3 schedule_work</span><a href="#3-3-schedule-work" class="header-anchor">#</a></h2><p><code>schedule_work</code> 会将 work 添加到默认的工作队列也就是 <code>system_wq </code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;<span class="comment">//queue_work_on ，增加一个参数 WORK_CPU_UNBOUND，这个参数并不是指将当前</span></span><br><span class="line"><span class="comment">//work 绑定到 unbound 类型的 worker_pool 中，只是说明调用者并不指定将当前</span></span><br><span class="line"><span class="comment">//work 绑定到哪个 cpu 上，由系统来分配 cpu.当然，调用者也可以直接使用</span></span><br><span class="line"><span class="comment">//queue_work_on 接口，通过第一个参数来指定当前 work 绑定的 cpu。</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">queue_work_on</span><span class="params">(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">        __queue_work(cpu, wq, work);</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3-3-1-queue-work">3.3.1 <code>__queue_work</code></span><a href="#3-3-1-queue-work" class="header-anchor">#</a></h3><p>继续调用<code>__queue_work</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __queue_work(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span><br><span class="line">             <span class="keyword">struct</span> work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取 cpu 相关参数</span></span><br><span class="line">    <span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">        cpu = wq_select_unbound_cpu(raw_smp_processor_id());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查当前的 work 是不是在这之前被添加到其他 worker_pool 中，</span></span><br><span class="line">    <span class="comment">//如果是，就让它继续在原本的 worker_pool 上运行</span></span><br><span class="line">    last_pool = get_work_pool(work);</span><br><span class="line">    <span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">        worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">            pwq = worker-&gt;current_pwq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">            spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">            spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果超过 pwq 支持的最大的 work 数量，将work添加到 pwq-&gt;delayed_works 中</span></span><br><span class="line">    <span class="comment">//，否则就添加到 pwq-&gt;pool-&gt;worklist 中。  </span></span><br><span class="line">    <span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">        trace_workqueue_activate_work(work);</span><br><span class="line">        pwq-&gt;nr_active++;</span><br><span class="line">        worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line">        <span class="keyword">if</span> (list_empty(worklist))</span><br><span class="line">            pwq-&gt;pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">        worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加 work 到队列中。</span></span><br><span class="line">    insert_work(pwq, work, worklist, work_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要由3个部分组成：</p>
<ol>
<li>获取 cpu 参数</li>
<li>检查冲突</li>
<li>添加 work 到队列<code>insert_work</code></li>
</ol>
<h4><span id="3-3-1-1-insert-work">3.3.1.1 insert_work</span><a href="#3-3-1-1-insert-work" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_work</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq, <span class="keyword">struct</span> work_struct *work,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> list_head *head, <span class="type">unsigned</span> <span class="type">int</span> extra_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> pwq-&gt;pool;</span><br><span class="line">    <span class="comment">//设置 work 的 pwq 和 flag。</span></span><br><span class="line">    set_work_pwq(work, pwq, extra_flags);</span><br><span class="line">    <span class="comment">//将 work 添加到 worklist 链表中</span></span><br><span class="line">    list_add_tail(&amp;work-&gt;entry, head);</span><br><span class="line">    <span class="comment">//为 pwq 添加引用计数</span></span><br><span class="line">    get_pwq(pwq);</span><br><span class="line">    <span class="comment">//添加内存屏障，防止 cpu 将指令乱序排列</span></span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒 worker 对应的内核线程</span></span><br><span class="line">    <span class="keyword">if</span> (__need_more_worker(pool))</span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地说，就是将<code> work</code> 插入到<code>worker_pool-&gt;worklist</code>中。<br>添加完之后，就会唤醒<code> worker_pool</code> 中第一个处于<code>idle</code>状态<code>worker-&gt;task</code>内核线程，work 就会进入到待处理状态。</p>
<h2><span id="3-4-worker-thread-diao-du">3.4 worker_thread调度</span><a href="#3-4-worker-thread-diao-du" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__worker)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    worker-&gt;task-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">woke_up:</span><br><span class="line">    spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">    <span class="comment">//在必要的时候删除 worker，退出当前线程。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">        spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">        WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">        worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line"></span><br><span class="line">        set_task_comm(worker-&gt;task, <span class="string">&quot;kworker/dying&quot;</span>);</span><br><span class="line">        ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">        worker_detach_from_pool(worker, pool);</span><br><span class="line">        kfree(worker);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line">    <span class="comment">//管理 worker 线程</span></span><br><span class="line">    <span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">        <span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">        <span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 work</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">            list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line">                     <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line"></span><br><span class="line">        pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line">            process_one_work(worker, work);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">                process_scheduled_works(worker);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">            process_scheduled_works(worker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">    worker_set_flags(worker, WORKER_PREP);</span><br><span class="line">sleep:</span><br><span class="line">    <span class="comment">//处理完成，陷入睡眠</span></span><br><span class="line">    worker_enter_idle(worker);</span><br><span class="line">    __set_current_state(TASK_IDLE);</span><br><span class="line">    spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>worker_thread</code>函数主要包括以下的几个主要部分：</p>
<ol>
<li>管理 worker</li>
<li>执行 work<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2.1</span> 从当前worker_pool-&gt;worklist 中的链表元素取出work</span><br><span class="line"><span class="number">2.2</span> move_linked_works 将会在执行前将 work 添加到 worker-&gt;scheduled 链表中</span><br><span class="line">    ，该接口和 list_add_tail 不同的是，这个接口会先删除链表中存在的节点并重新添加，</span><br><span class="line">	保证不会重复添加，且始终添加到最后一个节点。</span><br><span class="line"><span class="number">2.3</span> process_scheduled_works 函数正式执行 work，该函数会遍历 worker-&gt;scheduled 链表，</span><br><span class="line">    执行每一个 work，执行之前会做一些必要的检查，比如在同一个 cpu 上，</span><br><span class="line">	一个 worker 不能在多个 worker 线程中被并发执行(这里的并发执行指的是同时加入到 schedule 链表)，</span><br><span class="line">    是否需要唤醒其它的 worker 来协助执行(碰到 cpu 消耗型的work 需要这么做)，</span><br><span class="line">    执行 work 的方式就是调用 work-&gt;func</span><br></pre></td></tr></table></figure>
当执行完<code>worker_pool-&gt;worklist</code> 中所有的<code>work</code>之后，当前线程就会陷入睡眠.</li>
</ol>
<h2><span id="3-5-linux5-1-x-ban-ben-de-workqueue-bug">3.5 linux5.1.x版本的workqueue bug</span><a href="#3-5-linux5-1-x-ban-ben-de-workqueue-bug" class="header-anchor">#</a></h2><p>在多核<code>cpu</code>调度时，使用<code>workqueue</code>会小概率出现<code>WARNING: CPU: x PID: xx at linux_5.10/kernel/workqueue.c:1796 worker_enter_idle</code><br>的<code>call trace</code>提示，然后cpu进入idel休眠状态。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/20.png" alt="image"></p>
<p>由于如果在 <code>WORKER_NOT_RUNNING </code>检查时和下面的 <code>nr_running </code>增量之间被<code>unbind_workers()</code>抢占，我们可能会破坏 <code>nr_running </code>重置并在新的未绑定池上留下意外的<code> pool-&gt;nr_running == 1</code> 。</p>
<p>为了 防止这样的竞态产生，linux内核patch参考:<br><a href="https://lore.kernel.org/lkml/20220114081544.899493450@linuxfoundation.org/">https://lore.kernel.org/lkml/20220114081544.899493450@linuxfoundation.org/</a><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/21.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/22.png" alt="image"></p>
]]></content>
      <tags>
        <tag>中断体系</tag>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-9-中断子系统-中断设备树表述与解析</title>
    <url>/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu">1 中断在设备树中的表述</a><ul>
<li><a href="#1-1-zhong-duan-kong-zhi-qi">1.1 中断控制器</a></li>
<li><a href="#1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing">1.2 设备树中断相关属性</a><ul>
<li><a href="#1-2-1-interrupt-controller">1.2.1 interrupt-controller</a></li>
<li><a href="#1-2-2-interrupt-cells">1.2.2 interrupt-cells</a></li>
<li><a href="#1-2-3-interrupt-parent">1.2.3 interrupt-parent</a></li>
<li><a href="#1-2-4-interrupts">1.2.4 interrupts</a></li>
</ul>
</li>
<li><a href="#1-3-dts-zhong-huo-qu-zhong-duan">1.3 dts中获取中断</a><ul>
<li><a href="#1-3-1-dui-yu-platform-device">1.3.1 对于 platform_device</a><ul>
<li><a href="#1-3-1-1-platform-get-resource">1.3.1.1 platform_get_resource</a></li>
</ul>
</li>
<li><a href="#1-3-2-dui-yu-i2c-she-bei-spi-she-bei">1.3.2 对于 I2C 设备、SPI 设备</a><ul>
<li><a href="#1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao">1.3.2.1 调用 of_irq_get 获得中断号</a></li>
</ul>
</li>
<li><a href="#1-3-3-dui-yu-gpio">1.3.3 对于 GPIO</a><ul>
<li><a href="#1-3-3-1-gpio-to-irq-huo-gpiod-to-irq">1.3.3.1 gpio_to_irq或 gpiod_to_irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bian-xie-yi-ge-an-jian-zhong-duan">2 编写一个按键中断</a><ul>
<li><a href="#2-1-an-jian-dts-pei-zhi">2.1 按键dts配置</a><ul>
<li><a href="#2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi">2.1.1 添加2个按键的iomux配置</a></li>
<li><a href="#2-1-2-ding-yi-an-jian-dts-miao-shu">2.1.2 定义按键dts描述</a></li>
</ul>
</li>
<li><a href="#2-2-qu-dong-dai-ma">2.2 驱动代码</a><ul>
<li><a href="#2-2-1-qu-dong-dai-ma-fen-xi">2.2.1 驱动代码分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu">1 中断在设备树中的表述</span><a href="#1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu" class="header-anchor">#</a></h1><h2><span id="1-1-zhong-duan-kong-zhi-qi">1.1 中断控制器</span><a href="#1-1-zhong-duan-kong-zhi-qi" class="header-anchor">#</a></h2><p>如图：GPIO1 连接到 GIC，GPIO2 连接到 GIC，所以 GPIO1 的父亲是 GIC，GPIO2的父亲是 GIC。假设 GPIO1 有 32 个中断源，但是它把其中的 16 个汇聚起来向 GIC 发出一个中断，把另外 16 个汇聚起来向 GIC 发出另一个中断。这就意味着 GPIO1 会用到 GIC 的两个中断，会涉及 GIC 里的 2 个 <code>hwirq</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/1.png" alt="image"></p>
<h2><span id="1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing">1.2 设备树中断相关属性</span><a href="#1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing" class="header-anchor">#</a></h2><p>设备树中，中断控制器节点中必须有一个属性：</p>
<h3><span id="1-2-1-interrupt-controller">1.2.1 interrupt-controller</span><a href="#1-2-1-interrupt-controller" class="header-anchor">#</a></h3><p>表明它是 <code>“中断控制器”</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/2.png" alt="image"></p>
<h3><span id="1-2-2-interrupt-cells">1.2.2 interrupt-cells</span><a href="#1-2-2-interrupt-cells" class="header-anchor">#</a></h3><p>⚫ <code>#interrupt-cells=&lt;1&gt;</code><br>    别的节点要使用这个中断控制器时，只需要一个 cell 来表明使用 “哪一个中断”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vic: intc@<span class="number">10140000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;arm,versatile-vic&quot;</span>;</span><br><span class="line">interrupt-controller;</span><br><span class="line"><span class="meta">#interrupt-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">reg = &lt;<span class="number">0x10140000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>⚫ <code>#interrupt-cells=&lt;2&gt;</code><br>别的节点要使用这个中断控制器时，需要一个 cell 来表明使用 “哪一个中断”；还需要另一个 cell 来描述中断，一般是表明触发类型：<br>    第 2 个 cell 的 bits[3:0] 用来表示中断触发类型(<code>trigger type and level flags</code>)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> = low-to-high edge triggered，上升沿触发</span><br><span class="line"><span class="number">2</span> = high-to-low edge triggered，下降沿触发</span><br><span class="line"><span class="number">4</span> = active high level-sensitive，高电平触发</span><br><span class="line"><span class="number">8</span> = active low level-sensitive，低电平触发</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio2: gpio@<span class="number">020</span>a0000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6q-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x020a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">0</span> <span class="number">68</span> <span class="number">4</span>&gt;,</span><br><span class="line">		  &lt;<span class="number">0</span> <span class="number">69</span> <span class="number">4</span>&gt;;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-interrupt-parent">1.2.3 interrupt-parent</span><a href="#1-2-3-interrupt-parent" class="header-anchor">#</a></h3><p>你要用哪一个中断控制器里的中断？<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/3.png" alt="image"></p>
<h3><span id="1-2-4-interrupts">1.2.4 interrupts</span><a href="#1-2-4-interrupts" class="header-anchor">#</a></h3><p>你要用哪一个中断？<br><code>Interrupts</code> 里要用几个 cell，由<code>interrupt-parent</code>对应的中断控制器决定。在中断控制器里有<code>“#interrupt-cells”</code>属性，它指明了要用几个 cell来描述中断。比如下图表示用到gpio中断控制器的160号中断，上升沿触发。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/4.png" alt="image"></p>
<h2><span id="1-3-dts-zhong-huo-qu-zhong-duan">1.3 dts中获取中断</span><a href="#1-3-dts-zhong-huo-qu-zhong-duan" class="header-anchor">#</a></h2><h3><span id="1-3-1-dui-yu-platform-device">1.3.1 对于 platform_device</span><a href="#1-3-1-dui-yu-platform-device" class="header-anchor">#</a></h3><h4><span id="1-3-1-1-platform-get-resource">1.3.1.1 platform_get_resource</span><a href="#1-3-1-1-platform-get-resource" class="header-anchor">#</a></h4><p>当平台设备和平台驱动match上后，一个节点能被转换为 <code>platform_device</code>，调用<code>platform_get_resource</code>可获取节点资源信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *,<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/5.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/6.png" alt="image"><br>如果需要获取中断信息，传入<code>IORESOURCE_IRQ</code>。</p>
<h3><span id="1-3-2-dui-yu-i2c-she-bei-spi-she-bei">1.3.2 对于 I2C 设备、SPI 设备</span><a href="#1-3-2-dui-yu-i2c-she-bei-spi-she-bei" class="header-anchor">#</a></h3><p>I2C 总线驱动在处理设备树里的 I2C 子节点时，Linux总线会自动处理其中的中断信息。一个 I2C 设备会被转换为一个 <code>i2c_client</code>结构体，中断号会保存在 i2c_client 的 irq 成员里，代码如下(<code>drivers/i2c/i2c-core.c</code>)，probe函数里面<strong>of_irq_get</strong>函数会根据dts中的i2c节点获取中断资源。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/7.png" alt="image"></p>
<p><strong>GIC_SPI</strong>表示中断类型为共享中断。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/8.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/9.png" alt="image"><br>SPI总线同理，一个 SPI 设备会被转换为一个<code>spi_device</code>结构体，中断号会保存在 <code>spi_device</code> 的 irq 成员里，代码如下(<code>drivers/spi/spi.c</code>)：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/10.png" alt="image"></p>
<h4><span id="1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao">1.3.2.1 调用 of_irq_get 获得中断号</span><a href="#1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao" class="header-anchor">#</a></h4><p>如果我们没用<code>platform device</code>架构写字符设备驱动，也可以直接调用<code>of_irq_get</code>获取。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/11.png" alt="image"></p>
<h3><span id="1-3-3-dui-yu-gpio">1.3.3 对于 GPIO</span><a href="#1-3-3-dui-yu-gpio" class="header-anchor">#</a></h3><h4><span id="1-3-3-1-gpio-to-irq-huo-gpiod-to-irq">1.3.3.1 gpio_to_irq或 gpiod_to_irq</span><a href="#1-3-3-1-gpio-to-irq-huo-gpiod-to-irq" class="header-anchor">#</a></h4><p>参考：<code>drivers/input/keyboard/gpio_keys.c</code>， api路径<code>linux_5.10\include\linux\of_gpio.h</code><br>可以使用 <code>gpio_to_irq</code> 或 <code>gpiod_to_irq </code>获得中断号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">button-&gt;gpio = of_get_gpio_flags(pp, <span class="number">0</span>, &amp;flags);</span><br><span class="line">bdata-&gt;gpiod = gpio_to_desc(button-&gt;gpio);</span><br><span class="line"><span class="comment">//再去使用 gpiod_to_irq 获得中断号：</span></span><br><span class="line">irq = gpiod_to_irq(bdata-&gt;gpiod)；</span><br></pre></td></tr></table></figure>

<h1><span id="2-bian-xie-yi-ge-an-jian-zhong-duan">2 编写一个按键中断</span><a href="#2-bian-xie-yi-ge-an-jian-zhong-duan" class="header-anchor">#</a></h1><h2><span id="2-1-an-jian-dts-pei-zhi">2.1 按键dts配置</span><a href="#2-1-an-jian-dts-pei-zhi" class="header-anchor">#</a></h2><p>linux内核自带的<code>input sub system</code>本身就包含了gpio按键驱动，驱动程序 <code>drivers/input/keyboard/gpio_keys.c</code> 就可以，然后你需要做<br>的只是修改设备树指定引脚及键值。<br>为了简化我们直接写一个例子：强化熟悉对gpio中断的使用。</p>
<p>我们确定好用<code>gpio5_1</code>,  <code>gpio4_14</code>这2个按键来展开实验：定义好dts节点,这里定义<code>gpio_keys_100ask</code>，内核有函数自动把gpio num转成irq。在其他地方dts中(<code>imx6ull.dts</code>中)会描述好gpio5,gpio4节点信息，里面会有</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>因此，这里表示引用gpio5的第0个引脚，gpio4的第14个引脚，节点如下，需要把原来的节点<code>gpio-keys</code> disable掉，添加下面的<code>gpio_keys_100ask</code>。进入内核目录 <code>make dtbs</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio_keys_100ask &#123;</span><br><span class="line">	compatible = <span class="string">&quot;100ask,gpio_key&quot;</span>;</span><br><span class="line">	gpios = &lt;&amp;gpio5 <span class="number">1</span> GPIO_ACTIVE_HIGH</span><br><span class="line">	&amp;gpio4 <span class="number">14</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;key1_pinctrl &amp;key2_pinctrl&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/12.png" alt="image"></p>
<p>设备树中并没有对这2个引脚进行<code>pinctrl</code>配置，也就是<code>iomux</code>配置，那为什么这2个引脚还能工作，是因为这个个引脚默认就是gpio状态，不用进行<code>iomux</code>切换。<br>为了保险起见，按照标准流程还需要对其添加<code>pinctrl</code>信息。</p>
<h3><span id="2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi">2.1.1 添加2个按键的iomux配置</span><a href="#2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi" class="header-anchor">#</a></h3><p>imx6ull工具有制作好<code>pinctrl</code>如何配置:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/13.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/14.png" alt="image"></p>
<p>填入到对应的子节点下面：gpio5的iomux配置放在<code>iomuxc_snvs</code>节点下，gpio4的配置放在<code>iomuxc</code>下。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/15.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/16.png" alt="image"></p>
<h3><span id="2-1-2-ding-yi-an-jian-dts-miao-shu">2.1.2 定义按键dts描述</span><a href="#2-1-2-ding-yi-an-jian-dts-miao-shu" class="header-anchor">#</a></h3><p>再到定义的<code>gpio_keys_100ask</code>引用这2个<code>pinctrl</code>信息 <code>key1_100ask</code>和 <code>key2_100ask</code>。这里pinctrl只有一个default状态，<code>pinctrl-0</code>表示该默认状态，因此最终<code>gpio5_1</code>,  <code>gpio4_14</code>就被<code>iomux</code>成了gpio状态。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/17.png" alt="image"></p>
<h2><span id="2-2-qu-dong-dai-ma">2.2 驱动代码</span><a href="#2-2-qu-dong-dai-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码如下</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_key = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, g_key);</span><br><span class="line">	err = copy_to_user(buf, &amp;g_key, <span class="number">4</span>);</span><br><span class="line">	g_key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	g_key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count) </span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">                          , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span>        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h3><span id="2-2-1-qu-dong-dai-ma-fen-xi">2.2.1 驱动代码分析</span><a href="#2-2-1-qu-dong-dai-ma-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/18.png" alt="image"></p>
<p>定义<code>gpio_key</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/19.png" alt="image"><br>通过<code>.compatible = &quot;100ask,gpio_key&quot;</code>匹配<code>plateform_device</code>和<code>platform_driver</code>, 当<code>insmod ko</code>时probe函数被调用。<br><code>struct device_node *node = pdev-&gt;dev.of_node;//可以从platform_device获取到device_node</code>。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/20.png" alt="image"><br><code>of_gpio_count</code>可以根据设备树节点获取到gpio的数量。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/21.png" alt="image"><br><code>of_get_gpio_flags</code>可以根据设备树节点获取到<code>gpio</code>编号和<code>gpio flags</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/22.png" alt="image"><br>获取gpio描述子和gpio中断号:</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/23.png" alt="image"><br>注册中断服务程序<code>gpio_key_isr</code>，当按键按下会触发gpio中断，执行<code>gpio_key_isr</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/24.png" alt="image"><br>中断服务程序就简单的打印按键的电平状态:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>中断体系</tag>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>循环队列FIFO原理图解</title>
    <url>/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</a><ul>
<li><a href="#1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</a></li>
<li><a href="#1-2-fifo-chu-shi-hua">1.2 FIFO初始化</a></li>
<li><a href="#1-3-fifo-xiao-hui">1.3 FIFO销毁</a></li>
<li><a href="#1-4-ru-dui-lie">1.4 入队列</a></li>
<li><a href="#1-5-chu-dui-lie">1.5 出队列</a></li>
<li><a href="#1-6-fifo-pan-kong">1.6 FIFO判空</a></li>
<li><a href="#1-6-fifo-pan-man">1.6 FIFO判满</a></li>
<li><a href="#1-7-fifo-rong-liang">1.7 FIFO容量</a></li>
<li><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</a></li>
<li><a href="#1-9-fifo-bian-li">1.9 FIFO遍历</a></li>
<li><a href="#1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</a><ul>
<li><a href="#1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</a></li>
<li><a href="#1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ce-shi-yong-li">2 测试用例</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</span><a href="#1-xun-huan-dui-lie-fifo-jie-shao" class="header-anchor">#</a></h1><p>循环队列是把<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/20832734">顺序队列</a>首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/1.png" alt="img"></p>
<p>入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针。</p>
<h2><span id="1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</span><a href="#1-1-xun-huan-dui-lie-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_HEAD(name, type)                                          \</span></span><br><span class="line">        <span class="keyword">struct</span> name &#123;                                                  \</span><br><span class="line">                <span class="keyword">struct</span> type *fifo;                                     \</span><br><span class="line">                <span class="built_in">int</span> front, tail, capacity;                             \</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front表示首元素索引</span><br><span class="line">tail表示最后一个元素索引</span><br><span class="line">capacity表示队列的长度</span><br><span class="line">struct type fifo表示该队列中的元素指针，可以指向任意结构体指针</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">struct</span> person_q &#123;                                                        \</span><br><span class="line">    <span class="keyword">struct</span> person* *fifo;                                        \</span><br><span class="line">        <span class="built_in">int</span> front, tail, capacity;                                \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-fifo-chu-shi-hua">1.2 FIFO初始化</span><a href="#1-2-fifo-chu-shi-hua" class="header-anchor">#</a></h2><p>分配一个连续的空间存储队列元素。用户自定义队列容量。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/2.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_INIT(head, _capacity) do &#123;                                  \</span></span><br><span class="line">        (head)-&gt;fifo = malloc(<span class="keyword">sizeof</span>(*(head)-&gt;fifo) * _capacity);        \</span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                               \</span><br><span class="line">        (head)-&gt;capacity = _capacity;                                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-fifo-xiao-hui">1.3 FIFO销毁</span><a href="#1-3-fifo-xiao-hui" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EXIT(head) do &#123;                                                \</span></span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                                \</span><br><span class="line">        (head)-&gt;capacity = <span class="number">0</span>;                                                \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;fifo)                                                \</span><br><span class="line">                free((head)-&gt;fifo);                                        \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2><span id="1-4-ru-dui-lie">1.4 入队列</span><a href="#1-4-ru-dui-lie" class="header-anchor">#</a></h2><p>入队列就是尾元素的索引++，也就是tail++，让新元素放进队列的尾部。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_PUSH(head, elm) do &#123;                                      \</span></span><br><span class="line">        <span class="keyword">if</span> (FIFO_EMPTY(head))                                          \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">0</span>;                      \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;tail = ((head)-&gt;tail == (head)-&gt;capacity - <span class="number">1</span>)  \</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;tail + <span class="number">1</span>;                        \</span><br><span class="line">        (head)-&gt;fifo[(head)-&gt;tail] = elm;                              \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果队列是空的，则第一个元素入队列，front和tail索引都指向第一个元素，front &#x3D; tail &#x3D; 0;<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/3.png" alt="img"></p>
<p>其他情况入队，让tail++<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/4.png" alt="img"></p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/5.png" alt="img"></p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/6.png" alt="img"></p>
<h2><span id="1-5-chu-dui-lie">1.5 出队列</span><a href="#1-5-chu-dui-lie" class="header-anchor">#</a></h2><p>出队列就是让font对应的元素丢出去，font++。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_POP(head, pelm) do &#123;                                      \</span></span><br><span class="line">        *(pelm) = (head)-&gt;fifo[(head)-&gt;front];                         \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;front == (head)-&gt;tail)                             \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                     \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;front = ((head)-&gt;front == (head)-&gt;capacity - <span class="number">1</span>)\</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;front + <span class="number">1</span>;                \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>当front追上tail后，表示队列空了，重新设置起始点，需要将front &#x3D; tail &#x3D; -1 。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/7.png" alt="img"></p>
<p>其他情况出队，丢出front元素，让front++</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/8.png" alt="img"></p>
<h2><span id="1-6-fifo-pan-kong">1.6 FIFO判空</span><a href="#1-6-fifo-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EMPTY(head)    ((head)-&gt;front == -1)</span></span><br></pre></td></tr></table></figure>

<p>①队列初始化时，队列是空的，会让front为-1<br>②出队列时，font++, 当font追上tail表示空了，则可以重新设置起始点，令front &#x3D; tail &#x3D; -1<br>综合①②所以可以用-1判断</p>
<h2><span id="1-6-fifo-pan-man">1.6 FIFO判满</span><a href="#1-6-fifo-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FULL(head)     (((head)-&gt;front == ((head)-&gt;tail + 1)%(head)-&gt;capacity))</span></span><br></pre></td></tr></table></figure>

<p>①当front&#x3D;0时，那么tail到达capacity-1表示FIFO full。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/9.png" alt="img"></p>
<p>②否则，tail追上front后(front &#x3D; tail + 1)表示FIFO full。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/10.png" alt="img"></p>
<h2><span id="1-7-fifo-rong-liang">1.7 FIFO容量</span><a href="#1-7-fifo-rong-liang" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_CAPACITY(head) ((head)-&gt;capacity)</span></span><br></pre></td></tr></table></figure>

<h2><span id="1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</span><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_SIZE(head)     (FIFO_EMPTY(head) ? \</span></span><br><span class="line">        <span class="number">0</span> : ((((head)-&gt;tail + (head)-&gt;capacity - (head)-&gt;front) % (head)-&gt;capacity) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>用tail - front就表示有效元素个数，不过由于循环FIFO,可能tail&lt;front,这个时候就需要取余运算，如下图:</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/11.png" alt="img"></p>
<h2><span id="1-9-fifo-bian-li">1.9 FIFO遍历</span><a href="#1-9-fifo-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FOREACH(var, head, idx) \</span></span><br><span class="line">　　<span class="keyword">for</span> (idx = (head)-&gt;front, <span class="keyword">var</span> = (head)-&gt;fifo[idx]; \</span><br><span class="line">　　　　idx &lt; (head)-&gt;front + FIFO_SIZE(head); \</span><br><span class="line">　　　　<span class="keyword">var</span> = (head)-&gt;fifo[++idx % (head)-&gt;capacity])</span><br></pre></td></tr></table></figure>

<h2><span id="1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</span><a href="#1-10-dui-lie-yuan-su-huo-qu" class="header-anchor">#</a></h2><h3><span id="1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</span><a href="#1-10-1-di-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_FRONT(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;front])</span></span><br></pre></td></tr></table></figure>
<h3><span id="1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</span><a href="#1-10-2-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_TAIL(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;tail])</span></span><br></pre></td></tr></table></figure>
<h1><span id="2-ce-shi-yong-li">2 测试用例</span><a href="#2-ce-shi-yong-li" class="header-anchor">#</a></h1><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;fifo.h&quot;</span></span><br><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="keyword">struct</span> person_q person1_queue;</span><br><span class="line"><span class="keyword">struct</span> person_q person2_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">        FIFO_INIT(&amp;person1_queue, <span class="number">1</span>);</span><br><span class="line">        FIFO_INIT(&amp;person2_queue, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person2_queue) != <span class="number">5</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">20</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1001</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person1_queue, person_a);<span class="comment">//把person_a这个结构体指针元素丢进FIFO,</span></span><br><span class="line">        <span class="comment">//后面对它pop出来又能拿到它，所以不用担心地址弄丢导致无法释放.</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_FULL(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">30</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1002</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 3 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 4 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person1_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">20</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 5 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">40</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1003</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        FIFO_GET_FRONT(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_FRONT NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_GET_TAIL(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_TAIL NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 6 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 7 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_arr[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                person_arr[i] = malloc(<span class="keyword">sizeof</span>(*person_arr[<span class="number">0</span>]));</span><br><span class="line">                person_arr[i]-&gt;age = i;</span><br><span class="line">                person_arr[i]-&gt;id = <span class="number">1000</span> + i;</span><br><span class="line">                FIFO_PUSH(&amp;person2_queue, person_arr[i]);</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_EMPTY(&amp;person2_queue) &#123;</span><br><span class="line">                FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">                printf( <span class="string">&quot;age:%d, id:%d.\n&quot;</span>, person_a-&gt;age, person_a-&gt;id);</span><br><span class="line">                free(person_a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_EXIT(&amp;person1_queue);</span><br><span class="line">        FIFO_EXIT(&amp;person2_queue);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/12.png" alt="img"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-9-中断子系统-中断结构体</title>
    <url>/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#0-yin-ru-sparse-irq">0 引入SPARSE_IRQ</a></li>
<li><a href="#1-irq-desc-shu-zu">1 irq_desc 数组</a><ul>
<li><a href="#1-1-zhong-duan-chu-li-han-shu-handle-irq">1.1 中断处理函数handle_irq</a><ul>
<li><a href="#1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru">1.1.1 共享中断概念引入</a></li>
<li><a href="#1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan">1.1.2 中断的处理函数来源</a></li>
</ul>
</li>
<li><a href="#1-2-irqaction">1.2 irqaction</a><ul>
<li><a href="#1-2-1-request-threaded-irq">1.2.1 request_threaded_irq</a></li>
<li><a href="#1-2-2-request-irq">1.2.2 request_irq</a></li>
<li><a href="#1-2-3-devm-request-irq">1.2.3 devm_request_irq</a></li>
</ul>
</li>
<li><a href="#1-3-irq-data">1.3 irq_data</a></li>
<li><a href="#1-4-irq-domain">1.4 irq_domain</a><ul>
<li><a href="#1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain">1.4.0 中断控制器注册 irq_domain</a></li>
<li><a href="#1-4-1-irq-domain-ops">1.4.1 irq_domain_ops</a><ul>
<li><a href="#1-4-1-1-xlate-han-shu">1.4.1.1 xlate函数</a></li>
<li><a href="#1-4-1-2-map-han-shu">1.4.1.2 <code>map</code>函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-5-irq-chip">1.5 irq_chip</a></li>
</ul>
</li>
<li><a href="#2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu">2 中断不同结构体之间的关系框图</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="0-yin-ru-sparse-irq">0 引入SPARSE_IRQ</span><a href="#0-yin-ru-sparse-irq" class="header-anchor">#</a></h1><p>如果内核配置了 <strong>CONFIG_SPARSE_IRQ</strong>，那么它就会用 <strong>基数树(radix tree)</strong> 来代替 irq_desc 数组。<br>SPARSE 的意思是“稀疏”，假设大小为 1000 的数组中只用到 2 个数组项，那不是浪费嘛？当中断比较“稀疏”时可以用基数树来代替数组。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/1.png" alt="image"></p>
<h1><span id="1-irq-desc-shu-zu">1 irq_desc 数组</span><a href="#1-irq-desc-shu-zu" class="header-anchor">#</a></h1><p>位于<code>include/linux/irqdesc.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/2.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/3.png" alt="在这里插入图片描述"></p>
<p>内核中记录一个<code>irq_desc</code>的数组，数组的每一项对应一个中断或者一组中断（使用同一中断号）。<code>irq_desc</code>几乎记录所有中断相关的东西，这个结构是中断的核心。每一个<code>irq_desc</code>数组项中都有一个函数：<code>handle_irq</code>，还有一个<code>action链表</code>。</p>
<p><code>irq_desc </code>数组结构链路如下图：</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/4.png" alt="image"></p>
<h2><span id="1-1-zhong-duan-chu-li-han-shu-handle-irq">1.1 中断处理函数handle_irq</span><a href="#1-1-zhong-duan-chu-li-han-shu-handle-irq" class="header-anchor">#</a></h2><h3><span id="1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru">1.1.1 共享中断概念引入</span><a href="#1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru" class="header-anchor">#</a></h3><p>：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/5.png" alt="image"></p>
<ol>
<li>上图一个gpio按键连接gpio模块第一个引脚1，可以设置该引脚，当电平发生变化时，让该引脚产生中断，那么gpio模块会上报中断到gic模块, gic模块继续中断cpu。</li>
<li>同理当一个外部设备网卡和该gpio按键可以共享一个中断，也接到gpio模块第一个引脚1，gpio模块会上报中断到gic模块, gic模块继续中断cpu。这里就用到了共享中断的概念。</li>
</ol>
<p>可以看到中断的触发时从左到右的过程，那么cpu进行响应中断请求时就是从右到左的过程。</p>
<ol>
<li><p>cpu读取GIC控制器，判段中断号，如果是A号中断说明是来源于<code>gpio模块</code>，如果是<code>A&#39;</code>中断，说明来源于<code>其他模块</code>。</p>
</li>
<li><p>A号中断的来源有很多种，有<code>gpio0,gpio1....</code>， 又会从gpio控制寄存器来辨别倒是是哪一个gpio产生的中断，比如是B号中断</p>
</li>
<li><p>B号中断的来源有很多种，有<code>按键，网卡...</code></p>
</li>
</ol>
<h3><span id="1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan">1.1.2 中断的处理函数来源</span><a href="#1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan" class="header-anchor">#</a></h3><p>中断处理函数来源有三：</p>
<ol>
<li>GIC 的处理函数：<br> GIC 中断 CPU 时，CPU 读取 GIC 状态得到中断 A。假设<code> irq_desc[A].handle_irq 是 XXX_gpio_irq_handler</code>(XXX 指厂家)，这个函数需要读取芯片的 GPIO 控制器，细分发生的是哪一个 GPIO 中断(假设是B)，再去调用<code> irq_desc[B]. handle_irq</code>。</li>
</ol>
<p>  CPU从异常向量表中调用<code>handle_arch_irq</code>，这个函数指针是有GIC驱动设置的.调用<code>irq_desc[virq].handle_irq</code>函数：这也应该由GIC驱动提供。</p>
<ol start="2">
<li><p>模块的中断处理函数：<br>对于 GPIO 模块向 GIC 发出的中断 B ， 它 的 处 理 函 数 是<code>irq_desc[B].handle_irq</code>。<br>导致 GPIO 中断 B 发生的原因很多，可能是外部设备 1，可能是外部设备n，可能只是某一个设备，也可能是多个设备。所以<code> irq_desc[B].handle_irq</code>会调用链表里的函数，这些函数由外部设备提供。这些函数自行判断该中断是否自己产生，若是则处理。</p>
</li>
<li><p>外部设备提供的处理函数：（也就是<code>action</code>里面的函数）<br> 这里说的“外部设备”可能是芯片，也可能是简单的按键。它们的处理函数由自己驱动程序提供。对于共享中断，比如 GPIO 中断 B，它的中断来源可能有多个，每个中断源对应一个中断处理函数。所以<code> irq_desc[B]</code>中应该有一个链表, 这个链表就是<code> action</code> 链表。一旦程序确定发生了 GPIO 中断 B，那么就会从链表里把那些函数取出来，一一执行。</p>
</li>
</ol>
<h2><span id="1-2-irqaction">1.2 irqaction</span><a href="#1-2-irqaction" class="header-anchor">#</a></h2><p>irqaction 结构体在<code>include/linux/interrupt.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/6.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/7.png" alt="image"></p>
<p><code>irq_desc[A]</code>这里对应的<code>action一般为NULL</code>, 而<code>irq_desc[B]</code>的<code>handle_irq</code>会调用链表里的函数，这些函数就是对应不同的<code>irqaction</code>。</p>
<p>当调用<code>request_irq、request_threaded_irq </code>注册中断处理函数时，内核就会构造一个 <code>irqaction</code> 结构体。在里面保存<code>name、dev_id</code>等，最重要的是 <code>handler、thread_fn、thread</code>。<br>函数原型为：</p>
<h3><span id="1-2-1-request-threaded-irq">1.2.1 request_threaded_irq</span><a href="#1-2-1-request-threaded-irq" class="header-anchor">#</a></h3><h3><span id="1-2-2-request-irq">1.2.2 request_irq</span><a href="#1-2-2-request-irq" class="header-anchor">#</a></h3><h3><span id="1-2-3-devm-request-irq">1.2.3 devm_request_irq</span><a href="#1-2-3-devm-request-irq" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/8.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/9.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/10.png" alt="image"><br>这里irq编号使用的虚拟中断号，虚拟中断号怎么来？详见后面<code>1.4 irq_domain</code>。</p>
<pre><code>handler ：是中断处理的上半部函数，用来处理紧急的事情。
thread_fn ：对应一个内核线程 thread，当 handler 执行完毕，Linux 内核会唤醒对应的内核线程。在内核线程里，会调用 thread_fn 函数。
</code></pre>
<ol>
<li>可以提供 handler 而不提供 thread_fn，就退化为一般的 <code>request_irq</code> 函数。</li>
<li>可以不提供 handler 只提供 thread_fn，完全由内核线程来处理中断。</li>
<li>也可以既提供 handler 也提供 thread_fn，这就是中断上半部、下半部。</li>
</ol>
<p>在 reqeust_irq 时可以传入 dev_id，为何需要 dev_id？作用有 2：</p>
<ol>
<li>中断处理函数执行时，可以使用 <code>dev_id</code></li>
<li>卸载中断时要传入 <code>dev_id</code>，这样才能在<code>action</code>链表中根据 dev_id 找到对应项（所以在共享中断中必须提供<code> dev_id</code>，非共享中断可以不提供）</li>
</ol>
<h2><span id="1-3-irq-data">1.3 irq_data</span><a href="#1-3-irq-data" class="header-anchor">#</a></h2><p>定义再<code>include/linux/irq.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/11.png" alt="image"><br><code>irq_data</code>就是个中转站，里面有<code> irq_chip</code> 指针 <code>irq_domain </code>指针，<code>irq </code>是软件中断号，<code>hwirq </code>是硬件中断号。<br>比如GPIO 中断 B 就是软件中断号，可以找到<code> irq_desc[B]</code>这个数组项；GPIO 里的第 x 号中断，这就是 <code>hwirq</code>。</p>
<p><code>irq、hwirq </code>之间的联系呢？由 <code>irq_domain </code>来建立。下面介绍<code>irq_domain</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/12.png" alt="image"></p>
<h2><span id="1-4-irq-domain">1.4 irq_domain</span><a href="#1-4-irq-domain" class="header-anchor">#</a></h2><p><code>include/linux/irqdomain.h</code> 中定义该结构。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/13.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/14.png" alt="img"></p>
<p>设备树中你会看到这样的属性:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">interrupts = &lt;<span class="number">5</span> IRQ_TYPE_EDGE_RISING&gt;;</span><br></pre></td></tr></table></figure>
<p>表示使用<code>gpio1_5</code>作为中断，<code>hwirq </code>就是 5。当我们在驱动中会使用<code> request_irq(irq, handler)</code>这样的函数来注册中断，<code>irq编号</code>就是虚拟中断，那么虚拟中断号（软件中断号）要怎么得到？<br>就是<code>gpio1</code>对应的<code>irq_domain </code>结构体。<code>irq_domain </code>结构体中有一个 <code>irq_domain_ops </code>结构体，里面有各种操作函数。</p>
<h3><span id="1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain">1.4.0 中断控制器注册 irq_domain</span><a href="#1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/15.png" alt="img"></p>
<p>通过 <code>__irq_domain_add</code> 初始化<code>irq_domain</code>数据结构，然后把 irq_domain 添加到全局的链表<code>irq_domain_list</code>中。</p>
<h3><span id="1-4-1-irq-domain-ops">1.4.1 irq_domain_ops</span><a href="#1-4-1-irq-domain-ops" class="header-anchor">#</a></h3><h4><span id="1-4-1-1-xlate-han-shu">1.4.1.1 xlate函数</span><a href="#1-4-1-1-xlate-han-shu" class="header-anchor">#</a></h4><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/16.png" alt="image"></p>
<p><code>xlate</code>函数<br>用来解析设备树的中断属性，提取出 <code>hwirq、type</code> 等信息。</p>
<h4><span id="1-4-1-2-map-han-shu">1.4.1.2 <code>map</code>函数</span><a href="#1-4-1-2-map-han-shu" class="header-anchor">#</a></h4><p>把 <code>hwirq 转换为 irq</code>。</p>
<h2><span id="1-5-irq-chip">1.5 irq_chip</span><a href="#1-5-irq-chip" class="header-anchor">#</a></h2><p><code>irq_chip </code>结构体在<code>include/linux/irq.h</code>中定义</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/17.png" alt="image"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">* @<span class="attr">irq_startup</span>:  start up the interrupt (defaults to -&gt;enable <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_shutdown</span>:  shut down the interrupt (defaults to -&gt;disable <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_enable</span>:    enable the interrupt (defaults to chip-&gt;unmask <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_disable</span>:  disable the interrupt</span><br><span class="line">* @<span class="attr">irq_ack</span>:    start <span class="keyword">of</span> a <span class="keyword">new</span> interrupt</span><br><span class="line">* @<span class="attr">irq_mask</span>:    mask an interrupt source</span><br><span class="line">* @<span class="attr">irq_mask_ack</span>:  ack and mask an interrupt source</span><br><span class="line">* @<span class="attr">irq_unmask</span>:    unmask an interrupt source</span><br><span class="line">* @<span class="attr">irq_eoi</span>:    end <span class="keyword">of</span> interrupt</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/18.png" alt="在这里插入图片描述"></p>
<p>我们在<code>request_irq</code>后，并不需要手工去使能中断，原因就是系统调用对应的 <code>irq_chip </code>里的<code>irq_enable</code>函数帮我们使能了中断。<br>我们提供的中断处理函数中，也不需要执行主芯片相关的清中断操作，也是系统帮我们调用<code>irq_chip</code>中的相关函数。<br>但是对于外部设备相关的清中断操作，还是需要我们自己做的。就像上面图里的<code>“外部设备 1“、“外部设备 n”</code>，外设备千变万化，内核里没有对应的清除中断操作。</p>
<h1><span id="2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu">2 中断不同结构体之间的关系框图</span><a href="#2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu" class="header-anchor">#</a></h1><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/19.png" alt="image-20240810191140464"></p>
]]></content>
      <tags>
        <tag>中断体系</tag>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>通用裸机-传感器</title>
    <url>/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dht11-wen-shi-du-chuan-gan-qi">1 DHT11温湿度传感器</a><ul>
<li><a href="#1-1-shi-xu-jie-xi">1.1 时序解析</a><ul>
<li><a href="#1-1-1-shu-ju-ge-shi">1.1.1 数据格式</a></li>
<li><a href="#1-1-2-shi-xu-can-shu">1.1.2 时序参数</a></li>
<li><a href="#1-1-3-shu-ju-chuan-shu">1.1.3 数据传输</a></li>
</ul>
</li>
<li><a href="#1-1-4-dai-ma-shi-xian">1.1.4 代码实现</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-dht11-wen-shi-du-chuan-gan-qi">1 DHT11温湿度传感器</span><a href="#1-dht11-wen-shi-du-chuan-gan-qi" class="header-anchor">#</a></h1><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/1.png" alt="img"></p>
<p>MCU通过一条数据线与DH11连接，MCU通过这条线发命令给DH11，DH11再通过这条线把数据发送给MCU。只需要一根GPIO就OK了。</p>
<p>核心就是MCU发给DH11的命令格式和DH11返回的数据格式。</p>
<h2><span id="1-1-shi-xu-jie-xi">1.1 时序解析</span><a href="#1-1-shi-xu-jie-xi" class="header-anchor">#</a></h2><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/2.png" alt="img"></p>
<ol>
<li><p>MCU发送一个开始信号S，这个开始信号是一个低脉冲，然后再拉高。等待DHT11应答。</p>
</li>
<li><p>DH11拉低，做出一个响应信号，再拉高，准备发送数据。</p>
</li>
<li><p>接着就是DH11返回的数据。</p>
</li>
</ol>
<h3><span id="1-1-1-shu-ju-ge-shi">1.1.1 数据格式</span><a href="#1-1-1-shu-ju-ge-shi" class="header-anchor">#</a></h3><p>这些数据一共有40bit,高位先出。（8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据+8bit校验和）</p>
<p>数据有40bit: 8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据+8bit校验和</p>
<h3><span id="1-1-2-shi-xu-can-shu">1.1.2 时序参数</span><a href="#1-1-2-shi-xu-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/3.png" alt="img"></p>
<p>MCU必须先拉低至少18ms, 然后再拉高20-40us, DH11再拉低80us以响应,最后再拉高80us。</p>
<h3><span id="1-1-3-shu-ju-chuan-shu">1.1.3 数据传输</span><a href="#1-1-3-shu-ju-chuan-shu" class="header-anchor">#</a></h3><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/4.png" alt="img"></p>
<p><strong>Bit0</strong>：1bit 50us开始后，DHT11拉低数据时间为30us以内。</p>
<p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/5.png" alt="img"></p>
<p><strong>Bit1</strong>: 1bit 50us开始后，DHT11拉低数据时间为超过70us。</p>
<h2><span id="1-1-4-dai-ma-shi-xian">1.1.4 代码实现</span><a href="#1-1-4-dai-ma-shi-xian" class="header-anchor">#</a></h2><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/6.png" alt="img"></p>
<p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/7.png" alt="img"></p>
<p>使用GPG5引脚:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dht11_data_cfg_as_output</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        GPGCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">10</span>);</span><br><span class="line">        GPGCON |= (<span class="number">1</span>&lt;&lt;<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dht11_data_cfg_as_input</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        GPGCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dht11_data_set</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val)</span><br><span class="line">                GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dht11_data_get</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (GPGDAT &amp; (<span class="number">1</span>&lt;&lt;<span class="number">5</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DHT11操作：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dht11_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dht11_data_cfg_as_output();</span><br><span class="line">    dht11_data_set(<span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dht11_start</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dht11_data_set(<span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">20</span>);</span><br><span class="line">    dht11_data_cfg_as_input();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dht11_wait_ack</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    udelay(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> dht11_data_get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dht11_recv_byte</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dht11_wait_for_val(<span class="number">1</span>, <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;dht11 wait for high data err!\n\r&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        udelay(<span class="number">40</span>);</span><br><span class="line">        data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dht11_data_get() == <span class="number">1</span>)</span><br><span class="line">            data |= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dht11_wait_for_val(<span class="number">0</span>, <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;dht11 wait for low data err!\n\r&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dht11_wait_for_val</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> timeout_us)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (timeout_us--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dht11_data_get() == val)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* ok */</span></span><br><span class="line">        udelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* err */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dht11_read</span><span class="params">(<span class="type">int</span> *hum, <span class="type">int</span> *temp)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hum_m, hum_n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp_m, temp_n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> check;        </span><br><span class="line">    </span><br><span class="line">    dht11_start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != dht11_wait_ack()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dht11 not ack, err!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != dht11_wait_for_val(<span class="number">1</span>, <span class="number">1000</span>)) &#123; <span class="comment">/* 等待ACK变为高电平, 超时时间是1000us */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dht11 wait for ack high err!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != dht11_wait_for_val(<span class="number">0</span>, <span class="number">1000</span>)) &#123; <span class="comment">/* 数据阶段: 等待低电平, 超时时间是1000us */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dht11 wait for data low err!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hum_m  = dht11_recv_byte();</span><br><span class="line">    hum_n  = dht11_recv_byte();</span><br><span class="line">    temp_m = dht11_recv_byte();</span><br><span class="line">    temp_n = dht11_recv_byte();</span><br><span class="line">    check  = dht11_recv_byte();</span><br><span class="line"></span><br><span class="line">    dht11_data_cfg_as_output();</span><br><span class="line">    dht11_data_set(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hum_m + hum_n + temp_m + temp_n == check) &#123;</span><br><span class="line">        *hum  = hum_m;</span><br><span class="line">        *temp = temp_m;</span><br><span class="line">        mdelay(<span class="number">2000</span>);  <span class="comment">/* 读取周期是2S, 不能读太频繁 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dht11 checksum err!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dht11_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hum, temp;</span><br><span class="line">    dht11_init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dht11_read(&amp;hum, &amp;temp) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\rdht11 read err!\n\r&quot;</span>);</span><br><span class="line">            dht11_init();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\rDHT11 : %d humidity, %d temperature\n\r&quot;</span>, hum, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>裸机外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-编译过程Make分析</title>
    <url>/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-make-guo-cheng">1 Make过程</a><ul>
<li><a href="#1-1-zhao-dao-all-y-yi-lai">1.1 找到<code>$(ALL-y)</code>依赖</a></li>
<li><a href="#1-2-bian-yi-u-boot-bin">1.2 编译<code>u-boot.bin</code></a><ul>
<li><a href="#1-2-1-config-of-separate-de-zuo-yong">1.2.1 <code>CONFIG_OF_SEPARATE</code>的作用</a></li>
<li><a href="#1-2-2-if-changed-jie-shi">1.2.2 <code>if_changed</code>解释</a></li>
<li><a href="#1-2-3-head-y-yin-ru">1.2.3 <code>head-y</code>引入</a></li>
<li><a href="#1-2-3-libs-y-yin-ru">1.2.3 <code>libs-y</code>引入</a></li>
<li><a href="#1-2-4-u-boot-lds-yin-ru">1.2.4 <code>u-boot.lds</code>引入</a></li>
<li><a href="#1-2-4-zong-jie">1.2.4 总结</a></li>
<li><a href="#1-2-5-make-wan-zheng-log">1.2.5 make完整log</a><ul>
<li><a href="#1-2-5-1-distclean">1.2.5.1 distclean</a></li>
<li><a href="#1-2-5-2-xxx-defconfig">1.2.5.2 xxx_defconfig</a></li>
<li><a href="#1-2-5-3-make">1.2.5.3 make</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-make-guo-cheng">1 Make过程</span><a href="#1-make-guo-cheng" class="header-anchor">#</a></h1><h2><span id="1-1-zhao-dao-all-y-yi-lai">1.1 找到<code>$(ALL-y)</code>依赖</span><a href="#1-1-zhao-dao-all-y-yi-lai" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- V=1</span><br></pre></td></tr></table></figure>
<p>没有指定编译目标，使用第一个目标：<code>_all</code>。这 里 不 编 译 模 块 ， 所 以 <code>KBUILD_EXTMOD </code>肯定为空，<code>_all </code>的依赖就是<code> all</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/1.png" alt="image"><br>首先编译<code>all</code>目标，<code>$(ALL-y)</code>展开为<code>u-boot.srec u-boot.bin u-boot.sym System.map u-boot.cfg binary_size_check</code> 。<br>因此先编译所有依赖，<code>$(ALL-y)</code><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/2.png" alt="image"><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/3.png" alt="image"><br>根据 uboot 的配置情况也可能包含其他的文件，比如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ALL-<span class="variable">$(CONFIG_ONENAND_U_BOOT)</span> += u-boot-onenand.bin</span><br></pre></td></tr></table></figure>
<p><code>CONFIG_ONENAND_U_BOOT</code> 就是 uboot 中跟<code>ONENAND</code>配置有关的，如果我们使能了<code> ONENAND</code>，那么在<code>.config </code>配置文件中就会有<code>CONFIG_ONENAND_U_BOOT=y</code>这一句。因此展开以后就是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ALL-y += u-boot-onenand.bin</span><br></pre></td></tr></table></figure>
<p>同理，只要是.config配置了CONFIG_XXXX&#x3D;y,那么就会有：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ALL-<span class="variable">$(CONFIG_XXXX)</span> += xxxx.bin</span><br></pre></td></tr></table></figure>
<p>因此展开以后就有：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ALL-y += xxxx.bin</span><br></pre></td></tr></table></figure>
<h2><span id="1-2-bian-yi-u-boot-bin">1.2 编译<code>u-boot.bin</code></span><a href="#1-2-bian-yi-u-boot-bin" class="header-anchor">#</a></h2><p><code>ALL-y </code>里面有个<code> u-boot.bin</code>，这个就是我们最终需要的 uboot 二进制可执行文件。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/4.png" alt="image"><br>由于我们没配置<code>CONFIG_OF_SEPARATE</code>，因此走else流程。<br><code>u-boot.bin </code>依赖于<code> u-boot-nodtb.bin</code>，命令为<code>$(call if_changed,copy) </code>，<code>if_changed </code>是 一 个 函 数 ， 这 个 函 数 在 <code>scripts/Kbuild.include </code>中有定义，顶层 Makefile 中会包含 <code>scripts/Kbuild.include </code>文件。</p>
<h3><span id="1-2-1-config-of-separate-de-zuo-yong">1.2.1 <code>CONFIG_OF_SEPARATE</code>的作用</span><a href="#1-2-1-config-of-separate-de-zuo-yong" class="header-anchor">#</a></h3><p>uboot与dtb可以有以下几种打包组合方式：<br>（1）若定义了<code>CONFIG_OF_EMBED</code>选项，则在链接时会为dtb指定一个以<code>__dtb_dt_begin</code>开头的单独的段，dtb的内容将被直接链接到<code>uboot.bin</code>镜像中。官方建议这种方式只在开发和调试阶段使用，而不要用于生产阶段。<br>（2）若定义了<code>CONFIG_OF_SEPARATE</code>选项，dtb将会被编译为<code>u-boot.dtb</code>文件，而uboot原始镜像被编译为<code>u-boot-nodtb.bin</code>文件，并通过以下命令将它们连接为最终的<code>uboot.bin</code>文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cat u-boot-nodtb.bin u-boot.dtb &gt;uboot.bin</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-2-if-changed-jie-shi">1.2.2 <code>if_changed</code>解释</span><a href="#1-2-2-if-changed-jie-shi" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/5.png" alt="image"><br>判断<code>if $(strip $(any-prereq) $(arg-check))</code>条件，如果不为空，则<code>if_changed</code>等于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@set -e;                                                             		\</span><br><span class="line">	$(echo-cmd) $(cmd_$(1));                                             \</span><br><span class="line">	printf &#x27;%s\n&#x27; &#x27;cmd_<span class="variable">$@</span> := $(make-cmd)&#x27; &gt; $(dot-target).cmd)</span><br></pre></td></tr></table></figure>
<p>利用<code>strip</code>函数将首尾空格去掉，也把字符串中间的空格整理一下。最后输出的值，是以空格为间隔的一个个字符串。<br><code>set -e</code>指的是当其后的shell命令若返回值为非0，则直接错误退出，不再往下执行了。<br><code>dot-target</code>定义如下:<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/6.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">any-prereq = <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span>,<span class="variable">$?</span>)</span> <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span> $(<span class="built_in">wildcard</span> <span class="variable">$^</span>)</span>,<span class="variable">$^</span>)</span><br></pre></td></tr></table></figure>
<p>来分析下这个<code>any-prereq</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1. <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span>,<span class="variable">$?</span>)</span></span><br><span class="line">2. <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span> $(<span class="built_in">wildcard</span> <span class="variable">$^</span>)</span>,<span class="variable">$^</span>)</span><br></pre></td></tr></table></figure>
<p><code>filter-out</code>函数，是将第一组参数里面的值，从第二组排除掉。<br><code>$?</code>变量表示所有比目标文件更新的依赖文件列表，<code>$(PHONY)</code>伪目标声明的所有变量。<br>因此第一条结果就是：所有比目标新的依赖并且不包含伪目标。<br><code>$^</code>表示所有依赖，因此第二条结果表示：从依赖列表种排除所有伪依赖和已经生成的依赖，也就是新依赖。</p>
<p>来分析下这个<code>arg-check</code>：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/7.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$@</span>：是Makefile目标, $(1)表示函数的第一个参数。</span><br></pre></td></tr></table></figure>
<p>总结：当依赖比目标新的时候，或者命令有改变的时候，<code>if_changed </code>就会执行一些命令。</p>
<p>比如下图：当最后链接的时候：<code>cmd_u-boot</code>这条命令就会给到<code>if_changed</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/8.png" alt="image"><br>执行<code>if_changed</code>得到<code>u-boot</code>后再调用<code>obj-copy</code>得到<code>u-boot-nodtb.bin</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/9.png" alt="image"></p>
<h3><span id="1-2-3-head-y-yin-ru">1.2.3 <code>head-y</code>引入</span><a href="#1-2-3-head-y-yin-ru" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/10.png" alt="image"><br>从下图看到<code>uboot.bin</code>其实就是等于<code>uboot-nodtb.bin</code>,只是一个拷贝：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/11.png" alt="image"><br>下图可以看到编译u-boot又依赖<code>$(u-boot-init) $(u-boot-main) u-boot.lds</code>：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/12.png" alt="image"><br><code>u-boot_init </code>和 <code>u-boot-main </code>是两个 变量，在顶层 Makefile 中有定义：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/13.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">head-y 在 arch/arm/Makefile 中 被指定为：</span><br><span class="line">head-y := arch/arm/cpu/armv7/start.o</span><br><span class="line">因此u-boot-init= arch/arm/cpu/armv7/start.o</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-3-libs-y-yin-ru">1.2.3 <code>libs-y</code>引入</span><a href="#1-2-3-libs-y-yin-ru" class="header-anchor">#</a></h3><p><code>$(libs-y)</code>在顶层 Makefile 中被定义为 uboot 所有子目录下<code>build-in.o</code>的集合。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/14.png" alt="image"><br>从上面的代码可以看出，<code>libs-y </code>都是 uboot 各子目录的集合，最后：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs-y := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(libs-y)</span>)</span><br><span class="line">函数 patsubst，将 libs-y 中的“/”替换为”/built-in.o，那么最终libs-y就是所有目录的built-in.o集合。</span><br></pre></td></tr></table></figure>

<p>举个例子：<br>以 <code>drivers/gpio/built-in.o </code>为例，在<code> drivers/gpio/</code>目录下会有个名为<code>.built-in.o.cmd </code>的文件，里面存放了要得到<code>built-in.o</code>需要执行的命令：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/15.png" alt="image"><br><code>drivers/gpio/built-in.o </code>这个文件是使用<code>ld</code>命 令由文件<code> drivers/gpio/mxc_gpio.o</code>生成而来的，<code>mxc_gpio.o </code>是 <code>mxc_gpio.c </code>编译生成的<code>.o </code>文件， 这个是 NXP 的 I.MX 系列的 GPIO 驱动文件。<br>这里用到了<code>ld</code>的<code>“-r”</code>参数，参数含义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-r –relocateable: 产生可重定向的输出.</span><br><span class="line">比如，产生一个输出文件它可再次作为‘ld’的输入，这经常被叫做“部分链接”，</span><br><span class="line">当我们需要将几个小的.o 文件链接成为一个.o 文件的时候，需要使用此选项。</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-4-u-boot-lds-yin-ru">1.2.4 <code>u-boot.lds</code>引入</span><a href="#1-2-4-u-boot-lds-yin-ru" class="header-anchor">#</a></h3><p>前面编译得到<code>u-boot-init 和u-boot-main</code>是为了得到<code>arch/arm/cpu/armv7/start.o</code>和各个子目录 下的 <code>built-in.o</code>，最后通过<code>-T u-boot.lds</code>来链接成一个u-boot。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/16.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-buildroot-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds</span><br><span class="line"><span class="built_in">arch</span>/arm/cpu/armv7/start.o --start-group</span><br><span class="line"><span class="built_in">arch</span>/arm/cpu/built-in.o</span><br><span class="line"><span class="built_in">arch</span>/arm/cpu/armv7/built-in.o</span><br><span class="line"><span class="built_in">arch</span>/arm/imx-common/built-in.o</span><br><span class="line"><span class="built_in">arch</span>/arm/lib/built-in.o</span><br><span class="line">board/freescale/common/built-in.o</span><br><span class="line">board/freescale/mx6ullevk/built-in.o  cmd/built-in.o  common/built-in.o  disk/built-in.o  drivers/built-in.o  drivers/dma/built-in.o  drivers/gpio/built-in.o  drivers/i2c/built-in.o  drivers/mmc/built-in.o  drivers/mtd/built-in.o  drivers/mtd/onenand/built-in.o  drivers/mtd/spi/built-in.o  drivers/net/built-in.o  drivers/net/phy/built-in.o  drivers/pci/built-in.o  drivers/power/built-in.o  drivers/power/battery/built-in.o  drivers/power/fuel_gauge/built-in.o  drivers/power/mfd/built-in.o  drivers/power/pmic/built-in.o  drivers/power/regulator/built-in.o  drivers/serial/built-in.o  drivers/spi/built-in.o  drivers/usb/dwc3/built-in.o  drivers/usb/emul/built-in.o  drivers/usb/eth/built-in.o  drivers/usb/gadget/built-in.o  drivers/usb/gadget/udc/built-in.o  drivers/usb/host/built-in.o  drivers/usb/musb-new/built-in.o  drivers/usb/musb/built-in.o  drivers/usb/phy/built-in.o  drivers/usb/ulpi/built-in.o  fs/built-in.o  lib/built-in.o  net/built-in.o  <span class="built_in">test</span>/built-in.o  <span class="built_in">test</span>/dm/built-in.o</span><br><span class="line">--end-group <span class="built_in">arch</span>/arm/lib/eabi_compat.o</span><br><span class="line">-L /home/book/ftp/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0</span><br><span class="line">-lgcc -Map u-boot.map</span><br></pre></td></tr></table></figure>

<p>可以看出最终是用 <code>arm-linux-gnueabihf-ld.bfd 命令将 </code>arch&#x2F;arm&#x2F;cpu&#x2F;armv7&#x2F;start.o <code>和其他众多 的</code> built_in.o &#96;链接在一起，形成 u-boot。</p>
<h3><span id="1-2-4-zong-jie">1.2.4 总结</span><a href="#1-2-4-zong-jie" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/17.png" alt="image"><br>首先要找到<code>_all</code>目标，找到<code>ALL-y</code>依赖，最终会发现要编译<code>u-boot.bin</code>，又依赖要先编译<code>u-boot</code>。<br>然后<code>u-boot</code>又会依赖<code>u-boot-init</code>和<code> u-boot-main</code>，等得到<code>start.o</code>和所有依赖的<code>built-in.o</code>后，结合<code>u-boot.lds</code>链接成u-boot。</p>
<h3><span id="1-2-5-make-wan-zheng-log">1.2.5 make完整log</span><a href="#1-2-5-make-wan-zheng-log" class="header-anchor">#</a></h3><h4><span id="1-2-5-1-distclean">1.2.5.1 distclean</span><a href="#1-2-5-1-distclean" class="header-anchor">#</a></h4><details>
<summary>点击查看代码</summary>
<pre><code>
make distclean V=1
make -f ./scripts/Makefile.clean obj=api
make -f ./scripts/Makefile.clean obj=cmd
make -f ./scripts/Makefile.clean obj=common
make -f ./scripts/Makefile.clean obj=common/init
make -f ./scripts/Makefile.clean obj=disk
make -f ./scripts/Makefile.clean obj=drivers
make -f ./scripts/Makefile.clean obj=drivers/adc
make -f ./scripts/Makefile.clean obj=drivers/bios_emulator
make -f ./scripts/Makefile.clean obj=drivers/block
make -f ./scripts/Makefile.clean obj=drivers/bootcount
make -f ./scripts/Makefile.clean obj=drivers/clk
make -f ./scripts/Makefile.clean obj=drivers/clk/uniphier
make -f ./scripts/Makefile.clean obj=drivers/core
make -f ./scripts/Makefile.clean obj=drivers/cpu
make -f ./scripts/Makefile.clean obj=drivers/crypto
make -f ./scripts/Makefile.clean obj=drivers/crypto/fsl
make -f ./scripts/Makefile.clean obj=drivers/crypto/rsa_mod_exp
make -f ./scripts/Makefile.clean obj=drivers/ddr/microchip
make -f ./scripts/Makefile.clean obj=drivers/demo
make -f ./scripts/Makefile.clean obj=drivers/dfu
make -f ./scripts/Makefile.clean obj=drivers/fpga
make -f ./scripts/Makefile.clean obj=drivers/hwmon
make -f ./scripts/Makefile.clean obj=drivers/input
make -f ./scripts/Makefile.clean obj=drivers/led
make -f ./scripts/Makefile.clean obj=drivers/memory
make -f ./scripts/Makefile.clean obj=drivers/misc
make -f ./scripts/Makefile.clean obj=drivers/pch
make -f ./scripts/Makefile.clean obj=drivers/pcmcia
make -f ./scripts/Makefile.clean obj=drivers/pinctrl
make -f ./scripts/Makefile.clean obj=drivers/pinctrl/nxp
make -f ./scripts/Makefile.clean obj=drivers/pinctrl/rockchip
make -f ./scripts/Makefile.clean obj=drivers/pinctrl/uniphier
make -f ./scripts/Makefile.clean obj=drivers/pwm
make -f ./scripts/Makefile.clean obj=drivers/qe
make -f ./scripts/Makefile.clean obj=drivers/ram
make -f ./scripts/Makefile.clean obj=drivers/remoteproc
make -f ./scripts/Makefile.clean obj=drivers/rtc
make -f ./scripts/Makefile.clean obj=drivers/soc
make -f ./scripts/Makefile.clean obj=drivers/soc/keystone
make -f ./scripts/Makefile.clean obj=drivers/sound
make -f ./scripts/Makefile.clean obj=drivers/thermal
make -f ./scripts/Makefile.clean obj=drivers/timer
make -f ./scripts/Makefile.clean obj=drivers/tpm
make -f ./scripts/Makefile.clean obj=drivers/twserial
make -f ./scripts/Makefile.clean obj=drivers/video
make -f ./scripts/Makefile.clean obj=drivers/video/bridge
make -f ./scripts/Makefile.clean obj=drivers/video/rockchip
make -f ./scripts/Makefile.clean obj=drivers/video/tegra124
make -f ./scripts/Makefile.clean obj=drivers/watchdog
make -f ./scripts/Makefile.clean obj=drivers/ddr/altera
make -f ./scripts/Makefile.clean obj=drivers/ddr/fsl
make -f ./scripts/Makefile.clean obj=drivers/dma
make -f ./scripts/Makefile.clean obj=drivers/gpio
make -f ./scripts/Makefile.clean obj=drivers/i2c
make -f ./scripts/Makefile.clean obj=drivers/i2c/muxes
make -f ./scripts/Makefile.clean obj=drivers/mmc
make -f ./scripts/Makefile.clean obj=drivers/mtd
make -f ./scripts/Makefile.clean obj=drivers/mtd/nand
make -f ./scripts/Makefile.clean obj=drivers/mtd/onenand
make -f ./scripts/Makefile.clean obj=drivers/mtd/spi
make -f ./scripts/Makefile.clean obj=drivers/mtd/ubi
make -f ./scripts/Makefile.clean obj=drivers/net
make -f ./scripts/Makefile.clean obj=drivers/net/fsl-mc
make -f ./scripts/Makefile.clean obj=drivers/net/fsl-mc/dpio
make -f ./scripts/Makefile.clean obj=drivers/net/ldpaa_eth
make -f ./scripts/Makefile.clean obj=drivers/net/fm
make -f ./scripts/Makefile.clean obj=drivers/net/phy
make -f ./scripts/Makefile.clean obj=drivers/pci
make -f ./scripts/Makefile.clean obj=drivers/power
make -f ./scripts/Makefile.clean obj=drivers/power/battery
make -f ./scripts/Makefile.clean obj=drivers/power/fuel_gauge
make -f ./scripts/Makefile.clean obj=drivers/power/mfd
make -f ./scripts/Makefile.clean obj=drivers/power/pmic
make -f ./scripts/Makefile.clean obj=drivers/power/regulator
make -f ./scripts/Makefile.clean obj=drivers/serial
make -f ./scripts/Makefile.clean obj=drivers/spi
make -f ./scripts/Makefile.clean obj=drivers/usb/dwc3
make -f ./scripts/Makefile.clean obj=drivers/usb/emul
make -f ./scripts/Makefile.clean obj=drivers/usb/eth
make -f ./scripts/Makefile.clean obj=drivers/usb/gadget
make -f ./scripts/Makefile.clean obj=drivers/usb/gadget/udc
make -f ./scripts/Makefile.clean obj=drivers/usb/host
make -f ./scripts/Makefile.clean obj=drivers/usb/musb
make -f ./scripts/Makefile.clean obj=drivers/usb/musb-new
make -f ./scripts/Makefile.clean obj=drivers/usb/phy
make -f ./scripts/Makefile.clean obj=drivers/usb/ulpi
make -f ./scripts/Makefile.clean obj=dts
make -f ./scripts/Makefile.clean obj=dts/../arch/arm/dts
make -f ./scripts/Makefile.clean obj=dts/../arch/microblaze/dts
make -f ./scripts/Makefile.clean obj=dts/../arch/mips/dts
make -f ./scripts/Makefile.clean obj=dts/../arch/sandbox/dts
make -f ./scripts/Makefile.clean obj=dts/../arch/x86/dts
make -f ./scripts/Makefile.clean obj=examples
make -f ./scripts/Makefile.clean obj=examples/api
make -f ./scripts/Makefile.clean obj=examples/standalone
  rm -f examples/standalone/hello_world examples/standalone/hello_world.srec examples/standalone/hello_world.bin examples/standalone/libstubs.o examples/standalone/hello_world.o examples/standalone/stubs.o examples/standalone/hello_world.srec examples/standalone/hello_world.bin
make -f ./scripts/Makefile.clean obj=fs
make -f ./scripts/Makefile.clean obj=fs/cbfs
make -f ./scripts/Makefile.clean obj=fs/cramfs
make -f ./scripts/Makefile.clean obj=fs/ext4
make -f ./scripts/Makefile.clean obj=fs/fat
make -f ./scripts/Makefile.clean obj=fs/jffs2
make -f ./scripts/Makefile.clean obj=fs/reiserfs
make -f ./scripts/Makefile.clean obj=fs/sandbox
make -f ./scripts/Makefile.clean obj=fs/ubifs
make -f ./scripts/Makefile.clean obj=fs/yaffs2
make -f ./scripts/Makefile.clean obj=fs/zfs
make -f ./scripts/Makefile.clean obj=lib
make -f ./scripts/Makefile.clean obj=lib/bzip2
make -f ./scripts/Makefile.clean obj=lib/dhry
make -f ./scripts/Makefile.clean obj=lib/efi
make -f ./scripts/Makefile.clean obj=lib/libfdt
make -f ./scripts/Makefile.clean obj=lib/lzma
make -f ./scripts/Makefile.clean obj=lib/lzo
make -f ./scripts/Makefile.clean obj=lib/rsa
make -f ./scripts/Makefile.clean obj=lib/tizen
make -f ./scripts/Makefile.clean obj=lib/zlib
make -f ./scripts/Makefile.clean obj=net
make -f ./scripts/Makefile.clean obj=post
make -f ./scripts/Makefile.clean obj=post/cpu/mpc83xx
make -f ./scripts/Makefile.clean obj=post/cpu/mpc8xx
make -f ./scripts/Makefile.clean obj=post/cpu/ppc4xx
make -f ./scripts/Makefile.clean obj=post/drivers
make -f ./scripts/Makefile.clean obj=post/lib_powerpc
make -f ./scripts/Makefile.clean obj=post/lib_powerpc/fpu
make -f ./scripts/Makefile.clean obj=test
make -f ./scripts/Makefile.clean obj=test/dm
make -f ./scripts/Makefile.clean obj=test/env
make -f ./scripts/Makefile.clean obj=tools
make -f ./scripts/Makefile.clean obj=tools/easylogo
make -f ./scripts/Makefile.clean obj=tools/env
make -f ./scripts/Makefile.clean obj=tools/gdb
  rm -f tools/mkenvimage tools/dumpimage tools/mkimage tools/proftool tools/fdtgrep tools/mkenvimage tools/dumpimage tools/mkimage tools/proftool tools/fdtgrep tools/gen_eth_addr tools/img2srec
  rm -rf tools/lib tools/common
make -f ./scripts/Makefile.clean obj=doc/DocBook
  rm -rf .tmp_versions
  rm -f lpc32xx-* include/bmp_logo.h include/bmp_logo_data.h boot* u-boot* MLO* SPL System.map
make -f ./scripts/Makefile.clean obj=scripts
make -f ./scripts/Makefile.clean obj=scripts/basic
  rm -f scripts/basic/fixdep scripts/basic/fixdep
make -f ./scripts/Makefile.clean obj=scripts/kconfig
  rm -f scripts/kconfig/zconf.tab.c scripts/kconfig/zconf.lex.c scripts/kconfig/zconf.hash.c scripts/kconfig/conf
  rm -rf include/config include/generated
  rm -f .config include/autoconf.mk.dep include/autoconf.mk include/config.h
</code></pre></details>

<h4><span id="1-2-5-2-xxx-defconfig">1.2.5.2 xxx_defconfig</span><a href="#1-2-5-2-xxx-defconfig" class="header-anchor">#</a></h4><details>
<summary>点击查看代码</summary>
<pre><code>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig V=1
make -f ./scripts/Makefile.build obj=scripts/basic
  cc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/fixdep scripts/basic/fixdep.c
rm -f .tmp_quiet_recordmcount
echo "srctree ."
srctree .
KBUILD_KCONFIG
make -f ./scripts/Makefile.build obj=scripts/kconfig mx6ull_14x14_ddr512_emmc_defconfig
  cc -Wp,-MD,scripts/kconfig/.conf.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=600 -DCURSES_LOC="<ncurses.h>" -DNCURSES_WIDECHAR=1 -DLOCALE   -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c
  cat scripts/kconfig/zconf.tab.c_shipped > scripts/kconfig/zconf.tab.c
  cat scripts/kconfig/zconf.lex.c_shipped > scripts/kconfig/zconf.lex.c
  cat scripts/kconfig/zconf.hash.c_shipped > scripts/kconfig/zconf.hash.c
  cc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=600 -DCURSES_LOC="<ncurses.h>" -DNCURSES_WIDECHAR=1 -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c
In file included from scripts/kconfig/zconf.tab.c:2534:
scripts/kconfig/confdata.c: In function ‘conf_write’:
scripts/kconfig/confdata.c:771:19: warning: ‘%s’ directive writing likely 7 or more bytes into a region of size between 1 and 4097 [-Wformat-overflow=]
  771 |  sprintf(newname, "%s%s", dirname, basename);
      |                   ^~~~~~
scripts/kconfig/confdata.c:771:19: note: assuming directive output of 7 bytes
In file included from /usr/include/stdio.h:867,
                 from scripts/kconfig/zconf.tab.c:84:
/usr/include/x86_64-linux-gnu/bits/stdio2.h:36:10: note: ‘__builtin___sprintf_chk’ output 1 or more bytes (assuming 4104) into a destination of size 4097
   36 |   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   37 |       __bos (__s), __fmt, __va_arg_pack ());
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from scripts/kconfig/zconf.tab.c:2534:
scripts/kconfig/confdata.c:774:20: warning: ‘.tmpconfig.’ directive writing 11 bytes into a region of size between 1 and 4097 [-Wformat-overflow=]
  774 |   sprintf(tmpname, "%s.tmpconfig.%d", dirname, (int)getpid());
      |                    ^~~~~~~~~~~~~~~~~
In file included from /usr/include/stdio.h:867,
                 from scripts/kconfig/zconf.tab.c:84:
/usr/include/x86_64-linux-gnu/bits/stdio2.h:36:10: note: ‘__builtin___sprintf_chk’ output between 13 and 4119 bytes into a destination of size 4097
   36 |   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   37 |       __bos (__s), __fmt, __va_arg_pack ());
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  cc  -o scripts/kconfig/conf scripts/kconfig/conf.o scripts/kconfig/zconf.tab.o
scripts/kconfig/conf  --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig Kconfig
#
configuration written to .config
#
</ncurses.h></ncurses.h></code></pre></details>

<h4><span id="1-2-5-3-make">1.2.5.3 make</span><a href="#1-2-5-3-make" class="header-anchor">#</a></h4><details>
<summary>点击查看代码</summary>
<pre><code>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- V=1
make -f ./Makefile silentoldconfig
make -f ./scripts/Makefile.build obj=scripts/basic
rm -f .tmp_quiet_recordmcount
echo "srctree ."
srctree .
KBUILD_KCONFIG
make -f ./scripts/Makefile.build obj=scripts/kconfig silentoldconfig
mkdir -p include/config include/generated
scripts/kconfig/conf  --silentoldconfig Kconfig
make -f ./scripts/Makefile.autoconf || \
        { rm -f include/config/auto.conf; false; }
if [ -d arch/arm/mach-mx6/include/mach ]; then  \
        dest=../../mach-mx6/include/mach;                       \
else                                                            \
        dest=arch-mx6;                  \
fi;                                                             \
ln -fsn $dest arch/arm/include/asm/arch
set -e; : '  CHK     include/config.h'; mkdir -p include/;      (echo "/* Automatically generated - do not edit */"; for i in $(echo "IMX_CONFIG=board/freescale/mx6ullevk/imximage-ddr512.cfg,MX6ULL_EVK_EMMC_REWORK" | sed 's/,/ /g'); do echo \#define CONFIG_$i | sed '/=/ {s/=/      /;q; } ; { s/$/ 1/; }'; done; echo \#define CONFIG_BOARDDIR board/freescale/mx6ullevk; echo \#include \<config_defaults.h\>; echo \#include \<config_uncmd_spl.h\>; echo \#include \<configs "mx6ullevk".h\>; echo \#include \<asm config.h\>; echo \#include \<config_fallbacks.h\>;) < scripts/Makefile.autoconf > include/config.h.tmp; if [ -r include/config.h ] && cmp -s include/config.h include/config.h.tmp; then rm -f include/config.h.tmp; else : '  UPD     include/config.h'; mv -f include/config.h.tmp include/config.h; fi
  arm-linux-gnueabihf-gcc -E -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -O2 -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time  -D__KERNEL__ -D__UBOOT__   -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe -Iinclude  -I./arch/arm/include -include ./include/linux/kconfig.h  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include  -DDO_DEPS_ONLY -dM ./include/common.h > include/autoconf.mk.tmp && { sed -n -f ./tools/scripts/define2mk.sed include/autoconf.mk.tmp | while read line; do if [ -n "" ] || ! grep -q "${line%=*}=" include/config/auto.conf; then echo "$line"; fi done > include/autoconf.mk; rm include/autoconf.mk.tmp; } || { rm include/autoconf.mk.tmp; false; }
  arm-linux-gnueabihf-gcc -x c -DDO_DEPS_ONLY -M -MP -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -O2 -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time  -D__KERNEL__ -D__UBOOT__   -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe -Iinclude  -I./arch/arm/include -include ./include/linux/kconfig.h  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -MQ include/config/auto.conf ./include/common.h > include/autoconf.mk.dep || { rm include/autoconf.mk.dep; false; }
touch include/config/auto.conf
set -e; : '  CHK     include/config/uboot.release'; mkdir -p include/config/;   echo "2016.03$(/bin/bash ./scripts/setlocalversion .)" < include/config/auto.conf > include/config/uboot.release.tmp; if [ -r include/config/uboot.release ] && cmp -s include/config/uboot.release include/config/uboot.release.tmp; then rm -f include/config/uboot.release.tmp; else : '  UPD     include/config/uboot.release'; mv -f include/config/uboot.release.tmp include/config/uboot.release; fi
echo "srctree ."
srctree .
set -e; : '  CHK     include/generated/version_autogenerated.h'; mkdir -p include/generated/;   (echo \#define PLAIN_VERSION \"2016.03\"; echo \#define U_BOOT_VERSION \"U-Boot \" PLAIN_VERSION; echo \#define CC_VERSION_STRING \"$(arm-linux-gnueabihf-gcc --version | head -n 1)\"; echo \#define LD_VERSION_STRING \"$(arm-linux-gnueabihf-ld.bfd --version | head -n 1)\"; ) < include/config/uboot.release > include/generated/version_autogenerated.h.tmp; if [ -r include/generated/version_autogenerated.h ] && cmp -s include/generated/version_autogenerated.h include/generated/version_autogenerated.h.tmp; then rm -f include/generated/version_autogenerated.h.tmp; else : '  UPD     include/generated/version_autogenerated.h'; mv -f include/generated/version_autogenerated.h.tmp include/generated/version_autogenerated.h; fi
set -e; : '  CHK     include/generated/timestamp_autogenerated.h'; mkdir -p include/generated/;         (if test -n "${SOURCE_DATE_EPOCH}"; then SOURCE_DATE="@${SOURCE_DATE_EPOCH}"; DATE=""; for date in gdate date.gnu date; do ${date} -u -d "${SOURCE_DATE}" >/dev/null 2>&1 && DATE="${date}"; done; if test -n "${DATE}"; then LC_ALL=C ${DATE} -u -d "${SOURCE_DATE}" +'#define U_BOOT_DATE "%b %d %C%y"'; LC_ALL=C ${DATE} -u -d "${SOURCE_DATE}" +'#define U_BOOT_TIME "%T"'; LC_ALL=C ${DATE} -u -d "${SOURCE_DATE}" +'#define U_BOOT_TZ "%z"'; LC_ALL=C ${DATE} -u -d "${SOURCE_DATE}" +'#define U_BOOT_DMI_DATE "%m/%d/%Y"'; else return 42; fi; else LC_ALL=C date +'#define U_BOOT_DATE "%b %d %C%y"'; LC_ALL=C date +'#define U_BOOT_TIME "%T"'; LC_ALL=C date +'#define U_BOOT_TZ "%z"'; LC_ALL=C date +'#define U_BOOT_DMI_DATE "%m/%d/%Y"'; fi) < Makefile > include/generated/timestamp_autogenerated.h.tmp; if [ -r include/generated/timestamp_autogenerated.h ] && cmp -s include/generated/timestamp_autogenerated.h include/generated/timestamp_autogenerated.h.tmp; then rm -f include/generated/timestamp_autogenerated.h.tmp; else : '  UPD     include/generated/timestamp_autogenerated.h'; mv -f include/generated/timestamp_autogenerated.h.tmp include/generated/timestamp_autogenerated.h; fi
make -f ./scripts/Makefile.build obj=scripts/basic
rm -f .tmp_quiet_recordmcount
make -f ./scripts/Makefile.build obj=.
mkdir -p lib/
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.asm-offsets.s.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a -DDO_DEPS_ONLY    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(asm_offsets)"  -D"KBUILD_MODNAME=KBUILD_STR(asm_offsets)"  -fverbose-asm -S -o lib/asm-offsets.s lib/asm-offsets.c
set -e; : '  CHK     include/generated/generic-asm-offsets.h'; mkdir -p include/generated/;     (set -e; echo "#ifndef __GENERIC_ASM_OFFSETS_H__"; echo "#define __GENERIC_ASM_OFFSETS_H__"; echo "/*"; echo " * DO NOT MODIFY."; echo " *"; echo " * This file was generated by Kbuild"; echo " */"; echo ""; sed -ne    "s:[[:space:]]*\.ascii[[:space:]]*\"\(.*\)\":\1:; /^->/{s:->#\(.*\):/* \1 */:; s:^->\([^ ]*\) [\$#]*\([-0-9]*\) \(.*\):#define \1 \2 /* \3 */:; s:^->\([^ ]*\) [\$#]*\([^ ]*\) \(.*\):#define \1 \2 /* \3 */:; s:->::; p;}"; echo ""; echo "#endif" ) < lib/asm-offsets.s > include/generated/generic-asm-offsets.h.tmp; if [ -r include/generated/generic-asm-offsets.h ] && cmp -s include/generated/generic-asm-offsets.h include/generated/generic-asm-offsets.h.tmp; then rm -f include/generated/generic-asm-offsets.h.tmp; else : '  UPD     include/generated/generic-asm-offsets.h'; mv -f include/generated/generic-asm-offsets.h.tmp include/generated/generic-asm-offsets.h; fi
mkdir -p arch/arm/lib/
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.asm-offsets.s.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a -DDO_DEPS_ONLY    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(asm_offsets)"  -D"KBUILD_MODNAME=KBUILD_STR(asm_offsets)"  -fverbose-asm -S -o arch/arm/lib/asm-offsets.s arch/arm/lib/asm-offsets.c
set -e; : '  CHK     include/generated/asm-offsets.h'; mkdir -p include/generated/;     (set -e; echo "#ifndef __ASM_OFFSETS_H__"; echo "#define __ASM_OFFSETS_H__"; echo "/*"; echo " * DO NOT MODIFY."; echo " *"; echo " * This file was generated by Kbuild"; echo " */"; echo ""; sed -ne    "s:[[:space:]]*\.ascii[[:space:]]*\"\(.*\)\":\1:; /^->/{s:->#\(.*\):/* \1 */:; s:^->\([^ ]*\) [\$#]*\([-0-9]*\) \(.*\):#define \1 \2 /* \3 */:; s:^->\([^ ]*\) [\$#]*\([^ ]*\) \(.*\):#define \1 \2 /* \3 */:; s:->::; p;}"; echo ""; echo "#endif" ) < arch/arm/lib/asm-offsets.s > include/generated/asm-offsets.h.tmp; if [ -r include/generated/asm-offsets.h ] && cmp -s include/generated/asm-offsets.h include/generated/asm-offsets.h.tmp; then rm -f include/generated/asm-offsets.h.tmp; else : '  UPD     include/generated/asm-offsets.h'; mv -f include/generated/asm-offsets.h.tmp include/generated/asm-offsets.h; fi
make -f ./scripts/Makefile.build obj=tools
  cc -Wp,-MD,tools/.gen_eth_addr.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -o tools/gen_eth_addr tools/gen_eth_addr.c
  cc -Wp,-MD,tools/.img2srec.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -o tools/img2srec tools/img2srec.c
  cc -Wp,-MD,tools/.mkenvimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/mkenvimage.o tools/mkenvimage.c
  cc -Wp,-MD,tools/.os_support.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/os_support.o tools/os_support.c
  echo "#include <.. lib crc32.c>" >tools/lib/crc32.c
  cc -Wp,-MD,tools/lib/.crc32.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -c -o tools/lib/crc32.o tools/lib/crc32.c
  cc  -o tools/mkenvimage tools/mkenvimage.o tools/os_support.o tools/lib/crc32.o
  cc -Wp,-MD,tools/.aisimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/aisimage.o tools/aisimage.c
  cc -Wp,-MD,tools/.atmelimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/atmelimage.o tools/atmelimage.c
  echo "#include <.. common bootm.c>" >tools/common/bootm.c
  cc -Wp,-MD,tools/common/.bootm.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/common/bootm.o tools/common/bootm.c
  cc -Wp,-MD,tools/.default_image.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/default_image.o tools/default_image.c
  echo "#include <.. lib fdtdec_common.c>" >tools/lib/fdtdec_common.c
  cc -Wp,-MD,tools/lib/.fdtdec_common.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/fdtdec_common.o tools/lib/fdtdec_common.c
  echo "#include <.. lib fdtdec.c>" >tools/lib/fdtdec.c
  cc -Wp,-MD,tools/lib/.fdtdec.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/fdtdec.o tools/lib/fdtdec.c
  cc -Wp,-MD,tools/.fit_common.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/fit_common.o tools/fit_common.c
  cc -Wp,-MD,tools/.fit_image.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/fit_image.o tools/fit_image.c
  cc -Wp,-MD,tools/.gpimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/gpimage.o tools/gpimage.c
  cc -Wp,-MD,tools/.gpimage-common.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/gpimage-common.o tools/gpimage-common.c
  echo "#include <.. common image-fit.c>" >tools/common/image-fit.c
  cc -Wp,-MD,tools/common/.image-fit.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/common/image-fit.o tools/common/image-fit.c
  cc -Wp,-MD,tools/.image-host.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/image-host.o tools/image-host.c
  echo "#include <.. common image.c>" >tools/common/image.c
  cc -Wp,-MD,tools/common/.image.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/common/image.o tools/common/image.c
  cc -Wp,-MD,tools/.imagetool.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/imagetool.o tools/imagetool.c
  cc -Wp,-MD,tools/.imximage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/imximage.o tools/imximage.c
  cc -Wp,-MD,tools/.kwbimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/kwbimage.o tools/kwbimage.c
  echo "#include <.. lib md5.c>" >tools/lib/md5.c
  cc -Wp,-MD,tools/lib/.md5.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -c -o tools/lib/md5.o tools/lib/md5.c
  cc -Wp,-MD,tools/.lpc32xximage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lpc32xximage.o tools/lpc32xximage.c
  cc -Wp,-MD,tools/.mxsimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/mxsimage.o tools/mxsimage.c
  cc -Wp,-MD,tools/.omapimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/omapimage.o tools/omapimage.c
  cc -Wp,-MD,tools/.pblimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/pblimage.o tools/pblimage.c
  cc -Wp,-MD,tools/.pbl_crc32.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/pbl_crc32.o tools/pbl_crc32.c
  echo "#include <.. lib rc4.c>" >tools/lib/rc4.c
  cc -Wp,-MD,tools/lib/.rc4.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/rc4.o tools/lib/rc4.c
  cc -Wp,-MD,tools/.rkcommon.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/rkcommon.o tools/rkcommon.c
  cc -Wp,-MD,tools/.rkimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/rkimage.o tools/rkimage.c
  cc -Wp,-MD,tools/.rksd.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/rksd.o tools/rksd.c
  cc -Wp,-MD,tools/.rkspi.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/rkspi.o tools/rkspi.c
  cc -Wp,-MD,tools/.socfpgaimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/socfpgaimage.o tools/socfpgaimage.c
  echo "#include <.. lib sha1.c>" >tools/lib/sha1.c
  cc -Wp,-MD,tools/lib/.sha1.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -c -o tools/lib/sha1.o tools/lib/sha1.c
  echo "#include <.. lib sha256.c>" >tools/lib/sha256.c
  cc -Wp,-MD,tools/lib/.sha256.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -c -o tools/lib/sha256.o tools/lib/sha256.c
  echo "#include <.. common hash.c>" >tools/common/hash.c
  cc -Wp,-MD,tools/common/.hash.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/common/hash.o tools/common/hash.c
  cc -Wp,-MD,tools/.ublimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/ublimage.o tools/ublimage.c
  cc -Wp,-MD,tools/.zynqimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/zynqimage.o tools/zynqimage.c
  echo "#include <.. lib libfdt fdt.c>" >tools/lib/libfdt/fdt.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt.o tools/lib/libfdt/fdt.c
  echo "#include <.. lib libfdt fdt_ro.c>" >tools/lib/libfdt/fdt_ro.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_ro.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_ro.o tools/lib/libfdt/fdt_ro.c
  echo "#include <.. lib libfdt fdt_rw.c>" >tools/lib/libfdt/fdt_rw.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_rw.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_rw.o tools/lib/libfdt/fdt_rw.c
  echo "#include <.. lib libfdt fdt_strerror.c>" >tools/lib/libfdt/fdt_strerror.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_strerror.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_strerror.o tools/lib/libfdt/fdt_strerror.c
  echo "#include <.. lib libfdt fdt_wip.c>" >tools/lib/libfdt/fdt_wip.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_wip.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_wip.o tools/lib/libfdt/fdt_wip.c
  echo "#include <.. lib libfdt fdt_region.c>" >tools/lib/libfdt/fdt_region.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_region.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_region.o tools/lib/libfdt/fdt_region.c
  cc -Wp,-MD,tools/.dumpimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/dumpimage.o tools/dumpimage.c
  cc  -o tools/dumpimage tools/aisimage.o tools/atmelimage.o tools/common/bootm.o tools/lib/crc32.o tools/default_image.o tools/lib/fdtdec_common.o tools/lib/fdtdec.o tools/fit_common.o tools/fit_image.o tools/gpimage.o tools/gpimage-common.o tools/common/image-fit.o tools/image-host.o tools/common/image.o tools/imagetool.o tools/imximage.o tools/kwbimage.o tools/lib/md5.o tools/lpc32xximage.o tools/mxsimage.o tools/omapimage.o tools/os_support.o tools/pblimage.o tools/pbl_crc32.o tools/lib/rc4.o tools/rkcommon.o tools/rkimage.o tools/rksd.o tools/rkspi.o tools/socfpgaimage.o tools/lib/sha1.o tools/lib/sha256.o tools/common/hash.o tools/ublimage.o tools/zynqimage.o tools/lib/libfdt/fdt.o tools/lib/libfdt/fdt_ro.o tools/lib/libfdt/fdt_rw.o tools/lib/libfdt/fdt_strerror.o tools/lib/libfdt/fdt_wip.o tools/lib/libfdt/fdt_region.o tools/dumpimage.o
  cc -Wp,-MD,tools/.mkimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/mkimage.o tools/mkimage.c
  cc  -o tools/mkimage tools/aisimage.o tools/atmelimage.o tools/common/bootm.o tools/lib/crc32.o tools/default_image.o tools/lib/fdtdec_common.o tools/lib/fdtdec.o tools/fit_common.o tools/fit_image.o tools/gpimage.o tools/gpimage-common.o tools/common/image-fit.o tools/image-host.o tools/common/image.o tools/imagetool.o tools/imximage.o tools/kwbimage.o tools/lib/md5.o tools/lpc32xximage.o tools/mxsimage.o tools/omapimage.o tools/os_support.o tools/pblimage.o tools/pbl_crc32.o tools/lib/rc4.o tools/rkcommon.o tools/rkimage.o tools/rksd.o tools/rkspi.o tools/socfpgaimage.o tools/lib/sha1.o tools/lib/sha256.o tools/common/hash.o tools/ublimage.o tools/zynqimage.o tools/lib/libfdt/fdt.o tools/lib/libfdt/fdt_ro.o tools/lib/libfdt/fdt_rw.o tools/lib/libfdt/fdt_strerror.o tools/lib/libfdt/fdt_wip.o tools/lib/libfdt/fdt_region.o tools/mkimage.o
  cc -Wp,-MD,tools/.proftool.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -o tools/proftool tools/proftool.c
  cc -Wp,-MD,tools/.fdtgrep.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/fdtgrep.o tools/fdtgrep.c
  cc  -o tools/fdtgrep tools/lib/libfdt/fdt.o tools/lib/libfdt/fdt_ro.o tools/lib/libfdt/fdt_rw.o tools/lib/libfdt/fdt_strerror.o tools/lib/libfdt/fdt_wip.o tools/lib/libfdt/fdt_region.o tools/fdtgrep.o
make -f ./scripts/Makefile.build obj=arch/arm/cpu
   rm -f arch/arm/cpu/built-in.o; arm-linux-gnueabihf-ar rcs arch/arm/cpu/built-in.o
make -f ./scripts/Makefile.build obj=arch/arm/cpu/armv7
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.cache_v7.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache_v7)"  -D"KBUILD_MODNAME=KBUILD_STR(cache_v7)" -c -o arch/arm/cpu/armv7/cache_v7.o arch/arm/cpu/armv7/cache_v7.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.cpu.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cpu)"  -D"KBUILD_MODNAME=KBUILD_STR(cpu)" -c -o arch/arm/cpu/armv7/cpu.o arch/arm/cpu/armv7/cpu.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.cp15.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cp15)"  -D"KBUILD_MODNAME=KBUILD_STR(cp15)" -c -o arch/arm/cpu/armv7/cp15.o arch/arm/cpu/armv7/cp15.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.syslib.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(syslib)"  -D"KBUILD_MODNAME=KBUILD_STR(syslib)" -c -o arch/arm/cpu/armv7/syslib.o arch/arm/cpu/armv7/syslib.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.lowlevel_init.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/cpu/armv7/lowlevel_init.o arch/arm/cpu/armv7/lowlevel_init.S
make -f ./scripts/Makefile.build obj=arch/arm/cpu/armv7/mx6
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/mx6/.soc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(soc)"  -D"KBUILD_MODNAME=KBUILD_STR(soc)" -c -o arch/arm/cpu/armv7/mx6/soc.o arch/arm/cpu/armv7/mx6/soc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/mx6/.clock.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(clock)"  -D"KBUILD_MODNAME=KBUILD_STR(clock)" -c -o arch/arm/cpu/armv7/mx6/clock.o arch/arm/cpu/armv7/mx6/clock.c
   arm-linux-gnueabihf-ld.bfd     -r -o arch/arm/cpu/armv7/mx6/built-in.o arch/arm/cpu/armv7/mx6/soc.o arch/arm/cpu/armv7/mx6/clock.o
   arm-linux-gnueabihf-ld.bfd     -r -o arch/arm/cpu/armv7/built-in.o arch/arm/cpu/armv7/cache_v7.o arch/arm/cpu/armv7/cpu.o arch/arm/cpu/armv7/cp15.o arch/arm/cpu/armv7/syslib.o arch/arm/cpu/armv7/lowlevel_init.o arch/arm/cpu/armv7/mx6/built-in.o
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.start.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/cpu/armv7/start.o arch/arm/cpu/armv7/start.S
make -f ./scripts/Makefile.build obj=arch/arm/imx-common
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.iomux-v3.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(iomux_v3)"  -D"KBUILD_MODNAME=KBUILD_STR(iomux_v3)" -c -o arch/arm/imx-common/iomux-v3.o arch/arm/imx-common/iomux-v3.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.cpu.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cpu)"  -D"KBUILD_MODNAME=KBUILD_STR(cpu)" -c -o arch/arm/imx-common/cpu.o arch/arm/imx-common/cpu.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.speed.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(speed)"  -D"KBUILD_MODNAME=KBUILD_STR(speed)" -c -o arch/arm/imx-common/speed.o arch/arm/imx-common/speed.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.i2c-mxv7.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(i2c_mxv7)"  -D"KBUILD_MODNAME=KBUILD_STR(i2c_mxv7)" -c -o arch/arm/imx-common/i2c-mxv7.o arch/arm/imx-common/i2c-mxv7.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.misc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(misc)"  -D"KBUILD_MODNAME=KBUILD_STR(misc)" -c -o arch/arm/imx-common/misc.o arch/arm/imx-common/misc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.cache.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache)"  -D"KBUILD_MODNAME=KBUILD_STR(cache)" -c -o arch/arm/imx-common/cache.o arch/arm/imx-common/cache.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.init.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(init)"  -D"KBUILD_MODNAME=KBUILD_STR(init)" -c -o arch/arm/imx-common/init.o arch/arm/imx-common/init.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.syscounter.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(syscounter)"  -D"KBUILD_MODNAME=KBUILD_STR(syscounter)" -c -o arch/arm/imx-common/syscounter.o arch/arm/imx-common/syscounter.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.cmd_bmode.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cmd_bmode)"  -D"KBUILD_MODNAME=KBUILD_STR(cmd_bmode)" -c -o arch/arm/imx-common/cmd_bmode.o arch/arm/imx-common/cmd_bmode.c
   arm-linux-gnueabihf-ld.bfd     -r -o arch/arm/imx-common/built-in.o arch/arm/imx-common/iomux-v3.o arch/arm/imx-common/cpu.o arch/arm/imx-common/speed.o arch/arm/imx-common/i2c-mxv7.o arch/arm/imx-common/misc.o arch/arm/imx-common/cache.o arch/arm/imx-common/init.o arch/arm/imx-common/syscounter.o arch/arm/imx-common/cmd_bmode.o
make -f ./scripts/Makefile.build obj=arch/arm/lib
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.vectors.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/lib/vectors.o arch/arm/lib/vectors.S
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.crt0.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/lib/crt0.o arch/arm/lib/crt0.S
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.relocate.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/lib/relocate.o arch/arm/lib/relocate.S
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.bootm-fdt.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm_fdt)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm_fdt)" -c -o arch/arm/lib/bootm-fdt.o arch/arm/lib/bootm-fdt.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.bootm.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm)" -c -o arch/arm/lib/bootm.o arch/arm/lib/bootm.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.sections.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sections)"  -D"KBUILD_MODNAME=KBUILD_STR(sections)" -c -o arch/arm/lib/sections.o arch/arm/lib/sections.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.stack.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(stack)"  -D"KBUILD_MODNAME=KBUILD_STR(stack)" -c -o arch/arm/lib/stack.o arch/arm/lib/stack.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.interrupts.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(interrupts)"  -D"KBUILD_MODNAME=KBUILD_STR(interrupts)" -c -o arch/arm/lib/interrupts.o arch/arm/lib/interrupts.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.reset.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(reset)"  -D"KBUILD_MODNAME=KBUILD_STR(reset)" -c -o arch/arm/lib/reset.o arch/arm/lib/reset.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.cache.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache)"  -D"KBUILD_MODNAME=KBUILD_STR(cache)" -c -o arch/arm/lib/cache.o arch/arm/lib/cache.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.cache-cp15.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache_cp15)"  -D"KBUILD_MODNAME=KBUILD_STR(cache_cp15)" -c -o arch/arm/lib/cache-cp15.o arch/arm/lib/cache-cp15.c
   arm-linux-gnueabihf-ld.bfd     -r -o arch/arm/lib/built-in.o arch/arm/lib/vectors.o arch/arm/lib/crt0.o arch/arm/lib/relocate.o arch/arm/lib/bootm-fdt.o arch/arm/lib/bootm.o arch/arm/lib/sections.o arch/arm/lib/stack.o arch/arm/lib/interrupts.o arch/arm/lib/reset.o arch/arm/lib/cache.o arch/arm/lib/cache-cp15.o
  rm -f arch/arm/lib/lib.a; arm-linux-gnueabihf-ar rcs arch/arm/lib/lib.a
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.eabi_compat.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(eabi_compat)"  -D"KBUILD_MODNAME=KBUILD_STR(eabi_compat)" -c -o arch/arm/lib/eabi_compat.o arch/arm/lib/eabi_compat.c
make -f ./scripts/Makefile.build obj=board/freescale/common
  arm-linux-gnueabihf-gcc -Wp,-MD,board/freescale/common/.mmc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mmc)"  -D"KBUILD_MODNAME=KBUILD_STR(mmc)" -c -o board/freescale/common/mmc.o board/freescale/common/mmc.c
   arm-linux-gnueabihf-ld.bfd     -r -o board/freescale/common/built-in.o board/freescale/common/mmc.o
make -f ./scripts/Makefile.build obj=board/freescale/mx6ullevk
  arm-linux-gnueabihf-gcc -Wp,-MD,board/freescale/mx6ullevk/.mx6ullevk.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mx6ullevk)"  -D"KBUILD_MODNAME=KBUILD_STR(mx6ullevk)" -c -o board/freescale/mx6ullevk/mx6ullevk.o board/freescale/mx6ullevk/mx6ullevk.c
   arm-linux-gnueabihf-ld.bfd     -r -o board/freescale/mx6ullevk/built-in.o board/freescale/mx6ullevk/mx6ullevk.o
make -f ./scripts/Makefile.build obj=cmd
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.boot.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(boot)"  -D"KBUILD_MODNAME=KBUILD_STR(boot)" -c -o cmd/boot.o cmd/boot.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.bootm.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm)" -c -o cmd/bootm.o cmd/bootm.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.help.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(help)"  -D"KBUILD_MODNAME=KBUILD_STR(help)" -c -o cmd/help.o cmd/help.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.version.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(version)"  -D"KBUILD_MODNAME=KBUILD_STR(version)" -c -o cmd/version.o cmd/version.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.source.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(source)"  -D"KBUILD_MODNAME=KBUILD_STR(source)" -c -o cmd/source.o cmd/source.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.bdinfo.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bdinfo)"  -D"KBUILD_MODNAME=KBUILD_STR(bdinfo)" -c -o cmd/bdinfo.o cmd/bdinfo.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.cache.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache)"  -D"KBUILD_MODNAME=KBUILD_STR(cache)" -c -o cmd/cache.o cmd/cache.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.console.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(console)"  -D"KBUILD_MODNAME=KBUILD_STR(console)" -c -o cmd/console.o cmd/console.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.echo.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(echo)"  -D"KBUILD_MODNAME=KBUILD_STR(echo)" -c -o cmd/echo.o cmd/echo.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.elf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(elf)"  -D"KBUILD_MODNAME=KBUILD_STR(elf)" -c -o cmd/elf.o cmd/elf.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.exit.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(exit)"  -D"KBUILD_MODNAME=KBUILD_STR(exit)" -c -o cmd/exit.o cmd/exit.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.ext4.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4)" -c -o cmd/ext4.o cmd/ext4.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.ext2.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext2)"  -D"KBUILD_MODNAME=KBUILD_STR(ext2)" -c -o cmd/ext2.o cmd/ext2.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.fat.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fat)"  -D"KBUILD_MODNAME=KBUILD_STR(fat)" -c -o cmd/fat.o cmd/fat.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.fdt.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt)" -c -o cmd/fdt.o cmd/fdt.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.flash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(flash)"  -D"KBUILD_MODNAME=KBUILD_STR(flash)" -c -o cmd/flash.o cmd/flash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.fs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fs)"  -D"KBUILD_MODNAME=KBUILD_STR(fs)" -c -o cmd/fs.o cmd/fs.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.fuse.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fuse)"  -D"KBUILD_MODNAME=KBUILD_STR(fuse)" -c -o cmd/fuse.o cmd/fuse.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.gpio.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(gpio)"  -D"KBUILD_MODNAME=KBUILD_STR(gpio)" -c -o cmd/gpio.o cmd/gpio.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.i2c.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(i2c)"  -D"KBUILD_MODNAME=KBUILD_STR(i2c)" -c -o cmd/i2c.o cmd/i2c.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.itest.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(itest)"  -D"KBUILD_MODNAME=KBUILD_STR(itest)" -c -o cmd/itest.o cmd/itest.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.load.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(load)"  -D"KBUILD_MODNAME=KBUILD_STR(load)" -c -o cmd/load.o cmd/load.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.mem.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mem)"  -D"KBUILD_MODNAME=KBUILD_STR(mem)" -c -o cmd/mem.o cmd/mem.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.mii.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mii)"  -D"KBUILD_MODNAME=KBUILD_STR(mii)" -c -o cmd/mii.o cmd/mii.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.mdio.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mdio)"  -D"KBUILD_MODNAME=KBUILD_STR(mdio)" -c -o cmd/mdio.o cmd/mdio.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.misc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(misc)"  -D"KBUILD_MODNAME=KBUILD_STR(misc)" -c -o cmd/misc.o cmd/misc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.mmc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mmc)"  -D"KBUILD_MODNAME=KBUILD_STR(mmc)" -c -o cmd/mmc.o cmd/mmc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.net.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(net)"  -D"KBUILD_MODNAME=KBUILD_STR(net)" -c -o cmd/net.o cmd/net.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.pcmcia.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(pcmcia)"  -D"KBUILD_MODNAME=KBUILD_STR(pcmcia)" -c -o cmd/pcmcia.o cmd/pcmcia.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.sf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sf)"  -D"KBUILD_MODNAME=KBUILD_STR(sf)" -c -o cmd/sf.o cmd/sf.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.setexpr.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(setexpr)"  -D"KBUILD_MODNAME=KBUILD_STR(setexpr)" -c -o cmd/setexpr.o cmd/setexpr.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.test.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(test)"  -D"KBUILD_MODNAME=KBUILD_STR(test)" -c -o cmd/test.o cmd/test.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.usb.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb)"  -D"KBUILD_MODNAME=KBUILD_STR(usb)" -c -o cmd/usb.o cmd/usb.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.ximg.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ximg)"  -D"KBUILD_MODNAME=KBUILD_STR(ximg)" -c -o cmd/ximg.o cmd/ximg.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.nvedit.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(nvedit)"  -D"KBUILD_MODNAME=KBUILD_STR(nvedit)" -c -o cmd/nvedit.o cmd/nvedit.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.disk.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(disk)"  -D"KBUILD_MODNAME=KBUILD_STR(disk)" -c -o cmd/disk.o cmd/disk.c
   arm-linux-gnueabihf-ld.bfd     -r -o cmd/built-in.o cmd/boot.o cmd/bootm.o cmd/help.o cmd/version.o cmd/source.o cmd/bdinfo.o cmd/cache.o cmd/console.o cmd/echo.o cmd/elf.o cmd/exit.o cmd/ext4.o cmd/ext2.o cmd/fat.o cmd/fdt.o cmd/flash.o cmd/fs.o cmd/fuse.o cmd/gpio.o cmd/i2c.o cmd/itest.o cmd/load.o cmd/mem.o cmd/mii.o cmd/mdio.o cmd/misc.o cmd/mmc.o cmd/net.o cmd/pcmcia.o cmd/sf.o cmd/setexpr.o cmd/test.o cmd/usb.o cmd/ximg.o cmd/nvedit.o cmd/disk.o
make -f ./scripts/Makefile.build obj=common
make -f ./scripts/Makefile.build obj=common/init
  arm-linux-gnueabihf-gcc -Wp,-MD,common/init/.board_init.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(board_init)"  -D"KBUILD_MODNAME=KBUILD_STR(board_init)" -c -o common/init/board_init.o common/init/board_init.c
   arm-linux-gnueabihf-ld.bfd     -r -o common/init/built-in.o common/init/board_init.o
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.main.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(main)"  -D"KBUILD_MODNAME=KBUILD_STR(main)" -c -o common/main.o common/main.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.exports.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(exports)"  -D"KBUILD_MODNAME=KBUILD_STR(exports)" -c -o common/exports.o common/exports.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.hash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(hash)"  -D"KBUILD_MODNAME=KBUILD_STR(hash)" -c -o common/hash.o common/hash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.cli_hush.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cli_hush)"  -D"KBUILD_MODNAME=KBUILD_STR(cli_hush)" -c -o common/cli_hush.o common/cli_hush.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.autoboot.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(autoboot)"  -D"KBUILD_MODNAME=KBUILD_STR(autoboot)" -c -o common/autoboot.o common/autoboot.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.board_f.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(board_f)"  -D"KBUILD_MODNAME=KBUILD_STR(board_f)" -c -o common/board_f.o common/board_f.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.board_r.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(board_r)"  -D"KBUILD_MODNAME=KBUILD_STR(board_r)" -c -o common/board_r.o common/board_r.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.board_info.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(board_info)"  -D"KBUILD_MODNAME=KBUILD_STR(board_info)" -c -o common/board_info.o common/board_info.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.bootm.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm)" -c -o common/bootm.o common/bootm.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.bootm_os.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm_os)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm_os)" -c -o common/bootm_os.o common/bootm_os.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_attr.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_attr)"  -D"KBUILD_MODNAME=KBUILD_STR(env_attr)" -c -o common/env_attr.o common/env_attr.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_callback.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_callback)"  -D"KBUILD_MODNAME=KBUILD_STR(env_callback)" -c -o common/env_callback.o common/env_callback.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_flags.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_flags)"  -D"KBUILD_MODNAME=KBUILD_STR(env_flags)" -c -o common/env_flags.o common/env_flags.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_mmc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_mmc)"  -D"KBUILD_MODNAME=KBUILD_STR(env_mmc)" -c -o common/env_mmc.o common/env_mmc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.fdt_support.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_support)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_support)" -c -o common/fdt_support.o common/fdt_support.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.miiphyutil.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(miiphyutil)"  -D"KBUILD_MODNAME=KBUILD_STR(miiphyutil)" -c -o common/miiphyutil.o common/miiphyutil.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.usb.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb)"  -D"KBUILD_MODNAME=KBUILD_STR(usb)" -c -o common/usb.o common/usb.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.usb_hub.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb_hub)"  -D"KBUILD_MODNAME=KBUILD_STR(usb_hub)" -c -o common/usb_hub.o common/usb_hub.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.usb_storage.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb_storage)"  -D"KBUILD_MODNAME=KBUILD_STR(usb_storage)" -c -o common/usb_storage.o common/usb_storage.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.flash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(flash)"  -D"KBUILD_MODNAME=KBUILD_STR(flash)" -c -o common/flash.o common/flash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.splash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(splash)"  -D"KBUILD_MODNAME=KBUILD_STR(splash)" -c -o common/splash.o common/splash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_common.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_common)"  -D"KBUILD_MODNAME=KBUILD_STR(env_common)" -c -o common/env_common.o common/env_common.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.bouncebuf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bouncebuf)"  -D"KBUILD_MODNAME=KBUILD_STR(bouncebuf)" -c -o common/bouncebuf.o common/bouncebuf.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.console.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(console)"  -D"KBUILD_MODNAME=KBUILD_STR(console)" -c -o common/console.o common/console.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.dlmalloc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(dlmalloc)"  -D"KBUILD_MODNAME=KBUILD_STR(dlmalloc)" -c -o common/dlmalloc.o common/dlmalloc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.malloc_simple.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(malloc_simple)"  -D"KBUILD_MODNAME=KBUILD_STR(malloc_simple)" -c -o common/malloc_simple.o common/malloc_simple.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.image.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(image)"  -D"KBUILD_MODNAME=KBUILD_STR(image)" -c -o common/image.o common/image.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.image-fdt.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(image_fdt)"  -D"KBUILD_MODNAME=KBUILD_STR(image_fdt)" -c -o common/image-fdt.o common/image-fdt.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.memsize.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(memsize)"  -D"KBUILD_MODNAME=KBUILD_STR(memsize)" -c -o common/memsize.o common/memsize.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.stdio.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(stdio)"  -D"KBUILD_MODNAME=KBUILD_STR(stdio)" -c -o common/stdio.o common/stdio.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.cli_simple.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cli_simple)"  -D"KBUILD_MODNAME=KBUILD_STR(cli_simple)" -c -o common/cli_simple.o common/cli_simple.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.cli.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cli)"  -D"KBUILD_MODNAME=KBUILD_STR(cli)" -c -o common/cli.o common/cli.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.cli_readline.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cli_readline)"  -D"KBUILD_MODNAME=KBUILD_STR(cli_readline)" -c -o common/cli_readline.o common/cli_readline.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.command.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(command)"  -D"KBUILD_MODNAME=KBUILD_STR(command)" -c -o common/command.o common/command.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.s_record.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(s_record)"  -D"KBUILD_MODNAME=KBUILD_STR(s_record)" -c -o common/s_record.o common/s_record.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.xyzModem.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(xyzModem)"  -D"KBUILD_MODNAME=KBUILD_STR(xyzModem)" -c -o common/xyzModem.o common/xyzModem.c
   arm-linux-gnueabihf-ld.bfd     -r -o common/built-in.o common/init/built-in.o common/main.o common/exports.o common/hash.o common/cli_hush.o common/autoboot.o common/board_f.o common/board_r.o common/board_info.o common/bootm.o common/bootm_os.o common/env_attr.o common/env_callback.o common/env_flags.o common/env_mmc.o common/fdt_support.o common/miiphyutil.o common/usb.o common/usb_hub.o common/usb_storage.o common/flash.o common/splash.o common/env_common.o common/bouncebuf.o common/console.o common/dlmalloc.o common/malloc_simple.o common/image.o common/image-fdt.o common/memsize.o common/stdio.o common/cli_simple.o common/cli.o common/cli_readline.o common/command.o common/s_record.o common/xyzModem.o
make -f ./scripts/Makefile.build obj=disk
  arm-linux-gnueabihf-gcc -Wp,-MD,disk/.part.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(part)"  -D"KBUILD_MODNAME=KBUILD_STR(part)" -c -o disk/part.o disk/part.c
  arm-linux-gnueabihf-gcc -Wp,-MD,disk/.part_dos.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(part_dos)"  -D"KBUILD_MODNAME=KBUILD_STR(part_dos)" -c -o disk/part_dos.o disk/part_dos.c
   arm-linux-gnueabihf-ld.bfd     -r -o disk/built-in.o disk/part.o disk/part_dos.o
make -f ./scripts/Makefile.build obj=drivers
make -f ./scripts/Makefile.build obj=drivers/adc
   rm -f drivers/adc/built-in.o; arm-linux-gnueabihf-ar rcs drivers/adc/built-in.o
make -f ./scripts/Makefile.build obj=drivers/block
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/block/.disk-uclass.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(disk_uclass)"  -D"KBUILD_MODNAME=KBUILD_STR(disk_uclass)" -c -o drivers/block/disk-uclass.o drivers/block/disk-uclass.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/block/built-in.o drivers/block/disk-uclass.o
make -f ./scripts/Makefile.build obj=drivers/core
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.device.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(device)"  -D"KBUILD_MODNAME=KBUILD_STR(device)" -c -o drivers/core/device.o drivers/core/device.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.lists.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(lists)"  -D"KBUILD_MODNAME=KBUILD_STR(lists)" -c -o drivers/core/lists.o drivers/core/lists.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.root.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(root)"  -D"KBUILD_MODNAME=KBUILD_STR(root)" -c -o drivers/core/root.o drivers/core/root.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.uclass.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(uclass)"  -D"KBUILD_MODNAME=KBUILD_STR(uclass)" -c -o drivers/core/uclass.o drivers/core/uclass.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.util.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(util)"  -D"KBUILD_MODNAME=KBUILD_STR(util)" -c -o drivers/core/util.o drivers/core/util.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.device-remove.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(device_remove)"  -D"KBUILD_MODNAME=KBUILD_STR(device_remove)" -c -o drivers/core/device-remove.o drivers/core/device-remove.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.dump.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(dump)"  -D"KBUILD_MODNAME=KBUILD_STR(dump)" -c -o drivers/core/dump.o drivers/core/dump.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/core/built-in.o drivers/core/device.o drivers/core/lists.o drivers/core/root.o drivers/core/uclass.o drivers/core/util.o drivers/core/device-remove.o drivers/core/dump.o
make -f ./scripts/Makefile.build obj=drivers/crypto
make -f ./scripts/Makefile.build obj=drivers/crypto/fsl
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/crypto/fsl/.sec.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sec)"  -D"KBUILD_MODNAME=KBUILD_STR(sec)" -c -o drivers/crypto/fsl/sec.o drivers/crypto/fsl/sec.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/crypto/fsl/built-in.o drivers/crypto/fsl/sec.o
make -f ./scripts/Makefile.build obj=drivers/crypto/rsa_mod_exp
   rm -f drivers/crypto/rsa_mod_exp/built-in.o; arm-linux-gnueabihf-ar rcs drivers/crypto/rsa_mod_exp/built-in.o
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/crypto/built-in.o drivers/crypto/rsa_mod_exp/built-in.o drivers/crypto/fsl/built-in.o
make -f ./scripts/Makefile.build obj=drivers/dfu
   rm -f drivers/dfu/built-in.o; arm-linux-gnueabihf-ar rcs drivers/dfu/built-in.o
make -f ./scripts/Makefile.build obj=drivers/hwmon
   rm -f drivers/hwmon/built-in.o; arm-linux-gnueabihf-ar rcs drivers/hwmon/built-in.o
make -f ./scripts/Makefile.build obj=drivers/input
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/input/.input.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(input)"  -D"KBUILD_MODNAME=KBUILD_STR(input)" -c -o drivers/input/input.o drivers/input/input.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/input/built-in.o drivers/input/input.o
make -f ./scripts/Makefile.build obj=drivers/memory
   rm -f drivers/memory/built-in.o; arm-linux-gnueabihf-ar rcs drivers/memory/built-in.o
make -f ./scripts/Makefile.build obj=drivers/misc
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/misc/.mxc_ocotp.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mxc_ocotp)"  -D"KBUILD_MODNAME=KBUILD_STR(mxc_ocotp)" -c -o drivers/misc/mxc_ocotp.o drivers/misc/mxc_ocotp.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/misc/built-in.o drivers/misc/mxc_ocotp.o
make -f ./scripts/Makefile.build obj=drivers/pcmcia
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/pcmcia/.tqm8xx_pcmcia.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(tqm8xx_pcmcia)"  -D"KBUILD_MODNAME=KBUILD_STR(tqm8xx_pcmcia)" -c -o drivers/pcmcia/tqm8xx_pcmcia.o drivers/pcmcia/tqm8xx_pcmcia.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/pcmcia/built-in.o drivers/pcmcia/tqm8xx_pcmcia.o
make -f ./scripts/Makefile.build obj=drivers/pwm
   rm -f drivers/pwm/built-in.o; arm-linux-gnueabihf-ar rcs drivers/pwm/built-in.o
make -f ./scripts/Makefile.build obj=drivers/rtc
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/rtc/.date.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(date)"  -D"KBUILD_MODNAME=KBUILD_STR(date)" -c -o drivers/rtc/date.o drivers/rtc/date.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/rtc/built-in.o drivers/rtc/date.o
make -f ./scripts/Makefile.build obj=drivers/soc
   rm -f drivers/soc/built-in.o; arm-linux-gnueabihf-ar rcs drivers/soc/built-in.o
make -f ./scripts/Makefile.build obj=drivers/sound
   rm -f drivers/sound/built-in.o; arm-linux-gnueabihf-ar rcs drivers/sound/built-in.o
make -f ./scripts/Makefile.build obj=drivers/thermal
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/thermal/.thermal-uclass.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(thermal_uclass)"  -D"KBUILD_MODNAME=KBUILD_STR(thermal_uclass)" -c -o drivers/thermal/thermal-uclass.o drivers/thermal/thermal-uclass.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/thermal/.imx_thermal.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(imx_thermal)"  -D"KBUILD_MODNAME=KBUILD_STR(imx_thermal)" -c -o drivers/thermal/imx_thermal.o drivers/thermal/imx_thermal.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/thermal/built-in.o drivers/thermal/thermal-uclass.o drivers/thermal/imx_thermal.o
make -f ./scripts/Makefile.build obj=drivers/timer
   rm -f drivers/timer/built-in.o; arm-linux-gnueabihf-ar rcs drivers/timer/built-in.o
make -f ./scripts/Makefile.build obj=drivers/tpm
   rm -f drivers/tpm/built-in.o; arm-linux-gnueabihf-ar rcs drivers/tpm/built-in.o
make -f ./scripts/Makefile.build obj=drivers/twserial
   rm -f drivers/twserial/built-in.o; arm-linux-gnueabihf-ar rcs drivers/twserial/built-in.o
make -f ./scripts/Makefile.build obj=drivers/video
make -f ./scripts/Makefile.build obj=drivers/video/bridge
   rm -f drivers/video/bridge/built-in.o; arm-linux-gnueabihf-ar rcs drivers/video/bridge/built-in.o
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/video/built-in.o drivers/video/bridge/built-in.o
make -f ./scripts/Makefile.build obj=drivers/watchdog
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/watchdog/.imx_watchdog.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(imx_watchdog)"  -D"KBUILD_MODNAME=KBUILD_STR(imx_watchdog)" -c -o drivers/watchdog/imx_watchdog.o drivers/watchdog/imx_watchdog.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/watchdog/built-in.o drivers/watchdog/imx_watchdog.o
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/built-in.o drivers/core/built-in.o drivers/adc/built-in.o drivers/block/built-in.o drivers/crypto/built-in.o drivers/hwmon/built-in.o drivers/misc/built-in.o drivers/pcmcia/built-in.o drivers/dfu/built-in.o drivers/rtc/built-in.o drivers/sound/built-in.o drivers/timer/built-in.o drivers/tpm/built-in.o drivers/twserial/built-in.o drivers/video/built-in.o drivers/watchdog/built-in.o drivers/memory/built-in.o drivers/pwm/built-in.o drivers/input/built-in.o drivers/soc/built-in.o drivers/thermal/built-in.o
make -f ./scripts/Makefile.build obj=drivers/dma
   rm -f drivers/dma/built-in.o; arm-linux-gnueabihf-ar rcs drivers/dma/built-in.o
make -f ./scripts/Makefile.build obj=drivers/gpio
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/gpio/.mxc_gpio.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mxc_gpio)"  -D"KBUILD_MODNAME=KBUILD_STR(mxc_gpio)" -c -o drivers/gpio/mxc_gpio.o drivers/gpio/mxc_gpio.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/gpio/built-in.o drivers/gpio/mxc_gpio.o
make -f ./scripts/Makefile.build obj=drivers/i2c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/i2c/.i2c_core.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(i2c_core)"  -D"KBUILD_MODNAME=KBUILD_STR(i2c_core)" -c -o drivers/i2c/i2c_core.o drivers/i2c/i2c_core.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/i2c/.mxc_i2c.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mxc_i2c)"  -D"KBUILD_MODNAME=KBUILD_STR(mxc_i2c)" -c -o drivers/i2c/mxc_i2c.o drivers/i2c/mxc_i2c.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/i2c/built-in.o drivers/i2c/i2c_core.o drivers/i2c/mxc_i2c.o
make -f ./scripts/Makefile.build obj=drivers/mmc
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mmc/.fsl_esdhc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fsl_esdhc)"  -D"KBUILD_MODNAME=KBUILD_STR(fsl_esdhc)" -c -o drivers/mmc/fsl_esdhc.o drivers/mmc/fsl_esdhc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mmc/.mmc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mmc)"  -D"KBUILD_MODNAME=KBUILD_STR(mmc)" -c -o drivers/mmc/mmc.o drivers/mmc/mmc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mmc/.mmc_write.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mmc_write)"  -D"KBUILD_MODNAME=KBUILD_STR(mmc_write)" -c -o drivers/mmc/mmc_write.o drivers/mmc/mmc_write.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/mmc/built-in.o drivers/mmc/fsl_esdhc.o drivers/mmc/mmc.o drivers/mmc/mmc_write.o
make -f ./scripts/Makefile.build obj=drivers/mtd
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/.mtdcore.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mtdcore)"  -D"KBUILD_MODNAME=KBUILD_STR(mtdcore)" -c -o drivers/mtd/mtdcore.o drivers/mtd/mtdcore.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/.mtd_uboot.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mtd_uboot)"  -D"KBUILD_MODNAME=KBUILD_STR(mtd_uboot)" -c -o drivers/mtd/mtd_uboot.o drivers/mtd/mtd_uboot.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/mtd/built-in.o drivers/mtd/mtdcore.o drivers/mtd/mtd_uboot.o
make -f ./scripts/Makefile.build obj=drivers/mtd/onenand
   rm -f drivers/mtd/onenand/built-in.o; arm-linux-gnueabihf-ar rcs drivers/mtd/onenand/built-in.o
make -f ./scripts/Makefile.build obj=drivers/mtd/spi
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/spi/.sf_probe.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sf_probe)"  -D"KBUILD_MODNAME=KBUILD_STR(sf_probe)" -c -o drivers/mtd/spi/sf_probe.o drivers/mtd/spi/sf_probe.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/spi/.spi_flash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(spi_flash)"  -D"KBUILD_MODNAME=KBUILD_STR(spi_flash)" -c -o drivers/mtd/spi/spi_flash.o drivers/mtd/spi/spi_flash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/spi/.sf_params.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sf_params)"  -D"KBUILD_MODNAME=KBUILD_STR(sf_params)" -c -o drivers/mtd/spi/sf_params.o drivers/mtd/spi/sf_params.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/spi/.sf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sf)"  -D"KBUILD_MODNAME=KBUILD_STR(sf)" -c -o drivers/mtd/spi/sf.o drivers/mtd/spi/sf.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/mtd/spi/built-in.o drivers/mtd/spi/sf_probe.o drivers/mtd/spi/spi_flash.o drivers/mtd/spi/sf_params.o drivers/mtd/spi/sf.o
make -f ./scripts/Makefile.build obj=drivers/net
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/net/.fec_mxc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fec_mxc)"  -D"KBUILD_MODNAME=KBUILD_STR(fec_mxc)" -c -o drivers/net/fec_mxc.o drivers/net/fec_mxc.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/net/built-in.o drivers/net/fec_mxc.o
make -f ./scripts/Makefile.build obj=drivers/net/phy
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/net/phy/.phy.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(phy)"  -D"KBUILD_MODNAME=KBUILD_STR(phy)" -c -o drivers/net/phy/phy.o drivers/net/phy/phy.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/net/phy/.realtek.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(realtek)"  -D"KBUILD_MODNAME=KBUILD_STR(realtek)" -c -o drivers/net/phy/realtek.o drivers/net/phy/realtek.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/net/phy/.smsc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(smsc)"  -D"KBUILD_MODNAME=KBUILD_STR(smsc)" -c -o drivers/net/phy/smsc.o drivers/net/phy/smsc.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/net/phy/built-in.o drivers/net/phy/phy.o drivers/net/phy/realtek.o drivers/net/phy/smsc.o
make -f ./scripts/Makefile.build obj=drivers/pci
   rm -f drivers/pci/built-in.o; arm-linux-gnueabihf-ar rcs drivers/pci/built-in.o
make -f ./scripts/Makefile.build obj=drivers/power
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/power/.power_core.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(power_core)"  -D"KBUILD_MODNAME=KBUILD_STR(power_core)" -c -o drivers/power/power_core.o drivers/power/power_core.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/power/.power_i2c.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(power_i2c)"  -D"KBUILD_MODNAME=KBUILD_STR(power_i2c)" -c -o drivers/power/power_i2c.o drivers/power/power_i2c.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/power/built-in.o drivers/power/power_core.o drivers/power/power_i2c.o
make -f ./scripts/Makefile.build obj=drivers/power/battery
   rm -f drivers/power/battery/built-in.o; arm-linux-gnueabihf-ar rcs drivers/power/battery/built-in.o
make -f ./scripts/Makefile.build obj=drivers/power/fuel_gauge
   rm -f drivers/power/fuel_gauge/built-in.o; arm-linux-gnueabihf-ar rcs drivers/power/fuel_gauge/built-in.o
make -f ./scripts/Makefile.build obj=drivers/power/mfd
   rm -f drivers/power/mfd/built-in.o; arm-linux-gnueabihf-ar rcs drivers/power/mfd/built-in.o
make -f ./scripts/Makefile.build obj=drivers/power/pmic
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/power/pmic/.pmic_pfuze3000.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(pmic_pfuze3000)"  -D"KBUILD_MODNAME=KBUILD_STR(pmic_pfuze3000)" -c -o drivers/power/pmic/pmic_pfuze3000.o drivers/power/pmic/pmic_pfuze3000.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/power/pmic/built-in.o drivers/power/pmic/pmic_pfuze3000.o
make -f ./scripts/Makefile.build obj=drivers/power/regulator
   rm -f drivers/power/regulator/built-in.o; arm-linux-gnueabihf-ar rcs drivers/power/regulator/built-in.o
make -f ./scripts/Makefile.build obj=drivers/serial
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/serial/.serial.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(serial)"  -D"KBUILD_MODNAME=KBUILD_STR(serial)" -c -o drivers/serial/serial.o drivers/serial/serial.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/serial/.serial_mxc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(serial_mxc)"  -D"KBUILD_MODNAME=KBUILD_STR(serial_mxc)" -c -o drivers/serial/serial_mxc.o drivers/serial/serial_mxc.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/serial/built-in.o drivers/serial/serial.o drivers/serial/serial_mxc.o
make -f ./scripts/Makefile.build obj=drivers/spi
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/spi/.spi.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(spi)"  -D"KBUILD_MODNAME=KBUILD_STR(spi)" -c -o drivers/spi/spi.o drivers/spi/spi.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/spi/.fsl_qspi.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fsl_qspi)"  -D"KBUILD_MODNAME=KBUILD_STR(fsl_qspi)" -c -o drivers/spi/fsl_qspi.o drivers/spi/fsl_qspi.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/spi/built-in.o drivers/spi/spi.o drivers/spi/fsl_qspi.o
make -f ./scripts/Makefile.build obj=drivers/usb/dwc3
   rm -f drivers/usb/dwc3/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/dwc3/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/emul
   rm -f drivers/usb/emul/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/emul/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/eth
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/usb/eth/.usb_ether.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb_ether)"  -D"KBUILD_MODNAME=KBUILD_STR(usb_ether)" -c -o drivers/usb/eth/usb_ether.o drivers/usb/eth/usb_ether.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/usb/eth/.asix.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(asix)"  -D"KBUILD_MODNAME=KBUILD_STR(asix)" -c -o drivers/usb/eth/asix.o drivers/usb/eth/asix.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/usb/eth/built-in.o drivers/usb/eth/usb_ether.o drivers/usb/eth/asix.o
make -f ./scripts/Makefile.build obj=drivers/usb/gadget
   rm -f drivers/usb/gadget/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/gadget/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/gadget/udc
   rm -f drivers/usb/gadget/udc/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/gadget/udc/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/host
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/usb/host/.ehci-hcd.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ehci_hcd)"  -D"KBUILD_MODNAME=KBUILD_STR(ehci_hcd)" -c -o drivers/usb/host/ehci-hcd.o drivers/usb/host/ehci-hcd.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/usb/host/.ehci-mx6.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ehci_mx6)"  -D"KBUILD_MODNAME=KBUILD_STR(ehci_mx6)" -c -o drivers/usb/host/ehci-mx6.o drivers/usb/host/ehci-mx6.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/usb/host/built-in.o drivers/usb/host/ehci-hcd.o drivers/usb/host/ehci-mx6.o
make -f ./scripts/Makefile.build obj=drivers/usb/musb-new
   rm -f drivers/usb/musb-new/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/musb-new/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/musb
   rm -f drivers/usb/musb/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/musb/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/phy
   rm -f drivers/usb/phy/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/phy/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/ulpi
   rm -f drivers/usb/ulpi/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/ulpi/built-in.o
make -f ./scripts/Makefile.build obj=fs
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/.fs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fs)"  -D"KBUILD_MODNAME=KBUILD_STR(fs)" -c -o fs/fs.o fs/fs.c
make -f ./scripts/Makefile.build obj=fs/ext4
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.ext4fs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4fs)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4fs)" -c -o fs/ext4/ext4fs.o fs/ext4/ext4fs.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.ext4_common.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4_common)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4_common)" -c -o fs/ext4/ext4_common.o fs/ext4/ext4_common.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.dev.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(dev)"  -D"KBUILD_MODNAME=KBUILD_STR(dev)" -c -o fs/ext4/dev.o fs/ext4/dev.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.ext4_write.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4_write)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4_write)" -c -o fs/ext4/ext4_write.o fs/ext4/ext4_write.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.ext4_journal.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4_journal)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4_journal)" -c -o fs/ext4/ext4_journal.o fs/ext4/ext4_journal.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.crc16.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc16)"  -D"KBUILD_MODNAME=KBUILD_STR(crc16)" -c -o fs/ext4/crc16.o fs/ext4/crc16.c
   arm-linux-gnueabihf-ld.bfd     -r -o fs/ext4/built-in.o fs/ext4/ext4fs.o fs/ext4/ext4_common.o fs/ext4/dev.o fs/ext4/ext4_write.o fs/ext4/ext4_journal.o fs/ext4/crc16.o
make -f ./scripts/Makefile.build obj=fs/fat
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/fat/.fat_write.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fat_write)"  -D"KBUILD_MODNAME=KBUILD_STR(fat_write)" -c -o fs/fat/fat_write.o fs/fat/fat_write.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/fat/.file.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(file)"  -D"KBUILD_MODNAME=KBUILD_STR(file)" -c -o fs/fat/file.o fs/fat/file.c
   arm-linux-gnueabihf-ld.bfd     -r -o fs/fat/built-in.o fs/fat/fat_write.o fs/fat/file.o
   arm-linux-gnueabihf-ld.bfd     -r -o fs/built-in.o fs/fs.o fs/ext4/built-in.o fs/fat/built-in.o
make -f ./scripts/Makefile.build obj=lib
make -f ./scripts/Makefile.build obj=lib/libfdt
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt)" -c -o lib/libfdt/fdt.o lib/libfdt/fdt.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_ro.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_ro)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_ro)" -c -o lib/libfdt/fdt_ro.o lib/libfdt/fdt_ro.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_rw.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_rw)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_rw)" -c -o lib/libfdt/fdt_rw.o lib/libfdt/fdt_rw.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_strerror.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_strerror)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_strerror)" -c -o lib/libfdt/fdt_strerror.o lib/libfdt/fdt_strerror.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_sw.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_sw)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_sw)" -c -o lib/libfdt/fdt_sw.o lib/libfdt/fdt_sw.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_wip.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_wip)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_wip)" -c -o lib/libfdt/fdt_wip.o lib/libfdt/fdt_wip.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_empty_tree.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_empty_tree)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_empty_tree)" -c -o lib/libfdt/fdt_empty_tree.o lib/libfdt/fdt_empty_tree.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_addresses.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_addresses)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_addresses)" -c -o lib/libfdt/fdt_addresses.o lib/libfdt/fdt_addresses.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_region.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_region)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_region)" -c -o lib/libfdt/fdt_region.o lib/libfdt/fdt_region.c
   arm-linux-gnueabihf-ld.bfd     -r -o lib/libfdt/built-in.o lib/libfdt/fdt.o lib/libfdt/fdt_ro.o lib/libfdt/fdt_rw.o lib/libfdt/fdt_strerror.o lib/libfdt/fdt_sw.o lib/libfdt/fdt_wip.o lib/libfdt/fdt_empty_tree.o lib/libfdt/fdt_addresses.o lib/libfdt/fdt_region.o
make -f ./scripts/Makefile.build obj=lib/zlib
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/zlib/.zlib.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(zlib)"  -D"KBUILD_MODNAME=KBUILD_STR(zlib)" -c -o lib/zlib/zlib.o lib/zlib/zlib.c
   arm-linux-gnueabihf-ld.bfd     -r -o lib/zlib/built-in.o lib/zlib/zlib.o
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.crc7.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc7)"  -D"KBUILD_MODNAME=KBUILD_STR(crc7)" -c -o lib/crc7.o lib/crc7.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.crc8.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc8)"  -D"KBUILD_MODNAME=KBUILD_STR(crc8)" -c -o lib/crc8.o lib/crc8.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.crc16.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc16)"  -D"KBUILD_MODNAME=KBUILD_STR(crc16)" -c -o lib/crc16.o lib/crc16.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.gunzip.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(gunzip)"  -D"KBUILD_MODNAME=KBUILD_STR(gunzip)" -c -o lib/gunzip.o lib/gunzip.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.initcall.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(initcall)"  -D"KBUILD_MODNAME=KBUILD_STR(initcall)" -c -o lib/initcall.o lib/initcall.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.lmb.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(lmb)"  -D"KBUILD_MODNAME=KBUILD_STR(lmb)" -c -o lib/lmb.o lib/lmb.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.ldiv.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ldiv)"  -D"KBUILD_MODNAME=KBUILD_STR(ldiv)" -c -o lib/ldiv.o lib/ldiv.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.net_utils.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(net_utils)"  -D"KBUILD_MODNAME=KBUILD_STR(net_utils)" -c -o lib/net_utils.o lib/net_utils.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.qsort.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(qsort)"  -D"KBUILD_MODNAME=KBUILD_STR(qsort)" -c -o lib/qsort.o lib/qsort.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.rc4.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(rc4)"  -D"KBUILD_MODNAME=KBUILD_STR(rc4)" -c -o lib/rc4.o lib/rc4.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.strmhz.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(strmhz)"  -D"KBUILD_MODNAME=KBUILD_STR(strmhz)" -c -o lib/strmhz.o lib/strmhz.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.list_sort.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(list_sort)"  -D"KBUILD_MODNAME=KBUILD_STR(list_sort)" -c -o lib/list_sort.o lib/list_sort.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.hashtable.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(hashtable)"  -D"KBUILD_MODNAME=KBUILD_STR(hashtable)" -c -o lib/hashtable.o lib/hashtable.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.errno.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(errno)"  -D"KBUILD_MODNAME=KBUILD_STR(errno)" -c -o lib/errno.o lib/errno.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.display_options.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(display_options)"  -D"KBUILD_MODNAME=KBUILD_STR(display_options)" -c -o lib/display_options.o lib/display_options.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.crc32.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc32)"  -D"KBUILD_MODNAME=KBUILD_STR(crc32)" -c -o lib/crc32.o lib/crc32.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.ctype.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ctype)"  -D"KBUILD_MODNAME=KBUILD_STR(ctype)" -c -o lib/ctype.o lib/ctype.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.div64.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(div64)"  -D"KBUILD_MODNAME=KBUILD_STR(div64)" -c -o lib/div64.o lib/div64.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.hang.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(hang)"  -D"KBUILD_MODNAME=KBUILD_STR(hang)" -c -o lib/hang.o lib/hang.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.linux_compat.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(linux_compat)"  -D"KBUILD_MODNAME=KBUILD_STR(linux_compat)" -c -o lib/linux_compat.o lib/linux_compat.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.linux_string.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(linux_string)"  -D"KBUILD_MODNAME=KBUILD_STR(linux_string)" -c -o lib/linux_string.o lib/linux_string.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.membuff.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(membuff)"  -D"KBUILD_MODNAME=KBUILD_STR(membuff)" -c -o lib/membuff.o lib/membuff.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.slre.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slre)"  -D"KBUILD_MODNAME=KBUILD_STR(slre)" -c -o lib/slre.o lib/slre.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.string.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(string)"  -D"KBUILD_MODNAME=KBUILD_STR(string)" -c -o lib/string.o lib/string.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.time.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(time)"  -D"KBUILD_MODNAME=KBUILD_STR(time)" -c -o lib/time.o lib/time.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.vsprintf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(vsprintf)"  -D"KBUILD_MODNAME=KBUILD_STR(vsprintf)" -c -o lib/vsprintf.o lib/vsprintf.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.panic.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(panic)"  -D"KBUILD_MODNAME=KBUILD_STR(panic)" -c -o lib/panic.o lib/panic.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.strto.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(strto)"  -D"KBUILD_MODNAME=KBUILD_STR(strto)" -c -o lib/strto.o lib/strto.c
   arm-linux-gnueabihf-ld.bfd     -r -o lib/built-in.o lib/zlib/built-in.o lib/libfdt/built-in.o lib/crc7.o lib/crc8.o lib/crc16.o lib/gunzip.o lib/initcall.o lib/lmb.o lib/ldiv.o lib/net_utils.o lib/qsort.o lib/rc4.o lib/strmhz.o lib/list_sort.o lib/hashtable.o lib/errno.o lib/display_options.o lib/crc32.o lib/ctype.o lib/div64.o lib/hang.o lib/linux_compat.o lib/linux_string.o lib/membuff.o lib/slre.o lib/string.o lib/time.o lib/vsprintf.o lib/panic.o lib/strto.o
make -f ./scripts/Makefile.build obj=net
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.checksum.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(checksum)"  -D"KBUILD_MODNAME=KBUILD_STR(checksum)" -c -o net/checksum.o net/checksum.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.arp.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(arp)"  -D"KBUILD_MODNAME=KBUILD_STR(arp)" -c -o net/arp.o net/arp.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.bootp.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootp)"  -D"KBUILD_MODNAME=KBUILD_STR(bootp)" -c -o net/bootp.o net/bootp.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.eth_legacy.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(eth_legacy)"  -D"KBUILD_MODNAME=KBUILD_STR(eth_legacy)" -c -o net/eth_legacy.o net/eth_legacy.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.eth_common.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(eth_common)"  -D"KBUILD_MODNAME=KBUILD_STR(eth_common)" -c -o net/eth_common.o net/eth_common.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.net.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(net)"  -D"KBUILD_MODNAME=KBUILD_STR(net)" -c -o net/net.o net/net.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.nfs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(nfs)"  -D"KBUILD_MODNAME=KBUILD_STR(nfs)" -c -o net/nfs.o net/nfs.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.ping.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ping)"  -D"KBUILD_MODNAME=KBUILD_STR(ping)" -c -o net/ping.o net/ping.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.tftp.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(tftp)"  -D"KBUILD_MODNAME=KBUILD_STR(tftp)" -c -o net/tftp.o net/tftp.c
   arm-linux-gnueabihf-ld.bfd     -r -o net/built-in.o net/checksum.o net/arp.o net/bootp.o net/eth_legacy.o net/eth_common.o net/net.o net/nfs.o net/ping.o net/tftp.o
make -f ./scripts/Makefile.build obj=test
   rm -f test/built-in.o; arm-linux-gnueabihf-ar rcs test/built-in.o
make -f ./scripts/Makefile.build obj=test/dm
  arm-linux-gnueabihf-gcc -Wp,-MD,test/dm/.cmd_dm.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cmd_dm)"  -D"KBUILD_MODNAME=KBUILD_STR(cmd_dm)" -c -o test/dm/cmd_dm.o test/dm/cmd_dm.c
   arm-linux-gnueabihf-ld.bfd     -r -o test/dm/built-in.o test/dm/cmd_dm.o
make -f ./scripts/Makefile.build obj=examples
make -f ./scripts/Makefile.build obj=examples/standalone
  arm-linux-gnueabihf-gcc -Wp,-MD,examples/standalone/.stubs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -fno-toplevel-reorder -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(stubs)"  -D"KBUILD_MODNAME=KBUILD_STR(stubs)" -c -o examples/standalone/stubs.o examples/standalone/stubs.c
  arm-linux-gnueabihf-ld.bfd     -r -o examples/standalone/libstubs.o examples/standalone/stubs.o
  arm-linux-gnueabihf-gcc -Wp,-MD,examples/standalone/.hello_world.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -fno-toplevel-reorder -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(hello_world)"  -D"KBUILD_MODNAME=KBUILD_STR(hello_world)" -c -o examples/standalone/hello_world.o examples/standalone/hello_world.c
  arm-linux-gnueabihf-ld.bfd   -g -Ttext 0xc100000 -o examples/standalone/hello_world -e hello_world examples/standalone/hello_world.o examples/standalone/libstubs.o -L /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4 -lgcc
  arm-linux-gnueabihf-objcopy -O srec  examples/standalone/hello_world examples/standalone/hello_world.srec
  arm-linux-gnueabihf-objcopy -O binary  examples/standalone/hello_world examples/standalone/hello_world.bin
  arm-linux-gnueabihf-gcc -E -Wp,-MD,./.u-boot.lds.d -D__KERNEL__ -D__UBOOT__   -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe  -march=armv7-a   -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -include ./include/u-boot/u-boot.lds.h -DCPUDIR=arch/arm/cpu/armv7  -ansi -D__ASSEMBLY__ -x assembler-with-cpp -P -o u-boot.lds arch/arm/cpu/u-boot.lds
  arm-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o --start-group  arch/arm/cpu/built-in.o  arch/arm/cpu/armv7/built-in.o  arch/arm/imx-common/built-in.o  arch/arm/lib/built-in.o  board/freescale/common/built-in.o  board/freescale/mx6ullevk/built-in.o  cmd/built-in.o  common/built-in.o  disk/built-in.o  drivers/built-in.o  drivers/dma/built-in.o  drivers/gpio/built-in.o  drivers/i2c/built-in.o  drivers/mmc/built-in.o  drivers/mtd/built-in.o  drivers/mtd/onenand/built-in.o  drivers/mtd/spi/built-in.o  drivers/net/built-in.o  drivers/net/phy/built-in.o  drivers/pci/built-in.o  drivers/power/built-in.o  drivers/power/battery/built-in.o  drivers/power/fuel_gauge/built-in.o  drivers/power/mfd/built-in.o  drivers/power/pmic/built-in.o  drivers/power/regulator/built-in.o  drivers/serial/built-in.o  drivers/spi/built-in.o  drivers/usb/dwc3/built-in.o  drivers/usb/emul/built-in.o  drivers/usb/eth/built-in.o  drivers/usb/gadget/built-in.o  drivers/usb/gadget/udc/built-in.o  drivers/usb/host/built-in.o  drivers/usb/musb-new/built-in.o  drivers/usb/musb/built-in.o  drivers/usb/phy/built-in.o  drivers/usb/ulpi/built-in.o  fs/built-in.o  lib/built-in.o  net/built-in.o  test/built-in.o  test/dm/built-in.o --end-group arch/arm/lib/eabi_compat.o  -L /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4 -lgcc -Map u-boot.map
  arm-linux-gnueabihf-objcopy --gap-fill=0xff  -j .text -j .secure_text -j .rodata -j .hash -j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn -O binary  u-boot u-boot-nodtb.bin
  cp u-boot-nodtb.bin u-boot.bin
make -f ./scripts/Makefile.build obj=arch/arm/imx-common u-boot.imx
mkdir -p board/freescale/mx6ullevk/
  arm-linux-gnueabihf-gcc -E -Wp,-MD,board/freescale/mx6ullevk/.imximage-ddr512.cfg.cfgtmp.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__    -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe  -march=armv7-a     -x c -o board/freescale/mx6ullevk/imximage-ddr512.cfg.cfgtmp board/freescale/mx6ullevk/imximage-ddr512.cfg
  ./tools/mkimage -n board/freescale/mx6ullevk/imximage-ddr512.cfg.cfgtmp -T imximage -e 0x87800000 -d u-boot.bin u-boot.imx
Image Type:   Freescale IMX Boot Image
Image Ver:    2 (i.MX53/6/7 compatible)
Mode:         DCD
Data Size:    364544 Bytes = 356.00 kB = 0.35 MB
Load Address: 877ff420
Entry Point:  87800000
  arm-linux-gnueabihf-objcopy --gap-fill=0xff  -j .text -j .secure_text -j .rodata -j .hash -j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn -O srec u-boot u-boot.srec
  arm-linux-gnueabihf-objdump -t u-boot > u-boot.sym
  arm-linux-gnueabihf-gcc -E -Wp,-MD,./.u-boot.cfg.d -D__KERNEL__ -D__UBOOT__   -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe  -march=armv7-a   -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -include ./include/u-boot/u-boot.lds.h -DCPUDIR=arch/arm/cpu/armv7  -ansi -DDO_DEPS_ONLY -D__ASSEMBLY__ -x assembler-with-cpp -P -dM -E -o u-boot.cfg include/config.h
</..></..></..></..></..></..></..></..></..></..></..></..></..></..></..></..></..></config_fallbacks.h\></asm></configs></config_uncmd_spl.h\></config_defaults.h\></code></pre></details>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>通用裸机-arm汇编</title>
    <url>/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gnu-hui-bian-ge-shi">1 GNU 汇编格式</a><ul>
<li><a href="#1-1-wei-cao-zuo">1.1伪操作</a><ul>
<li><a href="#1-1-1-section">1.1.1 .section</a></li>
<li><a href="#1-1-2-global">1.1.2 .global</a></li>
<li><a href="#1-1-3-comm">1.1.3 .comm</a></li>
<li><a href="#1-1-4-byte-word">1.1.4 .byte ， .word</a></li>
<li><a href="#1-1-5-set-eqv-equ-equiv">1.1.5 .set， .eqv， .equ， .equiv</a></li>
<li><a href="#1-1-6-weak">1.1.6 .weak</a></li>
</ul>
</li>
<li><a href="#1-2-han-shu-ding-yi">1.2 函数定义</a></li>
</ul>
</li>
<li><a href="#2-armv7-hui-bian-zhi-ling">2 ARMv7汇编指令</a><ul>
<li><a href="#2-1-shu-ju-yi-dong-zhi-ling">2.1 数据移动指令</a><ul>
<li><a href="#2-1-1-mov">2.1.1 MOV</a></li>
<li><a href="#2-1-2-mrs">2.1.2 MRS</a></li>
<li><a href="#2-1-3-msr">2.1.3 MSR</a></li>
<li><a href="#2-1-4-cps">2.1.4 CPS</a></li>
</ul>
</li>
<li><a href="#2-2-shu-ju-cun-qu-zhi-ling-fang-wen-cun-chu-qi-ram">2.2 数据存取指令（访问存储器RAM）</a><ul>
<li><a href="#2-2-1-ldr">2.2.1 LDR</a></li>
<li><a href="#2-2-2-str">2.2.2 STR</a></li>
<li><a href="#2-2-3-duo-ji-cun-qi-jia-zai-cun-chu-zhi-ling-ldmia-stmia-deng">2.2.3 多寄存器加载存储指令LDMIA，STMIA等</a></li>
</ul>
</li>
<li><a href="#2-3-ru-zhan-chu-zhan-zhi-ling">2.3 入栈出栈指令</a><ul>
<li><a href="#2-3-1-push">2.3.1 PUSH</a></li>
<li><a href="#2-3-2-pop">2.3.2 POP</a></li>
</ul>
<ul>
<li><a href="#2-3-3-stmfd-he-ldmfd">2.3.3 STMFD和LDMFD</a></li>
</ul>
</li>
<li><a href="#2-4-tiao-zhuan-zhi-ling">2.4 跳转指令</a><ul>
<li><a href="#2-4-1-b-zhi-ling">2.4.1 B 指令</a></li>
<li><a href="#2-4-2-bl-zhi-ling">2.4.2 BL 指令</a></li>
</ul>
</li>
<li><a href="#2-5-suan-shu-yun-suan-zhi-ling">2.5 算数运算指令</a></li>
<li><a href="#2-6-luo-ji-yun-suan-zhi-ling">2.6 逻辑运算指令</a></li>
<li><a href="#2-7-nei-cun-ping-zhang-zhi-ling">2.7 内存屏障指令</a><ul>
<li><a href="#2-7-1-data-memory-barrier-dmb-shu-ju-nei-cun-ping-zhang">2.7.1 Data Memory Barrier(DMB)：数据内存屏障</a></li>
<li><a href="#2-7-2-data-synchronization-barrier-dsb-shu-ju-tong-bu-ping-zhang">2.7.2 Data Synchronization Barrier(DSB)：数据同步屏障</a></li>
<li><a href="#2-7-3-instruction-synchronization-barrier-isb-zhi-ling-tong-bu-ping-zhang">2.7.3 Instruction Synchronization Barrier(ISB)：指令同步屏障</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-arm-v7-cpu-yun-xing-mo-shi">3 arm-v7 cpu运行模式</a></li>
<li><a href="#4-arm-v7-cpu-tong-yong-he-te-shu-ji-cun-qi">4 arm-v7 cpu通用和特殊寄存器</a><ul>
<li><a href="#4-1-tong-yong-ji-cun-qi">4.1 通用寄存器</a><ul>
<li><a href="#4-1-1-tong-yong-ji-cun-qi-fen-lei">4.1.1 通用寄存器分类</a></li>
<li><a href="#4-1-2-wei-bei-fen-ji-cun-qi-r0-r7">4.1.2 未备份寄存器R0-R7</a></li>
<li><a href="#4-1-3-bei-fen-ji-cun-qi">4.1.3 备份寄存器</a><ul>
<li><a href="#4-1-3-1-r8-r12">4.1.3.1 R8~R12</a></li>
<li><a href="#4-1-3-2-r13-sp">4.1.3.2 R13 (SP)</a></li>
<li><a href="#4-1-3-2-r14-lr">4.1.3.2 R14 (LR)</a></li>
<li><a href="#4-1-3-2-r15-pc">4.1.3.2 R15 (PC)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-2-te-shu-ji-cun-qi">4.2 特殊寄存器</a><ul>
<li><a href="#4-2-1-cpsr">4.2.1 CPSR</a></li>
<li><a href="#4-2-2-spsr">4.2.2 SPSR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-cp15-xie-chu-li-qi">5 CP15协处理器</a><ul>
<li><a href="#5-1-xie-chu-li-qi-zhi-ling">5.1 协处理器指令</a></li>
<li><a href="#5-2-c0-ji-cun-qi-midr">5.2 c0寄存器（MIDR）</a></li>
<li><a href="#5-3-c1-ji-cun-qi-sctlr">5.3 c1寄存器（SCTLR）</a></li>
<li><a href="#5-4-c12-ji-cun-qi-vbar">5.4 c12寄存器（VBAR）</a></li>
<li><a href="#5-5-c15-ji-cun-qi-cbar">5.5 c15寄存器（CBAR）</a></li>
</ul>
</li>
<li><a href="#6-arm-guan-fang-can-kao-lian-jie">6 arm官方参考链接</a><ul>
<li><a href="#6-1-armv7-yu-armv8-jia-gou">6.1 armv7与armv8架构</a></li>
<li><a href="#6-2-armv7-can-kao-shou-ce">6.2 armv7参考手册</a></li>
<li><a href="#6-3-armv7-bian-cheng-shou-ce">6.3 armv7 编程手册</a></li>
<li><a href="#6-4-cortex-a7-mpcore-ji-zhu-can-kao-shou-ce">6.4 Cortex-A7 <code>MPCore</code> 技术参考手册</a></li>
</ul>
</li>
<li><a href="#7-fu-jian-1-armv7-luo-ji-qi-dong-hui-bian-shi-li">7 附件1：armv7裸机启动汇编示例：</a></li>
<li><a href="#8-fu-jian-2-gic-zhi-ling-he-ji-cun-qi-ding-yi-nei-lian-hui-bian-fang-shi">8 附件2：GIC指令和寄存器定义（内联汇编方式）</a><ul>
<li><a href="#8-1-nei-lian-hui-bian-yuan-li">8.1 内联汇编原理</a><ul>
<li><a href="#8-1-1-cao-zuo-shu-shu-xing">8.1.1 操作数属性</a></li>
<li><a href="#8-1-2-clobber-list">8.1.2 clobber list</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gnu-hui-bian-ge-shi">1 GNU 汇编格式</span><a href="#1-gnu-hui-bian-ge-shi" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label：instruction @ comment</span><br></pre></td></tr></table></figure>
<p><strong>label</strong> 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。<br><strong>instruction</strong> 即指令，也就是汇编指令或伪指令。<br><strong>@符号</strong>，表示后面的是注释，就跟 C 语言里面的<code>/*</code>和<code>*/</code>一样，其实在 GNU 汇编文件中我们也可以使用<code>\*</code>和<code>*/</code>来注释。<br><strong>comment</strong> 就是注释内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add:</span><br><span class="line">MOVS R0, #0X12 @设置 R0=0X12</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用</p>
<h2><span id="1-1-wei-cao-zuo">1.1伪操作</span><a href="#1-1-wei-cao-zuo" class="header-anchor">#</a></h2><h3><span id="1-1-1-section">1.1.1 .section</span><a href="#1-1-1-section" class="header-anchor">#</a></h3><p>来定义一个段，汇编系统预定义了一些段名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text 表示代码段。</span><br><span class="line">.data 初始化的数据段。</span><br><span class="line">.bss 未初始化的数据段。</span><br><span class="line">.rodata 只读数据段。</span><br></pre></td></tr></table></figure>

<p>定义一个 testsetcion 段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .testsection</span><br></pre></td></tr></table></figure>
<p>同时，还可以指定该段的属性，对应的属性见下表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a section is allocatable</span><br><span class="line">d section is a GNU_MBIND section</span><br><span class="line">e section is excluded from executable and shared library.</span><br><span class="line">w section is writable</span><br><span class="line">x section is executable</span><br><span class="line">M section is mergeable</span><br><span class="line">S section contains zero terminated strings</span><br><span class="line">G section is a member of a section group</span><br><span class="line">T section is used <span class="keyword">for</span> thread-local-storage</span><br></pre></td></tr></table></figure>

<p>属性可以组合， 比如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.section .foo，<span class="string">&quot;aex&quot;</span></span><br><span class="line">    text...</span><br></pre></td></tr></table></figure>

<p>汇编程序的默认入口标号是_start，不过我们也可以在链接脚本中使用 <code>ENTRY</code> 来指明其它的入口点。</p>
<h3><span id="1-1-2-global">1.1.2 .global</span><a href="#1-1-2-global" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">ldr r0, =0x12 @r0=0x12</span><br></pre></td></tr></table></figure>

<p><code>.global</code> 是伪操作，表示<code>_start</code> 是一个全局标号，类似 C 语言里面的全局变量一样，常见的伪操作有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.byte 定义单字节数据，比如.byte <span class="number">0x12</span>。</span><br><span class="line">.<span class="type">short</span> 定义双字节数据，比如.<span class="type">short</span> <span class="number">0x1234</span>。</span><br><span class="line">.<span class="type">long</span> 定义一个 <span class="number">4</span> 字节数据，比如.<span class="type">long</span> <span class="number">0x12345678</span>。</span><br><span class="line">.equ 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, <span class="number">0x12</span>，表示 num=<span class="number">0x12</span>。</span><br><span class="line">.align 数据字节对齐，比如：.align <span class="number">4</span> 表示 <span class="number">4</span> 字节对齐。</span><br><span class="line">.end 表示源文件结束。</span><br><span class="line">.global 定义一个全局符号，格式为：.global symbol，比如：.global _start。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-3-comm">1.1.3 .comm</span><a href="#1-1-3-comm" class="header-anchor">#</a></h3><p><code>.comm </code>表示目标文件中的<code> common symbol</code>，表示公共的符号:<br><code>.comm symbol，length</code></p>
<p>这和 GNU 中的强弱符号机制相关，未初始化的变量表示为弱符号，初始化的变量为强符号，当不同源文件中存在多个同名变量时，强符号会覆盖弱符号而不会报错，这是 <code>gcc </code>的扩展语法，所以实际上未初始化的全局变量是作为公共符号保存的，当多个文件中的<code>comm</code>符号出现冲突时，需要将其以一定规则融合. 实际上，C 语言中未定义的全局变量(也就是 <code>comm </code>符号)并非是存放到 <code>bss </code>段中的，而是保存在 COMMON 段.</p>
<h3><span id="1-1-4-byte-word">1.1.4 .byte ， .word</span><a href="#1-1-4-byte-word" class="header-anchor">#</a></h3><p>伪汇编中有一系列的数据放置指令，表示在当前位置放置某些数据，相对应的有:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.byte : 放置一个字节</span><br><span class="line">.hword:放置半字，在 <span class="number">32</span> 位平台中对应两个字节，<span class="number">64</span> 位对应四字节</span><br><span class="line">.<span class="type">short</span>:放置一个 <span class="type">short</span> 类型数据，两个字节.word:放置一个字，在 <span class="number">32</span> 位平台中对应四个字节，<span class="number">64</span> 位对应八字节</span><br><span class="line">.<span class="type">int</span> : 放置一个 <span class="type">int</span> 类型的数据，数据长度根据平台而定，<span class="number">16</span>位平台为两字节，<span class="number">32</span>位和<span class="number">64</span>位平台为四字节</span><br><span class="line">.<span class="type">long</span>:放置一个 <span class="type">long</span> 类型的数据，数据长度根据平台而定，<span class="number">32</span>位平台为四字节，<span class="number">64</span>位平台为八字节</span><br><span class="line">.<span class="type">float</span>:放置一个 <span class="type">float</span> 类型数据，四字节</span><br><span class="line">.<span class="type">double</span>:放置一个 <span class="type">double</span> 类型数据，八字节</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-5-set-eqv-equ-equiv">1.1.5 .set， .eqv， .equ， .equiv</span><a href="#1-1-5-set-eqv-equ-equiv" class="header-anchor">#</a></h3><p>set:设置一个符号的值, C 中的宏。通过设置一个符号的值，在后续的代码中可以重复使用该符号的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">set</span> sym_set，<span class="number">0x100</span></span><br><span class="line">mov r0，#sym_set</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-6-weak">1.1.6 .weak</span><a href="#1-1-6-weak" class="header-anchor">#</a></h3><p>定义一个 weak 类型的符号，当这个符号在相同作用域的地方存在定义，当前符号会被忽略，如果这个符号之前不存在，这个符号就会被使用. 这和 C 语言中的 weak 机制是一样的.</p>
<h2><span id="1-2-han-shu-ding-yi">1.2 函数定义</span><a href="#1-2-han-shu-ding-yi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数名:</span><br><span class="line">	函数体</span><br><span class="line">	返回语句</span><br></pre></td></tr></table></figure>

<p>GNU 汇编函数返回语句不是必须的，如下代码就是用汇编写的Cortex-A7 中断服务函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 未定义中断 */</span></span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, =Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* SVC 中断 */</span></span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 预取终止中断 */</span></span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler </span><br><span class="line">	bx r0</span><br></pre></td></tr></table></figure>

<p>以函数 <code>Undefined_Handler</code> 为例我们来看一下汇编函数组成，<code>Undefined_Handler</code>就是函数名，<code>ldr r0, =Undefined_Handler</code>是函数体，<code>bx r0</code>是函数返回语句，<code>bx</code>指令是返回指令，函数返回语句不是必须的.</p>
<h1><span id="2-armv7-hui-bian-zhi-ling">2 ARMv7汇编指令</span><a href="#2-armv7-hui-bian-zhi-ling" class="header-anchor">#</a></h1><h2><span id="2-1-shu-ju-yi-dong-zhi-ling">2.1 数据移动指令</span><a href="#2-1-shu-ju-yi-dong-zhi-ling" class="header-anchor">#</a></h2><p>数据移动指令都是cpu内部寄存器之间的数据拷贝。</p>
<h3><span id="2-1-1-mov">2.1.1 MOV</span><a href="#2-1-1-mov" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0，R1 @将寄存器 R1 中的数据传递给 R0，即 R0=R1</span><br><span class="line">MOV R0, #0X12 @将立即数 0X12 传递给 R0 寄存器，即 R0=0X12</span><br></pre></td></tr></table></figure>
<h3><span id="2-1-2-mrs">2.1.2 MRS</span><a href="#2-1-2-mrs" class="header-anchor">#</a></h3><p>读取特殊寄存器的数据只能使用 MRS 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS R0, CPSR @将 CPSR 里面的数据传递给 R0，即 R0=CPSR</span><br></pre></td></tr></table></figure>
<h3><span id="2-1-3-msr">2.1.3 MSR</span><a href="#2-1-3-msr" class="header-anchor">#</a></h3><p>和 MRS 刚好相反，通用寄存器写入到特殊寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSR CPSR, R0 @将 R0 中的数据复制到 CPSR 中，即 CPSR=R0</span><br></pre></td></tr></table></figure>

<p>举个例子利用MRS MSR进行清bss (_bss_start, __bss_end定义在链接脚本):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">.global _bss_start</span><br><span class="line">.global _bss_end</span><br><span class="line"></span><br><span class="line">_bss_start:</span><br><span class="line">	.word __bss_start</span><br><span class="line">_bss_end:</span><br><span class="line">	.word __bss_end</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	<span class="comment">//disable watchdog, disable icache dcache</span></span><br><span class="line">	<span class="comment">//init_clk</span></span><br><span class="line">	<span class="comment">//enter svc mode</span></span><br><span class="line">	<span class="comment">/*clear bss*/</span></span><br><span class="line">	ldr r0, _bss_start</span><br><span class="line">	ldr r1, _bss_end</span><br><span class="line">	move r2, <span class="number">0</span></span><br><span class="line">clr_bss:</span><br><span class="line">	stmia r0!, &#123;r2&#125; <span class="comment">//复制一r2中的数据给r0, 并将指针r0增加4</span></span><br><span class="line">	cmp r0, r1</span><br><span class="line">	ble clr_bss <span class="comment">/*if r0&lt;r1, b clr_bss*/</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-1-4-cps">2.1.4 CPS</span><a href="#2-1-4-cps" class="header-anchor">#</a></h3><p>特权模式下（除了用户模式，剩余的模式都是特权模式），可以通过CPS指令直接修改CPSR寄存器的M[4:0]，让处理器进入不同的模式。<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/1.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPS #0x12 /*irq mode*/</span><br><span class="line">CPS #0x13 /*svc mode*/</span><br></pre></td></tr></table></figure>
<h2><span id="2-2-shu-ju-cun-qu-zhi-ling-fang-wen-cun-chu-qi-ram">2.2 数据存取指令（访问存储器RAM）</span><a href="#2-2-shu-ju-cun-qu-zhi-ling-fang-wen-cun-chu-qi-ram" class="header-anchor">#</a></h2><h3><span id="2-2-1-ldr">2.2.1 LDR</span><a href="#2-2-1-ldr" class="header-anchor">#</a></h3><p>数据加载指令，从指定地址读取到cpu寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span><br><span class="line">LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-2-str">2.2.2 STR</span><a href="#2-2-2-str" class="header-anchor">#</a></h3><p>数据存放指令，从cpu寄存器写入指定地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span><br><span class="line">LDR R1, =0X20000002 @R1 保存要写入到寄存器的值，即 R1=0X20000002</span><br><span class="line">STR R1, [R0] @将 R1 中的值写入到 R0 中所保存的地址中</span><br></pre></td></tr></table></figure>

<p>LDR 和 STR 都是按照4 byte进行读取和写入的，也就是操作的 32 位数据，如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上 B 或 H，比如按字节操作的指令就是 LDRB 和STRB，按半字(16位)操作的指令就是 LDRH 和 STRH。</p>
<h3><span id="2-2-3-duo-ji-cun-qi-jia-zai-cun-chu-zhi-ling-ldmia-stmia-deng">2.2.3 多寄存器加载存储指令LDMIA，STMIA等</span><a href="#2-2-3-duo-ji-cun-qi-jia-zai-cun-chu-zhi-ling-ldmia-stmia-deng" class="header-anchor">#</a></h3><p><strong>1.LDMIA指令、LDMIB指令、LDMDB指令、LDMDA指令</strong><br>LDM是LDR指令的增强型 ， 将连续的数据加载到多组寄存器。<br>DB （Decrement Before）栈指针先减小再操作、DA（Decrement After）栈指针先操作再减小。<br>IB（Increment Before）栈指针先增加再操作、IA（Increment After）栈指针先操作再增加。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LDMIA指令，IA表示每次传送后地址加<span class="number">4</span></span><br><span class="line">LDMIB指令，IB表示每次传送前地址加<span class="number">4</span></span><br><span class="line">LDMDA指令，DA表示每次传送后地址减<span class="number">4</span></span><br><span class="line">LDMDB指令，DB表示每次传送前地址减<span class="number">4</span></span><br><span class="line"></span><br><span class="line">LDMIA R14，&#123;R0-R3，R12&#125; <span class="comment">/*从R14寄存器指向的地址取出5个32位数据分别存进到R0-R4以及R12*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="comment">//R0=*R14</span></span><br><span class="line"><span class="comment">//R1=*（R14+4）</span></span><br><span class="line"><span class="comment">//R2=*（R14+8）</span></span><br><span class="line"><span class="comment">//R3=*（R14+12）</span></span><br><span class="line"><span class="comment">//R12=*（R14+16）</span></span><br><span class="line"></span><br><span class="line">LDMIA R1！，&#123;R4-R11&#125; <span class="comment">/*从R1指向的地址取8个32位数据存入R4-R11, 每取一次，让R1指针加4，因此最后R1指针加了32*/</span></span><br></pre></td></tr></table></figure>

<p><strong>2.STMIA指令、STMIB指令、STMDB指令、STMDA指令</strong><br>同理，STM是STR指令的增强型 ， 将多组寄存器数据保存进连续地址空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STMIA R13！，&#123;R0-R1&#125; /*将R0，R1寄存器中的数据存入R13指向的栈空间, r13指向的地址存入R0数据，再地址+4后存入R1的数据*/</span><br></pre></td></tr></table></figure>
<h2><span id="2-3-ru-zhan-chu-zhan-zhi-ling">2.3 入栈出栈指令</span><a href="#2-3-ru-zhan-chu-zhan-zhi-ling" class="header-anchor">#</a></h2><p>函调调用过程中离不开现场的保护和恢复。保存 <code>R0~R15</code> 寄存器的操作就叫做现场保护，恢复 R0~R15 寄存器的操作就叫做恢复现场。</p>
<h4><span id="2-3-1-push">2.3.1 PUSH</span><a href="#2-3-1-push" class="header-anchor">#</a></h4><p>比如要将 R0~R3 和 R12 这 5 个寄存器压栈，当前的 <code>SP （stack pointer）</code>指针指向 <code>0X80000000</code>，我们知道栈空间的地址是向下增长的，堆空间地址向上增长。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈</span><br></pre></td></tr></table></figure>

<p>那么压栈完成以后的堆栈如下：入栈保护现场完这5个寄存器后，SP指向<code>0X7FFFFFEC</code>（每压栈一个寄存器，SP地址减4）<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/2.png" alt="image"><br>再次保存LR寄存器，进行压栈：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/3.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH &#123;LR&#125; @将 LR 进行压栈</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-2-pop">2.3.2 POP</span><a href="#2-3-2-pop" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POP &#123;LR&#125; @先恢复 LR</span><br><span class="line">POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12</span><br></pre></td></tr></table></figure>

<p>可以看出入栈出栈本质都是对SP指针进行加减，入栈减，出栈加，入栈把寄存器依次保存进SP指向的地址去，出栈从SP地址依次取出数据。</p>
<h3><span id="2-3-3-stmfd-he-ldmfd">2.3.3 STMFD和LDMFD</span><a href="#2-3-3-stmfd-he-ldmfd" class="header-anchor">#</a></h3><p>入栈出栈的另外一种写法是“STMFD SP！”和“LDMFD SP!”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈</span><br><span class="line">STMFD SP!,&#123;LR&#125; @LR 入栈</span><br><span class="line">bl xxx</span><br><span class="line">LDMFD SP!, &#123;LR&#125; @先恢复 LR</span><br><span class="line">LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12</span><br></pre></td></tr></table></figure>

<p>STMFD 可以分为两部分：STM 和 FD，同理，LDMFD 也可以分为 LDM 和 FD。前面我们讲了 LDR 和 STR，这两个是数据加载和存储指令，但是每次只能读写存储器中的一个数据。STM 和 LDM 就是多存储和多加载，可以连续的读写存储器中的多个连续数据。<br>FD 是 Full Descending 的缩写，即满递减的意思。根据 ATPCS 规则,ARM 使用的 FD 类型的堆栈，SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈，因此最常用的指令就是 STMFD 和 LDMFD。STM 和 LDM 的指令寄存器列表中编号小的对应低地址，编号高的对应高地址.</p>
<h2><span id="2-4-tiao-zhuan-zhi-ling">2.4 跳转指令</span><a href="#2-4-tiao-zhuan-zhi-ling" class="header-anchor">#</a></h2><h3><span id="2-4-1-b-zhi-ling">2.4.1 B 指令</span><a href="#2-4-1-b-zhi-ling" class="header-anchor">#</a></h3><p>B 指令会将 PC 寄存器的值设置为跳转目标地址，如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">ldr sp,=0X80200000 @设置栈指针</span><br><span class="line">b main @跳转到 main 函数</span><br></pre></td></tr></table></figure>

<p>在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行，上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等.</p>
<h3><span id="2-4-2-bl-zhi-ling">2.4.2 BL 指令</span><a href="#2-4-2-bl-zhi-ling" class="header-anchor">#</a></h3><p>有返回的跳转，跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过<strong>将 LR 寄存器中的值重新加载到 PC</strong> 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。<br>比如 Cortex-A 处理器的 irq 中断服务函数都是汇编写的，主要用汇编来实现现场的保护和恢复、获取中断号等。但是具体的中断处理过程都是 C 函数，所以就会存在汇编中调用 C 函数的问题。而且当 C 语言版本的中断处理函数执行完成以后是需要返回到irq 汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push &#123;r0, r1&#125; @保存 r0,r1</span><br><span class="line">cps #0x13 @进入 SVC 模式，允许其他中断再次进去</span><br><span class="line"></span><br><span class="line">bl system_irqhandler @加载 C 语言中断处理函数到 r2 寄存器中</span><br><span class="line"></span><br><span class="line">cps #0x12 @进入 IRQ 模式</span><br><span class="line">pop &#123;r0, r1&#125; </span><br><span class="line">str r0, [r1, #0X10] @中断执行完成，写 EOIR</span><br></pre></td></tr></table></figure>

<p>跳转指令总结：<br>有多种跳转操作，比如：<br>①、直接使用跳转指令 B、BL、BX 等。<br>②、直接向 PC 寄存器里面写入数据。<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/4.png" alt="image"></p>
<h2><span id="2-5-suan-shu-yun-suan-zhi-ling">2.5 算数运算指令</span><a href="#2-5-suan-shu-yun-suan-zhi-ling" class="header-anchor">#</a></h2><p>加减乘除，常用的运算指令用法：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/5.png" alt="image"></p>
<h2><span id="2-6-luo-ji-yun-suan-zhi-ling">2.6 逻辑运算指令</span><a href="#2-6-luo-ji-yun-suan-zhi-ling" class="header-anchor">#</a></h2><p>与或非指令用法：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/6.png" alt="image"><br>来看一个例子利用arm汇编进行初始化C语言环境。让arm进入svc模式，才能访问特殊寄存器如cpsr, spsr, sp指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">	/* 进入SVC模式 */</span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #0x1f  /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 */</span><br><span class="line">	orr r0, r0, #0x13  /* r0或上0x13,表示使用SVC模式 */</span><br><span class="line">	msr cpsr, r0 /* 将r0 的数据写入到cpsr_c中 */</span><br><span class="line"></span><br><span class="line">	ldr sp, =0X80200000 /* 设置栈指针 */</span><br><span class="line">	b main /* 跳转到main函数 */</span><br></pre></td></tr></table></figure>

<h2><span id="2-7-nei-cun-ping-zhang-zhi-ling">2.7 内存屏障指令</span><a href="#2-7-nei-cun-ping-zhang-zhi-ling" class="header-anchor">#</a></h2><h3><span id="2-7-1-data-memory-barrier-dmb-shu-ju-nei-cun-ping-zhang">2.7.1 Data Memory Barrier(DMB)：数据内存屏障</span><a href="#2-7-1-data-memory-barrier-dmb-shu-ju-nei-cun-ping-zhang" class="header-anchor">#</a></h3><p>DMB指令确保在DMB之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的数据内存传输指令都将在DMB执行之后开始执行，否则有些数据传输指令可能会提前执行。保证了两个内存访问能按正确的顺序执行。<br>应用场景：<br>（1）DMA<br>在使用DMA控制器时，需要在CPU内存访问和DMA操作之间插入DMB屏障，以确保CPU当前的内存读写操作在DMA开始之前完成。</p>
<p>（2）多核系统中的信号量<br>在多核系统中，使用信号量进行核间同步。需要使用DMB来强制指定内存执行顺序，以避免潜在的竞态条件或数据不一致性。当一个核要访问共享资源之前，它会先检查信号量的状态。如果信号量已经被另一个核获取，当前核就必须等待，直到信号量状态变为可用。这个等待过程需要保证在一个核释放信号量之后，其他核能够立即看到信号量状态的变化，而不是因为处理器优化或缓存导致的无效读取而产生错误。</p>
<h3><span id="2-7-2-data-synchronization-barrier-dsb-shu-ju-tong-bu-ping-zhang">2.7.2 Data Synchronization Barrier(DSB)：数据同步屏障</span><a href="#2-7-2-data-synchronization-barrier-dsb-shu-ju-tong-bu-ping-zhang" class="header-anchor">#</a></h3><p>在多线程编程中，两个线程同时对共享的内存进行读写操作，由于读&#x2F;写操作的重排序，就会导致数据的不一致, DSB指令时，它确保在DSB之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的指令都将在DSB执行之后开始执行。<br>应用场景：<br>例如启用或禁用特定的中断、配置时钟、设置系统控制位等。为了确保对SCS的修改在下一条指令执行之前生效，需要使用DSB指令进行数据同步。一些特殊的指令如SVC(Supervisor Call，特权级调用)、WFI(Wait For Interrupt，等待中断）、WFE(Wait For Event，等待事件)等操作，涉及到特权级的转换或者等待系统事件发生，需要使用DSB指令。</p>
<h3><span id="2-7-3-instruction-synchronization-barrier-isb-zhi-ling-tong-bu-ping-zhang">2.7.3 Instruction Synchronization Barrier(ISB)：指令同步屏障</span><a href="#2-7-3-instruction-synchronization-barrier-isb-zhi-ling-tong-bu-ping-zhang" class="header-anchor">#</a></h3><p>插入ISB指令，处理器会将流水线中的指令全部刷新，从而确保之前的指令不会影响后续指令的执行，并且后续指令将从正确的上下文开始重新获取。<br>应用场景：<br>在进行异常进入之前，处理器会执行ISB操作。这样做的目的是刷新指令流水线，确保异常处理程序的指令是从正确的地址开始执行，避免异常之前的指令对异常处理程序造成干扰。<br>在进行异常返回之前，处理器同样会执行ISB操作。这样做的目的是刷新指令流水线，确保返回时从正确的地址重新获取指令，避免异常处理程序的指令对正常任务造成干扰。</p>
<h1><span id="3-arm-v7-cpu-yun-xing-mo-shi">3 arm-v7 cpu运行模式</span><a href="#3-arm-v7-cpu-yun-xing-mo-shi" class="header-anchor">#</a></h1><p>以前的 ARM 处理器有 7 中运行模型：User、FIQ、IRQ、Supervisor(SVC)、Abort、Undef和 System，其中 User 是非特权模式，其余 6 中都是特权模式。</p>
<p>到了Cortex-A7 处理器有 9 种处理模式:</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">User(USR)</td>
<td align="center">用户模式，非特权模式，大部分程序运行的时候就处于此模式。</td>
</tr>
<tr>
<td align="center">FIQ</td>
<td align="center">快速中断模式，进入 FIQ 中断异常</td>
</tr>
<tr>
<td align="center">IRQ</td>
<td align="center">一般中断模式。</td>
</tr>
<tr>
<td align="center">Supervisor(SVC)</td>
<td align="center">超级管理员模式，特权模式，供操作系统使用。</td>
</tr>
<tr>
<td align="center">Monitor(MON)</td>
<td align="center">监视模式？这个模式用于安全扩展模式。</td>
</tr>
<tr>
<td align="center">Abort(ABT)</td>
<td align="center">数据访问终止模式，用于虚拟存储以及存储保护。</td>
</tr>
<tr>
<td align="center">Hyp(HYP)</td>
<td align="center">Hyp(HYP) 超级监视模式？用于虚拟化扩展。</td>
</tr>
<tr>
<td align="center">Undef(UND)</td>
<td align="center">Undef(UND) 未定义指令终止模式。</td>
</tr>
<tr>
<td align="center">System(SYS)</td>
<td align="center">System(SYS) 系统模式，用于运行特权级的操作系统任务</td>
</tr>
</tbody></table>
<p>九种模式所对应的寄存器：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/7.png" alt="image"><br><a href="https://www.cnblogs.com/fuzidage/p/12066599.html" title="arm920t cpu模式">arm920t cpu模式</a>或者查看<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>的CPU模式。</p>
<h1><span id="4-arm-v7-cpu-tong-yong-he-te-shu-ji-cun-qi">4 arm-v7 cpu通用和特殊寄存器</span><a href="#4-arm-v7-cpu-tong-yong-he-te-shu-ji-cun-qi" class="header-anchor">#</a></h1><p>ARM 架构提供了 16 个 32 位的通用寄存器<code>(R0~R15)</code>供软件使用，前 15 个(<code>R0~R14</code>)可以用作通用的数据存储，R15 是程序计数器 PC，用来保存将要执行的指令。ARM 还提供了一个当前程序状态寄存器 CPSR 和一个备份程序状态寄存器 SPSR，SPSR 寄存器就是 CPSR 寄存器的备份。<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/8.png" alt="image"></p>
<h2><span id="4-1-tong-yong-ji-cun-qi">4.1 通用寄存器</span><a href="#4-1-tong-yong-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-1-1-tong-yong-ji-cun-qi-fen-lei">4.1.1 通用寄存器分类</span><a href="#4-1-1-tong-yong-ji-cun-qi-fen-lei" class="header-anchor">#</a></h3><p><code>R0~R15</code> 就是通用寄存器，通用寄存器可以分为以下三类：<br>①、未备份寄存器，即 <code>R0~R7</code>。<br>②、备份寄存器，即 <code>R8~R14</code>。<br>③、程序计数器 PC，即 R15。</p>
<h3><span id="4-1-2-wei-bei-fen-ji-cun-qi-r0-r7">4.1.2 未备份寄存器R0-R7</span><a href="#4-1-2-wei-bei-fen-ji-cun-qi-r0-r7" class="header-anchor">#</a></h3><p>未备份寄存器指的是 <code>R0~R7</code> 这 8 个寄存器，因为在所有的处理器模式下这 8 个寄存器都是同一个物理寄存器，在不同的模式下，这 8 个寄存器中的数据就会被破坏.</p>
<h3><span id="4-1-3-bei-fen-ji-cun-qi">4.1.3 备份寄存器</span><a href="#4-1-3-bei-fen-ji-cun-qi" class="header-anchor">#</a></h3><h4><span id="4-1-3-1-r8-r12">4.1.3.1 R8~R12</span><a href="#4-1-3-1-r8-r12" class="header-anchor">#</a></h4><p><code>R8~R12</code> 这 5 个寄存器有2种物理寄存器.在快速中断模式下<code>(FIQ)</code>它们对应着 <code>Rx_irq(x=8~12)</code>物理寄存器，其他模式下对应着 <code>Rx(8~12)</code>物理寄存器. <code>FIQ </code>模式下的 <code>R8~R12</code> 是独立的，因此中断处理程序可以不用执行保存和恢复中断现场的指令，从而加速中断的执行过程。</p>
<h4><span id="4-1-3-2-r13-sp">4.1.3.2 R13 (SP)</span><a href="#4-1-3-2-r13-sp" class="header-anchor">#</a></h4><p>R13 一共有 8 个物理寄存器，其中一个是用户模式<code>(User)</code>和系统模式<code>(Sys)</code>共用的，剩下的 7 个分别对应 7 种不同的模式。R13 也叫做 SP，用来做为栈指针。基本上每种模式<br>都有一个自己的 R13 物理寄存器，应用程序会初始化 R13，使其指向该模式专用的栈地址，这就是常说的初始化 SP 指针.</p>
<h4><span id="4-1-3-2-r14-lr">4.1.3.2 R14 (LR)</span><a href="#4-1-3-2-r14-lr" class="header-anchor">#</a></h4><p> R14 一共有 7 个物理寄存器，其中一个是用户模式(User)、系统模式(Sys)和超级监视模式<code>(Hyp)</code>所共有的，剩下的 6 个分别对应 6 种不同的模式.<br> LR被叫做链接寄存器:<br>①用来存放子函数的返回地址。<br> 在子函数中，将 R14(LR)中的值赋给 R15(PC)即可完成子函数返回，比如在子程序中可以使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV PC, LR</span><br></pre></td></tr></table></figure>
<p>②当异常发生以后，该异常模式对应的 R14寄存器被设置成该异常模式将要返回的地址.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subs pc, lr, #4				/* 将lr-4赋给pc */</span><br></pre></td></tr></table></figure>
<p>比如下面代码示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0X2000 MOV R1, R0 ;执行</span><br><span class="line">0X2004 MOV R2, R3 ;译指</span><br><span class="line">0X2008 MOV R4, R5 ;取值 PC</span><br></pre></td></tr></table></figure>
<p>当前正在执行 <code>0X2000</code>地址处的指令<code>MOV R1, R0</code>，但是 PC 里面已经保存了 <code>0X2008 </code>地址处的指令<code>MOV R4, R5</code>。假设此时发生了中断，中断发生的时候保存在 <code>lr </code>中的是 <code>pc</code> 的值，也就是地址<code> 0X2008</code>。</p>
<h4><span id="4-1-3-2-r15-pc">4.1.3.2 R15 (PC)</span><a href="#4-1-3-2-r15-pc" class="header-anchor">#</a></h4><p>R15 保存着当前执行的指令地址值加 8 个字节，这是因为 ARM的流水线机制导致的。ARM 处理器 3 级流水线：取指-&gt;译码-&gt;执行，这三级流水线循环执行，比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在 <code>R15(PC)</code>中.<br>对于arm32位处理器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R15 (PC)值 = 当前执行的程序位置 + 8 个字节</span><br></pre></td></tr></table></figure>
<h2><span id="4-2-te-shu-ji-cun-qi">4.2 特殊寄存器</span><a href="#4-2-te-shu-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-2-1-cpsr">4.2.1 CPSR</span><a href="#4-2-1-cpsr" class="header-anchor">#</a></h3><p>当前程序状态寄存器<code>（current program status register）</code>，所有模式共用一个 <code>CPSR</code> 物理寄存器，因此 <code>CPSR </code>可以在任何模式下被访问。<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/9.png" alt="image"><br>N(bit31)：当两个补码表示的 有符号整数运算的时候，N&#x3D;1 表示运算对的结果为负数，N&#x3D;0表示结果为正数。<br>Z(bit30)：Z&#x3D;1 表示运算结果为零，Z&#x3D;0 表示运算结果不为零，对于 CMP 指令，Z&#x3D;1 表示进行比较的两个数大小相等。<br>C(bit29)：在加法指令中，当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢，其它情况下 C&#x3D;0。在减法指令中，当运算中发生借位，则 C&#x3D;0，表示无符号数运算发生下溢，其它情况下 C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令，C 中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令，C 位的值通常不受影响。<br>V(bit28)：对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V&#x3D;1 表示符号位溢出，通常其他位不影响 V 位。<br>Q(bit27)：仅 ARM v5TE_J 架构支持，表示饱和状态，Q&#x3D;1 表示累积饱和，Q&#x3D;0 表示累积不饱和。<br>IT<a href="bit26:25">1:0</a>：和 IT<a href="bit15:bit10">7:2</a>一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。<br>J(bit24)：仅 ARM_v5TE-J 架构支持，J&#x3D;1 表示处于 <code>Jazelle</code> 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集:</p>
<table>
<thead>
<tr>
<th>J</th>
<th>T</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>ARM</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Thumb</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>ThumbEE</td>
</tr>
</tbody></table>
<p>GE<a href="bit19:16">3:0</a>：SIMD 指令有效，大于或等于。<br>IT<a href="bit15:10">7:2</a>：参考 IT[1:0]。<br>E(bit9)：大小端控制位，E&#x3D;1 表示大端模式，E&#x3D;0 表示小端模式。<br>A(bit8)：禁止异步中断位，A&#x3D;1 表示禁止异步中断。<br>I(bit7)：I&#x3D;1 禁止 IRQ，I&#x3D;0 使能 IRQ。<br>F(bit6)：F&#x3D;1 禁止 FIQ，F&#x3D;0 使能 FIQ。<br>T(bit5)：控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。<br>M[4:0]：处理器模式控制位<br><code>cpsr</code>最常用就是来控制处理器模式</p>
<table>
<thead>
<tr>
<th>M[4:0]</th>
<th>处理器模式</th>
</tr>
</thead>
<tbody><tr>
<td>10000</td>
<td>User 模式</td>
</tr>
<tr>
<td>10001</td>
<td>FIQ 模式</td>
</tr>
<tr>
<td>10010</td>
<td>IRQ 模式</td>
</tr>
<tr>
<td>10011</td>
<td>Supervisor(SVC)模式</td>
</tr>
<tr>
<td>10110</td>
<td>Monitor(MON)模式</td>
</tr>
<tr>
<td>10111</td>
<td>Abort(ABT)模式</td>
</tr>
<tr>
<td>11010</td>
<td>Hyp(HYP)模式</td>
</tr>
<tr>
<td>11011</td>
<td>Undef(UND)模式</td>
</tr>
<tr>
<td>11111</td>
<td>System(SYS)模式</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进入SVC模式 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">orr r0, r0, #<span class="number">0x13</span> 	<span class="comment">/* r0或上0x13,表示使用SVC模式					*/</span></span><br><span class="line">msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">ldr sp, =<span class="number">0X80200000</span>	<span class="comment">/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */</span></span><br></pre></td></tr></table></figure>
<h3><span id="4-2-2-spsr">4.2.2 SPSR</span><a href="#4-2-2-spsr" class="header-anchor">#</a></h3><p>除了 User 和 Sys 这两个模式以外，其他 7 个模式每个都配备了一个专用的物理状态寄存器，叫做 SPSR(备份程序状态寄存器)，当特定的异常中断发生时，SPSR 寄存器用来保存当前程序状态寄存器(CPSR)的值，当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。User 和 Sys 这两个模式不是异常模式，所以并没有配备 SPSR，因此不能在 User 和Sys 模式下访问 SPSR。</p>
<h1><span id="5-cp15-xie-chu-li-qi">5 CP15协处理器</span><a href="#5-cp15-xie-chu-li-qi" class="header-anchor">#</a></h1><p>CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，比如进入reset复位异常向量时，需要利用协处理器命令进行<code>ICache DCache</code>的开关。CP15 协处理器一共有16 个 32 位寄存器（C0-C15），MRC和MCR用来访问CP15协处理器。</p>
<h2><span id="5-1-xie-chu-li-qi-zhi-ling">5.1 协处理器指令</span><a href="#5-1-xie-chu-li-qi-zhi-ling" class="header-anchor">#</a></h2><p><strong>MRC</strong>: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。<br><strong>MCR</strong>: 将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中。<br>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MCR&#123;cond&#125; p15, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;</span><br></pre></td></tr></table></figure>

<p><code>cond:</code>指令执行的条件码，如果忽略的话就表示无条件执行。<br><code>opc1：</code>协处理器要执行的操作码。<br><code>Rt：</code>ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中。<br><code>CRn：</code>CP15 协处理器的目标寄存器。<br><code>CRm：</code>协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将CRm 设置为 C0，否则结果不可预测。<br><code>opc2：</code>可选的协处理器特定操作码，当不需要的时候要设置为 0</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRC p15, 0, r0, c0, c0, 0 //将 CP15 中 C0 寄存器的值读取到 R0 寄存器</span><br></pre></td></tr></table></figure>

<h2><span id="5-2-c0-ji-cun-qi-midr">5.2 c0寄存器（MIDR）</span><a href="#5-2-c0-ji-cun-qi-midr" class="header-anchor">#</a></h2><p>使用 MRC 或者 MCR 指令访问<code>c0-c15</code>寄存器的时候，指令中的<code>CRn、opc1、CRm 和 opc2</code>通过不同的搭配，其得到的寄存器含义不同：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/10.png" alt="image"><br>当<code>CRn=c0，opc1=0，CRm=c0，opc2=0 </code>的时候就表示此时的 c0 就是 MIDR 寄存器，也就是主 ID 寄存器，这个也是 c0 的基本作用。来看下c0作为MDIR寄存器时的含义：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/11.png" alt="image"><br>bit31:24：厂商编号，0X41，ARM。<br>bit23:20：内核架构的主版本号，ARM 内核版本一般使用<code>rnpn</code>来表示，比如<code> r0p1</code>，其中 r0<br>后面的 0 就是内核架构主版本号。<br>bit19:16：架构代码，0XF，ARMv7 架构。<br>bit15:4：内核版本号，0XC07，<code>Cortex-A7 MPCore </code>内核。<br>bit3:0：内核架构的次版本号，<code>rnpn </code>中的 <code>pn</code>，比如<code>r0p1</code>中 <code>p1</code> 后面的 1 就是次版本号。</p>
<h2><span id="5-3-c1-ji-cun-qi-sctlr">5.3 c1寄存器（SCTLR）</span><a href="#5-3-c1-ji-cun-qi-sctlr" class="header-anchor">#</a></h2><p><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/12.png" alt="image"><br><code>CRn=c1，opc1=0，CRm=c0，opc2=0 </code>的时候就表示此时的 c1 就是 SCTLR 寄存器，也就是系统控制寄存器，这个是 c1 的基本作用。<br><strong>SCTLR 寄存器主要是完成控制功能的，比如使能或者禁止 MMU、I&#x2F;D Cache 等。</strong>  SCTLR 寄存器展开如下：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/13.png" alt="image"></p>
<p>bit13：V , 中断向量表基地址选择位，为 0 的话中断向量表基地址为 <code>0X00000000</code>，软件可以使用<code>VBAR</code>来重映射此基地址，也就是中断向量表重定位。为 1 的话中断向量表基地址为<code>0XFFFF0000</code>，此基地址不能被重映射。<br>bit12：I，I Cache 使能位，为 0 的话关闭 I Cache，为 1 的话使能 I Cache。<br>bit11：Z，分支预测使能位，如果开启 MMU 的话，此位也会使能。<br>bit10：SW，SWP 和 SWPB 使能位，当为 0 的话关闭 SWP 和 SWPB 指令，当为 1 的时候就使能 SWP 和 SWPB 指令。<br>bit9:3：未使用，保留。<br>bit2：C，D Cache 和缓存一致性使能位，为 0 的时候禁止 D Cache 和缓存一致性，为 1 时使能。<br>bit1：A，内存对齐检查使能位，为 0 的时候关闭内存对齐检查，为 1 的时候使能内存对齐检查。<br>bit0：M，MMU 使能位，为 0 的时候禁止 MMU，为 1 的时候使能 MMU。<br>举个读写SCTLR的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRC p15, 0, &lt;Rt&gt;, c1, c0, 0 ;读取 SCTLR 寄存器，数据保存到 Rt 中。</span><br><span class="line"></span><br><span class="line">MCR p15, 0, &lt;Rt&gt;, c1, c0, 0 ;将 Rt 中的数据写到 SCTLR(c1)寄存器中。</span><br></pre></td></tr></table></figure>

<p>再来一个关闭MMU,ICache,DCache的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mrc     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 读取CP15的C1寄存器到R0中       		        	*/</span></span><br><span class="line">bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">12</span>)     <span class="comment">/* 清除C1寄存器的bit12位(I位)，关闭I Cache            	*/</span></span><br><span class="line">bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt;  <span class="number">2</span>)     <span class="comment">/* 清除C1寄存器的bit2(C位)，关闭D Cache    				*/</span></span><br><span class="line">bic     r0,  r0, #<span class="number">0x2</span>             <span class="comment">/* 清除C1寄存器的bit1(A位)，关闭对齐						*/</span></span><br><span class="line">bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">11</span>)     <span class="comment">/* 清除C1寄存器的bit11(Z位)，关闭分支预测					*/</span></span><br><span class="line">bic     r0,  r0, #<span class="number">0x1</span>             <span class="comment">/* 清除C1寄存器的bit0(M位)，关闭MMU				       	*/</span></span><br><span class="line">mcr     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 将r0寄存器中的值写入到CP15的C1寄存器中	 				*/</span></span><br></pre></td></tr></table></figure>
<h2><span id="5-4-c12-ji-cun-qi-vbar">5.4 c12寄存器（VBAR）</span><a href="#5-4-c12-ji-cun-qi-vbar" class="header-anchor">#</a></h2><p><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/14.png" alt="image"><br><code>CRn=c12，opc1=0，CRm=c0，opc2=0 </code>的时候就表示此时 c12 为 <code>VBAR </code>寄存器，也就是<strong>中断向量表基地址寄存器</strong>。</p>
<p>比如代码链接到DDR的某个位置作为起始地址，起始地址为<code>0X87800000</code>，而中断向量表肯定要放到最前面，也就是 <code>0X87800000</code> 这个地址处。所以就需要设置 <code>VBAR</code> 为 <code>0X87800000</code>，设置命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line">ldr r0, =0x87800000 ; r0=0x87800000</span><br><span class="line">MCR p15, 0, r0, c12, c0, 0 ;将 r0 里面的数据写入到 c12 中，即 c12=0X87800000</span><br><span class="line">dsb</span><br><span class="line">isb</span><br></pre></td></tr></table></figure>
<h2><span id="5-5-c15-ji-cun-qi-cbar">5.5 c15寄存器（CBAR）</span><a href="#5-5-c15-ji-cun-qi-cbar" class="header-anchor">#</a></h2><p><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/15.png" alt="image"><br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/16.png" alt="image"></p>
<p>CBAR寄存器中保存了<code>GIC（Generic Interrupt Controller）</code>的基地址。<code>GIC</code>基地址偏移<code>0x1000</code>是<code>分发器 block</code>, 偏移<code>0x2000</code>是CPU <code>接口端 block</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRC p15, 4, r1, c15, c0, 0 ; 获取 GIC 基础地址，基地址保存在 r1 中</span><br></pre></td></tr></table></figure>
<h1><span id="6-arm-guan-fang-can-kao-lian-jie">6 arm官方参考链接</span><a href="#6-arm-guan-fang-can-kao-lian-jie" class="header-anchor">#</a></h1><h2><span id="6-1-armv7-yu-armv8-jia-gou">6.1 armv7与armv8架构</span><a href="#6-1-armv7-yu-armv8-jia-gou" class="header-anchor">#</a></h2><p>armv7都是32位处理器，典型的有<code>CorTex-A</code> A7 A8 A9 A15 A17。armv8采用64位处理器，典型的比如手机处理器，有Cortex A53 A76 A77都是64位架构。</p>
<h2><span id="6-2-armv7-can-kao-shou-ce">6.2 armv7参考手册</span><a href="#6-2-armv7-can-kao-shou-ce" class="header-anchor">#</a></h2><p><a href="https://developer.arm.com/documentation/ddi0406/cd?lang=en">https://developer.arm.com/documentation/ddi0406/cd?lang=en</a><br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/17.png" alt="image"></p>
<h2><span id="6-3-armv7-bian-cheng-shou-ce">6.3 armv7 编程手册</span><a href="#6-3-armv7-bian-cheng-shou-ce" class="header-anchor">#</a></h2><p><a href="https://developer.arm.com/documentation/den0013/d/?lang=en">https://developer.arm.com/documentation/den0013/d/?lang=en</a><br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/18.png" alt="image"></p>
<h2><span id="6-4-cortex-a7-mpcore-ji-zhu-can-kao-shou-ce">6.4 Cortex-A7 <code>MPCore</code> 技术参考手册</span><a href="#6-4-cortex-a7-mpcore-ji-zhu-can-kao-shou-ce" class="header-anchor">#</a></h2><p><a href="https://developer.arm.com/documentation/ddi0464/latest/">https://developer.arm.com/documentation/ddi0464/latest/</a><br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/19.png" alt="image"></p>
<h1><span id="7-fu-jian-1-armv7-luo-ji-qi-dong-hui-bian-shi-li">7 附件1：armv7裸机启动汇编示例：</span><a href="#7-fu-jian-1-armv7-luo-ji-qi-dong-hui-bian-shi-li" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start  				<span class="comment">/* 全局标号 */</span></span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	ldr pc, =Reset_Handler		<span class="comment">/* 复位中断 					*/</span>	</span><br><span class="line">	ldr pc, =Undefined_Handler	<span class="comment">/* 未定义中断 					*/</span></span><br><span class="line">	ldr pc, =SVC_Handler		<span class="comment">/* SVC(Supervisor)中断 		*/</span></span><br><span class="line">	ldr pc, =PrefAbort_Handler	<span class="comment">/* 预取终止中断 					*/</span></span><br><span class="line">	ldr pc, =DataAbort_Handler	<span class="comment">/* 数据终止中断 					*/</span></span><br><span class="line">	ldr	pc, =NotUsed_Handler	<span class="comment">/* 未使用中断					*/</span></span><br><span class="line">	ldr pc, =IRQ_Handler		<span class="comment">/* IRQ中断 					*/</span></span><br><span class="line">	ldr pc, =FIQ_Handler		<span class="comment">/* FIQ(快速中断)未定义中断 			*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复位中断 */</span>	</span><br><span class="line">Reset_Handler:</span><br><span class="line"></span><br><span class="line">	cpsid i						<span class="comment">/* 关闭全局中断 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关闭I,DCache和MMU </span></span><br><span class="line"><span class="comment">	 * 采取读-改-写的方式。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mrc     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 读取CP15的C1寄存器到R0中       		        	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">12</span>)     <span class="comment">/* 清除C1寄存器的bit12位(I位)，关闭I Cache            	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt;  <span class="number">2</span>)     <span class="comment">/* 清除C1寄存器的bit2(C位)，关闭D Cache    				*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x2</span>             <span class="comment">/* 清除C1寄存器的bit1(A位)，关闭对齐						*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">11</span>)     <span class="comment">/* 清除C1寄存器的bit11(Z位)，关闭分支预测					*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x1</span>             <span class="comment">/* 清除C1寄存器的bit0(M位)，关闭MMU				       	*/</span></span><br><span class="line">    mcr     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 将r0寄存器中的值写入到CP15的C1寄存器中	 				*/</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 汇编版本设置中断向量表偏移 */</span></span><br><span class="line">	ldr r0, =<span class="number">0X87800000</span></span><br><span class="line"></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	mcr p15, <span class="number">0</span>, r0, c12, c0, <span class="number">0</span></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 设置各个模式下的栈指针，</span></span><br><span class="line"><span class="comment">	 * 注意：IMX6UL的堆栈是向下增长的！</span></span><br><span class="line"><span class="comment">	 * 堆栈指针地址一定要是4字节地址对齐的！！！</span></span><br><span class="line"><span class="comment">	 * DDR范围:0X80000000~0X9FFFFFFF</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x12</span> 	<span class="comment">/* r0或上0x13,表示使用IRQ模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80600000</span>	<span class="comment">/* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进入SYS模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* r0或上0x13,表示使用SYS模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80400000</span>	<span class="comment">/* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进入SVC模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x13</span> 	<span class="comment">/* r0或上0x13,表示使用SVC模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0X80200000</span>	<span class="comment">/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */</span></span><br><span class="line"></span><br><span class="line">	cpsie i				<span class="comment">/* 打开全局中断 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 使能IRQ中断 */</span></span><br><span class="line">	mrs r0, cpsr		<span class="comment">/* 读取cpsr寄存器值到r0中 			*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0x80</span>	<span class="comment">/* 将r0寄存器中bit7清零，也就是CPSR中的I位清零，表示允许IRQ中断 */</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0重新写入到cpsr中 			*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	b main				<span class="comment">/* 跳转到main函数 			 	*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 未定义中断 */</span></span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, =Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SVC中断 */</span></span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 预取终止中断 */</span></span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler	</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数据终止中断 */</span></span><br><span class="line">DataAbort_Handler:</span><br><span class="line">	ldr r0, =DataAbort_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 未使用的中断 */</span></span><br><span class="line">NotUsed_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =NotUsed_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line">IRQ_Handler:</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存lr地址 */</span></span><br><span class="line">	push &#123;r0-r3, r12&#125;			<span class="comment">/* 保存r0-r3，r12寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrs r0, spsr				<span class="comment">/* 读取spsr寄存器 */</span></span><br><span class="line">	push &#123;r0&#125;					<span class="comment">/* 保存spsr寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrc p15, <span class="number">4</span>, r1, c15, c0, <span class="number">0</span> <span class="comment">/* 从CP15的C0寄存器内的值到R1寄存器中</span></span><br><span class="line"><span class="comment">								* 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49</span></span><br><span class="line"><span class="comment">								* Cortex-A7 Technical ReferenceManua.pdf P68 P138</span></span><br><span class="line"><span class="comment">								*/</span>							</span><br><span class="line">	add r1, r1, #<span class="number">0X2000</span>			<span class="comment">/* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */</span></span><br><span class="line">	ldr r0, [r1, #<span class="number">0XC</span>]			<span class="comment">/* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，</span></span><br><span class="line"><span class="comment">								 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据</span></span><br><span class="line"><span class="comment">								 * 这个中断号来绝对调用哪个中断服务函数</span></span><br><span class="line"><span class="comment">								 */</span></span><br><span class="line">	push &#123;r0, r1&#125;				<span class="comment">/* 保存r0,r1 */</span></span><br><span class="line">	</span><br><span class="line">	cps #<span class="number">0x13</span>					<span class="comment">/* 进入SVC模式，允许其他中断再次进去 */</span></span><br><span class="line">	</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存SVC模式的lr寄存器 */</span></span><br><span class="line">	ldr r2, =system_irqhandler	<span class="comment">/* 加载C语言中断处理函数到r2寄存器中*/</span></span><br><span class="line">	blx r2						<span class="comment">/* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* 执行完C语言中断服务函数，lr出栈 */</span></span><br><span class="line">	cps #<span class="number">0x12</span>					<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	pop &#123;r0, r1&#125;				</span><br><span class="line">	str r0, [r1, #<span class="number">0X10</span>]			<span class="comment">/* 中断执行完成，写EOIR */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0&#125;						</span><br><span class="line">	msr spsr_cxsf, r0			<span class="comment">/* 恢复spsr */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0-r3, r12&#125;			<span class="comment">/* r0-r3,r12出栈 */</span></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* lr出栈 */</span></span><br><span class="line">	subs pc, lr, #<span class="number">4</span>				<span class="comment">/* 将lr-4赋给pc */</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/* FIQ中断 */</span></span><br><span class="line">FIQ_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =FIQ_Handler	</span><br><span class="line">	bx r0</span><br></pre></td></tr></table></figure>
<h1><span id="8-fu-jian-2-gic-zhi-ling-he-ji-cun-qi-ding-yi-nei-lian-hui-bian-fang-shi">8 附件2：GIC指令和寄存器定义（内联汇编方式）</span><a href="#8-fu-jian-2-gic-zhi-ling-he-ji-cun-qi-ding-yi-nei-lian-hui-bian-fang-shi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CORTEX_CA7_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CORTEX_CA7_H</span></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">文件名	: 	 core_ca7.h</span></span><br><span class="line"><span class="comment">描述	   : Cortex-A7内核通用文件。</span></span><br><span class="line"><span class="comment">其他	   : 本文件主要实现了对GIC操作函数</span></span><br><span class="line"><span class="comment">论坛 	   : www.wtmembed.com</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FORCEDINLINE  __attribute__((always_inline))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASM            __asm                         	<span class="comment">/* GNU C语言内嵌汇编关键字 */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE         inline                      	<span class="comment">/* GNU内联关键字 */</span>             </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STATIC_INLINE  static inline					</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     __IM     volatile const      <span class="comment">/* 只读 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     __OM     volatile            <span class="comment">/* 只写 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     __IOM    volatile            <span class="comment">/* 读写 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STRINGIFY(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* C语言实现MCR指令 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MCR(coproc, opcode_1, src, CRn, CRm, opcode_2)                          \</span></span><br><span class="line"><span class="meta">    __ASM volatile (<span class="string">&quot;MCR &quot;</span> __STRINGIFY(p##coproc) <span class="string">&quot;, &quot;</span> __STRINGIFY(opcode_1) <span class="string">&quot;, &quot;</span> \</span></span><br><span class="line"><span class="meta">                    <span class="string">&quot;%0, &quot;</span> __STRINGIFY(c##CRn) <span class="string">&quot;, &quot;</span> __STRINGIFY(c##CRm) <span class="string">&quot;, &quot;</span>      \</span></span><br><span class="line"><span class="meta">                    __STRINGIFY(opcode_2)                                         \</span></span><br><span class="line"><span class="meta">                    : : <span class="string">&quot;r&quot;</span> (src) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* C语言实现MRC指令 */</span>                    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MRC(coproc, opcode_1, CRn, CRm, opcode_2)                               \</span></span><br><span class="line"><span class="meta">  (&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    uint32_t __dst;                                                               \</span></span><br><span class="line"><span class="meta">    __ASM volatile (<span class="string">&quot;MRC &quot;</span> __STRINGIFY(p##coproc) <span class="string">&quot;, &quot;</span> __STRINGIFY(opcode_1) <span class="string">&quot;, &quot;</span> \</span></span><br><span class="line"><span class="meta">                    <span class="string">&quot;%0, &quot;</span> __STRINGIFY(c##CRn) <span class="string">&quot;, &quot;</span> __STRINGIFY(c##CRm) <span class="string">&quot;, &quot;</span>      \</span></span><br><span class="line"><span class="meta">                    __STRINGIFY(opcode_2)                                         \</span></span><br><span class="line"><span class="meta">                    : <span class="string">&quot;=r&quot;</span> (__dst) );                                             \</span></span><br><span class="line"><span class="meta">    __dst;                                                                        \</span></span><br><span class="line"><span class="meta">  &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他一些C语言内嵌汇编 */</span>  </span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">void</span> __set_APSR(<span class="type">uint32_t</span> apsr)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;MSR apsr, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (apsr) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">uint32_t</span> __get_CPSR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> result;</span><br><span class="line"></span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;MRS %0, cpsr&quot;</span> : <span class="string">&quot;=r&quot;</span> (result) )</span>;</span><br><span class="line">  <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">void</span> __set_CPSR(<span class="type">uint32_t</span> cpsr)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;MSR cpsr, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (cpsr) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">uint32_t</span> __get_FPEXC(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> result;</span><br><span class="line"></span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;VMRS %0, fpexc&quot;</span> : <span class="string">&quot;=r&quot;</span> (result) )</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">void</span> __set_FPEXC(<span class="type">uint32_t</span> fpexc)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;VMSR fpexc, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (fpexc))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> *        		一些内核寄存器定义和抽象</span></span><br><span class="line"><span class="comment">  定义如下几个内核寄存器:</span></span><br><span class="line"><span class="comment">  - CPSR</span></span><br><span class="line"><span class="comment">  - CP15</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CPSR寄存器 </span></span><br><span class="line"><span class="comment"> * 参考资料：ARM Cortex-A(armV7)编程手册V4.0.pdf P46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> M:<span class="number">5</span>;                        <span class="comment">/*!&lt; bit:  0.. 4  Mode field */</span></span><br><span class="line">    <span class="type">uint32_t</span> T:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      5  Thumb execution state bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> F:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      6  FIQ mask bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> I:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      7  IRQ mask bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> A:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      8  Asynchronous abort mask bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> E:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      9  Endianness execution state bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> IT1:<span class="number">6</span>;                      <span class="comment">/*!&lt; bit: 10..15  If-Then execution state bits 2-7 */</span></span><br><span class="line">    <span class="type">uint32_t</span> GE:<span class="number">4</span>;                       <span class="comment">/*!&lt; bit: 16..19  Greater than or Equal flags */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">4</span>;               <span class="comment">/*!&lt; bit: 20..23  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> J:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     24  Jazelle bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> IT0:<span class="number">2</span>;                      <span class="comment">/*!&lt; bit: 25..26  If-Then execution state bits 0-1 */</span></span><br><span class="line">    <span class="type">uint32_t</span> Q:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     27  Saturation condition flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> V:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     28  Overflow condition code flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> C:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     29  Carry condition code flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> Z:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     30  Zero condition code flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> N:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     31  Negative condition code flag */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; CPSR_Type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的SCTLR寄存器 </span></span><br><span class="line"><span class="comment"> * 参考资料：Cortex-A7 Technical ReferenceManua.pdf P105</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> M:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     0  MMU enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> A:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     1  Alignment check enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> C:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     2  Cache enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">2</span>;               <span class="comment">/*!&lt; bit: 3.. 4  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> CP15BEN:<span class="number">1</span>;                  <span class="comment">/*!&lt; bit:     5  CP15 barrier enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:     6  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> B:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     7  Endianness model */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved2:<span class="number">2</span>;               <span class="comment">/*!&lt; bit: 8.. 9  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> SW:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    10  SWP and SWPB enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> Z:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:    11  Branch prediction enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> I:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:    12  Instruction cache enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> V:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:    13  Vectors bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> RR:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    14  Round Robin select */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved3:<span class="number">2</span>;               <span class="comment">/*!&lt; bit:15..16  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> HA:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    17  Hardware Access flag enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved4:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    18  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> WXN:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    19  Write permission implies XN */</span></span><br><span class="line">    <span class="type">uint32_t</span> UWXN:<span class="number">1</span>;                     <span class="comment">/*!&lt; bit:    20  Unprivileged write permission implies PL1 XN */</span></span><br><span class="line">    <span class="type">uint32_t</span> FI:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    21  Fast interrupts configuration enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> U:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:    22  Alignment model */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved5:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    23  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> VE:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    24  Interrupt Vectors Enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> EE:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    25  Exception Endianness */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved6:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    26  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> NMFI:<span class="number">1</span>;                     <span class="comment">/*!&lt; bit:    27  Non-maskable FIQ (NMFI) support */</span></span><br><span class="line">    <span class="type">uint32_t</span> TRE:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    28  TEX remap enable. */</span></span><br><span class="line">    <span class="type">uint32_t</span> AFE:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    29  Access flag enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> TE:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    30  Thumb Exception enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved7:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; SCTLR_Type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15 寄存器SCTLR各个位定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_TE_Pos                     30U                                    <span class="comment">/*!&lt; SCTLR: TE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_TE_Msk                     (1UL &lt;&lt; SCTLR_TE_Pos)                  <span class="comment">/*!&lt; SCTLR: TE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_AFE_Pos                    29U                                    <span class="comment">/*!&lt; SCTLR: AFE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_AFE_Msk                    (1UL &lt;&lt; SCTLR_AFE_Pos)                 <span class="comment">/*!&lt; SCTLR: AFE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_TRE_Pos                    28U                                    <span class="comment">/*!&lt; SCTLR: TRE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_TRE_Msk                    (1UL &lt;&lt; SCTLR_TRE_Pos)                 <span class="comment">/*!&lt; SCTLR: TRE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_NMFI_Pos                   27U                                    <span class="comment">/*!&lt; SCTLR: NMFI Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_NMFI_Msk                   (1UL &lt;&lt; SCTLR_NMFI_Pos)                <span class="comment">/*!&lt; SCTLR: NMFI Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_EE_Pos                     25U                                    <span class="comment">/*!&lt; SCTLR: EE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_EE_Msk                     (1UL &lt;&lt; SCTLR_EE_Pos)                  <span class="comment">/*!&lt; SCTLR: EE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_VE_Pos                     24U                                    <span class="comment">/*!&lt; SCTLR: VE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_VE_Msk                     (1UL &lt;&lt; SCTLR_VE_Pos)                  <span class="comment">/*!&lt; SCTLR: VE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_U_Pos                      22U                                    <span class="comment">/*!&lt; SCTLR: U Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_U_Msk                      (1UL &lt;&lt; SCTLR_U_Pos)                   <span class="comment">/*!&lt; SCTLR: U Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_FI_Pos                     21U                                    <span class="comment">/*!&lt; SCTLR: FI Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_FI_Msk                     (1UL &lt;&lt; SCTLR_FI_Pos)                  <span class="comment">/*!&lt; SCTLR: FI Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_UWXN_Pos                   20U                                    <span class="comment">/*!&lt; SCTLR: UWXN Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_UWXN_Msk                   (1UL &lt;&lt; SCTLR_UWXN_Pos)                <span class="comment">/*!&lt; SCTLR: UWXN Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_WXN_Pos                    19U                                    <span class="comment">/*!&lt; SCTLR: WXN Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_WXN_Msk                    (1UL &lt;&lt; SCTLR_WXN_Pos)                 <span class="comment">/*!&lt; SCTLR: WXN Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_HA_Pos                     17U                                    <span class="comment">/*!&lt; SCTLR: HA Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_HA_Msk                     (1UL &lt;&lt; SCTLR_HA_Pos)                  <span class="comment">/*!&lt; SCTLR: HA Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_RR_Pos                     14U                                    <span class="comment">/*!&lt; SCTLR: RR Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_RR_Msk                     (1UL &lt;&lt; SCTLR_RR_Pos)                  <span class="comment">/*!&lt; SCTLR: RR Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_V_Pos                      13U                                    <span class="comment">/*!&lt; SCTLR: V Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_V_Msk                      (1UL &lt;&lt; SCTLR_V_Pos)                   <span class="comment">/*!&lt; SCTLR: V Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_I_Pos                      12U                                    <span class="comment">/*!&lt; SCTLR: I Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_I_Msk                      (1UL &lt;&lt; SCTLR_I_Pos)                   <span class="comment">/*!&lt; SCTLR: I Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_Z_Pos                      11U                                    <span class="comment">/*!&lt; SCTLR: Z Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_Z_Msk                      (1UL &lt;&lt; SCTLR_Z_Pos)                   <span class="comment">/*!&lt; SCTLR: Z Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_SW_Pos                     10U                                    <span class="comment">/*!&lt; SCTLR: SW Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_SW_Msk                     (1UL &lt;&lt; SCTLR_SW_Pos)                  <span class="comment">/*!&lt; SCTLR: SW Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_B_Pos                      7U                                     <span class="comment">/*!&lt; SCTLR: B Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_B_Msk                      (1UL &lt;&lt; SCTLR_B_Pos)                   <span class="comment">/*!&lt; SCTLR: B Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_CP15BEN_Pos                5U                                     <span class="comment">/*!&lt; SCTLR: CP15BEN Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_CP15BEN_Msk                (1UL &lt;&lt; SCTLR_CP15BEN_Pos)             <span class="comment">/*!&lt; SCTLR: CP15BEN Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_C_Pos                      2U                                     <span class="comment">/*!&lt; SCTLR: C Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_C_Msk                      (1UL &lt;&lt; SCTLR_C_Pos)                   <span class="comment">/*!&lt; SCTLR: C Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_A_Pos                      1U                                     <span class="comment">/*!&lt; SCTLR: A Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_A_Msk                      (1UL &lt;&lt; SCTLR_A_Pos)                   <span class="comment">/*!&lt; SCTLR: A Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_M_Pos                      0U                                     <span class="comment">/*!&lt; SCTLR: M Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_M_Msk                      (1UL &lt;&lt; SCTLR_M_Pos)                   <span class="comment">/*!&lt; SCTLR: M Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的ACTLR寄存器</span></span><br><span class="line"><span class="comment"> * 参考资料:Cortex-A7 Technical ReferenceManua.pdf P113</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">6</span>;               <span class="comment">/*!&lt; bit: 0.. 5  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> SMP:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:     6  Enables coherent requests to the processor */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">3</span>;               <span class="comment">/*!&lt; bit: 7.. 9  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> DODMBS:<span class="number">1</span>;                   <span class="comment">/*!&lt; bit:    10  Disable optimized data memory barrier behavior */</span></span><br><span class="line">    <span class="type">uint32_t</span> L2RADIS:<span class="number">1</span>;                  <span class="comment">/*!&lt; bit:    11  L2 Data Cache read-allocate mode disable */</span></span><br><span class="line">    <span class="type">uint32_t</span> L1RADIS:<span class="number">1</span>;                  <span class="comment">/*!&lt; bit:    12  L1 Data Cache read-allocate mode disable */</span></span><br><span class="line">    <span class="type">uint32_t</span> L1PCTL:<span class="number">2</span>;                   <span class="comment">/*!&lt; bit:13..14  L1 Data prefetch control */</span></span><br><span class="line">    <span class="type">uint32_t</span> DDVM:<span class="number">1</span>;                     <span class="comment">/*!&lt; bit:    15  Disable Distributed Virtual Memory (DVM) transactions */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved3:<span class="number">12</span>;              <span class="comment">/*!&lt; bit:16..27  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> DDI:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    28  Disable dual issue */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved7:<span class="number">3</span>;               <span class="comment">/*!&lt; bit:29..31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; ACTLR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DDI_Pos                    28U                                     <span class="comment">/*!&lt; ACTLR: DDI Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DDI_Msk                    (1UL &lt;&lt; ACTLR_DDI_Pos)                  <span class="comment">/*!&lt; ACTLR: DDI Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DDVM_Pos                   15U                                     <span class="comment">/*!&lt; ACTLR: DDVM Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DDVM_Msk                   (1UL &lt;&lt; ACTLR_DDVM_Pos)                 <span class="comment">/*!&lt; ACTLR: DDVM Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L1PCTL_Pos                 13U                                     <span class="comment">/*!&lt; ACTLR: L1PCTL Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L1PCTL_Msk                 (3UL &lt;&lt; ACTLR_L1PCTL_Pos)               <span class="comment">/*!&lt; ACTLR: L1PCTL Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L1RADIS_Pos                12U                                     <span class="comment">/*!&lt; ACTLR: L1RADIS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L1RADIS_Msk                (1UL &lt;&lt; ACTLR_L1RADIS_Pos)              <span class="comment">/*!&lt; ACTLR: L1RADIS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L2RADIS_Pos                11U                                     <span class="comment">/*!&lt; ACTLR: L2RADIS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L2RADIS_Msk                (1UL &lt;&lt; ACTLR_L2RADIS_Pos)              <span class="comment">/*!&lt; ACTLR: L2RADIS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DODMBS_Pos                 10U                                     <span class="comment">/*!&lt; ACTLR: DODMBS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DODMBS_Msk                 (1UL &lt;&lt; ACTLR_DODMBS_Pos)               <span class="comment">/*!&lt; ACTLR: DODMBS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_SMP_Pos                    6U                                      <span class="comment">/*!&lt; ACTLR: SMP Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_SMP_Msk                    (1UL &lt;&lt; ACTLR_SMP_Pos)                  <span class="comment">/*!&lt; ACTLR: SMP Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的CPACR寄存器</span></span><br><span class="line"><span class="comment"> * 参考资料：Cortex-A7 Technical ReferenceManua.pdf P115</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">20</span>;              <span class="comment">/*!&lt; bit: 0..19  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> cp10:<span class="number">2</span>;                     <span class="comment">/*!&lt; bit:20..21  Access rights for coprocessor 10 */</span></span><br><span class="line">    <span class="type">uint32_t</span> cp11:<span class="number">2</span>;                     <span class="comment">/*!&lt; bit:22..23  Access rights for coprocessor 11 */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">6</span>;               <span class="comment">/*!&lt; bit:24..29  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> D32DIS:<span class="number">1</span>;                   <span class="comment">/*!&lt; bit:    30  Disable use of registers D16-D31 of the VFP register file */</span></span><br><span class="line">    <span class="type">uint32_t</span> ASEDIS:<span class="number">1</span>;                   <span class="comment">/*!&lt; bit:    31  Disable Advanced SIMD Functionality */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; CPACR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_ASEDIS_Pos                 31U                                    <span class="comment">/*!&lt; CPACR: ASEDIS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_ASEDIS_Msk                 (1UL &lt;&lt; CPACR_ASEDIS_Pos)              <span class="comment">/*!&lt; CPACR: ASEDIS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_D32DIS_Pos                 30U                                    <span class="comment">/*!&lt; CPACR: D32DIS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_D32DIS_Msk                 (1UL &lt;&lt; CPACR_D32DIS_Pos)              <span class="comment">/*!&lt; CPACR: D32DIS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_cp11_Pos                   22U                                    <span class="comment">/*!&lt; CPACR: cp11 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_cp11_Msk                   (3UL &lt;&lt; CPACR_cp11_Pos)                <span class="comment">/*!&lt; CPACR: cp11 Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_cp10_Pos                   20U                                    <span class="comment">/*!&lt; CPACR: cp10 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_cp10_Msk                   (3UL &lt;&lt; CPACR_cp10_Pos)                <span class="comment">/*!&lt; CPACR: cp10 Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的DFSR寄存器</span></span><br><span class="line"><span class="comment"> * 参考资料：Cortex-A7 Technical ReferenceManua.pdf P128</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> FS0:<span class="number">4</span>;                      <span class="comment">/*!&lt; bit: 0.. 3  Fault Status bits bit 0-3 */</span></span><br><span class="line">    <span class="type">uint32_t</span> Domain:<span class="number">4</span>;                   <span class="comment">/*!&lt; bit: 4.. 7  Fault on which domain */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">2</span>;               <span class="comment">/*!&lt; bit: 8.. 9  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> FS1:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    10  Fault Status bits bit 4 */</span></span><br><span class="line">    <span class="type">uint32_t</span> WnR:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    11  Write not Read bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> ExT:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    12  External abort type */</span></span><br><span class="line">    <span class="type">uint32_t</span> CM:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    13  Cache maintenance fault */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">18</span>;              <span class="comment">/*!&lt; bit:14..31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; DFSR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_CM_Pos                      13U                                    <span class="comment">/*!&lt; DFSR: CM Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_CM_Msk                      (1UL &lt;&lt; DFSR_CM_Pos)                   <span class="comment">/*!&lt; DFSR: CM Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_Ext_Pos                     12U                                    <span class="comment">/*!&lt; DFSR: Ext Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_Ext_Msk                     (1UL &lt;&lt; DFSR_Ext_Pos)                  <span class="comment">/*!&lt; DFSR: Ext Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_WnR_Pos                     11U                                    <span class="comment">/*!&lt; DFSR: WnR Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_WnR_Msk                     (1UL &lt;&lt; DFSR_WnR_Pos)                  <span class="comment">/*!&lt; DFSR: WnR Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_FS1_Pos                     10U                                    <span class="comment">/*!&lt; DFSR: FS1 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_FS1_Msk                     (1UL &lt;&lt; DFSR_FS1_Pos)                  <span class="comment">/*!&lt; DFSR: FS1 Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_Domain_Pos                  4U                                     <span class="comment">/*!&lt; DFSR: Domain Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_Domain_Msk                  (0xFUL &lt;&lt; DFSR_Domain_Pos)             <span class="comment">/*!&lt; DFSR: Domain Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_FS0_Pos                     0U                                     <span class="comment">/*!&lt; DFSR: FS0 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_FS0_Msk                     (0xFUL &lt;&lt; DFSR_FS0_Pos)                <span class="comment">/*!&lt; DFSR: FS0 Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的IFSR寄存器 </span></span><br><span class="line"><span class="comment"> * 参考资料：Cortex-A7 Technical ReferenceManua.pdf P131</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> FS0:<span class="number">4</span>;                      <span class="comment">/*!&lt; bit: 0.. 3  Fault Status bits bit 0-3 */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">6</span>;               <span class="comment">/*!&lt; bit: 4.. 9  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> FS1:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    10  Fault Status bits bit 4 */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    11  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> ExT:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    12  External abort type */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved2:<span class="number">19</span>;              <span class="comment">/*!&lt; bit:13..31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; IFSR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_ExT_Pos                     12U                                    <span class="comment">/*!&lt; IFSR: ExT Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_ExT_Msk                     (1UL &lt;&lt; IFSR_ExT_Pos)                  <span class="comment">/*!&lt; IFSR: ExT Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_FS1_Pos                     10U                                    <span class="comment">/*!&lt; IFSR: FS1 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_FS1_Msk                     (1UL &lt;&lt; IFSR_FS1_Pos)                  <span class="comment">/*!&lt; IFSR: FS1 Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_FS0_Pos                     0U                                     <span class="comment">/*!&lt; IFSR: FS0 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_FS0_Msk                     (0xFUL &lt;&lt; IFSR_FS0_Pos)                <span class="comment">/*!&lt; IFSR: FS0 Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的ISR寄存器</span></span><br><span class="line"><span class="comment"> * 参考资料：ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf P1640</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">6</span>;               <span class="comment">/*!&lt; bit: 0.. 5  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> F:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     6  FIQ pending bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> I:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     7  IRQ pending bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> A:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     8  External abort pending bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">23</span>;              <span class="comment">/*!&lt; bit:14..31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; ISR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_A_Pos                        13U                                    <span class="comment">/*!&lt; ISR: A Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_A_Msk                        (1UL &lt;&lt; ISR_A_Pos)                     <span class="comment">/*!&lt; ISR: A Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_I_Pos                        12U                                    <span class="comment">/*!&lt; ISR: I Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_I_Msk                        (1UL &lt;&lt; ISR_I_Pos)                     <span class="comment">/*!&lt; ISR: I Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_F_Pos                        11U                                    <span class="comment">/*!&lt; ISR: F Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_F_Msk                        (1UL &lt;&lt; ISR_F_Pos)                     <span class="comment">/*!&lt; ISR: F Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mask and shift a bit field value for use in a register bit range. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _VAL2FLD(field, value)    ((value &lt;&lt; field ## _Pos) &amp; field ## _Msk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mask and shift a register value to extract a bit filed value. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FLD2VAL(field, value)    ((value &amp; field ## _Msk) &gt;&gt; field ## _Pos)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> *       			CP15 访问函数</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_SCTLR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_SCTLR(<span class="type">uint32_t</span> sctlr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, sctlr, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_ACTLR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_ACTLR(<span class="type">uint32_t</span> actlr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, actlr, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_CPACR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_CPACR(<span class="type">uint32_t</span> cpacr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, cpacr, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_TTBR0(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_TTBR0(<span class="type">uint32_t</span> ttbr0)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ttbr0, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_TTBR1(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_TTBR1(<span class="type">uint32_t</span> ttbr1)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ttbr1, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_TTBCR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_TTBCR(<span class="type">uint32_t</span> ttbcr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ttbcr, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_DACR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_DACR(<span class="type">uint32_t</span> dacr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, dacr, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_DFSR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_DFSR(<span class="type">uint32_t</span> dfsr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, dfsr, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_IFSR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_IFSR(<span class="type">uint32_t</span> ifsr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ifsr, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_DFAR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_DFAR(<span class="type">uint32_t</span> dfar)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, dfar, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_IFAR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_IFAR(<span class="type">uint32_t</span> ifar)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ifar, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_VBAR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_VBAR(<span class="type">uint32_t</span> vbar)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, vbar, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_ISR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_ISR(<span class="type">uint32_t</span> isr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, isr, <span class="number">12</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_CONTEXTIDR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_CONTEXTIDR(<span class="type">uint32_t</span> contextidr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, contextidr, <span class="number">13</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_CBAR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> *                 GIC相关内容</span></span><br><span class="line"><span class="comment"> *有关GIC的内容，参考：ARM Generic Interrupt Controller(ARM GIC控制器)V2.0.pdf</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GIC寄存器描述结构体，</span></span><br><span class="line"><span class="comment"> * GIC分为分发器端和CPU接口端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED0[<span class="number">1024</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_CTLR;                 <span class="comment">/*!&lt; Offset: 0x1000 (R/W) Distributor Control Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_TYPER;                <span class="comment">/*!&lt; Offset: 0x1004 (R/ )  Interrupt Controller Type Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_IIDR;                 <span class="comment">/*!&lt; Offset: 0x1008 (R/ )  Distributor Implementer Identification Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED1[<span class="number">29</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_IGROUPR[<span class="number">16</span>];          <span class="comment">/*!&lt; Offset: 0x1080 - 0x0BC (R/W) Interrupt Group Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED2[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ISENABLER[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1100 - 0x13C (R/W) Interrupt Set-Enable Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED3[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ICENABLER[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1180 - 0x1BC (R/W) Interrupt Clear-Enable Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED4[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ISPENDR[<span class="number">16</span>];          <span class="comment">/*!&lt; Offset: 0x1200 - 0x23C (R/W) Interrupt Set-Pending Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED5[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ICPENDR[<span class="number">16</span>];          <span class="comment">/*!&lt; Offset: 0x1280 - 0x2BC (R/W) Interrupt Clear-Pending Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED6[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ISACTIVER[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1300 - 0x33C (R/W) Interrupt Set-Active Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED7[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ICACTIVER[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1380 - 0x3BC (R/W) Interrupt Clear-Active Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED8[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint8_t</span>  D_IPRIORITYR[<span class="number">512</span>];      <span class="comment">/*!&lt; Offset: 0x1400 - 0x5FC (R/W) Interrupt Priority Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED9[<span class="number">128</span>];</span><br><span class="line">  __IOM <span class="type">uint8_t</span>  D_ITARGETSR[<span class="number">512</span>];       <span class="comment">/*!&lt; Offset: 0x1800 - 0x9FC (R/W) Interrupt Targets Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED10[<span class="number">128</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ICFGR[<span class="number">32</span>];            <span class="comment">/*!&lt; Offset: 0x1C00 - 0xC7C (R/W) Interrupt configuration registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED11[<span class="number">32</span>];</span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PPISR;                <span class="comment">/*!&lt; Offset: 0x1D00 (R/ ) Private Peripheral Interrupt Status Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_SPISR[<span class="number">15</span>];            <span class="comment">/*!&lt; Offset: 0x1D04 - 0xD3C (R/ ) Shared Peripheral Interrupt Status Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED12[<span class="number">112</span>];</span><br><span class="line">  __OM  <span class="type">uint32_t</span> D_SGIR;                 <span class="comment">/*!&lt; Offset: 0x1F00 ( /W) Software Generated Interrupt Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED13[<span class="number">3</span>];</span><br><span class="line">  __IOM <span class="type">uint8_t</span>  D_CPENDSGIR[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1F10 - 0xF1C (R/W) SGI Clear-Pending Registers */</span></span><br><span class="line">  __IOM <span class="type">uint8_t</span>  D_SPENDSGIR[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1F20 - 0xF2C (R/W) SGI Set-Pending Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED14[<span class="number">40</span>];</span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR4;                <span class="comment">/*!&lt; Offset: 0x1FD0 (R/ ) Peripheral ID4 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR5;                <span class="comment">/*!&lt; Offset: 0x1FD4 (R/ ) Peripheral ID5 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR6;                <span class="comment">/*!&lt; Offset: 0x1FD8 (R/ ) Peripheral ID6 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR7;                <span class="comment">/*!&lt; Offset: 0x1FDC (R/ ) Peripheral ID7 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR0;                <span class="comment">/*!&lt; Offset: 0x1FE0 (R/ ) Peripheral ID0 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR1;                <span class="comment">/*!&lt; Offset: 0x1FE4 (R/ ) Peripheral ID1 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR2;                <span class="comment">/*!&lt; Offset: 0x1FE8 (R/ ) Peripheral ID2 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR3;                <span class="comment">/*!&lt; Offset: 0x1FEC (R/ ) Peripheral ID3 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_CIDR0;                <span class="comment">/*!&lt; Offset: 0x1FF0 (R/ ) Component ID0 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_CIDR1;                <span class="comment">/*!&lt; Offset: 0x1FF4 (R/ ) Component ID1 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_CIDR2;                <span class="comment">/*!&lt; Offset: 0x1FF8 (R/ ) Component ID2 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_CIDR3;                <span class="comment">/*!&lt; Offset: 0x1FFC (R/ ) Component ID3 Register */</span></span><br><span class="line"></span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_CTLR;                 <span class="comment">/*!&lt; Offset: 0x2000 (R/W) CPU Interface Control Register */</span></span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_PMR;                  <span class="comment">/*!&lt; Offset: 0x2004 (R/W) Interrupt Priority Mask Register */</span></span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_BPR;                  <span class="comment">/*!&lt; Offset: 0x2008 (R/W) Binary Point Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_IAR;                  <span class="comment">/*!&lt; Offset: 0x200C (R/ ) Interrupt Acknowledge Register */</span></span><br><span class="line">  __OM  <span class="type">uint32_t</span> C_EOIR;                 <span class="comment">/*!&lt; Offset: 0x2010 ( /W) End Of Interrupt Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_RPR;                  <span class="comment">/*!&lt; Offset: 0x2014 (R/ ) Running Priority Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_HPPIR;                <span class="comment">/*!&lt; Offset: 0x2018 (R/ ) Highest Priority Pending Interrupt Register */</span></span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_ABPR;                 <span class="comment">/*!&lt; Offset: 0x201C (R/W) Aliased Binary Point Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_AIAR;                 <span class="comment">/*!&lt; Offset: 0x2020 (R/ ) Aliased Interrupt Acknowledge Register */</span></span><br><span class="line">  __OM  <span class="type">uint32_t</span> C_AEOIR;                <span class="comment">/*!&lt; Offset: 0x2024 ( /W) Aliased End Of Interrupt Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_AHPPIR;               <span class="comment">/*!&lt; Offset: 0x2028 (R/ ) Aliased Highest Priority Pending Interrupt Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED15[<span class="number">41</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_APR0;                 <span class="comment">/*!&lt; Offset: 0x20D0 (R/W) Active Priority Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED16[<span class="number">3</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_NSAPR0;               <span class="comment">/*!&lt; Offset: 0x20E0 (R/W) Non-secure Active Priority Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED17[<span class="number">6</span>];</span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_IIDR;                 <span class="comment">/*!&lt; Offset: 0x20FC (R/ ) CPU Interface Identification Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED18[<span class="number">960</span>];</span><br><span class="line">  __OM  <span class="type">uint32_t</span> C_DIR;                  <span class="comment">/*!&lt; Offset: 0x3000 ( /W) Deactivate Interrupt Register */</span></span><br><span class="line">&#125; GIC_Type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * GIC初始化</span></span><br><span class="line"><span class="comment"> * 为了简单使用GIC的group0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> i;</span><br><span class="line">  <span class="type">uint32_t</span> irqRegs;</span><br><span class="line">  GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line"></span><br><span class="line">  irqRegs = (gic-&gt;D_TYPER &amp; <span class="number">0x1F</span>UL) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* On POR, all SPI is in group 0, level-sensitive and using 1-N model */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable all PPI, SGI and SPI */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; irqRegs; i++)</span><br><span class="line">    gic-&gt;D_ICENABLER[i] = <span class="number">0xFFFFFFFF</span>UL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make all interrupts have higher priority */</span></span><br><span class="line">  gic-&gt;C_PMR = (<span class="number">0xFF</span>UL &lt;&lt; (<span class="number">8</span> - __GIC_PRIO_BITS)) &amp; <span class="number">0xFF</span>UL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No subpriority, all priority level allows preemption */</span></span><br><span class="line">  gic-&gt;C_BPR = <span class="number">7</span> - __GIC_PRIO_BITS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable group0 distribution */</span></span><br><span class="line">  gic-&gt;D_CTLR = <span class="number">1UL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable group0 signaling */</span></span><br><span class="line">  gic-&gt;C_CTLR = <span class="number">1UL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 使能指定的中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_EnableIRQ</span><span class="params">(IRQn_Type IRQn)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;D_ISENABLER[((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn) &gt;&gt; <span class="number">5</span>] = (<span class="type">uint32_t</span>)(<span class="number">1UL</span> &lt;&lt; (((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn) &amp; <span class="number">0x1F</span>UL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 关闭指定的中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_DisableIRQ</span><span class="params">(IRQn_Type IRQn)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;D_ICENABLER[((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn) &gt;&gt; <span class="number">5</span>] = (<span class="type">uint32_t</span>)(<span class="number">1UL</span> &lt;&lt; (((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn) &amp; <span class="number">0x1F</span>UL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 返回中断号 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">GIC_AcknowledgeIRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	<span class="keyword">return</span> gic-&gt;C_IAR &amp; <span class="number">0x1FFF</span>UL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 向EOIR写入发送中断的中断号来释放中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_DeactivateIRQ</span><span class="params">(<span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;C_EOIR = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取运行优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">GIC_GetRunningPriority</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	<span class="keyword">return</span> gic-&gt;C_RPR &amp; <span class="number">0xFF</span>UL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置组优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_SetPriorityGrouping</span><span class="params">(<span class="type">uint32_t</span> PriorityGroup)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;C_BPR = PriorityGroup &amp; <span class="number">0x7</span>UL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取组优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">GIC_GetPriorityGrouping</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gic-&gt;C_BPR &amp; <span class="number">0x7</span>UL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_SetPriority</span><span class="params">(IRQn_Type IRQn, <span class="type">uint32_t</span> priority)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;D_IPRIORITYR[((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn)] = (<span class="type">uint8_t</span>)((priority &lt;&lt; (<span class="number">8UL</span> - __GIC_PRIO_BITS)) &amp; (<span class="type">uint32_t</span>)<span class="number">0xFF</span>UL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">GIC_GetPriority</span><span class="params">(IRQn_Type IRQn)</span></span><br><span class="line">&#123;</span><br><span class="line">  GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  <span class="keyword">return</span>(((<span class="type">uint32_t</span>)gic-&gt;D_IPRIORITYR[((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn)] &gt;&gt; (<span class="number">8UL</span> - __GIC_PRIO_BITS)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2><span id="8-1-nei-lian-hui-bian-yuan-li">8.1 内联汇编原理</span><a href="#8-1-nei-lian-hui-bian-yuan-li" class="header-anchor">#</a></h2><p>先看一个错误的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov r1,r0&quot;</span>);</span><br><span class="line">    __asm__(<span class="string">&quot;mov r2,r1&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种操作可能产生负面的影响，因为 r0~r2 寄存器很可能正在被程序的其它部分使用而在这里被意外地修改。<br>这就需要使用到嵌入汇编的另一种表达形式：<br><code>asm(code : output operand list : input operand list : clobber list);</code><br>这种嵌入汇编的形式一共分为四个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* code</span><br><span class="line">* [attr]output operand list</span><br><span class="line">* [attr]input operand list</span><br><span class="line">* clobber list</span><br></pre></td></tr></table></figure>

<p><code>code</code>：汇编的操作代码，一条或者多条指令，如果是多条指令，需要在指令间使用<code>\n\t</code>隔开。<br>    与通用的汇编代码有一些不同：因为支持 C 变量的操作，所以在操作由第二、三部分提供<br>    的操作数时，使用 %n 来替代操作数。<br><code>output operand list</code>：表示输出的操作数，通常是一个或者多个 C 函数中的变量。<br><code>input operand list</code>：表示输入的操作数，通常是一个或者多个 C 函数中的变量，<code>attr</code>部分表示操作数的属性，以字符串的形式提供，是必须的参数。<br><code>clobber list</code>：被破坏的列表，这部分我们放到后面讨论。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> val1 = <span class="number">111</span>,val2 = <span class="number">222</span>;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;mov %0,%1&quot;</span></span><br><span class="line">        :<span class="string">&quot;+r&quot;</span>(val1)</span><br><span class="line">        :<span class="string">&quot;r&quot;</span>(val2)</span><br><span class="line">        :);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;val1 = %d\n&quot;</span>,val1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>func</code> 函数的输出结果为：<code>val1 = 222</code>.<br>分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出操作数为 val1，属性为 &quot;=r&quot;。</span><br><span class="line">输入操作数为 val2，属性为 &quot;r&quot;</span><br><span class="line">code 部分为 mov %1,%0, %0 表示输入输出列表中的第一个操作数，</span><br><span class="line">	%1 表示操作数列表中提供的第二个操作数，以此类推，这条汇编指</span><br><span class="line">	令很明显就是将第二个操作数(val2)赋值给第一个操作数(val1),所以最后的结果为 val1 = 222.</span><br><span class="line"></span><br><span class="line">code 中的操作数命名顺序为输出操作书列表递增，输入操作数列表递增，比如增加一个操作数的代码为：</span><br><span class="line">	int val1 = 111,val2 = 222,val3=333;</span><br><span class="line">	asm(&quot;mov %0,%2&quot; :&quot;+r&quot;(val1) :&quot;r&quot;(val2),&quot;r&quot;(val3) :);</span><br></pre></td></tr></table></figure>

<h3><span id="8-1-1-cao-zuo-shu-shu-xing">8.1.1 操作数属性</span><a href="#8-1-1-cao-zuo-shu-shu-xing" class="header-anchor">#</a></h3><p>在上述的示例中，输入操作数和输出操作数都会使用到 <code>attr </code>字段，即操作数的属性，下面是其属性对应的列表:</p>
<ul>
<li>“&#x3D;” 表示只写，通常用于所有输出操作数的属性</li>
<li>“+” 表示读写，只能被列为输出操作数的属性，否则编译会报错。</li>
</ul>
<h3><span id="8-1-2-clobber-list">8.1.2 clobber list</span><a href="#8-1-2-clobber-list" class="header-anchor">#</a></h3><p>clobber 的意思为破坏，在这里的意思是：这段汇编指令将会破坏哪些寄存器的值。</p>
<p>在目前的 gcc 设计中，编译分为4个过程：<code>预编译、编译、汇编、链接</code>。  其中，编译就是将 C 代码编译成汇编代码，而通用的汇编代码在这个过程是不会处理的，也就是说，<code>嵌入汇编代码</code>的解析只涉及到输入输出操作数的替换，对于不包含输入输出操作数的部分不会解析，所以在编译阶段，编译器不会知道嵌入汇编代码中静态地使用到哪些寄存器，而是自顾自地编译 C 代码，从而导致 C 代码和嵌入汇编代码操作到同一个寄存器，而出现错误。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov lr,#1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>嵌入汇编代码过程</code>中，将<code>lr</code>的值修改为 1，当前函数返回的时候也就返回到 1 地址，不出意料: 程序出现段错误:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>解决办法是：将程序修改一下,用<code>clobber list</code>这种标准格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov lr,#1&quot;</span>:::<span class="string">&quot;lr&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了进一步追求真相，我们来对比它们的反汇编代码:</p>
<p>不添加 clobber list 的反汇编代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000083f</span>4 &lt;func3&gt;:</span><br><span class="line">    <span class="number">83f</span>4:       b480            push    &#123;r7&#125;</span><br><span class="line">    <span class="number">83f</span>6:       af00            add     r7, sp, #<span class="number">0</span></span><br><span class="line">    <span class="number">83f</span>8:       f04f <span class="number">0e01</span>       mov.w   lr, #<span class="number">1</span></span><br><span class="line">    <span class="number">83f</span>c:       <span class="number">46b</span>d            mov     sp, r7</span><br><span class="line">    <span class="number">83f</span>e:       f85d <span class="number">7b</span>04       ldr.w   r7, [sp], #<span class="number">4</span></span><br><span class="line">    <span class="number">8402</span>:       <span class="number">4770</span>            bx      lr</span><br></pre></td></tr></table></figure>

<p>添加 clobber list 的反汇编代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">83f</span>4:       b580            push    &#123;r7, lr&#125;</span><br><span class="line">    <span class="number">83f</span>6:       af00            add     r7, sp, #<span class="number">0</span></span><br><span class="line">    <span class="number">83f</span>8:       f04f <span class="number">0e01</span>       mov.w   lr, #<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="number">83f</span>c:       bd80            pop     &#123;r7, pc&#125;</span><br><span class="line">    <span class="number">83f</span>e:       bf00            nop</span><br></pre></td></tr></table></figure>

<p>对比可以看出，对于不将<code>&quot;lr&quot;</code>添加到 <code>clobber list </code>中的代码，返回指令为<code> bx lr</code>，因为<code>lr</code>被修改为 1，所以返回一定出错.<br>第二个代码则不一样，在函数调用之初，就将<code>lr</code>寄存器使用 push 指令保存到了栈上，在最后返回的时候再将栈上的原 <code>lr </code>数据 pop 到 pc 指针中，其中<code>lr</code>的修改没有任何影响。</p>
<p>通常情况下，<code>clobber list </code>对应着寄存器的修改，所以我们只需要将寄存器的名字作为参数添加到<code>clobber list</code>中，比如<code>&quot;r0&quot; &quot;lr&quot;</code>等，有<strong>两个特殊的参数需要关注</strong>，就是 **<code>&quot;cc&quot; 和 &quot;memory&quot;</code>**。  </p>
<p><code>&quot;cc&quot; </code>对应的并非是普通寄存器，而是 CPU 的<code>状态寄存器</code>，如果某些指令将状态寄存器修改了，需要在<code>clobber list</code>中添加<code>&quot;cc&quot;</code>来声明这个事情。</p>
<p><code>&quot;memory&quot; </code>对应内存操作，这从名称也可以看出，当<code>clobber list</code>中包含<code>&quot;memory&quot;</code>时，表示嵌入汇编代码会对内存进行一些操作，gcc 生成的代码会将特定的寄存器的值写回到内存中以保证内存中的值是最新的，这样做的原因是 gcc 经常会将内存数据缓存在寄存器中，如果不及时写回，嵌入汇编代码读到的内存就是原来的值。</p>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>arm汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>buildroot教程</title>
    <url>/2024/07/23/buildroot%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-buildroot">1 引入buildroot</a><ul>
<li><a href="#1-1-xia-zai-buildroot">1.1 下载buildroot</a></li>
<li><a href="#1-2-buildroot-mu-lu-jie-gou">1.2 buildroot目录结构</a><ul>
<li><a href="#1-2-0-buildroot-yuan-mu-lu">1.2.0 buildroot源目录</a></li>
<li><a href="#1-2-1-bian-yi-chu-de-output-shu-chu-mu-lu-jie-shao">1.2.1 编译出的output输出目录介绍</a></li>
</ul>
</li>
<li><a href="#1-3-pei-zhi-target-options">1.3 配置 Target options</a></li>
<li><a href="#1-4-pei-zhi-gong-ju-lian">1.4 配置工具链</a><ul>
<li><a href="#1-4-1-nei-bu-gong-ju-lian">1.4.1 内部工具链</a></li>
<li><a href="#1-4-2-wai-bu-gong-ju-lian">1.4.2 外部工具链</a></li>
</ul>
</li>
<li><a href="#1-5-pei-zhi-build-options">1.5 配置 build options</a></li>
<li><a href="#1-6-pei-zhi-system-configuration">1.6 配置 System configuration</a></li>
<li><a href="#1-7-pei-zhi-filesystem-images">1.7 配置 Filesystem images</a></li>
<li><a href="#1-8-jin-zhi-bian-yi-linux-nei-he-he-uboot">1.8 禁止编译 Linux 内核和 uboot</a></li>
<li><a href="#1-9-pei-zhi-target-packages">1.9 配置 Target packages</a></li>
</ul>
</li>
<li><a href="#2-bian-yi-buildroot">2 编译buildroot</a><ul>
<li><a href="#2-1-make-help">2.1 make help</a></li>
<li><a href="#2-2-make-print-version">2.2 make print-version</a></li>
<li><a href="#2-3-make-menuconfig">2.3 make menuconfig</a></li>
<li><a href="#2-4-make-xxxx-defconfig">2.4 make xxxx_defconfig</a></li>
<li><a href="#2-5-make">2.5 make</a><ul>
<li><a href="#2-5-1-nfs-gua-zai-gen-wen-jian-xi-tong">2.5.1 nfs 挂载根文件系统</a></li>
</ul>
</li>
<li><a href="#2-6-make-show-targets">2.6 make show-targets</a></li>
</ul>
</li>
<li><a href="#3-buildroot-kuang-jia-yuan-li">3 buildroot框架原理</a><ul>
<li><a href="#3-1-tian-jia-zi-ji-de-ruan-jian-bao">3.1 添加自己的软件包</a><ul>
<li><a href="#3-1-1-package-config-in-zong-ru-kou-tian-jia-cai-dan">3.1.1 package&#x2F;Config.in总入口添加菜单</a></li>
<li><a href="#3-1-2-pei-zhi-app-dui-ying-de-config-in-he-mk-wen-jian">3.1.2 配置APP对应的Config.in和mk文件</a><ul>
<li><a href="#3-1-2-1-config-in">3.1.2.1 Config.in</a></li>
<li><a href="#3-1-2-2-helloworld-mk">3.1.2.2 helloworld.mk</a></li>
</ul>
</li>
<li><a href="#3-1-3-bian-xie-app-yuan-ma-he-makefile">3.1.3 编写APP源码和Makefile</a></li>
<li><a href="#3-1-4-tong-guo-make-menuconfig-xuan-zhong-app">3.1.4 通过make menuconfig选中APP</a></li>
<li><a href="#3-1-5-bian-yi-shi-yong-app">3.1.5 编译使用APP</a></li>
</ul>
</li>
<li><a href="#3-2-ru-he-chong-xin-bian-yi-ruan-jian-bao">3.2 如何重新编译软件包</a></li>
<li><a href="#3-3-shi-neng-di-san-fang-ruan-jian-he-ku">3.3 使能第三方软件和库</a><ul>
<li><a href="#3-3-1-shi-neng-yin-pin-de-alsa-ku-tao-jian">3.3.1 使能音频的ALSA库套件</a></li>
<li><a href="#3-3-2-shi-neng-busybox-tao-jian">3.3.2 使能busybox套件</a><ul>
<li><a href="#3-3-2-1-xiu-gai-pei-zhi-busybox-tao-jian">3.3.2.1 修改配置busybox套件</a></li>
<li><a href="#3-3-2-2-rebuild-busybox-tao-jian">3.3.2.2 rebuild busybox套件</a></li>
</ul>
</li>
<li><a href="#3-3-3-ps1-huan-jing-bian-liang">3.3.3 PS1环境变量</a></li>
</ul>
</li>
<li><a href="#3-4-dan-du-sheng-cheng-mu-biao-build-out-of-tree">3.4 单独生成目标（build out of tree）</a></li>
</ul>
</li>
<li><a href="#4-buildroot-guan-fang-jiao-cheng-lian-jie">4 buildroot官方教程链接</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-buildroot">1 引入buildroot</span><a href="#1-yin-ru-buildroot" class="header-anchor">#</a></h1><p>Buildroot是Linux平台上一个开源的嵌入式Linux系统<strong>自动构建框架</strong>。用来制作根文件系统，我们还要自己去移植一些第三方软件和库，比如 <code>alsa</code>、<code>iperf</code>、<code>mplayer</code> 等等。</p>
<p>那么有没有一种傻瓜式的方法或软件，它不仅包含了 <code>busybox</code> 的功能，而且里面还集成了各种软件，需要什么软件就选择什么软件，不需要我们去移植。答案肯定是有的，<code>buildroot </code>就是这样一种工具。</p>
<h2><span id="1-1-xia-zai-buildroot">1.1 下载buildroot</span><a href="#1-1-xia-zai-buildroot" class="header-anchor">#</a></h2><p>Buildroot版本每2个月，2月，5月，8月和11月发布一次。版本号的格式为YYYY.MM，例如2013.02、2014.08。</p>
<p>可以从<a href="http://buildroot.org/downloads/">http://buildroot.org/downloads/</a>获得发行包。</p>
<p>也可通过<code>github</code>仓库获取最新版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.busybox.net/buildroot</span><br></pre></td></tr></table></figure>

<p><code>buildroot</code> 和<code> uboot</code>、<code>Linux kernel </code>一样也支持图形化配置：<br><code>make menuconfig</code><br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/1.png" alt="image"></p>
<h2><span id="1-2-buildroot-mu-lu-jie-gou">1.2 buildroot目录结构</span><a href="#1-2-buildroot-mu-lu-jie-gou" class="header-anchor">#</a></h2><h3><span id="1-2-0-buildroot-yuan-mu-lu">1.2.0 buildroot源目录</span><a href="#1-2-0-buildroot-yuan-mu-lu" class="header-anchor">#</a></h3><ul>
<li><p><code>arch</code>: CPU架构相关的配置脚本</p>
</li>
<li><p><code>board</code>: 在构建系统时，board默认的boot和Linux kernel配置文件，以及一些板级相关脚本</p>
</li>
<li><p><code>boot</code>: uboot配置脚本目录</p>
</li>
<li><p><code>configs</code>: 板级配置文件，该目录下的配置文件记录着该机器平台或者方案使用的工具链，boot， kernel，各种应用软件包的配置</p>
</li>
<li><p><code>dl</code>: download的简写，下载一些开源包。第一次下载后，下次就不会再去从官网下载了，而是从dl&#x2F;目录下拿开源包，以节约时间</p>
</li>
<li><p><code>docs</code>:</p>
</li>
<li><p><code>fs</code>: 各种文件系统的自动构建脚本</p>
</li>
<li><p><code>linux</code>: 存放Linux kernel的自动构建脚本</p>
</li>
<li><p><code>package</code>: 第三方开源包的自动编译构建脚本，用来配置编译dl目录下载的开源包</p>
</li>
<li><p><code>support</code>:</p>
</li>
<li><p><code>system</code>: 存放文件系统目录的和设备节点的模板，这些模板会被拷贝到<code>output/</code>目录下，用于制作根文件系统<code>rootfs</code></p>
</li>
<li><p><code>toolchain/ </code>目录中存放着各种制作工具链的脚本</p>
</li>
</ul>
<h3><span id="1-2-1-bian-yi-chu-de-output-shu-chu-mu-lu-jie-shao">1.2.1 编译出的output输出目录介绍</span><a href="#1-2-1-bian-yi-chu-de-output-shu-chu-mu-lu-jie-shao" class="header-anchor">#</a></h3><ul>
<li><p><code>images/</code>存储所有映像（内核映像，引导加载程序和根文件系统映像）的位置。这些是您需要放在目标系统上的文件。</p>
</li>
<li><p><code>build/</code>构建所有组件的位置（包括主机上Buildroot所需的工具和针对目标编译的软件包）。该目录为每个组件包含一个子目录。</p>
</li>
<li><p><code>host/</code>包含为主机构建的工具和目标工具链。</p>
</li>
<li><p><code>staging/</code>是到内部目标工具链host&#x2F;的符号链接 </p>
</li>
<li><p><code>target/</code>它几乎包含了目标的完整根文件系统。除了设备文件<code>/dev/</code>（Buildroot无法创建它们，因为Buildroot不能以root身份运行并且不想以root身份运行）之外，所需的一切都存在。</p>
</li>
</ul>
<h2><span id="1-3-pei-zhi-target-options">1.3 配置 Target options</span><a href="#1-3-pei-zhi-target-options" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Target options</span><br><span class="line">	-&gt; Target Architecture = ARM (little endian)</span><br><span class="line">	-&gt; Target Binary Format = ELF</span><br><span class="line">	-&gt; Target Architecture Variant = cortex-A7</span><br><span class="line">	-&gt; Target ABI = EABIhf</span><br><span class="line">	-&gt; Floating point strategy = NEON/VFPv4</span><br><span class="line">	-&gt; ARM instruction <span class="built_in">set</span> = ARM</span><br></pre></td></tr></table></figure>
<p>配置输出目标选项，架构，格式，浮点策略，指令集啊。配置好后如下：<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/2.png" alt="image"></p>
<h2><span id="1-4-pei-zhi-gong-ju-lian">1.4 配置工具链</span><a href="#1-4-pei-zhi-gong-ju-lian" class="header-anchor">#</a></h2><p>Buildroot为交叉编译工具链提供了两种解决方案：</p>
<h3><span id="1-4-1-nei-bu-gong-ju-lian">1.4.1 内部工具链</span><a href="#1-4-1-nei-bu-gong-ju-lian" class="header-anchor">#</a></h3><ul>
<li>内部工具链，称为<code>Buildroot toolchain</code>。<code>buildroot </code>其实是可以自动下载交叉编译器的，但是都是从国外服务器下载的， 鉴于国内的网络环境，推荐大家设置成自己所使用的交叉编译器(也就是外部工具链)。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/3.png" alt="image"></li>
</ul>
<h3><span id="1-4-2-wai-bu-gong-ju-lian">1.4.2 外部工具链</span><a href="#1-4-2-wai-bu-gong-ju-lian" class="header-anchor">#</a></h3><ul>
<li>外部工具链<code>External toolchain</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Toolchain</span><br><span class="line">-&gt; Toolchain type = External toolchain</span><br><span class="line">-&gt; Toolchain = Custom toolchain <span class="comment">//选择用户自己的交叉编译器</span></span><br><span class="line">-&gt; Toolchain origin = Pre-installed toolchain <span class="comment">//选择预装的编译器,否则Toolchain to be downloaded and installed</span></span><br><span class="line">-&gt; Toolchain path =/usr/local/arm/gcc-linaro<span class="number">-4.9</span><span class="number">.4</span><span class="number">-2017.01</span>-x86_64_arm-linux-gnueabihf</span><br><span class="line">-&gt; Toolchain prefix = $(ARCH)-linux-gnueabihf <span class="comment">//前缀</span></span><br><span class="line">-&gt; External toolchain gcc version = <span class="number">4.9</span>.x</span><br><span class="line">-&gt; External toolchain kernel headers series = <span class="number">4.1</span>.x</span><br><span class="line">-&gt; External toolchain C library = glibc/eglibc</span><br><span class="line">-&gt; [*] Toolchain has SSP support? (NEW) <span class="comment">//选中</span></span><br><span class="line">-&gt; [*] Toolchain has RPC support? (NEW) <span class="comment">//选中</span></span><br><span class="line">-&gt; [*] Toolchain has C++ support? <span class="comment">//选中</span></span><br><span class="line">-&gt; [*] Enable MMU support (NEW) <span class="comment">//选中</span></span><br></pre></td></tr></table></figure>

<p><code>Toolchain</code>：设置为 Custom toolchain，表示使用用户自己的交叉编译器。<br><code>Toolchain origin</code>：设置为 Pre-installed toolchain，表示使用预装的交叉编译器。<br><code>Toolchain path</code>：设置自己安装的交叉编译器绝对路径！buildroot 要用到。<br><code>Toolchain prefix</code>：设置交叉编译器前缀，要根据自己实际所使用的交叉编译器来设置，比如我们使用的是 <code>arm-linux-gnueabihf-gcc</code>，因此前缀就是<code>$(ARCH)-linux-gnueabihf</code>，其中 ARCH 我们前面已经设置为了 arm。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/4.png" alt="image"></p>
<h2><span id="1-5-pei-zhi-build-options">1.5 配置 build options</span><a href="#1-5-pei-zhi-build-options" class="header-anchor">#</a></h2><p>编译选项，编译第三方插件使用静态还是动态链接等。</p>
<h2><span id="1-6-pei-zhi-system-configuration">1.6 配置 System configuration</span><a href="#1-6-pei-zhi-system-configuration" class="header-anchor">#</a></h2><p>系统配置，比如开发板名字、欢迎语、用户名、密码等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">System configuration</span><br><span class="line">-&gt; System hostname = alpha_imx6ull <span class="comment">//平台名字，自行设置</span></span><br><span class="line">-&gt; System banner = Welcome to alpha i.mx6ull <span class="comment">//欢迎语</span></span><br><span class="line">-&gt; Init system = BusyBox <span class="comment">//使用 busybox</span></span><br><span class="line">-&gt; /dev management = Dynamic using devtmpfs + mdev <span class="comment">//使用 mdev</span></span><br><span class="line">-&gt; [*] Enable root login with password (NEW) <span class="comment">//使能登录密码</span></span><br><span class="line">-&gt; Root password = <span class="number">123456</span> <span class="comment">//登录密码为 123456</span></span><br></pre></td></tr></table></figure>

<h2><span id="1-7-pei-zhi-filesystem-images">1.7 配置 Filesystem images</span><a href="#1-7-pei-zhi-filesystem-images" class="header-anchor">#</a></h2><p>根文件系统格式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-&gt; Filesystem images</span><br><span class="line">-&gt; [*] ext2/<span class="number">3</span>/<span class="number">4</span> root filesystem <span class="comment">//如果是 EMMC 或 SD 卡的话就用 ext3/ext4</span></span><br><span class="line">-&gt; ext2/<span class="number">3</span>/<span class="number">4</span> variant = ext4 <span class="comment">//选择 ext4 格式</span></span><br><span class="line">-&gt; [*] ubi image containing an ubifs root filesystem <span class="comment">//如果使用 NAND 的话就用 ubifs</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/5.png" alt="image"></p>
<h2><span id="1-8-jin-zhi-bian-yi-linux-nei-he-he-uboot">1.8 禁止编译 Linux 内核和 uboot</span><a href="#1-8-jin-zhi-bian-yi-linux-nei-he-he-uboot" class="header-anchor">#</a></h2><p>一版不建议uboot和kernel也用buildroot。buildroot 不仅仅能构建根文件系统，也可以编译 linux 内核和 uboot。</p>
<p>buildroot如果开启了uboot和Linux内核的编译，会自动下载最新的 linux 内核和 uboot，那么最新的内核和uboot会对编译器版本号有要求，可能导致编译失败。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-&gt; Kernel</span><br><span class="line">-&gt; [ ] Linux Kernel <span class="comment">//不要选择编译 Linux Kernel 选项！</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/6.png" alt="image"></p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/7.png" alt="image"></p>
<h2><span id="1-9-pei-zhi-target-packages">1.9 配置 Target packages</span><a href="#1-9-pei-zhi-target-packages" class="header-anchor">#</a></h2><p><a name="1.9配置Targetpackages"></a></p>
<p>配置要选择的第三方库或软件、比如 <code>alsa-utils、ffmpeg、iperf</code>等工具。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/8.png" alt="image"></p>
<h1><span id="2-bian-yi-buildroot">2 编译buildroot</span><a href="#2-bian-yi-buildroot" class="header-anchor">#</a></h1><h2><span id="2-1-make-help">2.1 make help</span><a href="#2-1-make-help" class="header-anchor">#</a></h2><p>可以看到<code>buildroot</code>下make的使用细节，包括对<code>package、uclibc、busybox、linux</code>以及文档生成等配置。</p>
<h2><span id="2-2-make-print-version">2.2 make print-version</span><a href="#2-2-make-print-version" class="header-anchor">#</a></h2><p>打印<code>buildroot</code>版本号</p>
<h2><span id="2-3-make-menuconfig">2.3 make menuconfig</span><a href="#2-3-make-menuconfig" class="header-anchor">#</a></h2><p>或者(<code>make linux-menuconfig</code>…):进行图形化配置</p>
<h2><span id="2-4-make-xxxx-defconfig">2.4 make xxxx_defconfig</span><a href="#2-4-make-xxxx-defconfig" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Buildroot_2020.02.x/configs$ <span class="built_in">ls</span></span><br><span class="line">100ask                                                nexbox_a95x_defconfig</span><br><span class="line">100ask_imx6ull_mini_ddr512m_systemV_core_defconfig    nitrogen6sx_defconfig</span><br><span class="line">100ask_imx6ull_mini_ddr512m_systemV_qt5_defconfig     nitrogen6x_defconfig</span><br><span class="line">100ask_imx6ull_pro_ddr512m_systemV_core_defconfig     nitrogen7_defconfig</span><br><span class="line">100ask_imx6ull_pro_ddr512m_systemV_qt5_defconfig      nitrogen8m_defconfig</span><br><span class="line">100ask_stm32mp157_pro_ddr512m_busybox_core_defconfig  odroidxu4_defconfig</span><br><span class="line">100ask_stm32mp157_pro_ddr512m_systemD_core_defconfig  olimex_a10_olinuxino_lime_defconfig</span><br><span class="line">100ask_stm32mp157_pro_ddr512m_systemD_qt5_defconfig   olimex_a13_olinuxino_defconfig</span><br><span class="line">100ask_stm32mp157_pro_ddr512m_systemV_core_defconfig  olimex_a20_olinuxino_lime2_defconfig</span><br></pre></td></tr></table></figure>

<p><code>make 100ask_imx6ull_pro_ddr512m_systemV_core_defconfig</code>即可产生<code>.config</code>和<code>output目录</code>：<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/9.png" alt="image"></p>
<h2><span id="2-5-make">2.5 make</span><a href="#2-5-make" class="header-anchor">#</a></h2><p><code>sudo make //注意不能-jxxx，来指定多核编译</code></p>
<p>make命令通常将执行以下步骤：</p>
<ol>
<li>下载源文件（根据需要）；</li>
<li>配置、构建和安装交叉编译工具链，或仅导入外部工具链；</li>
<li>配置、构建和安装选定的目标软件包；</li>
<li>构建内核映像（如果选择）；</li>
<li>构建引导加载程序映像（如果选择）；</li>
<li>以选定的格式创建一个根文件系统</li>
</ol>
<ul>
<li><code>make clean</code>：delete all build products (including build directories, host, staging and target trees, the images and the toolchain)</li>
<li><code>make distclean</code>: 等于make clean+删除配置</li>
<li><code>make show-targets</code>:显示出本次配置所要编译所有的目标</li>
<li><code>make  pkg-target</code>:单独编译某个pkg模块</li>
<li><code>make pkg-rebuild</code>:重新编译pkg</li>
<li><code>make  pkg-extrac</code>t:只下载解压pkg,不编译，pkg解压后放在 <code>output/build/</code>对应的<code>pkg-dir</code>目录下</li>
<li><code>make pkg-source</code>:只下载某pkg，然后不做任何事情</li>
<li><code>make list-defconfigs</code>:例举所有可用的defconfigs。</li>
<li><code>make xxx_menuconfig</code>:比如<code>make linux-menuconfig</code></li>
</ul>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/10.png" alt="image"></p>
<p><code>rootfs.tar</code>就是编译出的根文件系统，解压缩后就能使用。</p>
<h3><span id="2-5-1-nfs-gua-zai-gen-wen-jian-xi-tong">2.5.1 nfs 挂载根文件系统</span><a href="#2-5-1-nfs-gua-zai-gen-wen-jian-xi-tong" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=tty1 console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.253:</span></span><br><span class="line"><span class="string">/home/zuozhongkai/linux/nfs/buildrootfs rw ip=192.168.1.251:192.168.1.253:192.168.1.1:255.255.</span></span><br><span class="line"><span class="string">255.0::eth0:off&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/11.png" alt="image"></p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/12.png" alt="image"></p>
<p>可以看到能进入rootfs，但是驱动ko和第三方软件和库没有。</p>
<h2><span id="2-6-make-show-targets">2.6 make show-targets</span><a href="#2-6-make-show-targets" class="header-anchor">#</a></h2><p><code>make show-targets</code>显示出本次配置所要编译所有的目标。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/13.png" alt="image"></p>
<h1><span id="3-buildroot-kuang-jia-yuan-li">3 buildroot框架原理</span><a href="#3-buildroot-kuang-jia-yuan-li" class="header-anchor">#</a></h1><p><code>Buildroot</code>提供了函数框架和变量命令框架，采用它的框架编写的<code>app_pkg.mk</code>这种<code>Makefile</code>格式的<code>自动构建脚本</code>，将被<code>package/pkg-generic.mk</code> 这个核心脚本展开填充到<code>buildroot</code>主目录下的<code>Makefile</code>中去。</p>
<p>最后<code>make all</code>执行<code>Buildroot</code>主目录下的<code>Makefile</code>，生成你想要的image。 <code>package/pkg-generic.mk</code>中通过调用同目录下的<code>pkg-download.mk</code>、<code>pkg-utils.mk</code>文件，已经帮你自动实现了下载、解压、依赖包下载编译等一系列机械化的流程。</p>
<p>你只要需要按照格式写<code>app_pkg.mk</code>，填充下载地址，链接依赖库的名字等一些特有的构建细节即可。 总而言之，<code>Buildroot</code>本身提供构建流程的框架，开发者按照格式写脚本，提供必要的构建细节，配置整个系统，最后自动构建出你的系统。</p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/14.png"></p>
<h2><span id="3-1-tian-jia-zi-ji-de-ruan-jian-bao">3.1 添加自己的软件包</span><a href="#3-1-tian-jia-zi-ji-de-ruan-jian-bao" class="header-anchor">#</a></h2><h3><span id="3-1-1-package-x2f-config-in-zong-ru-kou-tian-jia-cai-dan">3.1.1 package&#x2F;Config.in总入口添加菜单</span><a href="#3-1-1-package-x2f-config-in-zong-ru-kou-tian-jia-cai-dan" class="header-anchor">#</a></h3><p>添加如下语句：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">menu <span class="string">&quot;myown(fuzidage) package&quot;</span></span><br><span class="line">	source <span class="string">&quot;package/helloworld/Config.in&quot;</span></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>为自己的软件包添加入口，这样在<code>make menuconfig</code>的时候就可以找到自己的软件包的<code>Config.in</code>，如果在<code>make menuconfig</code>的时候选中<code>helloworld</code>，那么<code>&quot;BR2_PACKAGE_HELLOWORLD=y&quot;</code>也会同步到<code>.config</code>中去。</p>
<h3><span id="3-1-2-pei-zhi-app-dui-ying-de-config-in-he-mk-wen-jian">3.1.2 配置APP对应的Config.in和mk文件</span><a href="#3-1-2-pei-zhi-app-dui-ying-de-config-in-he-mk-wen-jian" class="header-anchor">#</a></h3><p>在<code>package</code>中新增目录<code>helloworld</code>，并在里面添加<code>Config.in</code>和<code>helloworld.mk</code></p>
<h4><span id="3-1-2-1-config-in">3.1.2.1 Config.in</span><a href="#3-1-2-1-config-in" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">config BR2_PACKAGE_HELLOWORLD</span><br><span class="line">bool <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">help</span><br><span class="line">  This is a demo to add myown(fuzidage) package.</span><br></pre></td></tr></table></figure>

<p><code>helloworld/Config.in</code>文件，可以通过<code>make menuconfig</code>可以对<code>helloworld</code>进行选择。只有在<code>BR2_PACKAGE_HELLOWORLD=y</code>条件下，才会调用<code>helloworld.mk</code>进行编译</p>
<h4><span id="3-1-2-2-helloworld-mk">3.1.2.2 helloworld.mk</span><a href="#3-1-2-2-helloworld-mk" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># helloworld</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line">HELLOWORLD_VERSION:= 1.0.0</span><br><span class="line">HELLOWORLD_SITE:= <span class="variable">$(CURDIR)</span>/work/helloworld</span><br><span class="line">HELLOWORLD_SITE_METHOD:=local</span><br><span class="line">HELLOWORLD_INSTALL_TARGET:=YES</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> HELLOWORLD_BUILD_CMDS</span><br><span class="line">    <span class="variable">$(MAKE)</span> CC=<span class="string">&quot;<span class="variable">$(TARGET_CC)</span>&quot;</span> LD=<span class="string">&quot;<span class="variable">$(TARGET_LD)</span>&quot;</span> -C $(@D) all</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> HELLOWORLD_INSTALL_TARGET_CMDS</span><br><span class="line">    <span class="variable">$(INSTALL)</span> -D -m 0755 $(@D)/helloworld <span class="variable">$(TARGET_DIR)</span>/bin</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> HELLOWORLD_PERMISSIONS</span><br><span class="line">    /bin/helloworld f 4755 0 0 - - - - -</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"><span class="variable">$(<span class="built_in">eval</span> $(generic-package)</span>)</span><br></pre></td></tr></table></figure>

<p><code>helloworld.mk</code>包括源码位置、安装目录、权限设置等。</p>
<h3><span id="3-1-3-bian-xie-app-yuan-ma-he-makefile">3.1.3 编写APP源码和Makefile</span><a href="#3-1-3-bian-xie-app-yuan-ma-he-makefile" class="header-anchor">#</a></h3><p>创建一个<code>work/helloworld</code>目录，建立<code>hello_world.c</code>和<code>makefile</code>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">all: helloworld</span></span><br><span class="line"><span class="section">helloworld: helloworld.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o helloworld helloworld.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o</span><br><span class="line">	rm -rf helloworld</span><br><span class="line"><span class="section">install:</span></span><br><span class="line">	<span class="variable">$(INSTALL)</span> -D -m 0755 helloworld <span class="variable">$(TARGET_DIR)</span>/bin</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-4-tong-guo-make-menuconfig-xuan-zhong-app">3.1.4 通过make menuconfig选中APP</span><a href="#3-1-4-tong-guo-make-menuconfig-xuan-zhong-app" class="header-anchor">#</a></h3><p>通过上面对<code>package/Config.in</code>入口的配置, 我们可以通过<code>make menuconfig</code>，进入<code>Target packages</code>可以看见多了一个<code>&quot;myown(fuzidage) package&quot;</code>入口，选中，保存配置到<code>.config</code>。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/15.png" alt="image"></p>
<p>然后<code>make savedefconfig</code>，对helloworld的配置就会保存到对应的<code>xxx_defconfig</code>中。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/16.png" alt="image"></p>
<h3><span id="3-1-5-bian-yi-shi-yong-app">3.1.5 编译使用APP</span><a href="#3-1-5-bian-yi-shi-yong-app" class="header-anchor">#</a></h3><p>可以和整个平台一起编译APP；或者<code>make helloworld</code>单独编译。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/17.png" alt="image"></p>
<p>编译过程中，会被拷贝到<code>output/build/helloworld-1.0.0</code>文件夹中。然后生成的bin文件拷贝到<code>output/target/bin/helloworld</code>，这个文件会打包到文件系统中。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/18.png" alt="image"></p>
<p>如果需要清空相应的源文件，通过<code>make helloworld-dirclean</code>。</p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/19.png" alt="image"></p>
<h2><span id="3-2-ru-he-chong-xin-bian-yi-ruan-jian-bao">3.2 如何重新编译软件包</span><a href="#3-2-ru-he-chong-xin-bian-yi-ruan-jian-bao" class="header-anchor">#</a></h2><p>经过第一次完整编译后，如果我们需要对源码包重新配置，我们不能直接在<code>buildroot</code>上的根目录下直接make，<code>buildroot</code>是不知道你已经对源码进行重新配置，它只会将第一次编译出来的文件，再次打包成根文件系统镜像文件。</p>
<p>那么可以通过以下2种方式重新编译：</p>
<ol>
<li><p>直接删除源码包,然后<code>make all</code></p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">例如我们要重新编译helloworld，那么可以直接删除output/build/helloworld目录，</span><br><span class="line">那么当你make的时候，就会自动从dl文件夹下，解压缩源码包，并重新安装。这种效率偏低</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行<code>xxx-rebuild</code>,然后<code>make all</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">也是以helloworld为例子，我们直接输入make helloworld-rebuild，</span><br><span class="line">即可对build/helloworld/目录进行重新编译，然后还要进行make all(或者make world 或者 make target-post-image)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果要重新配置编译安装：</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make &lt;package&gt;-reconfigure; make all</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="3-3-shi-neng-di-san-fang-ruan-jian-he-ku">3.3 使能第三方软件和库</span><a href="#3-3-shi-neng-di-san-fang-ruan-jian-he-ku" class="header-anchor">#</a></h2><p>前面 <a href="#1.9%E9%85%8D%E7%BD%AETargetpackages">1.9配置Targetpackages</a> 有引入介绍。</p>
<h3><span id="3-3-1-shi-neng-yin-pin-de-alsa-ku-tao-jian">3.3.1 使能音频的ALSA库套件</span><a href="#3-3-1-shi-neng-yin-pin-de-alsa-ku-tao-jian" class="header-anchor">#</a></h3><p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/20.png" alt="image"></p>
<h3><span id="3-3-2-shi-neng-busybox-tao-jian">3.3.2 使能busybox套件</span><a href="#3-3-2-shi-neng-busybox-tao-jian" class="header-anchor">#</a></h3><p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/21.png" alt="image"></p>
<p>使能后，<code>buildroot</code> 会自动下载 <code>busybox</code> 压缩包，<code>buildroot </code>下载的源码压缩包都存 放在<code>/dl </code>目录下，在<code> dl</code> 目录下就有一个叫做<code>“busybox”</code>的文件夹，此目录下保存着 busybox 压 缩包:<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/22.png" alt="image"></p>
<p><code>make all</code>编译完后, <code>buildroot</code> 将所有解压缩后的软件保存在<code>/output/build </code>软件中，我们可以找到<code>/output/build/busybox-1.29.3</code> 这个文件夹，此文件夹就是解压后的 busybox 源码:<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/23.png" alt="image"><br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/24.png" alt="image"></p>
<h4><span id="3-3-2-1-xiu-gai-pei-zhi-busybox-tao-jian">3.3.2.1 修改配置busybox套件</span><a href="#3-3-2-1-xiu-gai-pei-zhi-busybox-tao-jian" class="header-anchor">#</a></h4><p>修改busybox源码就直接在<code>/output/build/busybox-1.29.3</code>修改。</p>
<p><code>make busybox-menuconfig</code>可以配置busybox套件选择哪些功能：<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/25.png" alt="image"></p>
<h4><span id="3-3-2-2-rebuild-busybox-tao-jian">3.3.2.2 rebuild busybox套件</span><a href="#3-3-2-2-rebuild-busybox-tao-jian" class="header-anchor">#</a></h4><p><code>make busybox</code>或者<code>make busybox-rebuild</code>即可重新编译。</p>
<p>编译完后还要<code>make</code>或者<code>make target-post-image</code>对其进行打包进根文件系统。</p>
<h3><span id="3-3-3-ps1-huan-jing-bian-liang">3.3.3 PS1环境变量</span><a href="#3-3-3-ps1-huan-jing-bian-liang" class="header-anchor">#</a></h3><p>我们构建的根文件系统启动以后会发现， 输入命令的时候命令行前面一直都是<code>“#”</code>，如果我们进入到某个目录的话前面并不会显示当前目录路径:<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/26.png" alt="image"></p>
<p>PS1 用于设置命令提示符格式，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1 = ‘命令列表’</span><br><span class="line">命令列表中可选的参数如下：</span><br><span class="line">\! 显示该命令的历史记录编号。</span><br><span class="line"> \<span class="comment"># 显示当前命令的命令编号。</span></span><br><span class="line"> \$ 显示$符作为提示符，如果用户是 root 的话，则显示<span class="comment">#号。</span></span><br><span class="line"> \\ 显示反斜杠。</span><br><span class="line"> \d 显示当前日期。</span><br><span class="line"> \h 显示主机名。</span><br><span class="line"> \n 打印新行。</span><br><span class="line"> \nnn 显示 nnn 的八进制值。</span><br><span class="line"> \s 显示当前运行的 shell 的名字。</span><br><span class="line"> \t 显示当前时间。</span><br><span class="line"> \u 显示当前用户的用户名。</span><br><span class="line"> \W 显示当前工作目录的名字。</span><br><span class="line"> \w 显示当前工作目录的路径</span><br></pre></td></tr></table></figure>

<p>我们打开&#x2F;etc&#x2F;profie，修改成如下：<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/27.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&#x27;[\u@\h]:\w$:&#x27;</span></span><br><span class="line"><span class="built_in">export</span> PS1</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-dan-du-sheng-cheng-mu-biao-build-out-of-tree">3.4 单独生成目标（build out of tree）</span><a href="#3-4-dan-du-sheng-cheng-mu-biao-build-out-of-tree" class="header-anchor">#</a></h2><p><code>make O=/home/XXX/output</code></p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/28.png"></p>
<h1><span id="4-buildroot-guan-fang-jiao-cheng-lian-jie">4 buildroot官方教程链接</span><a href="#4-buildroot-guan-fang-jiao-cheng-lian-jie" class="header-anchor">#</a></h1><p><a href="https://bootlin.com/doc/training/buildroot/">buildroot官方训练教程</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2147438">buildroot中文手册</a></p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/29.png" alt="image-20240814004339288"></p>
<p>可以下载正点原子翻译的中文版buildroot手册。</p>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-mmap机制</title>
    <url>/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-mmap">1 引入mmap</a><ul>
<li><a href="#1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</a><ul>
<li><a href="#1-1-1-yin-ru-mmu">1.1.1 引入MMU</a></li>
<li><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</a><ul>
<li><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</a><ul>
<li><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ye-biao-ying-she">3 页表映射</a><ul>
<li><a href="#3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</a></li>
<li><a href="#3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</a></li>
</ul>
</li>
<li><a href="#4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</a><ul>
<li><a href="#4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</a></li>
<li><a href="#4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</a><ul>
<li><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</a><ul>
<li><a href="#4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-mmap">1  引入mmap</span><a href="#1-yin-ru-mmap" class="header-anchor">#</a></h1><p>应用程序和驱动程序之间传递数据时，可以通过 read、write 函数进行, 用户态和内核态的数据交互一般用<code>copy_from_user</code>,<code>copy_to_user</code>。这种方式在数据量比较小时没什么问题；但是数据量比较大时效率就太低了。比如更新 LCD 显示时，如果每次都让 APP 传递一帧数据给内核，假设 LCD 采用<code>1024x600x32 bpp </code>的格式，一帧数据就有<code>1024x600x32/8=2.3MB</code> 左右,而且一般为了显示动态画面，LDC输出fps要求是<code>60fps or 30 fps</code>，那么一秒数据量为<code>30x2.3 = 70M</code>左右，显然<code>copy_from_user</code>，<code>copy_to_user</code>的方式不再适合。<br>改进的方法就是让程序可以直接读写驱动程序中的 buffer，这可以通过mmap 实现(memory map)，把内核的 buffer 映射到用户态，让 APP 在用户态直接读写。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<h2><span id="1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</span><a href="#1-1-nei-cun-ying-she-xian-xiang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;number&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a&#x27;s address = 0x%lx, a&#x27;s value = %d\n&quot;</span>, &amp;a, a);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 PC 上如下编译(必须静态编译)：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c -staitc</span><br></pre></td></tr></table></figure>
<p>分别后台执行 test 程序 2 次。最后执行 ps，可以看到这 2 个程序同时存在，这 2 个程序里 a 变量的地址相同，但是值不同。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/3.png" alt="image"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2 个程序同时运行，它们的变量a的地址都是一样的：0x6bc3a0；</span><br><span class="line">2 个程序同时运行，它们的变量a的值是不一样的，一个是 111，另一个是 123。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-yin-ru-mmu">1.1.1 引入MMU</span><a href="#1-1-1-yin-ru-mmu" class="header-anchor">#</a></h3><p>来分析一下：<br>2个程序同时在内存中运行，它们的值不一样，所以变量 a 的物理内存地址肯定不同（2个变量存放不是同一个地方）；<br>但是打印出来的变量 a 的地址却是一样的。怎么回事？<br>这里要引入<strong>虚拟地址</strong>的概念：CPU 发出的地址是虚拟地址，它经过<code>MMU(Memory Manage Unit，内存管理单元)</code>映射到物理地址上，对于不同进程的同一个虚拟地址，MMU 会把它们映射到不同的物理地址。<br>总结:虽然虚拟地址一样，但物理地址不一样，这个是mmu的功劳，将同一虚拟地址映射到不同物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">当前运行的是 app1 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr1，用 paddr1 去访问内存。</span><br><span class="line">当前运行的是 app2 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr2，用 paddr2 去访问内存。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</span><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian" class="header-anchor">#</a></h3><p>MMU 负责把虚拟地址映射为物理地址，虚拟地址映射到哪个物理地址去？可以执行<code>ps</code>命令查看进程 ID，然后执行<code>“cat /proc/[PID]/maps”</code>得到虚拟地址空间映射关系。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00400000</span><span class="number">-004b</span>6000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>6000<span class="number">-006b</span>c000 rw-p <span class="number">000b</span>6000 <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>c000<span class="number">-006b</span>d000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">021</span>c8000<span class="number">-021</span>eb000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</span><br><span class="line"><span class="number">7f</span>fe18738000<span class="number">-7f</span>fe18759000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>fe187f9000<span class="number">-7f</span>fe187fc000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vvar]</span><br><span class="line"><span class="number">7f</span>fe187fc000<span class="number">-7f</span>fe187fd000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>第一行地址范围显示权限为可读可执行，表示该程序<code>代码段（.text）</code><br>第二行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code><br>第三行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code>刚才变量a地址就在这段地址范围内<br>第四行地址范围是<code>堆空间（.heap段）</code>,malloc的内存就会处于这段<br>第5行地址范围是<code>栈空间（.stack段）</code>,局部变量处于这段<br>p表示<code>private</code>, s表示<code>share</code>, 再来看一个使用动态库的进程，比如bash进程：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/6.png" alt="image"></p>
<h1><span id="2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</span><a href="#2-mmap-nei-he-tai-de-miao-shu" class="header-anchor">#</a></h1><h2><span id="2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</span><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct" class="header-anchor">#</a></h2><p>每一个 APP对应了很多虚拟地址空间，比如栈空间，堆空间，数据段，代码段等,也叫做进程地址空间<code>（mm_strcut）</code>。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/7.png" alt="image"></p>
<p>因此在内核里都有一个 tast_struct，这个结构体中保存有内存信息：mm_struct。而虚拟地址、物理地址的映射关系保存在页目录表中：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 每个 APP 在内核中都有一个 task_struct 结构体，它用来描述一个进程；</span><br><span class="line"><span class="number">2.</span> 每个 APP 都要占据内存，在 task_struct 中用 mm_struct 来管理进程占用的内存；</span><br><span class="line"><span class="number">3.</span> 内存有虚拟地址、物理地址，mm_struct 中用 mmap 来描述虚拟地址，</span><br><span class="line">用 pgd 来描述对应的物理地址。(注意：pgd，Page Global Directory，页目录)</span><br><span class="line"><span class="number">4.</span> 每个 APP 都有一系列的 VMA：virtual memory，即mmap会指向vm_area_struct, </span><br><span class="line">比如 APP 含有代码段、数据段、BSS 段、栈等等，还有共享库。这些单元会保存在内存里，</span><br><span class="line">它们的地址空间不同，权限不同(代码段是只读的可运行的、数据段可读可写)，内核用一系列的 vm_area_struct 来描述它们。</span><br><span class="line"><span class="number">6.</span> vm_area_struct 中的 vm_start、vm_end 是虚拟地址。</span><br><span class="line"><span class="number">7.</span> vm_area_struct 中虚拟地址如何映射到物理地址去？ 每一个 APP 的虚拟地址可能相同，</span><br><span class="line">物理地址不相同，这些对应关系保存在 pgd 中。</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</span><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu" class="header-anchor">#</a></h3><p>每个进程有一个<code>task_struct</code>和一个<code>mm_struct</code>, 其中<code>mm_struct</code>中的mmap对应<code>vm_area_struct</code>虚拟内存区域：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/9.png" alt="image-20240816222839173"></p>
<p>可以看到<code>mm_struct</code>每一段都对应一块<code>vm_area_struct</code>。</p>
<h1><span id="3-ye-biao-ying-she">3 页表映射</span><a href="#3-ye-biao-ying-she" class="header-anchor">#</a></h1><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/10.png" alt="image"></p>
<p>页表是存在<code>ddr</code>中的一段连续地址空间，页表里面存放了要映射的物理地址集合，页表分为很多个页表项。<br>ARM 架构支持一级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址可以找到第 1 个页表，从第 1 个页表里就可以知道这个虚拟地址对应的物理地址。一级页表里地址映射的最小单位是 1M。<br>ARM 架构还支持二级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址先找到第 1 个页表，从第 1 个页表里就可以知道第 2 级页表在哪里；再取出第 2 级页表，从第 2 个页表里才能确定这个虚拟地址对应的物理地址。二级页表地址映射的最小单位有 4K、1K，Linux 使用 4K。<br><strong>一级页表项里的内容，决定了它是指向一块物理内存，还是指问二级页表</strong>，一个页表项格式如下图：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/11.png" alt="image"></p>
<h2><span id="3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</span><a href="#3-1-yi-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>arm32系统中，一个页表项占4个byte, 32bit,它分为一级页表项和二级页表项，通过<code>bit[1:0]</code>区分，一级页表项保存有物理地址，用<code>bit[31:20]</code> 共12位表示段基地址，有1M物理内存。比如cpu发出虚拟地址<code>0x12345678</code>, MMU通过<code>bit[31:20]</code>发现为0x123,也就是从第0x123个页表项中找到<code>Section Base Address</code>, 比如第0个页表项中物理及地址为<code>0x8000,0000</code>， 那么第0x123个页表项目物理基地址就是<code>0x123 * 1M + 0x8000,0000</code>,也就是<code>0x9230,0000</code>, 因为每一个一级页表项物理内存大小为1M.<br>段内偏移是 <code>0x45678</code>，那么最终通过一级页表映射最终映射到物理地址就为<code>0x0x9230,0000 + 0x45678</code>,也就是<code>0x9234,5678</code>。<br><code>Section Base Address</code>的数量为多少呢？一共12bit，也就是4096个，每一个1级页表项大小为1M, 因此总共可表示4G。对于 32 位的系统，虚拟地址空间有 4G，<code>4G/1M=4096</code>。所以一级页表要映射整个 4G 空间的话，刚好需要 4096 个页表项。<br>所以 CPU 要访问虚拟地址 0x12345678 时，实际上访问的是 0x81045678 的物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/12.png" alt="image"></p>
<h2><span id="3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</span><a href="#3-2-er-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>一级页表项每项有1M空间, 一级页表映射时是吧虚拟地址的1M映射到物理地址的1M连续空间，但有时我们的程序没有那么大，显然用1M太浪费空间。 那么引入二级页表映射来映射更小的块，对于二级页表，每一个页可以是1K, 4K，64K， Linux系统一般使用4K, 对应<code>Small Page</code>, 64K对应的是大页（<code>Large Page</code>）, 1K对应的是Tine Page(一般很少用)。<br><strong>二级页表映射过程：</strong><br>首先设置好一级页表、二级页表，并且把一级页表的首地址告诉 MMU,比如<code>0x8000,0000</code>。<br>二级页表首先也是要经过一级页表映射，用<code>bit[31:20] </code>共12位表示段基地址，找到对应的一级页表项比如<code>0x123</code>项，通过这一项里面的<code>bit[1:0]</code>发现它是一个二级页表项（注意不再是取出1M的物理地址），然后根据二级页表项的<code>bit[19：12]</code>这8位得到二级页表是得到索引0x45,表示为第0x45个二级页表项。从这个二级页表项中取出里面的物理地址，比如为addr。<br>二级页表格式如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/13.png" alt="image"></p>
<p>可以看到里面含有<code>64k(Large Page) 4k(Small Page）</code>或 <code>1K(Tine) </code>物理空间的基地址<code> page base addr</code>，假设从第0x45个二级页表项取出的物理地址为<code>0x8188,9000</code>。然后<code>offset=0x678</code>, 那么它跟 <code>vaddr[11:0] </code>组 合 得 到 物 理 地 址 ：<code> 0x8188,9000 + 0x678 = 0x8188,9678</code>，所以 CPU 要访问虚拟地址 <code>0x1234,5678 </code>时，实际上访问的是<code>0x8188,9678</code>的物理地址, 根据<code>bit[1:0]</code>得到映射的大小为<code>4K(linux Small Page)</code>。假如这里不使用二级页表映射，理论去计算对应物理地址则会是<code>0x8180,0000</code>往后1M内存，显然浪费了。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/14.png" alt="image"></p>
<h1><span id="4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</span><a href="#4-mmap-han-shu-diao-yong-guo-cheng" class="header-anchor">#</a></h1><p>从上面内存映射的过程可以知道，要给 APP 新开劈一块虚拟内存，并且让它指向某块内核buffer，我们要做这些事：</p>
<ol>
<li>得到一个 <code>vm_area_struct</code>，它表示 APP 的一块虚拟内存空间：<br> 很 幸 运 ， APP 调 用 mmap 系 统 函 数 时 ， 内 核 就 帮 我 们 构 造 了 一 个<code>vm_area_stuct </code>结构体。里面含有虚拟地址的地址范围、权限，属性。</li>
<li>确定物理地址：<br> 你想映射某个内核 buffer，你需要得到它的物理地址，这得由你提供。</li>
<li>给<code>vm_area_struct</code>和物理地址建立映射关系</li>
</ol>
<p>比如APP 里调用 mmap 时，导致的内核相关函数调用过程如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/15.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>可以传入一个addr虚拟地址，需要用户自己malloc。也可以将addr设置为NULL, 让linux内核帮你产生一段内存映射，返回虚拟地址给你。<br>内核得到可用的虚拟地址后会分配一个<code>vm_area_struct</code>, 用来描述一块虚拟地址空间，里面有这块虚拟地址空间的起始地址、结束地址、权限信息。最后会调用驱动里面的mmap函数，参数为刚刚分配的<code>vm_area_sruct</code>。<br>那么需要再驱动程序实现mmap函数，主要包括：</p>
<ol>
<li>提供物理地址</li>
<li>设置属性，<code>cache，buffer</code></li>
<li>给<code>vm_area_stuct</code>和物理地址建立映射</li>
</ol>
<h2><span id="4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</span><a href="#4-1-vm-area-struct-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/16.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct describes a virtual memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task. A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Access permissions of this VMA.</span></span><br><span class="line"><span class="comment">	 * See vmf_insert_mixed_prot() for discussion.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br></pre></td></tr></table></figure>

<p>它表示的是一块连续的虚拟地址空间区域，给进程使用的，地址空间范围是<code>0~3G</code>，对应的物理页面都可以是不连续的.<br>主要成员有起始地址、结束地址、权限信息，属性信息。<br><code>vm_flags:</code>可读，可写，可执行权限，私有，共享等权限</p>
<p>常用<strong>vm_flags</strong>访问权限的取值说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VM_READ：可读</span><br><span class="line">VM_WRITE：可写</span><br><span class="line">VM_EXEC：可执行</span><br><span class="line">VM_SHARD：可多进程之间共享</span><br><span class="line">VM_IO：可映射至设备 IO 空间</span><br><span class="line">VM_RESERVED：内存区域不可被换出</span><br><span class="line">VM_SEQ_READ：内存区域可能被顺序访问</span><br><span class="line">VM_RAND_READ：内存区域可能被随机访问</span><br></pre></td></tr></table></figure>

<p><code>vm_pgoff:</code>是否使用cache? 是否使用buffer？</p>
<h2><span id="4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</span><a href="#4-2-yin-ru-cache-he-buffer" class="header-anchor">#</a></h2><p>使用<code> mmap</code> 时，需要有<code>cache、 buffer</code>的知识。下图是 CPU 和内存之间的关系，有<code> cache、 buffer</code>(写缓冲器)。 Cache 是一块高速内存；写缓冲器相当于一个 FIFO，可以把多个写操作集合起来一次写入内存。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/17.png" alt="image"></p>
<h3><span id="4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</span><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing" class="header-anchor">#</a></h3><p>当程序运行时有<code>“局部性原理”</code>，这又分为<strong>时间局部性、空间局部性</strong>。举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间局部性：</strong><br>a++在很短的时间内被重复写了100次，与此同时i也被访问了100次，像这种在某个时间点访问了存储器的特定位置，反复地访问这个位置被称为<code>“时间局部性”</code>。<br><strong>空间局部性：</strong><br>访问变量a的同时也访问了它周围临近变量i, 像这种访问了存储器的特定位置，很可能在不久的将来访问它附近的位置被称作<code>”空间局部性“</code>， 那么为什么不用<code>buffer or cache</code>把它一次性访问完呢？<br>根据<code>“局部性原理”</code>，引入 <code>cache</code>和<code>buffer</code>。</p>
<h4><span id="4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</span><a href="#4-2-1-1-cache-miss-he-cache-hit" class="header-anchor">#</a></h4><p>读数据：</p>
<ol>
<li>要读取内存指定addr处的数据时，先看看cache中有没有addr的数据，如果有则直接从cache返回数据，这一过程叫做<code>cache命中(cache hit)</code>。</li>
<li>假如cache中没有该addr的数据，触发<code>cache缺失 (cache miss)</code>, 那么会从addr读一段连续数据进去，注意：它不是仅仅读入一个数据，而是读入一行数据(cache line)。</li>
<li>那么CPU 短时间内很可能会再次用到甚至多次用到这个 addr 的数据或者周围临近的数据，那么就可以直接从cache快速的获取数据。这样<strong>弥补了时间和空间上的”局部性“</strong>。</li>
</ol>
<p>写数据：</p>
<ol>
<li>CPU 写数据时，可以<strong>直接写内存</strong>，这很慢；也可以先把数据<strong>写入 cache</strong>，这很快。</li>
<li>cache 中的数据终究是要写入内存的啊，这有 2 种写策略:<br> <strong>2.1 写通(write through)：</strong><br> ◆ 数据要同时写入 cache 和内存，所以 cache 和内存中的数据保持一致，但是它的效率很低。能改进吗？可以！使用“<strong>写缓冲器</strong>”：cache 大哥，你把数据给我就可以了，我来慢慢写，保证帮你写完。<br> ◆ 有些写缓冲器有“<strong>写合并</strong>”的功能，比如 CPU 执行了 4 条写指令：写第 0、 1、 2、 3 个字节，每次写 1 字节；写缓冲器会把这 4 个写操作合并成一个写操作：写 word。对于内存来说，这没什么差别，但是对于硬件寄存器，这就有可能导致问题。<br> ◆ 所以对于寄存器操作，不会启动 buffer 功能；对于内存操作，比如 LCD 的显存，可以启用 buffer 功能(cpu直接用<code>write buffer</code>进行操作<code>frame buffer内存</code>)<br> <strong>2.2 写回(write back)：</strong><br> ◆ 新数据只是写入<code> cache</code>，不会立刻写入内存， <code>cache </code>和内存中的数据并不一致。<br> ◆ 新数据写入 cache 时，这一行 cache 被标为<code>“脏” (dirty)</code>；当cache 不够用时，才需要把脏的数据写入内存。</li>
</ol>
<p>对内存或者变量进行写操作可以使用写回功能，可以大幅提高效率。但是要注意 cache 和内存中的数据很可能不一致。这在很多时间要小心处理：比如 CPU 产生了新数据， DMA 把数据从内存搬到网卡，这时候就要 CPU 执行命令先把新数据从 cache 刷到内存。反过来也是一样的， DMA 从网卡得过了新数据存在内存里， CPU 读数据之前先把 cache中的数据丢弃。下图举例说明哪些硬件可以用或者不能用cache：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/18.png" alt="image"></p>
<p>是否使用 cache、是否使用 buffer，就有 4 种组合(位于<code>arch\arm\include\asm\pgtable-2level.h</code>：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/19.png" alt="image"></p>
<p>以s3c2440芯片为例，上面 4 种组合对应下表中的各项：</p>
<table>
<thead>
<tr>
<th>是否启用 cache</th>
<th>是否启用 buffer</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td><code>Non-cached, non-buffered (NCNB)</code>读、写都直达外设硬件</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td><code>Non-cached buffered (NCB)</code>读、写都直达外设硬件；写操作通过 buffer 实现， CPU 不等待操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td><code>Cached, write-through mode (WT)</code>，写通    ①读：<code>cache hit</code>时从 cahce 读数据； <code>cache miss </code>时已入一行数据到 cache；②写：通过 buffer 实现， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td><code>Cached, write-back mode (WB)</code>，写回    ①读：<code> cache hit</code> 时从 cahce 读数据；<code>cache miss</code>时已入一行数据到 cache；②写：通过 buffer 实现， <code>cache hit</code> 时新数据不会到达硬件，而是在 cahce 中被标为 “脏”； <code>cache miss</code> 时，通过 buffer写入硬件， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
</tbody></table>
<p>◼ 第 1 种是不使用 cache 也不使用 buffer，读写时都直达硬件，这适合寄存器的读写。<br>◼ 第 2 种是不使用 cache 但是使用 buffer，写数据时会用 buffer 进行优化，可能会有<code>“写合并”</code>，这适合显存的操作。因为对显存很少有读操作，基本都是写操作，而写操作即使被“合并”也没有关系。<br>◼ 第 3 种是使用 cache 不使用 buffer，就是<code>“ write through”</code>，适用于只读设备：在读数据时用 cache 加速，基本不需要写。<br>◼ 第 4 种是既使用 cache 又使用 buffer，适合一般的内存读写</p>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-mmap驱动应用实例</title>
    <url>/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mmap-qu-dong-yao-zuo-de-shi-qing">1 mmap驱动要做的事情</a></li>
<li><a href="#2-mmap-qu-dong-dai-ma-shi-li-fen-xi">2 mmap驱动代码示例分析</a></li>
<li><a href="#3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi">3 mmap应用代码示例与分析</a><ul>
<li><a href="#3-1-gong-xiang-ying-she-yu-si-you-ying-she">3.1 共享映射与私有映射</a><ul>
<li><a href="#3-1-1-copy-on-write">3.1.1 copy on write</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-mmap-qu-dong-yao-zuo-de-shi-qing">1 mmap驱动要做的事情</span><a href="#1-mmap-qu-dong-yao-zuo-de-shi-qing" class="header-anchor">#</a></h1><ol>
<li>确定物理地址</li>
<li>确定属性：是否使用 <code>cache、 buffer</code></li>
<li>建立映射关系</li>
</ol>
<p>参考 Linux 驱动源文件代码：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/2.png" alt="image"><br>我们要验证mmap功能，在驱动程序中申请一个 8K 的 buffer，让 APP 通过 mmap 能直接访问。</p>
<h1><span id="2-mmap-qu-dong-dai-ma-shi-li-fen-xi">2 mmap驱动代码示例分析</span><a href="#2-mmap-qu-dong-dai-ma-shi-li-fen-xi" class="header-anchor">#</a></h1><p>linux内核中常用的内存申请方式：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>kmalloc</td>
<td>分配到的内存物理地址是连续的</td>
</tr>
<tr>
<td>kzalloc</td>
<td>分配到的内存物理地址是连续的，内容清 0</td>
</tr>
<tr>
<td>vmalloc</td>
<td>分配到的内存物理地址不保证是连续的</td>
</tr>
<tr>
<td>vzalloc</td>
<td>vzalloc 分配到的内存物理地址不保证是连续的，内容清 0</td>
</tr>
</tbody></table>
<p>我们在 mmap 时应该使用 kmalloc 或 kzalloc，这样得到的内存物理地址是连续的，mmap后 APP 才可以使用同一个基地址去访问这块内存。 (如果物理地址不连续，就要执行多次 mmap 了)</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/pgtable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *kernel_buf;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bufsiz = <span class="number">1024</span>*<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = copy_to_user(buf, kernel_buf, MIN(bufsiz, size));</span><br><span class="line">	<span class="keyword">return</span> MIN(bufsiz, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = copy_from_user(kernel_buf, buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">	<span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获得物理地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line">	<span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">	vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line">	<span class="comment">/* map */</span></span><br><span class="line">	<span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT,</span><br><span class="line">			    vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;mmap remap_pfn_range failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = hello_drv_open,</span><br><span class="line">	.read    = hello_drv_read,</span><br><span class="line">	.write   = hello_drv_write,</span><br><span class="line">	.release = hello_drv_close,</span><br><span class="line">	.mmap    = hello_drv_mmap,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	kernel_buf = kmalloc(bufsiz, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">strcpy</span>(kernel_buf, <span class="string">&quot;old&quot;</span>);</span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);</span><br><span class="line">	hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">	err = PTR_ERR(hello_class);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(hello_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	kfree(kernel_buf);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>分析：init时，驱动使用kmalloc分配8K空间(物理地址连续), 初始化为<code>”old“</code>字符串。实现read，write函数。mmap函数中：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获得物理地址 */</span></span><br><span class="line">unsigned <span class="built_in">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line"><span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line"><span class="comment">/*映射*/</span></span><br><span class="line">remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT, vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/3.png" alt="image"></p>
<p><code>pgprot_writecombine</code>设置属性为<code>Non-cached buffered (NCB)</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;asm/pgtable.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_noncached(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_DEVICE_nGnRnE) | PTE_PXN | PTE_UXN)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_writecombine(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_NORMAL_NC) | PTE_PXN | PTE_UXN)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_device(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_DEVICE_nGnRE) | PTE_PXN | PTE_UXN)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/4.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/5.png" alt="image"></p>
<p>注意：<code>remap_pfn_range</code> 中，<code>pfn </code>的意思是<code>“ Page Frame Number”</code>。在 Linux 中，整个物理地址空间可以分为第 0 页、第 1 页、第 2 页，诸如此类，这就是 pfn。假设每页大小是 4K，那么给定物理地址<code> phy</code>，它的<code> pfn = phy / 4096 = phy &gt;&gt; 12</code>。内核的 page 一般是 4K，但是也可以配置内核修改 page的大小。所以为了通用， <code>pfn = phy &gt;&gt; PAGE_SHIFT</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们的buf不是用<code>kmalloc</code>, 而是<code>vmalloc</code>，那么需要映射多次，每次映射一个<code>page 4k</code>.(MMU过程中内存以page为单位作为连续内存单元)<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/6.png" alt="image"></p>
<h1><span id="3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi">3 mmap应用代码示例与分析</span><a href="#3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi" class="header-anchor">#</a></h1><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./hello_drv_test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *buf;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">/* 1. 打开文件 */</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 2. mmap </span></span><br><span class="line"><span class="comment">	 * MAP_SHARED  : 多个APP都调用mmap映射同一块内存时, 对内存的修改大家都可以看到。</span></span><br><span class="line"><span class="comment">	 *               就是说多个APP、驱动程序实际上访问的都是同一块内存</span></span><br><span class="line"><span class="comment">	 * MAP_PRIVATE : 创建一个copy on write的私有映射。</span></span><br><span class="line"><span class="comment">	 *               当APP对该内存进行修改时，其他程序是看不到这些修改的。</span></span><br><span class="line"><span class="comment">	 *               就是当APP写内存时, 内核会先创建一个拷贝给这个APP, </span></span><br><span class="line"><span class="comment">	 *               这个拷贝是这个APP私有的, 其他APP、驱动无法访问。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	buf =  mmap(<span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">8</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (buf == MAP_FAILED)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not mmap file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mmap address = 0x%x\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;buf origin data = %s\n&quot;</span>, buf); <span class="comment">/* old */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. write */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buf, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4. read &amp; compare */</span></span><br><span class="line">	<span class="comment">/* 对于MAP_SHARED映射:  str = &quot;new&quot; </span></span><br><span class="line"><span class="comment">	 * 对于MAP_PRIVATE映射: str = &quot;old&quot; </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	read(fd, str, <span class="number">1024</span>);  </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, str) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_SHARED映射，APP写的数据驱动可见</span></span><br><span class="line"><span class="comment">		 * APP和驱动访问的是同一个内存块</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare ok!\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_PRIVATE映射，APP写数据时, 是写入原来内存块的&quot;拷贝&quot;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare err!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str = %s!\n&quot;</span>, str);  <span class="comment">/* old */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buf = %s!\n&quot;</span>, buf);  <span class="comment">/* new */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		sleep(<span class="number">10</span>);  <span class="comment">/* cat /proc/pid/maps */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	munmap(buf, <span class="number">1024</span>*<span class="number">8</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-1-gong-xiang-ying-she-yu-si-you-ying-she">3.1 共享映射与私有映射</span><a href="#3-1-gong-xiang-ying-she-yu-si-you-ying-she" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MAP_SHARED  : 多个APP都调用mmap映射同一块内存时, 对内存的修改大家都可以看到。</span></span><br><span class="line"><span class="comment"> *               就是说多个APP、驱动程序实际上访问的都是同一块内存</span></span><br><span class="line"><span class="comment"> * MAP_PRIVATE : 创建一个copy on write的私有映射。</span></span><br><span class="line"><span class="comment"> *               当APP对该内存进行修改时，其他程序是看不到这些修改的。</span></span><br><span class="line"><span class="comment"> *               就是当APP写内存时, 内核会先创建一个拷贝给这个APP, </span></span><br><span class="line"><span class="comment"> *               这个拷贝是这个APP私有的, 其他APP、驱动无法访问。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">   <span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">			  <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-copy-on-write">3.1.1 copy on write</span><a href="#3-1-1-copy-on-write" class="header-anchor">#</a></h3><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/7.png" alt="image"></p>
<pre><code>① mmap时使用MAP_PRIVATE
②③ 当写入mmap内存时，会copy这块内存
④写入新数据，会将数据写入新copy的内存
⑤读数据还是从旧的那块映射内存去读，因此这时会与buf中的数据不一样
</code></pre>
<p>根据上面的mmap应用示例来分析和验证<code>MAP_SHARED</code>和<code>MAP_PRIVATE</code>的差异：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/8.png" alt="image"><br>先用<code>MAP_PRIVATE</code>，执行测试程序：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/9.png" alt="image"><br>再用<code>MAP_SHARED</code>，执行测试程序：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/10.png" alt="image"></p>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-misc杂项设备</title>
    <url>/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-misc-device">1 引入misc device</a><ul>
<li><a href="#1-1-chuan-tong-cdev-fang-shi">1.1 传统cdev方式</a></li>
<li><a href="#1-2-misc-device-fang-shi">1.2 misc device方式</a></li>
</ul>
</li>
<li><a href="#2-misc-za-xiang-she-bei-jie-xi">2 misc杂项设备解析</a><ul>
<li><a href="#2-1-misc-init-guo-cheng">2.1 misc_init过程</a></li>
<li><a href="#2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng">2.2 misc设备注册misc_register过程</a></li>
<li><a href="#2-3-misc-she-bei-xie-zai-guo-cheng">2.3 misc设备卸载过程</a></li>
<li><a href="#2-4-misc-she-bei-da-kai-guo-cheng">2.4 misc设备打开过程</a></li>
</ul>
</li>
<li><a href="#3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi">3 如何从fops中获取模块设备信息</a><ul>
<li><a href="#3-1-yin-ru">3.1 引入</a><ul>
<li><a href="#3-1-1-fang-fa-1-dui-yu-misc-she-bei">3.1.1 方法1：（对于misc设备）</a></li>
<li><a href="#3-1-2-fang-fa-2-dui-yu-cdev-she-bei">3.1.2 方法2：（对于cdev设备）</a></li>
<li><a href="#3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi">3.1.3方法3：xxx_open中保存设备信息</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-misc-device">1 引入misc device</span><a href="#1-yin-ru-misc-device" class="header-anchor">#</a></h1><h2><span id="1-1-chuan-tong-cdev-fang-shi">1.1 传统cdev方式</span><a href="#1-1-chuan-tong-cdev-fang-shi" class="header-anchor">#</a></h2><details>
<summary>char_drv.c</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> led_major;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> * ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv_fops</span> =</span> &#123;</span><br><span class="line">    .owner  =   THIS_MODULE,</span><br><span class="line">    .open   =   led_drv_open,</span><br><span class="line">    .write	=	led_drv_write,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_setup_cdev</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err, devno = MKDEV(led_major, <span class="number">0</span>);<span class="comment">//index 为从设备号</span></span><br><span class="line">  cdev_init(&amp;cdev, &amp;led_drv_fops);</span><br><span class="line">  cdev.owner = THIS_MODULE;</span><br><span class="line">  cdev.ops = &amp;led_drv_fops;</span><br><span class="line">  err = cdev_add(&amp;cdev, devno, <span class="number">1</span>);<span class="comment">//devno 为第一个设备号，1为数量</span></span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    printk(KERN_NOTICE <span class="string">&quot;Error %d adding&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">dev_t</span> devno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    devno=MKDEV(led_major,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(led_major)<span class="comment">//静态申请设备号</span></span><br><span class="line">        result=register_chrdev_region(devno,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        result = alloc_chrdev_region(&amp;devno,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);<span class="comment">//动态申请设备号</span></span><br><span class="line">        led_major = MAJOR(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        printk (KERN_WARNING <span class="string">&quot;hello: can&#x27;t get major number %d\n&quot;</span>, led_major);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    led_setup_cdev();</span><br><span class="line">    led_class = class_create(THIS_MODULE, <span class="string">&quot;led_class&quot;</span>);</span><br><span class="line">	dev = device_create(led_class, <span class="literal">NULL</span>, devno, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;led_dev&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev)) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;device create failed error code(%ld)\n&quot;</span>, PTR_ERR(dev));</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dev);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(led_class, dev);     <span class="comment">/* remove the device */</span></span><br><span class="line">    class_destroy(led_class);           <span class="comment">/* remove the device class */</span></span><br><span class="line">    cdev_del(&amp;cdev);</span><br><span class="line">    unregister_chrdev_region(MKDEV(led_major,<span class="number">0</span>),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_drv_init);</span><br><span class="line">module_exit(led_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
总结流程：

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">A：创建设备号。MKDEV(major_no,<span class="number">0</span>)，其值为一个整数。因为linux中使用设备号来关联相应的设备和设备对于的驱动程序。</span><br><span class="line">B：注册设备号。register_chrdev_region(devno,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>)</span><br><span class="line">    或者alloc_chrdev_region(&amp;devno,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);<span class="comment">//动态申请设备号</span></span><br><span class="line">C：初始化并关联file_operations结构体。  cdev_init(&amp;cdev, &amp;led_drv_fops);</span><br><span class="line">D：添加字符设备到内核。<span class="function"><span class="built_in">int</span> <span class="title">cdev_add</span>(<span class="params"><span class="keyword">struct</span> cdev *p, dev_t dev, unsigned count</span>)，</span></span><br><span class="line"><span class="function">E：移除字符设备及设备号。<span class="title">cdev_del</span>(<span class="params">&amp;cdev</span>)</span>; unregister_chrdev_region(MKDEV(led_major,<span class="number">0</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>kdev_t.h</code><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/1.png" alt="image"></p>
<p>上面涉及到的API可以在函数<code>linux/fs/char_dev.c</code>中找到定义。</p>
<h2><span id="1-2-misc-device-fang-shi">1.2 misc device方式</span><a href="#1-2-misc-device-fang-shi" class="header-anchor">#</a></h2><p>使用<code>misc_register</code>，在加载模块时会自动创建设备节点，为<code>主设备号为10</code>的字符设备。使用<code>misc_deregister</code>，在卸载模块时会自动删除设备节点。因此<code>无需调用cdev这一套框架</code>流程，无需调用<code>class_create</code>和<code>device_create</code>操作。<code>misc_register</code>时会自行调用了<code> class_create()</code>, <code>device_create() </code>因此<code>/sys/class/misc</code>类会被创建， <code>/dev/</code>下的设备节点也会自动创建。<br><code>/proc/misc</code>记录了系统中所有加载的misc设备：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/2.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_dev</span> <span class="title">my_led</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_ioctl</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	<span class="comment">//filp-&gt;private_data = &amp;my_led;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">leds_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">leds_fops</span> =</span>&#123;</span><br><span class="line">	.owner   = THIS_MODULE,</span><br><span class="line">	.read    = leds_read,</span><br><span class="line">	.ioctl   = leds_ioctl,</span><br><span class="line">	.open    = leds_open,</span><br><span class="line">	.release = leds_release</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">dev_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> *<span class="title">miscdev</span> =</span> &amp;my_led.miscdev;</span><br><span class="line">	miscdev-&gt;minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">	miscdev-&gt;name = <span class="string">&quot;misc_leds&quot;</span>,</span><br><span class="line">	miscdev-&gt;fops = &amp;leds_fops,</span><br><span class="line">	miscdev-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret = misc_register(miscdev);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">dev_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	misc_deregister(&amp;my_led.miscdev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(dev_init);</span><br><span class="line">module_exit(dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="2-misc-za-xiang-she-bei-jie-xi">2 misc杂项设备解析</span><a href="#2-misc-za-xiang-she-bei-jie-xi" class="header-anchor">#</a></h1><p>源代码位置<code>driver/char/misc.c</code>，主设备号固定为10，所有的<code>miscdevice</code>设备形成了一个链表，对设备访问时内核根据次设备号查找对应的miscdevice设备，然后调用其<code>file_operations</code>结构中注册的文件操作接口进行操作。</p>
<h2><span id="2-1-misc-init-guo-cheng">2.1 misc_init过程</span><a href="#2-1-misc-init-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/3.png" alt="image"><br>misc子系统的初始化是利用<code>subsys_initcall</code>进行子系统初始化，首先创建<code>/proc/misc</code>条目，对应<code>cat /proc/misc</code>可以看到所有misc设备信息，<code>cat /proc/misc</code>于是就会调用<code>misc_seq_ops</code>中的<code>misc_seq_show</code>函数，可以看到刚好为misc设备的次设备号和名字信息。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/4.png" alt="image"><br>主设备号固定为10，调用<code>class_create</code>创建<code>/sys/class/misc</code>, 调用<code>register_chrdev</code>注册字符设备，添加<code>file_operations</code>。(<code>register_chrdev</code>如果传入主设备号，则静态注册，否则动态注册返回主设备号)<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/5.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/6.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/7.png" alt="image"></p>
<h2><span id="2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng">2.2 misc设备注册misc_register过程</span><a href="#2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/8.png" alt="image"></p>
<p><code>MISC_DYNAMIC_MINOR = 255</code>，使用者调用<code>misc_register</code>时一般会次设备号传入<code>MISC_DYNAMIC_MINOR</code>，那么会自动分配次设备号；否则遍历<code>misc_list</code>链表，看这个次设备号以前有没有被用过，如果次设备号已被占有则退出返回-EBUSY。<br>得到这个次设备号后<code>set_bit(i, misc_minors);</code>设置位图中相应位为1。<code>device_create_with_groups</code>等同于<code>device_create</code>创建设备节点。<br>最后将list节点添加到<code>misc_list</code>链表中。<br><code>cat /sys/class</code>可以看到所有驱动中调用<code>class_creat()</code>函数的模块，<code>cat /sys/class/misc</code>则可以看到所有misc杂项驱动模块。<code>ls /dev/*</code>可以看到对应的设备节点<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/9.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/10.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/11.png" alt="image"></p>
<h2><span id="2-3-misc-she-bei-xie-zai-guo-cheng">2.3 misc设备卸载过程</span><a href="#2-3-misc-she-bei-xie-zai-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/12.png" alt="image"><br>从<code>misc_list链表</code>中删除节点list,  然后删除设备节点。释放位图相应位清0，以便次设备号留给下一个模块使用。</p>
<h2><span id="2-4-misc-she-bei-da-kai-guo-cheng">2.4 misc设备打开过程</span><a href="#2-4-misc-she-bei-da-kai-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/13.png" alt="image"></p>
<ol>
<li>当用户调用<code>open(&quot;/dev/xxx&quot;)</code>时，由于misc设备主设备号都为10，那么会统一进入到<code>misc_open</code>，那么会根据次设备号来区分不同的misc设备，首先<code>iminor(inode)</code>取出次设备号，<code>i_rdev</code>是对应具体misc设备的<code>设备号dev_t</code>。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/14.png" alt="image"></li>
<li>然后遍历<code>misc_list</code>链表，找到与<code>minor次设备号</code>相匹配的<code>misc device</code>，找到后将<code>file_operations(简称fops)</code>暂存到<code>new_fops</code>。如果匹配不到，则请求加载这个次设备号对应的模块。<code>request_module</code>表示让linux系统的用户空间调用<code>/sbin/modprobe</code>函数加载名为<code>char-major-%d-%d</code>的模块。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/15.png" alt="image"><br>匹配成功后<code>file-&gt;private_data = c;</code>表示将链表中匹配出的<code>miscdevice</code>作为<code>file-&gt;private_data</code>(后面会介绍作用)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Place the miscdevice in the file&#x27;s</span></span><br><span class="line"><span class="comment">* private_data so it can be used by the</span></span><br><span class="line"><span class="comment">* file operations, including f_op-&gt;open below</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">file-&gt;private_data = c;</span><br></pre></td></tr></table></figure>
<p>最后将暂存的<code>new_fops</code>赋值给<code>file-&gt;f_op</code>，调用具体的misc模块的fops：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">file-&gt;f_op-&gt;open(inode, file)；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/16.png" alt="image"></p>
<h1><span id="3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi">3 如何从fops中获取模块设备信息</span><a href="#3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi" class="header-anchor">#</a></h1><h2><span id="3-1-yin-ru">3.1 引入</span><a href="#3-1-yin-ru" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">dwa_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span> =</span> container_of(filp-&gt;private_data, <span class="keyword">struct</span> xxx_dev, miscdev);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-fang-fa-1-dui-yu-misc-she-bei">3.1.1 方法1：（对于misc设备）</span><a href="#3-1-1-fang-fa-1-dui-yu-misc-she-bei" class="header-anchor">#</a></h3><p>可以看到如果我们想要重file_oprations获取设备入口，可以通过如下方式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> xxx_dev *m = container_of(filp-&gt;private_data, <span class="keyword">struct</span> xxx_dev, miscdev);</span><br></pre></td></tr></table></figure>
<p>前面2.4讲过了匹配成功后<code>file-&gt;private_data = c;</code>表示将链表中匹配出的<code>miscdevice</code>作为<code>file-&gt;private_data</code>.</p>
<h3><span id="3-1-2-fang-fa-2-dui-yu-cdev-she-bei">3.1.2 方法2：（对于cdev设备）</span><a href="#3-1-2-fang-fa-2-dui-yu-cdev-she-bei" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">xxx_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line">	m = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> xxx_dev, cdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inode</code>的<code>i_cdev</code>指向的即为<code>cdev</code>结构体。调用<code>container_of</code>即可获取设备信息。</p>
<h3><span id="3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi">3.1.3方法3：xxx_open中保存设备信息</span><a href="#3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span>* <span class="title">res</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">keyscan_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="type">uint32_t</span> res_size = (<span class="type">uint32_t</span>)resource_size(m-&gt;res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">xxx_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	file-&gt;private_data = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file-&gt;private_data = m</code>保存设备信息。</p>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-ioctl命令详解</title>
    <url>/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-ioctl">1 引入ioctl</a></li>
<li><a href="#2-yong-hu-kong-jian-ioctl">2 用户空间 ioctl</a></li>
<li><a href="#3-nei-he-kong-jian-ioctl">3 内核空间 ioctl</a></li>
<li><a href="#4-ioctl-de-ming-ling-gou-cheng">4 IOCTL的命令构成</a></li>
<li><a href="#5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie">5 ioctl系统调用过程详解</a><ul>
<li><a href="#5-1-app-shi-li">5.1 app示例</a></li>
<li><a href="#5-2-qu-dong-shi-li">5.2 驱动示例</a></li>
<li><a href="#5-3-ioctl-guo-cheng-xiang-jie">5.3 ioctl过程详解</a><ul>
<li><a href="#5-3-1-sys-ioctl">5.3.1 sys_ioctl</a><ul>
<li><a href="#5-3-1-1-do-vfs-ioctl">5.3.1.1 do_vfs_ioctl</a><ul>
<li><a href="#5-3-1-1-1-vfs-ioctl">5.3.1.1.1 vfs_ioctl</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-yin-ru-ioctl">1 引入ioctl</span><a href="#1-yin-ru-ioctl" class="header-anchor">#</a></h1><p>一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能增添命令，通常以增设 <code>ioctl() </code>命令的方式实现。<br>对于ioctl这个系统调用接口，Linux的创始人在2.0版本之前并没有进行添加，仅有write和read两个接口，但是后来发现当需要去控制文件的某些操作的时候，很显然这两个接口根本不够用。所以才有了这个万能控制接口ioctl，但是作为Linux的创始人Linus本人一直排斥该接口，因为这个ioctl接口的在内核中的使用相当于对应用层开设了一个能够直接交互的窗口，很影响内核整体的权限控制，不过由于目前还暂时没有更好可以替代的方法，所以还是继续保留了这个接口的使用。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/1.png" alt="image"></p>
<h1><span id="2-yong-hu-kong-jian-ioctl">2 用户空间 ioctl</span><a href="#2-yong-hu-kong-jian-ioctl" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, …)</span>;</span><br><span class="line">ret = ioctl(fd, MYCMD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数功能：<br>1.向硬件设备发送控制命令<br>2.还可以和硬件设备进行读或者写操作<br>参数：<br><code>fd：</code>文件描述符<br><code>request：</code>给硬件设备发送的控制命令<br><code>arg：</code>保存的就是用户缓冲区的首地址<br>返回值：执行成功返回0，执行失败返回-1, ioctl 最常见的<code> errorno</code> 值为<code> ENOTTY</code>（<code>error not a typewriter</code>)表示命令找不到。</p>
<h1><span id="3-nei-he-kong-jian-ioctl">3 内核空间 ioctl</span><a href="#3-nei-he-kong-jian-ioctl" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="4-ioctl-de-ming-ling-gou-cheng">4 IOCTL的命令构成</span><a href="#4-ioctl-de-ming-ling-gou-cheng" class="header-anchor">#</a></h1><p> ioctl命令就是用户和驱动约定的一种协议， 理论上可以为任意 int 型数据，可以为 0、1、2、3……，但是为了确保该 “协议” 的唯一性，ioctl 命令应该使用更科学严谨的方法赋值，在linux中，提供了一种 ioctl 命令的统一格式，将 32 位 int 型数据划分为四个位段，如下图所示：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/4.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. <span class="built_in">dir</span>（direction），ioctl 命令访问模式（数据传输方向），占据 2 bit，</span><br><span class="line">	可以为 _IOC_NONE、_IOC_READ、_IOC_WRITE、_IOC_READ | _IOC_WRITE，</span><br><span class="line">	分别指示了四种访问模式：无数据、读数据、写数据、读写数据；</span><br><span class="line">2. size，涉及到 ioctl 函数第三个参数 arg ，占据14bit，指定了 arg 的数据类型及长度；</span><br><span class="line">3. <span class="built_in">type</span>（device <span class="built_in">type</span>），设备类型，占据 8 bit，可以为任意 char 型字符，</span><br><span class="line">	例如‘a’、’b’、’c’ 等等，其主要作用是使 ioctl 命令有唯一的设备标识；</span><br><span class="line">4. nr（number），命令编号/序数，占据 8 bit，可以为任意 unsigned char 型数据，</span><br><span class="line">	取值范围 0~255，如果定义了多个 ioctl 命令，通常从 0 开始编号递增</span><br></pre></td></tr></table></figure>

<p>通常而言，为了方便会使用<code>宏 _IOC() 衍生的接口</code>来直接定义 ioctl 命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ioctl.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRBITS	8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEBITS	8</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Let any architecture override either of the following before</span></span><br><span class="line"><span class="comment"> * including this file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_SIZEBITS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_SIZEBITS	14</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_DIRBITS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_DIRBITS	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRMASK	((1 &lt;&lt; _IOC_NRBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEMASK	((1 &lt;&lt; _IOC_TYPEBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZEMASK	((1 &lt;&lt; _IOC_SIZEBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRMASK	((1 &lt;&lt; _IOC_DIRBITS)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRSHIFT	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direction bits, which any architecture can choose to override</span></span><br><span class="line"><span class="comment"> * before including this file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _IOC_WRITE means userland is writing and kernel is</span></span><br><span class="line"><span class="comment"> * reading. _IOC_READ means userland is reading and kernel is writing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_NONE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_NONE	0U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_WRITE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_WRITE	1U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_READ</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_READ	2U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line"><span class="meta">	(((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPECHECK(t) (sizeof(t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used to create numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _IOW means userland is writing and kernel is reading. _IOR</span></span><br><span class="line"><span class="comment"> * means userland is reading and kernel is writing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used to decode ioctl numbers.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr)		(((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr)		(((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr)		(((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr)		(((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ...and for the drivers/sound files... */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_IN		(_IOC_WRITE &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_OUT		(_IOC_READ &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_INOUT	((_IOC_WRITE|_IOC_READ) &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_MASK	(_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_SHIFT	(_IOC_SIZESHIFT)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/5.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/6.png" alt="image"><br>除了<code>_IO/_IOR/_IOW/_IOW</code>等命令外，还支持反向解析 ioctl 命令的宏接口：主要就是利用Mask看是否4个位段是否越界,如果越界说明cmd构造的不合法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr) (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr) (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr) (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr) (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br></pre></td></tr></table></figure>

<p>举个例子比如<img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/7.png" alt="image">，展开命令成一个<code>unsigned int</code>的 cmd整数为：(<code>字符D的ascii码为68</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>&lt;&lt;<span class="number">30</span> | <span class="number">0</span>&lt;&lt;<span class="number">16</span> | <span class="number">68</span>&lt;&lt;<span class="number">8</span> | <span class="number">0x7</span>&lt;&lt;<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1><span id="5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie">5 ioctl系统调用过程详解</span><a href="#5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie" class="header-anchor">#</a></h1><h2><span id="5-1-app-shi-li">5.1 app示例</span><a href="#5-1-app-shi-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCINIT _IO(IOC_MAGIC, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, int)<span class="comment">//定义3个cmd</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAXNR 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/ioctl-test&quot;</span>, O_RDWR);</span><br><span class="line">ioctl(fd, IOCINIT);</span><br><span class="line"><span class="comment">/* 往寄存器0x01写入数据0xef */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">my_msg.addr = <span class="number">0x01</span>;</span><br><span class="line">my_msg.data = <span class="number">0xef</span>;</span><br><span class="line">ioctl(fd, IOCWREG, &amp;my_msg);</span><br><span class="line"><span class="comment">/* 读寄存器0x01 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">my_msg.addr = <span class="number">0x01</span>;</span><br><span class="line">ret = ioctl(fd, IOCRREG, &amp;my_msg);</span><br></pre></td></tr></table></figure>
<p>构造了<code>IOCINIT</code> <code>IOCRREG</code> <code>IOCWREG</code>3个命令。</p>
<h2><span id="5-2-qu-dong-shi-li">5.2 驱动示例</span><a href="#5-2-qu-dong-shi-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCINIT _IO(IOC_MAGIC, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, int)<span class="comment">//定义3个cmd</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAXNR 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">my_msg</span>;</span></span><br><span class="line">	<span class="comment">/* 检查设备类型 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_TYPE(cmd) != IOC_MAGIC) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;[%s] command type [%c] error!\n&quot;</span>, __func__, _IOC_TYPE(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 检查序数 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_NR(cmd) &gt; IOC_MAXNR) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;[%s] command numer [%d] exceeded!\n&quot;</span>, __func__, _IOC_NR(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 检查访问模式 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_DIR(cmd) &amp; _IOC_READ)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0))</span></span><br><span class="line">		ret= !access_ok(VERIFY_WRITE, (<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		ret= !access_ok((<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (_IOC_DIR(cmd) &amp; _IOC_WRITE)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0))</span></span><br><span class="line">		ret= !access_ok(VERIFY_READ, (<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		ret= !access_ok((<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">switch</span>(cmd) &#123; </span><br><span class="line">	<span class="comment">/* 初始化设备 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCINIT:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* 读寄存器 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCRREG:</span><br><span class="line">		ret = copy_from_user(&amp;msg, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		msg-&gt;data = read_reg(msg-&gt;addr);</span><br><span class="line">		ret = copy_to_user((<span class="keyword">struct</span> msg __user *)arg, &amp;msg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* 写寄存器 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCWREG:</span><br><span class="line">		ret = copy_from_user(&amp;msg, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		write_reg(msg-&gt;addr, msg-&gt;data);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/8.png" alt="image"><br>首先定好3个命令，通过<code>arg</code>传入要写入的地址和数据or 要读的地址。然后检查<code>type</code>是否为<code>‘c’</code>, 检查命令号是否超过最大值3，检查方向是读还是写，利用<code>access_ok</code>判断用户地址是否可以访问。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/9.png" alt="image"><br>最后将用户地址arg的数据透过<code>copy_from_user</code>和<code>copy_to_user</code>进行拷贝。然后进行寄存器读写。</p>
<h2><span id="5-3-ioctl-guo-cheng-xiang-jie">5.3 ioctl过程详解</span><a href="#5-3-ioctl-guo-cheng-xiang-jie" class="header-anchor">#</a></h2><p>在系统调用中，是通过<code>SWI(Software Interrupt)</code>的方式陷入内核态的, 首先通过软中断方式切换到内核态，ioctl的系统调用位于<code>arch/arm/include/asm/unistd.h</code>：</p>
<h3><span id="5-3-1-sys-ioctl">5.3.1 sys_ioctl</span><a href="#5-3-1-sys-ioctl" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl	(__NR_SYSCALL_BASE+ 54)</span></span><br></pre></td></tr></table></figure>

<p><code>arch/arm/kernel/calls.S</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 55 */</span>	CALL(sys_ioctl);</span><br></pre></td></tr></table></figure>
<p>调用<code>sys_ioctl()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/include/linux.h</span><br><span class="line">	asmlinkage <span class="type">long</span> <span class="title function_">sys_ioctl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br></pre></td></tr></table></figure>


<p>然后调用<code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">/include/linux/syscalls.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE3(name, ...)  SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<p><code>SYSCALL_DEFINE3</code><br><code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)</code>就是<code>sys_ioctl</code>的定义:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/10.png" alt="image"><br><code>fget_light() </code>以及 <code>security_file_ioctl() </code>就是检验可操作安全性，所以<code>sys_ioctl</code>更多是调用更深一层接口 <code>do_vfs_ioctl()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">	<span class="type">int</span> error = -EBADF;</span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	filp = fget_light(fd, &amp;fput_needed);<span class="comment">//由fd得带filp指针</span></span><br><span class="line">	<span class="keyword">if</span> (!filp)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	error = security_file_ioctl(filp, cmd, arg);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out_fput;</span><br><span class="line">	error = do_vfs_ioctl(filp, fd, cmd, arg);</span><br><span class="line"> out_fput:</span><br><span class="line">	fput_light(filp, fput_needed);</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-3-1-1-do-vfs-ioctl">5.3.1.1 do_vfs_ioctl</span><a href="#5-3-1-1-do-vfs-ioctl" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/11.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> __user *argp = (<span class="type">int</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> filp-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> FIOCLEX:</span><br><span class="line">		set_close_on_exec(fd, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIONCLEX:</span><br><span class="line">		set_close_on_exec(fd, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIONBIO:</span><br><span class="line">		error = ioctl_fionbio(filp, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIOASYNC:</span><br><span class="line">		error = ioctl_fioasync(fd, filp, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIOQSIZE:</span><br><span class="line">		<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode) ||</span><br><span class="line">			S_ISLNK(inode-&gt;i_mode)) &#123;</span><br><span class="line">			<span class="type">loff_t</span> res = inode_get_bytes(inode);</span><br><span class="line">			error = copy_to_user(argp, &amp;res, <span class="keyword">sizeof</span>(res)) ?</span><br><span class="line">					-EFAULT : <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -ENOTTY;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIFREEZE:</span><br><span class="line">		error = ioctl_fsfreeze(filp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FITHAW:</span><br><span class="line">		error = ioctl_fsthaw(filp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FS_IOC_FIEMAP:</span><br><span class="line">		<span class="keyword">return</span> ioctl_fiemap(filp, arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIGETBSZ:</span><br><span class="line">		<span class="keyword">return</span> put_user(inode-&gt;i_sb-&gt;s_blocksize, argp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))<span class="comment">//是否为常规文件若是常规文件</span></span><br><span class="line">			error = file_ioctl(filp, cmd, arg);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			error = vfs_ioctl(filp, cmd, arg);<span class="comment">//调用vfs_ioctl</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="5-3-1-1-1-vfs-ioctl">5.3.1.1.1 vfs_ioctl</span><a href="#5-3-1-1-1-vfs-ioctl" class="header-anchor">#</a></h5><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/12.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!filp-&gt;f_op || !filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">unlocked_ioctl</span><br><span class="line">	error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);<span class="comment">//调用unlocked_ioctl()</span></span><br><span class="line">	<span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">		error = -EINVAL;</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>最终调用对应驱动人员自己fops的unlocked_ioctl函数。</p>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-用户态构造IP寄存器结构体和读写寄存器</title>
    <url>/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou">1 用户态定义寄存器结构</a></li>
<li><a href="#2-qu-dong-dai-ma">2 驱动代码</a></li>
<li><a href="#3-yong-hu-tai-dai-ma">3 用户态代码</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou">1 用户态定义寄存器结构</span><a href="#1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou" class="header-anchor">#</a></h1><p>以键盘<code>keyscan</code>为例，定义一个IP寄存器描述头文件，<code>IOCRREG</code>, <code>IOCWREG</code>定义了两个ioctl命令，用来读写寄存器。<code>struct msg</code>用来存放寄存器地址和值。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/1.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/2.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Keyscan register: addr + offset + mask */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config1			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config2			0x4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config3			0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config4			0xc</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count				0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count_OFFSET			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count_MASK				0xf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty				0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty_OFFSET			4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty_MASK			0x10</span></span><br><span class="line"><span class="keyword">struct</span> msg &#123;</span><br><span class="line">	<span class="built_in">long</span> unsigned <span class="built_in">int</span> addr;</span><br><span class="line">	unsigned <span class="built_in">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC &#x27;k&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, struct msg)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, struct msg)</span></span><br></pre></td></tr></table></figure>

<h1><span id="2-qu-dong-dai-ma">2 驱动代码</span><a href="#2-qu-dong-dai-ma" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/3.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">keyscan_ioctl</span>(<span class="params"><span class="keyword">struct</span> file *file, unsigned <span class="built_in">int</span> cmd, unsigned <span class="built_in">long</span> arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> msg m;</span><br><span class="line">	memset(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	<span class="keyword">void</span> __iomem* <span class="keyword">base</span> = dev-&gt;<span class="keyword">base</span>;</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> IOCRREG:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;m, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		m.data = readl(<span class="keyword">base</span> + m.addr);</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;base_addr:0x%lx, offset:0x%lx, read data: 0x%x \n&quot;</span>, <span class="keyword">base</span>, m.addr, m.data);</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user((<span class="keyword">struct</span> msg __user *)arg, &amp;m, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IOCWREG:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;m, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;base_addr:0x%lx, offset:0x%lx, write data: 0x%x \n&quot;</span>, <span class="keyword">base</span>, m.addr, m.data);</span><br><span class="line">		writel(m.data, <span class="keyword">base</span> + m.addr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="literal">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>驱动先定义<code>IP base addr</code>，然后透过<code>ioctl</code>进行<code>arg</code>参数接收，确定<code>msg</code>中的<code>addr</code>和<code>data</code>, 接收<code>cmd</code>调用<code>writel, readl</code>进行读写。</p>
<h1><span id="3-yong-hu-tai-dai-ma">3 用户态代码</span><a href="#3-yong-hu-tai-dai-ma" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">clrsetbits_32</span><span class="params">(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">int</span> clear, <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	m.addr = addr;</span><br><span class="line">	ret = ioctl(fd, IOCRREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: read error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m.data = (m.data &amp; (~clear)) | <span class="built_in">set</span>;</span><br><span class="line">	ret = ioctl(fd, IOCWREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: write error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">read_reg</span><span class="params">(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">    m.addr = addr;</span><br><span class="line">	ret = ioctl(fd, IOCRREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: read reg error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先实现基础读写函数进行寄存器读写，<code>reg_read</code>函数传入<code>addr</code>即可得到<code>val</code>, <code>clrsetbits_32</code>需要先读，在写入<code>val.</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_MASK(REG_NAME) keyscan_top_##REG_NAME##_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_OFFSET(REG_NAME) keyscan_top_##REG_NAME##_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_SET(REG_NAME, VAL)                                             \</span></span><br><span class="line">	clrsetbits_32(keyscan_top_<span class="meta">##REG_NAME, KEYSCAN_MASK(REG_NAME),          \</span></span><br><span class="line">			  (VAL) &lt;&lt; KEYSCAN_OFFSET(REG_NAME))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_GET(REG_NAME)                                                  \</span></span><br><span class="line">	((read_reg(keyscan_top_<span class="meta">##REG_NAME) &amp; KEYSCAN_MASK(REG_NAME)) &gt;&gt;        \</span></span><br><span class="line">	 KEYSCAN_OFFSET(REG_NAME))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/5.png" alt="image"></p>
<p>例如，当调用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">KEYSCAN_GET(reg_fifo_count); </span><br><span class="line"><span class="comment">//表示</span></span><br><span class="line">read_reg(keycan_top_reg_fifo_count) &amp;</span><br><span class="line">    keycan_top_reg_fifo_count_MASK &gt;&gt; keycan_top_reg_fifo_count_OFFSET);</span><br></pre></td></tr></table></figure>

<p><code>reg_fifo</code>表示IP的某一个寄存器:</p>
<p>①<code>count</code>表示位域，因此对<code>OFFSET</code>定义成位域在该寄存器的偏移量（<code>count位域是bit[3:0]</code>）定义为0，因此<code>MASK</code>定义为<code>0xf</code>.<br>②同理<code>not_empty</code>也是一个位域，<code>bit[4]</code>，<code>OFFSET</code>定义成4，<code>MASK</code>定义成<code>0x10</code>，来屏蔽除<code>bit[4]</code>的其他bit.</p>
<p><code>KEYSCAN_GET(reg_fifo_count);</code>最终就获取到了<code>reg_fifo</code>寄存器的<code>count</code>位域的内容。<br><code>KEYSCAN_GET(reg_fifo_not_empty);</code>最终就获取到了<code>reg_fifo</code>寄存器的<code>not_empty</code>位域的内容</p>
<p>又例如，当调用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">KEYSCAN_SET(reg_enable, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//表示</span></span><br><span class="line">clrsetbits_32(keycan_top_reg_enable, </span><br><span class="line">              keycan_top_reg_enable_MASK, </span><br><span class="line">              <span class="number">1</span> &lt;&lt; keycan_top_reg_enable_OFFSET);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/6.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask_OFFSET			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask_MASK			0xff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask_OFFSET			8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask_MASK			0xff00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable				0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable_OFFSET			16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable_MASK			0x10000</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>offset</code>定义为<code>16</code>，mask定义为<code>0x10000</code>，用来屏蔽除<code>bit[16]</code>的其他位。<code>clrsetbits_32</code>会先读出该寄存器，然后对该位set1, mask掉其他位，再次写入该寄存器。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-gpio子系统</title>
    <url>/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gpio-zi-xi-tong-yin-ru">1 gpio 子系统引入</a></li>
<li><a href="#2-gpio-zi-xi-tong-jia-gou">2 gpio子系统架构</a><ul>
<li><a href="#2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi">2.0 gpio控制器源码分析</a><ul>
<li><a href="#2-0-1-probe-fen-xi">2.0.1 probe分析</a><ul>
<li><a href="#2-0-1-0-mxc-gpio-get-hw">2.0.1.0 mxc_gpio_get_hw</a></li>
<li><a href="#2-0-1-1-get-resource-and-ioremap">2.0.1.1 get resource and ioremap</a></li>
<li><a href="#2-0-1-2-bgpio-init">2.0.1.2 bgpio_init</a></li>
<li><a href="#2-0-1-3-devm-gpiochip-add-data">2.0.1.3 devm_gpiochip_add_data</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-1-gpio-zi-xi-tong-shu-ju-jie-gou">2.1 gpio子系统数据结构</a><ul>
<li><a href="#2-1-1-gpio-device">2.1.1 gpio_device</a></li>
<li><a href="#2-1-2-gpio-chip">2.1.2 gpio_chip</a></li>
<li><a href="#2-1-3-gpio-desc">2.1.3 gpio_desc</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-gpio-zi-xi-tong-api">3 gpio子系统api</a><ul>
<li><a href="#3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi">3.1使用整数的GPIO传统方式</a><ul>
<li><a href="#3-1-1-qing-qiu-he-pei-zhi">3.1.1 请求和配置</a></li>
<li><a href="#3-1-2-du-qu-he-she-zhi-zhi">3.1.2 读取和设置值</a></li>
<li><a href="#3-1-3-gpiochip-cao-zuo">3.1.3 gpiochip操作</a></li>
</ul>
</li>
<li><a href="#3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi">3.2 基于描述符的GPIO方式</a></li>
<li><a href="#3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou">3.3 和设备树相关GPIO接口</a></li>
</ul>
</li>
<li><a href="#4-ji-yu-sysfs-cao-zuo-gpio">4 基于sysfs操作gpio</a></li>
<li><a href="#5-gpio-zi-xi-tong-shi-li">5 gpio子系统示例</a><ul>
<li><a href="#5-1-gpio-kong-zhi-qi-dts-miao-shu">5.1 gpio控制器dts描述</a></li>
<li><a href="#5-2-gpio-kong-zhi-qi-shi-yong-zhe">5.2 gpio控制器使用者</a><ul>
<li><a href="#5-2-1-shi-yong-zhe-cao-zuo-liu-cheng">5.2.1 使用者操作流程</a><ul>
<li><a href="#5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led">5.2.1.1 dts自定义gpio控制器使用者（demo1,gpio_led）</a></li>
<li><a href="#5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep">5.2.1.2 dts自定义gpio控制器使用者（demo2,beep）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gpio-zi-xi-tong-yin-ru">1 gpio 子系统引入</span><a href="#1-gpio-zi-xi-tong-yin-ru" class="header-anchor">#</a></h1><p>如果 <code>pinctrl </code>子系统将一个 PIN 复用为 GPIO 的话，那么接下来要用到 gpio 子系统了。gpio 子系统顾名思义，就是用于初始化 GPIO 并且提供相应的 API 函数，比如设置 GPIO为输入输出，设置读取 GPIO 的值等。</p>
<p>gpio 子系统的主要目的就是方便驱动开发者使用 gpio，驱动开发者在设备树中添加 gpio 相关信息，然后就可以在驱动程序中使用 gpio 子系统提供的 API函数来操作 GPIO，Linux 内核向驱动开发者屏蔽掉了 GPIO 的设置过程，极大的方便了驱动开发者使用 GPIO。</p>
<h1><span id="2-gpio-zi-xi-tong-jia-gou">2 gpio子系统架构</span><a href="#2-gpio-zi-xi-tong-jia-gou" class="header-anchor">#</a></h1><p>Linux的GPIO子系统驱动框架由三个主要部分组成：① GPIO控制器驱动程序、②gpio lib驱动程序 ③GPIO字符设备驱动程序：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image-20240817202346143"><br>使用<code>gpiochip_add/gpiochip_add_data</code>向系统<code>注册gpio_chip</code>, 这些都是半导体原厂要做的，设备商只需要使用即可。</p>
<h2><span id="2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi">2.0 gpio控制器源码分析</span><a href="#2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><code>drivers/gpio/gpio-mxc.c</code> 就是 I.MX6ULL的 GPIO 控制器驱动文件，在此文件中有如下所示<code>of_device_id</code> 匹配表:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"><br>对照<code>imx6ull.dtsi</code>的gpio控制器可以看到能匹配：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>打开<code>drivers/gpio/gpio-mxc.c</code>：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"><br>probe函数内容如下：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mxc_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mxc_gpio_port</span> *<span class="title">port</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">iores</span>;</span></span><br><span class="line">	<span class="type">int</span> irq_base = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	mxc_gpio_get_hw(pdev);</span><br><span class="line"></span><br><span class="line">	port = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*port), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!port)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	iores = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	port-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, iores);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(port-&gt;base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(port-&gt;base);</span><br><span class="line"></span><br><span class="line">	port-&gt;irq_high = platform_get_irq(pdev, <span class="number">1</span>);</span><br><span class="line">	port-&gt;irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (port-&gt;irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> port-&gt;irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the controller clock is optional */</span></span><br><span class="line">	port-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(port-&gt;clk))</span><br><span class="line">		port-&gt;clk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	err = clk_prepare_enable(port-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Unable to enable clock.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line">	err = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_pm_dis;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* disable the interrupt and clear the status */</span></span><br><span class="line">	writel(<span class="number">0</span>, port-&gt;base + GPIO_IMR);</span><br><span class="line">	writel(~<span class="number">0</span>, port-&gt;base + GPIO_ISR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mxc_gpio_hwtype == IMX21_GPIO) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Setup one handler for all GPIO interrupts. Actually setting</span></span><br><span class="line"><span class="comment">		 * the handler is needed only once, but doing it for every port</span></span><br><span class="line"><span class="comment">		 * is more robust and easier.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		irq_set_chained_handler(port-&gt;irq, mx2_gpio_irq_handler);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* setup one handler for each entry */</span></span><br><span class="line">		irq_set_chained_handler_and_data(port-&gt;irq,</span><br><span class="line">						 mx3_gpio_irq_handler, port);</span><br><span class="line">		<span class="keyword">if</span> (port-&gt;irq_high &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">/* setup handler for GPIO 16 to 31 */</span></span><br><span class="line">			irq_set_chained_handler_and_data(port-&gt;irq_high,</span><br><span class="line">							 mx3_gpio_irq_handler,</span><br><span class="line">							 port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = bgpio_init(&amp;port-&gt;gc, &amp;pdev-&gt;dev, <span class="number">4</span>,</span><br><span class="line">			 port-&gt;base + GPIO_PSR,</span><br><span class="line">			 port-&gt;base + GPIO_DR, <span class="literal">NULL</span>,</span><br><span class="line">			 port-&gt;base + GPIO_GDIR, <span class="literal">NULL</span>,</span><br><span class="line">			 BGPIOF_READ_OUTPUT_REG_SET);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_property_read_bool(np, <span class="string">&quot;gpio_ranges&quot;</span>))</span><br><span class="line">		port-&gt;gpio_ranges = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		port-&gt;gpio_ranges = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	port-&gt;gc.request = mxc_gpio_request;</span><br><span class="line">	port-&gt;gc.<span class="built_in">free</span> = mxc_gpio_free;</span><br><span class="line">	port-&gt;gc.parent = &amp;pdev-&gt;dev;</span><br><span class="line">	port-&gt;gc.to_irq = mxc_gpio_to_irq;</span><br><span class="line">	port-&gt;gc.base = (pdev-&gt;id &lt; <span class="number">0</span>) ? of_alias_get_id(np, <span class="string">&quot;gpio&quot;</span>) * <span class="number">32</span> :</span><br><span class="line">					     pdev-&gt;id * <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	err = devm_gpiochip_add_data(&amp;pdev-&gt;dev, &amp;port-&gt;gc, port);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line"></span><br><span class="line">	irq_base = irq_alloc_descs(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">32</span>, numa_node_id());</span><br><span class="line">	<span class="keyword">if</span> (irq_base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err = irq_base;</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	port-&gt;domain = irq_domain_add_legacy(np, <span class="number">32</span>, irq_base, <span class="number">0</span>,</span><br><span class="line">					     &amp;irq_domain_simple_ops, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!port-&gt;domain) &#123;</span><br><span class="line">		err = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out_irqdesc_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* gpio-mxc can be a generic irq chip */</span></span><br><span class="line">	err = mxc_gpio_init_gc(port, irq_base, &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_irqdomain_remove;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;port-&gt;node, &amp;mxc_gpio_ports);</span><br><span class="line"></span><br><span class="line">	platform_set_drvdata(pdev, port);</span><br><span class="line">	pm_runtime_put(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_pm_dis:</span><br><span class="line">	pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">	clk_disable_unprepare(port-&gt;clk);</span><br><span class="line">out_irqdomain_remove:</span><br><span class="line">	irq_domain_remove(port-&gt;domain);</span><br><span class="line">out_irqdesc_free:</span><br><span class="line">	irq_free_descs(irq_base, <span class="number">32</span>);</span><br><span class="line">out_bgio:</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;%s failed with errno %d\n&quot;</span>, __func__, err);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3><span id="2-0-1-probe-fen-xi">2.0.1 probe分析</span><a href="#2-0-1-probe-fen-xi" class="header-anchor">#</a></h3><p>里面定义了一个很重要的结构体<code>mxc_gpio_port</code> 就是对<code> I.MX6ULL GPIO</code> 的抽象。<code>mxc_gpio_port </code>结构体定义如下：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"><br><code>mxc_gpio_probe</code>又会继续调用<code>mxc_gpio_get_hw</code>获取gpio的硬件相关数据，也就是gpio组，gpio1.gpio2等。</p>
<h4><span id="2-0-1-0-mxc-gpio-get-hw">2.0.1.0 mxc_gpio_get_hw</span><a href="#2-0-1-0-mxc-gpio-get-hw" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<p>我们imx6ull gpio<code>控制器类型</code>就是<code>imx35系列</code>。因此选用<code>imx35_gpio_hwdata</code>，如下：可以看出这些成员不就是对应寄存器的偏移量吗？</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h4><span id="2-0-1-1-get-resource-and-ioremap">2.0.1.1 get resource and ioremap</span><a href="#2-0-1-1-get-resource-and-ioremap" class="header-anchor">#</a></h4><p>比如我们probe中通过<code>platform_get_resource</code> 获取<code>gpio1</code>的<code>基地址为0X0209,C000</code>，那么就可以通过配置<code>mxc_gpio_hwdata</code>结构体成员来配置寄存器。</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p>然后调用 <code>devm_ioremap_resource</code> 函数进行内存映射，得到 <code>0x0209C000</code> 在 Linux 内核中的虚拟地址。<br>然后<code>platform_get_irq</code> 函数获取中断号，分为获取高 16 位 GPIO 的中断号，和获取低 16 位 GPIO 中断号。</p>
<p>操作 GPIO1 的 <code>IMR</code> 和 <code>ISR</code> 这两个寄存器，关闭 GPIO1 所有 IO 中断，并且清除状态寄存器:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<p>设置对应 GPIO 的中断服务函数，不管是高 16 位还是低 16 位，中断服务函数都是 <code>mx3_gpio_irq_handler</code>:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<h4><span id="2-0-1-2-bgpio-init">2.0.1.2 bgpio_init</span><a href="#2-0-1-2-bgpio-init" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image-20240817211118974"></p>
<p>调用<code>bgpio_init</code> 函数主 要 任 务 就 是 初 始 化<code> port-&gt;gc, (gc就是gpio_chip)</code>。顾名思义<code>bgpio_init</code>就是<code>basic gpio init</code>，里 面 有 三 个 <code>setup</code> 函 数 :</p>
<ol>
<li><code>bgpio_setup_io</code> </li>
<li><code>bgpio_setup_accessors</code> </li>
<li><code>bgpio_setup_direction</code>。这三个函数就是初始化 <code>port-&gt;gc</code> 中的各种有关GPIO 的操作，比如输出，输入等等。</li>
</ol>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image-20240817213544044"></p>
<h4><span id="2-0-1-3-devm-gpiochip-add-data">2.0.1.3 devm_gpiochip_add_data</span><a href="#2-0-1-3-devm-gpiochip-add-data" class="header-anchor">#</a></h4><p>调用<code>devm_gpiochip_add_data</code>注册这个port。gpio控制器就成功注册给了gpio子系统。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>至此，<code>port-&gt;gc</code>既有了对 GPIO 的操作函数，又有了 I.MX6ULL 有关 GPIO的寄存器，那么只要得到 port 就可以对 I.MX6ULL 的 GPIO 进行操作。</p>
<h2><span id="2-1-gpio-zi-xi-tong-shu-ju-jie-gou">2.1 gpio子系统数据结构</span><a href="#2-1-gpio-zi-xi-tong-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="2-1-1-gpio-device">2.1.1 gpio_device</span><a href="#2-1-1-gpio-device" class="header-anchor">#</a></h3><p>每个<code>GPIO Controller</code>用一个<code>gpio_device</code>来表示:</p>
<ol>
<li>每组gpio引脚对应一个<code>gpio_desc</code>和一个<code>gpio_chip</code></li>
<li>gpio引脚的操作函数，都放在<code>gpio_chip</code>成员函数中。</li>
</ol>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image-20240818143429583"></p>
<h3><span id="2-1-2-gpio-chip">2.1.2 gpio_chip</span><a href="#2-1-2-gpio-chip" class="header-anchor">#</a></h3><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image-20240818140515596"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*label;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span>	*<span class="title">gpiodev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">int</span>			(*request)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//请求一个 GPIO 引脚</span></span><br><span class="line">	<span class="type">void</span>			(*<span class="built_in">free</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//释放一个之前请求的 GPIO 引脚</span></span><br><span class="line">	<span class="type">int</span>			(*get_direction)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//获取方向</span></span><br><span class="line">	<span class="type">int</span>			(*direction_input)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//输入模式</span></span><br><span class="line">	<span class="type">int</span>			(*direction_output)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset, <span class="type">int</span> value);<span class="comment">//输出模式，并且set gpio val</span></span><br><span class="line">	<span class="type">int</span>			(*get)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//读取 GPIO 引脚的值</span></span><br><span class="line">	<span class="type">void</span>			(*<span class="built_in">set</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset, <span class="type">int</span> value);<span class="comment">//设置gpio 引脚值</span></span><br><span class="line">	<span class="type">void</span>			(*set_multiple)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> <span class="type">long</span> *mask,</span><br><span class="line">						<span class="type">unsigned</span> <span class="type">long</span> *bits);</span><br><span class="line">	<span class="type">int</span>			(*set_debounce)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset,</span><br><span class="line">						<span class="type">unsigned</span> debounce);<span class="comment">//设置 GPIO 引脚的去抖动时间</span></span><br><span class="line">	<span class="type">int</span>			(*set_single_ended)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset,</span><br><span class="line">						<span class="keyword">enum</span> single_ended_mode mode);</span><br><span class="line">	<span class="type">int</span>			(*to_irq)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);</span><br><span class="line">	<span class="type">void</span>			(*dbg_show)(<span class="keyword">struct</span> seq_file *s,</span><br><span class="line">						<span class="keyword">struct</span> gpio_chip *chip);<span class="comment">//调试目的，显示 GPIO 引脚的状态</span></span><br><span class="line">	<span class="type">int</span>			base;<span class="comment">//chip的基地址</span></span><br><span class="line">	u16			ngpio;<span class="comment">//GPIO 引脚数量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*<span class="type">const</span> *names;</span><br><span class="line">	<span class="type">bool</span>			can_sleep;</span><br><span class="line">	<span class="type">bool</span>			irq_not_threaded;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_GPIO_GENERIC)<span class="comment">// bgpio使能</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*read_reg)</span><span class="params">(<span class="type">void</span> __iomem *reg)</span>;</span><br><span class="line">	<span class="type">void</span> (*write_reg)(<span class="type">void</span> __iomem *reg, <span class="type">unsigned</span> <span class="type">long</span> data);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*pin2mask)</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> pin)</span>;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_dat;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_set;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_clr;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_dir;</span><br><span class="line">	<span class="type">int</span> bgpio_bits;</span><br><span class="line">	<span class="type">spinlock_t</span> bgpio_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bgpio_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bgpio_dir;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GPIOLIB_IRQCHIP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		*<span class="title">irqchip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">irqdomain</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_base;</span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	irq_handler;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_default_type;</span><br><span class="line">	<span class="type">int</span>			irq_parent;</span><br><span class="line">	<span class="type">bool</span>			irq_need_valid_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*irq_valid_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	*<span class="title">lock_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_GPIO)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">	<span class="type">int</span> of_gpio_n_cells;<span class="comment">//dts描述几个cells构成</span></span><br><span class="line">	<span class="type">int</span> (*of_xlate)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line">			<span class="type">const</span> <span class="keyword">struct</span> of_phandle_args *gpiospec, u32 *flags);<span class="comment">//设备树中 GPIO 引脚的转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3><span id="2-1-3-gpio-desc">2.1.3 gpio_desc</span><a href="#2-1-3-gpio-desc" class="header-anchor">#</a></h3><p>在<code>gpio_device</code>中有一个<code>gpio_desc</code>数组，每一引脚有一项<code>gpio_desc</code>。</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image-20240818145531275"></p>
<h1><span id="3-gpio-zi-xi-tong-api">3 gpio子系统api</span><a href="#3-gpio-zi-xi-tong-api" class="header-anchor">#</a></h1><h2><span id="3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi">3.1使用整数的GPIO传统方式</span><a href="#3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi" class="header-anchor">#</a></h2><h3><span id="3-1-1-qing-qiu-he-pei-zhi">3.1.1 请求和配置</span><a href="#3-1-1-qing-qiu-he-pei-zhi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求和释放GPIO</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span>* label)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断gpio释放可用</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">gpio_is_valid</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gpio为输入还是输出</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gpio的去抖动时间，其中debounce以ms为单位</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_set_debounce</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">unsigned</span> debounce)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-2-du-qu-he-she-zhi-zhi">3.1.2 读取和设置值</span><a href="#3-1-2-du-qu-he-she-zhi-zhi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当gpio没有连接到I2C或SPI等慢速总线上，不会导致睡眠，可以在原子上下文中使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_get_value</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; <span class="comment">// value为bool值，0表示低电平，非0高电平</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用gpio_can_sleep()判断gpio线是否可能睡眠</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">gpio_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当gpio没有连接到I2C或SPI等慢速总线上，不会导致睡眠，可以在原子上下文中使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_get_value_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当gpio映射到irq时，使用方式如下gpio_to_irq，返回irq号，接下来可以使用request_irq申请irq</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_to_irq</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_to_gpio</span><span class="params">(<span class="type">int</span> irq)</span></span><br></pre></td></tr></table></figure>
<h3><span id="3-1-3-gpiochip-cao-zuo">3.1.3 gpiochip操作</span><a href="#3-1-3-gpiochip-cao-zuo" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">gpiochip_add</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span><span class="comment">//注册一个gpio_chip结构体，它描述了一组GPIO引脚及其操作函数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiochip_remove</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span><span class="comment">//移除之前注册的gpio_chip。</span></span><br><span class="line"></span><br><span class="line">gpiochip_line_config<span class="comment">//配置gpio_chip中的特定引脚。</span></span><br><span class="line">gpiochip_request_own<span class="comment">//请求对gpio_chip中的引脚的所有权。</span></span><br><span class="line">gpiochip_request_unown<span class="comment">//释放对gpio_chip中的引脚的所有权。</span></span><br><span class="line">gpiochip_set<span class="comment">//为gpio_chip中的多个引脚设置值。</span></span><br><span class="line">gpiochip_clear<span class="comment">//清除gpio_chip中的多个引脚的值。</span></span><br><span class="line"></span><br><span class="line">gpiochip_set_direction<span class="comment">//为gpio_chip中的多个引脚设置方向。</span></span><br><span class="line">gpiochip_get_direction<span class="comment">//获取gpio_chip中引脚的方向。</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi">3.2 基于描述符的GPIO方式</span><a href="#3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo_device &#123;</span><br><span class="line">	compatible = <span class="string">&quot;acme,foo&quot;</span>;</span><br><span class="line">	[...];</span><br><span class="line">	led-gpios = &lt;&amp;gpio <span class="number">15</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//红色</span></span><br><span class="line">				&lt;&amp;gpio <span class="number">16</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//绿色</span></span><br><span class="line">				&lt;&amp;gpio <span class="number">17</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//蓝色</span></span><br><span class="line">				;</span><br><span class="line">	power-gpios = &lt;&amp;gpio <span class="number">1</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	reset-gpios = &lt;&amp;gpio <span class="number">1</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在代码中获取GPIO的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取gpio的代码</span></span><br><span class="line">sruct gpio_desc * <span class="title function_">gpiod_get_index</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">								<span class="keyword">enum</span> gpiod_flags flags)</span>;</span><br><span class="line">sruct gpio_desc * <span class="title function_">gpiod_get</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">								<span class="keyword">enum</span> gpiod_flags flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_put</span><span class="params">(sruct gpio_desc *desc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">red</span>, *<span class="title">green</span>, *<span class="title">blue</span>, *<span class="title">power</span>, *<span class="title">reset</span>;</span></span><br><span class="line">red = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">0</span>, GPIO_OUT_HIGH);</span><br><span class="line">green = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">1</span>, GPIO_OUT_HIGH);</span><br><span class="line">blue = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">2</span>, GPIO_OUT_HIGH);</span><br><span class="line"></span><br><span class="line">power = gpiod_get(dev, <span class="string">&quot;power&quot;</span>, GPIO_OUT_HIGH);</span><br><span class="line">reset = gpiod_get(dev, <span class="string">&quot;reset&quot;</span>, GPIO_OUT_HIGH);</span><br></pre></td></tr></table></figure>

<p>其他类似的功能函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_input</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_output</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_set_debounce</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">unsigned</span> debounce)</span>;</span><br><span class="line"><span class="comment">// 输出逻辑1</span></span><br><span class="line"><span class="comment">// 在Active-High的情况下它会输出高电平</span></span><br><span class="line"><span class="comment">// 在Active-Low的情况下它会输出低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_set_value</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_set_value_cansleep</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_get_value</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_get_value_cansleep</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二者之间相互转换</span></span><br><span class="line"><span class="keyword">struct</span> gpio_desc *<span class="title function_">gpio_to_desc</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">desc_to_gpio</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image-20240818143109206"></p>
<p>无论是传统GPIO控制还是基于描述符的gpio方式，都是调用底层控制器gpio_chip的操作函数。</p>
<h2><span id="3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou">3.3 和设备树相关GPIO接口</span><a href="#3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gpio1: gpio1 &#123;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio2 : gpio2 &#123;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">foo-device &#123;</span><br><span class="line">	cs-gpios = &lt;&amp;gpio1 <span class="number">17</span> <span class="number">0</span>&gt;</span><br><span class="line">				&lt;&amp;gpio1 <span class="number">2</span>&gt;</span><br><span class="line">				&lt;&amp;gpio1 <span class="number">17</span> <span class="number">0</span>&gt;;</span><br><span class="line">	reset-gpio = &lt;&amp;gpio1 <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">	cs-gpios = &lt;&amp;gpio2 <span class="number">10</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在传统使用gpio的方式中，需要获取gpio编号，获取方式如下：</span></span><br><span class="line"><span class="type">int</span> n_gpios = of_get_named_gpio_count(dev.of_node, <span class="string">&quot;cs-gpios&quot;</span>);</span><br><span class="line"><span class="type">int</span> first_gpio = of_get_named_gpio(dev.of_node, <span class="string">&quot;cs-gpios&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="4-ji-yu-sysfs-cao-zuo-gpio">4 基于sysfs操作gpio</span><a href="#4-ji-yu-sysfs-cao-zuo-gpio" class="header-anchor">#</a></h1><p><strong>声明GPIO口:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 256 &gt; /sys/class/gpio/export  <span class="comment">#/sys/class/gpio会生成gpio256目录</span></span><br><span class="line"><span class="built_in">echo</span> 256 &gt; /sys/class/gpio/unexport</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<p><strong>方向：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;in&quot;</span> &gt; direction    <span class="comment">#输入方向</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;out&quot;</span> &gt; direction   <span class="comment">#输出方向</span></span><br><span class="line"><span class="built_in">cat</span> direction</span><br></pre></td></tr></table></figure>
<p><strong>val:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; value</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; value</span><br><span class="line"><span class="built_in">cat</span> value</span><br></pre></td></tr></table></figure>

<p><strong>edge:</strong><br>表示中断的触发方式，edge文件有如下四个值：<code>&quot;none&quot;, &quot;rising&quot;,&quot;falling&quot;，&quot;both&quot;</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">none：<span class="comment">#表示引脚为输入，不是中断引脚</span></span><br><span class="line">rising：<span class="comment">#表示引脚为中断输入，上升沿触发</span></span><br><span class="line">falling：<span class="comment">#表示引脚为中断输入，下降沿触发</span></span><br><span class="line">both：<span class="comment">#表示引脚为中断输入，边沿触发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;both&quot;</span> &gt; /sys/class/gpio/gpioN/edge</span><br></pre></td></tr></table></figure>
<h1><span id="5-gpio-zi-xi-tong-shi-li">5 gpio子系统示例</span><a href="#5-gpio-zi-xi-tong-shi-li" class="header-anchor">#</a></h1><p>以<code>nxp</code>官方<code>evk</code>公板<code>imx6ull-14x14-evk.dts</code>为例：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"><br>重新定义了<code>iomuxc</code>引脚控制器，<code>evk</code>设备默认default状态对应的pins为<code>pinctrl_hog_1</code>, 配置3个引脚（<code>UART1_RTS_B, GPIO1_IO05, GPIO1_IO09</code>)信息。看起来是要做成sd卡的热插拔功能。<br>我们再找到描述sd的设备树节点：<code>usdhc1</code>和<code>usdhc2</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;usdhc1 &#123;</span><br><span class="line">         pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;state_100mhz&quot;</span>, <span class="string">&quot;state_200mhz&quot;</span>;</span><br><span class="line">         pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_usdhc1&gt;;</span><br><span class="line">         pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_usdhc1_100mhz&gt;;</span><br><span class="line">         pinctrl<span class="number">-2</span> = &lt;&amp;pinctrl_usdhc1_200mhz&gt;;</span><br><span class="line">         cd-gpios = &lt;&amp;gpio1 <span class="number">19</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">         keep-power-in-suspend;</span><br><span class="line">         enable-sdio-wakeup;</span><br><span class="line">         vmmc-supply = &lt;&amp;reg_sd1_vmmc&gt;;</span><br><span class="line">         status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>iomuxc</code>控制器节点下有<code>usdhc1</code>要用的<code>pins</code>信息，包括<code>pinctrl_hog_1</code>，<code>pinctrl_usdhc1</code>，<code>pinctrl_usdhc1_100mhz</code>节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">     pinctrl_usdhc1: usdhc1grp &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x10071</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x17059</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     pinctrl_usdhc1_100mhz: usdhc1grp100mhz &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x100b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x170b9</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     pinctrl_usdhc1_200mhz: usdhc1grp200mhz &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x100f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x170f9</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-1-gpio-kong-zhi-qi-dts-miao-shu">5.1 gpio控制器dts描述</span><a href="#5-1-gpio-kong-zhi-qi-dts-miao-shu" class="header-anchor">#</a></h2><p>前面讲的其实都还是<code>pinctrl</code>的内容，<code>usdhc1</code>有一个属性<code>cd-gpios</code>。这时就需要用到gpio控制器了，以<code>imx6ull</code>为例，gpio控制器描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linux<span class="number">-4.9</span><span class="number">.88</span>/Documentation/devicetree/bindings/gpio$ ls -l fsl-imx-gpio.txt</span><br><span class="line"></span><br><span class="line">   * Freescale i.MX/MXC GPIO controller</span><br><span class="line">  </span><br><span class="line">   Required properties:</span><br><span class="line">   - compatible : Should be <span class="string">&quot;fsl,&lt;soc&gt;-gpio&quot;</span></span><br><span class="line">   - reg : Address and length of the <span class="keyword">register</span> <span class="built_in">set</span> <span class="keyword">for</span> the device</span><br><span class="line">   - interrupts : Should be the port interrupt shared by all <span class="number">32</span> pins, <span class="keyword">if</span></span><br><span class="line">     one number.  If two numbers, the first one is the interrupt shared</span><br><span class="line">     by low <span class="number">16</span> pins and the second one is <span class="keyword">for</span> high <span class="number">16</span> pins.</span><br><span class="line">   - gpio-controller : Marks the device node as a gpio controller.</span><br><span class="line">  - <span class="meta">#gpio-cells : Should be two.  The first cell is the pin number and</span></span><br><span class="line">    the second cell is used to specify the gpio polarity:</span><br><span class="line">        <span class="number">0</span> = active high</span><br><span class="line">        <span class="number">1</span> = active low</span><br><span class="line">  - interrupt-controller: Marks the device node as an interrupt controller.</span><br><span class="line">  - <span class="meta">#interrupt-cells : Should be 2.  The first cell is the GPIO number.</span></span><br><span class="line">    The second cell bits[<span class="number">3</span>:<span class="number">0</span>] is used to specify trigger type and level flags:</span><br><span class="line">        <span class="number">1</span> = low-to-high edge triggered.</span><br><span class="line">        <span class="number">2</span> = high-to-low edge triggered.</span><br><span class="line">        <span class="number">4</span> = active high level-sensitive.</span><br><span class="line">        <span class="number">8</span> = active low level-sensitive.</span><br><span class="line"> </span><br><span class="line">  Example:</span><br><span class="line"> </span><br><span class="line">gpio0: gpio@<span class="number">73f</span>84000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl,imx51-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x73f84000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">50</span> <span class="number">51</span>&gt;;</span><br><span class="line">        gpio-controller;</span><br><span class="line">        <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">        interrupt-controller;</span><br><span class="line">        <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打开具体的<code>imx6ull.dtsi</code>:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"><br>打开芯片参考书册，刚好对应gpio1控制器：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<h2><span id="5-2-gpio-kong-zhi-qi-shi-yong-zhe">5.2 gpio控制器使用者</span><a href="#5-2-gpio-kong-zhi-qi-shi-yong-zhe" class="header-anchor">#</a></h2><p>回到<code>usdhc1</code>的属性<code>cd-gpios</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd-gpios = &lt;&amp;gpio1 <span class="number">19</span> GPIO_ACTIVE_LOW&gt;;</span><br></pre></td></tr></table></figure>

<p>表述使用gpio1控制器，由于该控制器的gpio-cells为2， 根据描述：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#gpio-cells : Should be two.  The first cell is the pin number and</span></span><br><span class="line">the second cell is used to specify the gpio polarity:</span><br><span class="line">    0 = active high</span><br><span class="line">    1 = active low</span><br></pre></td></tr></table></figure>
<p>19表示<code>pin number</code>， <code>GPIO_ACTIVE_LOW</code>是一个宏定义：可以看到为1，也就是低电平有效<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<h3><span id="5-2-1-shi-yong-zhe-cao-zuo-liu-cheng">5.2.1 使用者操作流程</span><a href="#5-2-1-shi-yong-zhe-cao-zuo-liu-cheng" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> of_find_node_by_path获取使用该gpio的节点</span><br><span class="line"><span class="number">2.</span> of_get_named_gpio，获取gpio编号</span><br><span class="line"><span class="number">3.</span> gpio_request,申请gpio</span><br><span class="line"><span class="number">4.</span> gpio_direction_set/gpio_direction_get</span><br><span class="line"><span class="number">5.</span> gpio_val_set</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led">5.2.1.1 dts自定义gpio控制器使用者（demo1,gpio_led）</span><a href="#5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led" class="header-anchor">#</a></h4><p>编写一个gpioled节点：</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"><br>同时修改<code>iomuxc</code>节点，因为用到了<code>GPIO1_IO03</code>，要设置该pin脚为<code>gpio</code>：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOLED_CNT			1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOLED_NAME		<span class="string">&quot;gpioled&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 				0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 				1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line">	<span class="type">int</span> major;</span><br><span class="line">	<span class="type">int</span> minor;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span></span><br><span class="line">	<span class="type">int</span> led_gpio;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> <span class="title">gpioled</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;gpioled;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ledstat = databuf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ledstat == LEDON) &#123;	</span><br><span class="line">		gpio_set_value(dev-&gt;led_gpio, <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">		gpio_set_value(dev-&gt;led_gpio, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpioled_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = led_open,</span><br><span class="line">	.read = led_read,</span><br><span class="line">	.write = led_write,</span><br><span class="line">	.release = 	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	gpioled.nd = of_find_node_by_path(<span class="string">&quot;/gpioled&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(gpioled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;gpioled node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;gpioled node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">&quot;led-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(gpioled.led_gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t get led-gpio&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;led-gpio num = %d\r\n&quot;</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">	ret = gpio_direction_output(gpioled.led_gpio, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gpioled.major) &#123;</span><br><span class="line">		gpioled.devid = MKDEV(gpioled.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(gpioled.devid, GPIOLED_CNT, GPIOLED_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;gpioled.devid, <span class="number">0</span>, GPIOLED_CNT, GPIOLED_NAME);</span><br><span class="line">		gpioled.major = MAJOR(gpioled.devid);</span><br><span class="line">		gpioled.minor = MINOR(gpioled.devid);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;gpioled major=%d,minor=%d\r\n&quot;</span>,gpioled.major, gpioled.minor);	</span><br><span class="line">	</span><br><span class="line">	gpioled.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);</span><br><span class="line">	</span><br><span class="line">	cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">	gpioled.class = class_create(THIS_MODULE, GPIOLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpioled.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpioled.device = device_create(gpioled.class, <span class="literal">NULL</span>, gpioled.devid, <span class="literal">NULL</span>, GPIOLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpioled.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cdev_del(&amp;gpioled.cdev);</span><br><span class="line">	unregister_chrdev_region(gpioled.devid, GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">	device_destroy(gpioled.class, gpioled.devid);</span><br><span class="line">	class_destroy(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>


<h4><span id="5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep">5.2.1.2 dts自定义gpio控制器使用者（demo2,beep）</span><a href="#5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep" class="header-anchor">#</a></h4><p>evk公板的蜂鸣器。<code>BEEP</code>使用了<code>SNVS_TAMPER1</code>这个PIN，打开<code>imx6ull-alientek-emmc.dts</code>，<code>SNVS_TAMPER1</code>属于<code>iomuxc_snvs</code>这个<code>pin controller</code>。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"><br>在<code>iomuxc</code>节点的<code>imx6ul-evk</code>子节点下创建一个名为<code>“pinctrl_beep”</code>的子节点:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl_beep: beepgrp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01 <span class="number">0x10B0</span> <span class="comment">/* beep */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根节点<code>“/”</code>下创建<code>BEEP</code>节点：可以看到用到了引脚控制器的<code>pinctrl_beep</code>节点。同时使用gpio子系统，<code>beep-gpio</code>属性用到<code>gpio5</code>控制器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">beep &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;evk-beep&quot;</span>;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_beep&gt;;</span><br><span class="line">	beep-gpio = &lt;&amp;gpio5 <span class="number">1</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>蜂鸣器使用的 PIN 为<code> SNVS_TAMPER1</code>，因此先检查 PIN 为<code>SNVS_TAMPER1 </code>这个 PIN 有没有被其他的 pinctrl 节点使用，如果有使用的话就要屏蔽掉，然后再检查 <code>GPIO5_IO01</code> 这个 GPIO 有没有被其他外设使用，如果有的话也要屏蔽掉。</p>
<p>输入<code>“make dtbs”</code>命令重新编译设备树，然后使用新编译出来的 <code>imx6ull-alientek-emmc.dtb</code> 文件启动 Linux 系统，进入<code>“/proc/device-tree”</code>目录中 查看<code>“beep”</code>节点是否存在：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_CNT			1		<span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_NAME			<span class="string">&quot;beep&quot;</span>	<span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEPOFF 			0		<span class="comment">/* 关蜂鸣器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEPON 				1		<span class="comment">/* 开蜂鸣器 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> beep_gpio;			<span class="comment">/* beep所使用的GPIO编号		*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span> <span class="title">beep</span>;</span>		<span class="comment">/* beep设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">beep_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;beep; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">beep_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> beepstat;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beepstat = databuf[<span class="number">0</span>];		<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(beepstat == BEEPON) &#123;	</span><br><span class="line">		gpio_set_value(dev-&gt;beep_gpio, <span class="number">0</span>);	<span class="comment">/* 打开蜂鸣器 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(beepstat == BEEPOFF) &#123;</span><br><span class="line">		gpio_set_value(dev-&gt;beep_gpio, <span class="number">1</span>);	<span class="comment">/* 关闭蜂鸣器 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">beep_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">beep_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = beep_open,</span><br><span class="line">	.write = beep_write,</span><br><span class="line">	.release = 	beep_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">beep_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1、获取设备节点：beep */</span></span><br><span class="line">	beep.nd = of_find_node_by_path(<span class="string">&quot;/beep&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(beep.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;beep node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;beep node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、 获取设备树中的gpio属性，得到BEEP所使用的BEEP编号 */</span></span><br><span class="line">	beep.beep_gpio = of_get_named_gpio(beep.nd, <span class="string">&quot;beep-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(beep.beep_gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t get beep-gpio&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;led-gpio num = %d\r\n&quot;</span>, beep.beep_gpio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、设置GPIO5_IO01为输出，并且输出高电平，默认关闭BEEP */</span></span><br><span class="line">	ret = gpio_direction_output(beep.beep_gpio, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1、创建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (beep.major) &#123;		<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">		beep.devid = MKDEV(beep.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(beep.devid, BEEP_CNT, BEEP_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">		alloc_chrdev_region(&amp;beep.devid, <span class="number">0</span>, BEEP_CNT, BEEP_NAME);	<span class="comment">/* 申请设备号 */</span></span><br><span class="line">		beep.major = MAJOR(beep.devid);	<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">		beep.minor = MINOR(beep.devid);	<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;beep major=%d,minor=%d\r\n&quot;</span>,beep.major, beep.minor);	</span><br><span class="line">	</span><br><span class="line">	beep.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;beep.cdev, &amp;beep_fops);</span><br><span class="line">	cdev_add(&amp;beep.cdev, beep.devid, BEEP_CNT);</span><br><span class="line"></span><br><span class="line">	beep.class = class_create(THIS_MODULE, BEEP_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(beep.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(beep.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beep.device = device_create(beep.class, <span class="literal">NULL</span>, beep.devid, <span class="literal">NULL</span>, BEEP_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(beep.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(beep.device);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">beep_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cdev_del(&amp;beep.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">	unregister_chrdev_region(beep.devid, BEEP_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">	device_destroy(beep.class, beep.devid);</span><br><span class="line">	class_destroy(beep.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(beep_init);</span><br><span class="line">module_exit(beep_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>核心代码分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> of_find_node_by_path(<span class="string">&quot;/beep&quot;</span>);<span class="comment">//找到设备节点</span></span><br><span class="line"><span class="number">2.</span> of_get_named_gpio(beep.nd, <span class="string">&quot;beep-gpio&quot;</span>, <span class="number">0</span>);<span class="comment">//获取beep-gpio这个引脚编号</span></span><br><span class="line"><span class="number">3.</span> gpio_direction_output(beep.beep_gpio, <span class="number">1</span>);<span class="comment">//请求gpio并且配成输出</span></span><br><span class="line"><span class="number">4.</span> gpio_set_value(dev-&gt;beep_gpio, <span class="number">0</span>);<span class="comment">//设置高低电平</span></span><br></pre></td></tr></table></figure>

<p>注意这里并没有使用<code>pinctrl</code>, <code>pinctrl子系统</code>是内核启动时就对<code>pinctrl(也叫iomuxc)控制器</code>进行了配置，进行了IOMUX配置。因此<code>SNVS_TAMPER1</code>会复用成gpio模式。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/32.png" alt="image"></p>
<p>按键作为输入时：</p>
<pre><code>static int keyio_init(void)
&#123;
    keydev.nd = of_find_node_by_path(&quot;/key&quot;);
    if (keydev.nd== NULL) &#123;
        return -EINVAL;
    &#125;

    keydev.key_gpio = of_get_named_gpio(keydev.nd ,&quot;key-gpio&quot;, 0);
    if (keydev.key_gpio &lt; 0) &#123;
        printk(&quot;can&#39;t get key0\r\n&quot;);
        return -EINVAL;
    &#125;
    printk(&quot;key_gpio=%d\r\n&quot;, keydev.key_gpio);

    /* 初始化key所使用的IO */
    gpio_request(keydev.key_gpio, &quot;key0&quot;);	/* 请求IO */
    gpio_direction_input(keydev.key_gpio);	/* 设置为输入 */
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动-pinctrl子系统</title>
    <url>/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-pinctrl-he-gpio-subsystem-yin-ru">1 pinctrl和gpio subsystem引入</a></li>
<li><a href="#2-pinctrl-zi-xi-tong-yuan-li-jie-shao">2 pinctrl子系统原理介绍</a><ul>
<li><a href="#2-1-pinctrl-zi-xi-tong">2.1 pinctrl子系统</a><ul>
<li><a href="#2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou">2.1.1 pinctrl子系统软件架构</a></li>
<li><a href="#2-1-2-pinctrl-chong-yao-gai-nian">2.1.2 Pinctrl重要概念</a></li>
<li><a href="#2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng">2.1.3 pinctrl 子系统注册流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-soc-pinctrl-zhu-yao-jie-gou-ti-controller">3 soc pinctrl主要结构体（controller）</a><ul>
<li><a href="#3-0-shu-ju-jie-gou-guan-xi-tu">3.0 数据结构关系图</a></li>
<li><a href="#3-1-pinctrl-dev">3.1 pinctrl_dev</a></li>
<li><a href="#3-2-pinctrl-desc">3.2 pinctrl_desc</a><ul>
<li><a href="#3-2-1-pinctrl-pin-desc">3.2.1 pinctrl_pin_desc</a></li>
<li><a href="#3-2-2-pin-desc">3.2.2 pin_desc</a></li>
<li><a href="#3-2-3-san-ge-ops">3.2.3 三个ops</a><ul>
<li><a href="#3-2-3-1-pinctrl-ops">3.2.3.1 pinctrl_ops</a></li>
<li><a href="#3-2-3-2-pinmux-ops">3.2.3.2 pinmux_ops</a></li>
<li><a href="#3-2-3-3-pinconf-ops">3.2.3.3 pinconf_ops</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client">4 board pinctrl相关结构体(使用者client)</a><ul>
<li><a href="#4-0-shu-ju-jie-gou-guan-xi">4.0 数据结构关系</a></li>
<li><a href="#4-1-pinctrl-map">4.1 pinctrl_map</a></li>
<li><a href="#4-2-dev-pin-info">4.2 dev_pin_info</a><ul>
<li><a href="#4-2-1-pinctrl">4.2.1 pinctrl</a><ul>
<li><a href="#4-2-1-1-pinctrl-state">4.2.1.1 pinctrl_state</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-pinctrl-shi-li-hua-shi-li">5 pinctrl实例化示例</a><ul>
<li><a href="#5-1-pin-controller-shi-li">5.1 pin controller示例</a></li>
<li><a href="#5-2-client-shi-li">5.2 client示例</a><ul>
<li><a href="#5-2-1-client-ru-he-shi-yong-pinctrl">5.2.1 client如何使用pinctrl</a><ul>
<li><a href="#5-2-1-1-pinctrl-bind-pins-guo-cheng">5.2.1.1 pinctrl_bind_pins过程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-pinctrl-he-gpio-subsystem-yin-ru">1 pinctrl和gpio subsystem引入</span><a href="#1-pinctrl-he-gpio-subsystem-yin-ru" class="header-anchor">#</a></h1><p>上一节引入gpio了子系统：</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/18085417">linux内核驱动-gpio子系统 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统 | Hexo (fuzidage.github.io)</a></p>
<p>Linux 驱动讲究驱动分离与分层，pinctrl 和 gpio 子系统就是驱动分离与分层思想下的产物。<br>pinctrl顾名思义就是引脚控制，用来配置比如引脚mux复用信息，引脚电器属性（比如上&#x2F;下拉、速度、驱动能力等）信息。<br>gpio顾名思义就是控制gpio的输入输出，以及高低电平。不过，大多数的芯片并没有单独的IOMUX模块，引脚的复用、配置等，而是在GPIO模块内部实现的。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<h1><span id="2-pinctrl-zi-xi-tong-yuan-li-jie-shao">2 pinctrl子系统原理介绍</span><a href="#2-pinctrl-zi-xi-tong-yuan-li-jie-shao" class="header-anchor">#</a></h1><h2><span id="2-1-pinctrl-zi-xi-tong">2.1  pinctrl子系统</span><a href="#2-1-pinctrl-zi-xi-tong" class="header-anchor">#</a></h2><h3><span id="2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou">2.1.1 pinctrl子系统软件架构</span><a href="#2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou" class="header-anchor">#</a></h3><p>pinctrl子系统源码路径是linux&#x2F;drivers&#x2F;pinctrl：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">其他驱动层（client）：具体到使用系统pin资源的设备驱动程序</span><br><span class="line">pinctrl核心层(core)：内核抽象出来，向下为SoC pin controler drvier提供底层通信接口的能力， 向上为其他驱动提供了控制pin的能力，比如pin复用、配置引脚的电气特性，同时也为GPIO子系统提供pin操作。</span><br><span class="line">pin控制器驱动层(pinctrl-driver)： 提供了操作pin的具体方法。</span><br></pre></td></tr></table></figure>

<p><code>pinctrl-driver</code>主要为<code>pinctrl-core</code>提供pin的操作能力。把系统所有的pin以及对于pin的控制接口实例化成<code>pinctrl_desc</code>，并将<code>pinctrl_desc</code>注册到<code>pinctrl-core</code>中去。</p>
<h3><span id="2-1-2-pinctrl-chong-yao-gai-nian">2.1.2 Pinctrl重要概念</span><a href="#2-1-2-pinctrl-chong-yao-gai-nian" class="header-anchor">#</a></h3><p><code>Documentation\devicetree\bindings\pinctrl\pinctrl-bindings.txt</code>有介绍重要相关概念：</p>
<p><strong>1. pin controller：</strong><br>    芯片手册里你找不到 <code>pin controller</code>，它是一个软件上的概念。对应 IOMUX──用来复用引脚，还可以配置引脚(比如上下拉电阻等)。<br><strong>2. client device：</strong><br>    “客户设备”，客户是指<code>Pinctrl</code>系统的客户，即使用Pinctrl系统的设备，使用引脚的设备<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<ul>
<li><ol>
<li><strong>pin state</strong><br>  对于一个<code>&quot;client device&quot;</code>，如UART设备，它有多个<code>“状态”</code>：<code>default、sleep</code>等，那么对应的引脚也有这些状态。</li>
</ol>
<p>  比如，默认状态下，UART设备正常工作，那么所用的引脚就要复用为UART功能；<br>  休眠状态下，为了省电，可以把这些引脚复用为GPIO功能；或者直接把它们配置输出高电平。</p>
<p>  上图<code>pinctrl-names</code>定义2种状态：<code>default，sleep</code>。<br>  第0种状态用到的引脚在<code>pinctrl-0</code>中定义，它是<code>state_0_node_a</code>，位于<code>pincontroller</code>节点中。<br>  第1种状态用到的引脚在<code>Pinctrl-1</code>中定义，它是<code>state_1_node_a</code>，位于<code>pincontroller</code>节点中。</p>
<p>  当UART设备处于<code>default</code>状态时，pinctrl子系统会自动根据上述信息将所用引脚复用为uart0功能。<br>  当UART设备处于<code>sleep</code>状态时，pinctrl子系统会自动根据上述信息将所用引脚配置为高电平。</p>
</li>
<li><ol start="2">
<li><strong>groups和function</strong><br>  一个设备会用到一个或多个引脚，这些引脚可以归纳为一组<code>（group）</code>；<br>  这些引脚可以复用为某个功能：<code>function</code>，如I2C功能，SPI功能，GPIO功能等。当然：一个设备可以用到多组引脚，比如A1、A2两组引脚，A1组复用为F1功能，A2组复用为F2功能：<br>  <img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></li>
</ol>
</li>
<li><ol start="3">
<li><strong>Generic pin multiplexing node和Generic pin configuration node</strong><br>  下图左边<code>pin controller</code>节点中，有子节点或孙节点，它们是给<code>client device</code>使用的。<br>  可用来描述复用信息：哪组<code>（group）</code>引脚复用为哪个功能<code>（function）</code>；<br>  配置信息：<code>哪组（group）</code>引脚配置为哪个设置功能（<code>setting</code>），如上拉、下拉等；</li>
</ol>
</li>
</ul>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h3><span id="2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng">2.1.3 pinctrl 子系统注册流程</span><a href="#2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng" class="header-anchor">#</a></h3><p>以imx6ull为例，<code>drivers/pinctrl/freescale/pinctrl-imx6ul.c</code><br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<p>驱动的入口是 <code>arch_initcall</code> 中声明的函数，类似于我们经常写的 <code>module_init</code>是动态ko加载，<code>arch_initcall</code>是编译进入内核镜像。可以看到是利用platform_device框架来写的。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"><br>根据 <code>compatible</code> 和<code>设备树的compatible </code>字段进行匹配，匹配成功执行 probe 函数，调用<code>imx_pinctrl_probe_dt</code>解析dts中的<code>pinctrl</code>描述信息。调用<code>pinctrl_register</code>或者<code>devm_pinctrl_register</code>注册pinctl子系统。</p>
<h1><span id="3-soc-pinctrl-zhu-yao-jie-gou-ti-controller">3 soc pinctrl主要结构体（controller）</span><a href="#3-soc-pinctrl-zhu-yao-jie-gou-ti-controller" class="header-anchor">#</a></h1><h2><span id="3-0-shu-ju-jie-gou-guan-xi-tu">3.0 数据结构关系图</span><a href="#3-0-shu-ju-jie-gou-guan-xi-tu" class="header-anchor">#</a></h2><p>总框图记录数据结构之间的关联。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="1876680-20240315174913445-1187095793"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pincontroller数据结构</span></span><br><span class="line">drivers\pinctrl\core.h</span><br><span class="line">include\linux\pinctrl\pinctrl.h</span><br><span class="line">include\linux\pinctrl\pinmux.h</span><br><span class="line">include\linux\pinctrl\pinconf.h</span><br><span class="line"><span class="comment">//client数据结构</span></span><br><span class="line">drivers\pinctrl\core.h</span><br><span class="line">include\linux\pinctrl\devinfo.h</span><br><span class="line">include\linux\device.h</span><br><span class="line">include\linux\pinctrl\machine.h</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-pinctrl-dev">3.1 pinctrl_dev</span><a href="#3-1-pinctrl-dev" class="header-anchor">#</a></h2><p><code>pinctrl_dev</code> 是 pinctrl 子系统的根源结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span> <span class="comment">//提供具体操作方法和抽象包括pincrtl_ops函数，pinmux操作函数和pin的描述等</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_desc_tree</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCTRL_GROUPS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_group_tree</span>;</span><span class="comment">//存储group的描述信息</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_groups;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINMUX_FUNCTIONS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_function_tree</span>;</span><span class="comment">//存储function的描述信息</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_functions;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">gpio_ranges</span>;</span><span class="comment">//链接gpio range 2 pin range相关的信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">void</span> *driver_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span><span class="comment">//每个pinctrl都描述着一组gpio的复用和状态配置，如果这个pinctrl_dev是一个通过iic连接的，那么使用这个pinctrl_dev就需要配置其占用的gpio为iic功能，那么就要用这个来描述</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_default</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_sleep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">device_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>/driver/pinctrl/core.c</code>中注册pinctrl时将soc中所有的<code>pinctrl_dev</code>挂载到<code>pinctrl_dev_list</code>链表中方便查询使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pinctrl_dev *<span class="title function_">pinctrl_register</span><span class="params">(<span class="keyword">struct</span> pinctrl_desc *pctldesc,</span></span><br><span class="line"><span class="params">								 <span class="keyword">struct</span> device *dev, <span class="type">void</span> *driver_data)</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="3-2-pinctrl-desc">3.2 pinctrl_desc</span><a href="#3-2-pinctrl-desc" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span>   <span class="comment">//描述一个pin控制器的引脚,</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> npins;                    <span class="comment">//描述该控制器有多少个引脚</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span>     <span class="comment">//引脚操作函数，有描述引脚，获取引脚等，全局控制函数</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>       <span class="comment">//引脚复用相关的操作函数</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span>     <span class="comment">//引脚配置相关的操作函数</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> num_custom_params;</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">custom_params</span>;</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_config_item</span> *<span class="title">custom_conf_items</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p>三个ops:</p>
<ol>
<li><p><code>group</code>操作接口对应数据结构<code>struct pinctrl_ops</code>，包含<code>get_groups_count</code>、<code>get_group_name</code>、<code>get_group_pins</code>等接口；</p>
</li>
<li><p><code>mux</code>操作接口对应的数据结构为<code>struct pinmux_ops</code>，包含<code>pin request</code>、<code>free</code>、<code>set_mux</code>、<code>get_functions_count</code>、<code>get_function_groups</code>等；</p>
</li>
<li><p><code>function</code>操作接口对应的数据结构为<code>struct pinconf_ops</code>，包含<code>pin_config_set</code>、<code>pin_config_get</code>、<code>pin_config_group_get</code>、<code>pin_config_group_set</code>等接口；</p>
</li>
</ol>
<h3><span id="3-2-1-pinctrl-pin-desc">3.2.1 pinctrl_pin_desc</span><a href="#3-2-1-pinctrl-pin-desc" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> number;<span class="comment">//引脚序号</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//引脚名</span></span><br><span class="line">	<span class="type">void</span> *drv_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>pinctrl_pin_desc</code>来描述一个引脚.</p>
<h3><span id="3-2-2-pin-desc">3.2.2 pin_desc</span><a href="#3-2-2-pin-desc" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">bool</span> dynamic_name;</span><br><span class="line">	<span class="type">void</span> *drv_data;</span><br><span class="line">	<span class="comment">/* These fields only added when supporting pinmux drivers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PINMUX</span></span><br><span class="line">	<span class="type">unsigned</span> mux_usecount;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *mux_owner;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> *<span class="title">mux_setting</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *gpio_owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>记录引脚的使用计数、引脚当前所属的<code>function、group</code>信息（该数据结构主要是pinctrl子系统用于判断一个引脚是否被多次配置不同的复用情况使用（<code>pin_request、pin_free</code>）</p>
<h3><span id="3-2-3-san-ge-ops">3.2.3 三个ops</span><a href="#3-2-3-san-ge-ops" class="header-anchor">#</a></h3><h4><span id="3-2-3-1-pinctrl-ops">3.2.3.1 pinctrl_ops</span><a href="#3-2-3-1-pinctrl-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">//获取组数</span></span><br><span class="line">	<span class="type">int</span> (*get_groups_count) ();</span><br><span class="line">	<span class="comment">//获取组名</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *(*get_group_name) ();</span><br><span class="line">	<span class="comment">//获取某组的引脚</span></span><br><span class="line">	<span class="type">int</span> (*get_group_pins) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供每个引脚的信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_dbg_show) ();</span><br><span class="line">	<span class="comment">//解析设备树节点，转换成pinctrl_map，重点</span></span><br><span class="line">	<span class="type">int</span> (*dt_node_to_map) ();</span><br><span class="line">	<span class="comment">//释放map</span></span><br><span class="line">	<span class="type">void</span> (*dt_free_map) ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>来取出某组的引脚：<code>get_groups_count、get_group_pins</code></li>
<li>处理设备树中<code>pin controller</code>中的某个节点创建映射：<code>dt_node_to_map</code>，把device_node转换为一系列的<code>pinctrl_map</code></li>
</ul>
<h4><span id="3-2-3-2-pinmux-ops">3.2.3.2 pinmux_ops</span><a href="#3-2-3-2-pinmux-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">	<span class="type">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//获取单个引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_get) ();</span><br><span class="line">	<span class="comment">//配置单个引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_set) ();</span><br><span class="line">	<span class="comment">//获取某组引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_get) ();</span><br><span class="line">	<span class="comment">//配置某组引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_set) ();</span><br><span class="line">	<span class="comment">//用以debugfs修改pin配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_dbg_parse_modify) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供pin配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供group配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_group_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs解析并显示pin的配置</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_config_dbg_show) (s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-3-3-pinconf-ops">3.2.3.3 pinconf_ops</span><a href="#3-2-3-3-pinconf-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">	<span class="type">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//获取单个引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_get) ();</span><br><span class="line">	<span class="comment">//配置单个引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_set) ();</span><br><span class="line">	<span class="comment">//获取某组引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_get) ();</span><br><span class="line">	<span class="comment">//配置某组引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_set) ();</span><br><span class="line">	<span class="comment">//用以debugfs修改pin配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_dbg_parse_modify) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供pin配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供group配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_group_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs解析并显示pin的配置</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_config_dbg_show) (s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1><span id="4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client">4 board pinctrl相关结构体(使用者client)</span><a href="#4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client" class="header-anchor">#</a></h1><h2><span id="4-0-shu-ju-jie-gou-guan-xi">4.0 数据结构关系</span><a href="#4-0-shu-ju-jie-gou-guan-xi" class="header-anchor">#</a></h2><p>前面Soc pin描述相关的数据结构，已经搭建了该soc所支持的<code>pin</code>、<code>function</code>、<code>group</code>以及相关操作接口等信息；而<code>board pin</code>描述相关的数据结构则描述一块board所使用到的<code>function</code>及相关的<code>group</code>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="1876680-20240316150501629-222504717"></p>
<h2><span id="4-1-pinctrl-map">4.1 pinctrl_map</span><a href="#4-1-pinctrl-map" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *dev_name;<span class="comment">//设备名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//该pinctrl_map对应的状态（default、idle、sleep等</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span><span class="comment">//pinctrl_map的类型，包括mux group、config group、config pins等</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ctrl_dev_name;<span class="comment">//pinctrl device的名称，根据该名称可获取到soc pin controller对应的pinctrl device</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> <span class="title">mux</span>;</span><span class="comment">//引脚复用的内容，该数据结构中包含function名称、group名称，通过function、group就可以确定进行引脚复用的引脚id与引脚复用值等信息；</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> <span class="title">configs</span>;</span><span class="comment">//引脚配置相关的内容，包括group或者pin的名称，以及该group、pin的配置信息，实现引脚配置操作。</span></span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该数据结构可以理解为一个function类型：</p>
<h2><span id="4-2-dev-pin-info">4.2 dev_pin_info</span><a href="#4-2-dev-pin-info" class="header-anchor">#</a></h2><p>device结构体中有一个<code>dev_pin_info</code>，用来保存设备的pinctrl信息：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span>    <span class="comment">//该device对应引脚的配置与复用信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span><span class="comment">//该设备支持引脚配置类型（包括支持的pinctrl状态，每一种pinctrl状态下的引脚复用以及引脚配置信息）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">sleep_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">idle_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="4-2-1-pinctrl">4.2.1 pinctrl</span><a href="#4-2-1-pinctrl" class="header-anchor">#</a></h3><p>一个设备的所有引脚配置相关的信息:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span><span class="comment">//states下链接了该设备支持的所有引脚配置状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">users</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5><span id="4-2-1-1-pinctrl-state">4.2.1.1 pinctrl_state</span><a href="#4-2-1-1-pinctrl-state" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<h1><span id="5-pinctrl-shi-li-hua-shi-li">5 pinctrl实例化示例</span><a href="#5-pinctrl-shi-li-hua-shi-li" class="header-anchor">#</a></h1><h2><span id="5-1-pin-controller-shi-li">5.1 pin controller示例</span><a href="#5-1-pin-controller-shi-li" class="header-anchor">#</a></h2><p>打开imx6ull的dtsi找到<code>pin controller</code>控制器节点，对比IMX6ULL参考手册可知：<code>imx6ull一共3个IOMUX控制器</code>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<h2><span id="5-2-client-shi-li">5.2 client示例</span><a href="#5-2-client-shi-li" class="header-anchor">#</a></h2><p>以<code>evk</code>公板为例：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"><br><strong>imx6ull pinmux dts配置描述：</strong><br>我们看到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19       <span class="number">0x17059</span> <span class="comment">/* SD1 CD */</span></span><br></pre></td></tr></table></figure>
<p>它是表示什么意思呢？配置了哪些信息呢？<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p><code>UART1_RTS_B</code>复用成<code>GPIO1_IO19</code>:<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"></p>
<p>此宏定义在imx_6ull_pinfunc.h, 后面跟着 5 个数字，也就是这个宏定义的具体值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0090</span> <span class="number">0x031C</span> <span class="number">0x0000</span> <span class="number">0x5</span> <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>这 5 个值的含义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;mux_reg conf_reg input_reg mux_mode input_val&gt;</span><br></pre></td></tr></table></figure>
<p>0x0090表示<code>UART1_RTS_B</code>的iomux寄存器<br>0x031C表示<code>UART1_RTS_B</code>的电器属性寄存器<br>0x0000表示<code>input寄存器</code><br>0x5表示复用成模式5<br>0x0表示input寄存器设置值为0x0</p>
<p>注意还少了一项电器属性的值啊？别急定义在dts中，<code>0x17059</code>就刚好是电器属性的值。</p>
<h3><span id="5-2-1-client-ru-he-shi-yong-pinctrl">5.2.1 client如何使用pinctrl</span><a href="#5-2-1-client-ru-he-shi-yong-pinctrl" class="header-anchor">#</a></h3><p>前面讲过client包含device结构体，每个device结构体里都有一个<code>dev_pin_info</code>结构体，用来保存设备的pinctrl信息。<code>platform_device</code>匹配driver会执行probe，probe前会进行pinctrl处理，处理函数为<code>pinctrl_bind_pins</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">platform_device_register</span><br><span class="line">	platform_device_add</span><br><span class="line">		device_add</span><br><span class="line">			bus_probe_device;</span><br><span class="line">				device_initial_probe</span><br><span class="line">					__device_attach</span><br><span class="line">						<span class="title function_">bus_for_each_drv</span><span class="params">(dev-&gt;bus, <span class="literal">NULL</span>, &amp;data, __device_attach_driver)</span>; <span class="comment">// 对于plarform_bus_type下的每一个driver, 调用__device_attach_driver</span></span><br><span class="line"></span><br><span class="line">__device_attach_driver</span><br><span class="line">	<span class="title function_">driver_match_device</span><span class="params">(drv, dev)</span>;</span><br><span class="line">		drv-&gt;bus-&gt;match(dev, drv)<span class="comment">// 调用platform_bus_type.match</span></span><br><span class="line">			driver_probe_device</span><br><span class="line">				really_probe</span><br><span class="line">				<span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">					pinctrl_bind_pins</span><br><span class="line">					drv-&gt;probe <span class="comment">//执行driver中的probe函数			</span></span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-pinctrl-bind-pins-guo-cheng">5.2.1.1 pinctrl_bind_pins过程</span><a href="#5-2-1-1-pinctrl-bind-pins-guo-cheng" class="header-anchor">#</a></h4><ul>
<li>构造<code>pinctrl</code><ul>
<li>通过<code>pinctrl_ops.dt_node_to_map</code>将设备树节点转换成一系列<code>pinctrl_map</code></li>
<li><code>pinctrl_map</code>转换成<code>pinctrl_setting</code>，放入settings链表，记录在<code>pinctrl_state</code>中</li>
</ul>
</li>
<li>选择<code>state</code>，遍历settings链表，进行pinctrl的mux和config<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image"></li>
</ul>
<p>函数调用过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl_bind_pins</span><br><span class="line">	<span class="comment">/* 分配dev_pin_info结构体 */</span></span><br><span class="line">	devm_kzalloc(dev, <span class="keyword">sizeof</span>(*(dev-&gt;pins)), GFP_KERNEL);</span><br><span class="line">	<span class="comment">/* 获取pinctrl */</span></span><br><span class="line">	devm_pinctrl_get(dev);</span><br><span class="line">		pinctrl_get</span><br><span class="line">			<span class="comment">/* 构建pinctrl */</span></span><br><span class="line">			create_pinctrl(dev);</span><br><span class="line">				<span class="comment">/* 分配pinctrl */</span></span><br><span class="line">				p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">				<span class="comment">/* 设备树节点转换为pinctrl_map */</span></span><br><span class="line">				pinctrl_dt_to_map(p);</span><br><span class="line">				<span class="comment">/* 每个pinctrl_map，又被转换为一个pinctrl_setting，添加到setting链表 */</span></span><br><span class="line">				for_each_maps(maps_node, i, <span class="built_in">map</span>) &#123;</span><br><span class="line">					ret = add_setting(p, <span class="built_in">map</span>);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p><strong>节点转换为pinctrl_map过程</strong>：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl_dt_to_map(p);</span><br><span class="line">	<span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line">		propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line">	    <span class="comment">/* 取出pinctrl-%d节点属性 */</span></span><br><span class="line">	   	prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">	    <span class="built_in">list</span> = prop-&gt;value;</span><br><span class="line">		size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line">	   	<span class="comment">/* 对pinctrl-%d中的每一个phandle进行pinctrl_map转换 */</span></span><br><span class="line">	    <span class="comment">/* 例如pinctrl-0 = &lt;&amp;state_0_node_a &amp;state_0_node_b&gt;有两个phandle */</span></span><br><span class="line">	    <span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123;</span><br><span class="line">	    	<span class="comment">/* 根据phandle找到对应节点 */</span></span><br><span class="line">	       	np_config = of_find_node_by_phandle(phandle);</span><br><span class="line">	        <span class="comment">/* Parse the node */</span></span><br><span class="line">			dt_to_map_one_config(p, statename, np_config);</span><br><span class="line">	           	<span class="comment">/* 调用Pincontroller中dt_node_to_map函数,构造pinctrl_map */</span></span><br><span class="line">	       		ops-&gt;dt_node_to_map()</span><br><span class="line">	            <span class="comment">/* 将pinctrl_map添加到maps链表 */</span></span><br><span class="line">	            dt_remember_or_free_map</span><br><span class="line">	            	pinctrl_register_map</span><br><span class="line">	                	list_add_tail</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* fy00的dt_node_to_map函数 */</span></span><br><span class="line">mc_pctrl_dt_node_to_map()</span><br><span class="line">	<span class="comment">/* 取出每一个子节点 */</span></span><br><span class="line">    for_each_child_of_node(np_config, np) &#123;</span><br><span class="line">   		mc_pctrl_dt_subnode_to_map</span><br><span class="line">   			<span class="comment">/* 获取设备树pinmux属性 */</span></span><br><span class="line">        	pins = of_find_property(node, <span class="string">&quot;pinmux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    		num_pins = pins-&gt;length / <span class="keyword">sizeof</span>(u32);</span><br><span class="line">    		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">            	of_property_read_u32_index(node, <span class="string">&quot;pinmux&quot;</span>,i, &amp;pinfunc); </span><br><span class="line">                <span class="comment">/* 解析设备树，将pinmux属性中每一个成员记录在pin和func中 */</span></span><br><span class="line">                pin = MC_GET_PIN_NO(pinfunc);</span><br><span class="line">				func = MC_GET_PIN_FUNC(pinfunc);</span><br><span class="line">                <span class="comment">/* 设置复用的pinctrl_map */</span></span><br><span class="line">                mc_pctrl_dt_node_to_map_func();</span><br><span class="line">                	(*<span class="built_in">map</span>)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;</span><br><span class="line">					(*<span class="built_in">map</span>)[*num_maps].data.mux.group = grp-&gt;name;</span><br><span class="line">                	(*<span class="built_in">map</span>)[*num_maps].data.mux.function = mc_gpio_functions[fnum];</span><br><span class="line">					(*num_maps)++;</span><br><span class="line">              	<span class="keyword">if</span> (has_config) &#123;</span><br><span class="line">                    <span class="comment">/* 设置配置pinctrl_map，fy00没有配置pinctrl_map */</span></span><br><span class="line">                    pinctrl_utils_add_map_configs</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].type = type;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.group_or_pin = group;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.configs = dup_configs;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.num_configs = num_configs;</span><br><span class="line">                        (*num_maps)++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><strong>pinctrl_map转换为pinctrl_setting过程</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">for_each_maps() &#123;</span><br><span class="line">	add_setting();</span><br><span class="line">		find_state();</span><br><span class="line">		<span class="keyword">if</span> (!state)</span><br><span class="line">			<span class="comment">/* 第一次添加state到states链表 */</span></span><br><span class="line">			create_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">				list_add_tail(&amp;state-&gt;node, &amp;p-&gt;states);</span><br><span class="line">		<span class="comment">/* 将map的name和tpye赋值给setting */</span></span><br><span class="line">		setting-&gt;type = <span class="built_in">map</span>-&gt;type;</span><br><span class="line">		setting-&gt;dev_name = <span class="built_in">map</span>-&gt;dev_name;</span><br><span class="line">		<span class="keyword">switch</span> (<span class="built_in">map</span>-&gt;type) &#123;</span><br><span class="line">			<span class="comment">/* MUX类型 */</span></span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">				pinmux_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">					<span class="comment">/* 将pinctrl_map中的function字符串转换为序号，赋值给setting*/</span></span><br><span class="line">					pinmux_func_name_to_selector(pctldev, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">					setting-&gt;data.mux.func = ret;</span><br><span class="line">					<span class="comment">/* 将pinctrl_map中的group字符串转换为序号，赋值给setting */</span></span><br><span class="line">					ret = pinctrl_get_group_selector(pctldev, group);</span><br><span class="line">					setting-&gt;data.mux.group = ret;</span><br><span class="line">			<span class="comment">/* CONFIGS类型 */</span></span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">				pinconf_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">					<span class="comment">/* 从pinctrl_map取出pin或group赋值给setting */</span></span><br><span class="line">					setting-&gt;data.configs.group_or_pin = pin;</span><br><span class="line">					<span class="comment">/* 将pinctrl_map的configs赋值给setting */</span></span><br><span class="line">					setting-&gt;data.configs.num_configs = <span class="built_in">map</span>-&gt;data.configs.num_configs;</span><br><span class="line">					setting-&gt;data.configs.configs = <span class="built_in">map</span>-&gt;data.configs.configs;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 添加到settings链表 */</span></span><br><span class="line">			list_add_tail(&amp;setting-&gt;node, &amp;state-&gt;settings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pin脚的复用和配置过程</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pinctrl_bind_pins</span><br><span class="line">	<span class="comment">/* 寻找state */</span></span><br><span class="line">	pinctrl_lookup_state</span><br><span class="line">	<span class="comment">/* 选择state */</span></span><br><span class="line">	pinctrl_select_state</span><br><span class="line">		pinctrl_commit_state</span><br><span class="line">			<span class="comment">/* 遍历settings链表 */</span></span><br><span class="line">        	list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line">                	<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">                		<span class="comment">/* 设置复用 */</span></span><br><span class="line">                   		pinmux_enable_setting(setting);</span><br><span class="line">                        	ops-&gt;set_mux(...);</span><br><span class="line">                    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">					<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">						<span class="comment">/* 设置配置 */</span></span><br><span class="line">						pinconf_apply_setting(setting);</span><br><span class="line">							ops-&gt;pin_config_group_set(...);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux设备驱动</tag>
      </tags>
  </entry>
</search>
